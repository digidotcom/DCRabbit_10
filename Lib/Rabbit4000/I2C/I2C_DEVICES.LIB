/*** BeginHeader */
#ifndef __I2C_DEVICES_LIB
#define __I2C_DEVICES_LIB
/*** EndHeader */

/* START LIBRARY DESCRIPTION *********************************************
I2C_DEVICES.LIB

Rabbit Semiconductor, 2001

This library contains higher level functions for specific I2C devices

The library currently has routines for

serial EEPROM devices:
	I2CWrite
	I2CRead
	L24C08_put
	XL24C08_get
	WriteEEPROM
	ReadEEPROM

I2C DAC chips(MAX517/518/519):
	I2CSetDAC


	 Acknowledgement:
				 	This library contains code written for Rabbit Semiconductor
				 	 	by
               KENT JOHANSEN
               ANAKRON / ANAKRON CANADA INC
               www.anakron.com
               kent@anakron.com


END DESCRIPTION *********************************************************/

/*** BeginHeader */

#use "I2C.LIB"

/*** EndHeader */

/*** BeginHeader I2CWrite */
int I2CWrite(unsigned char slave,
				 unsigned char index,
				 char *buf,
				 unsigned char len);
/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
I2CWrite            <I2C.LIB>
SYNTAX: int I2CWrite(unsigned char slave,
							unsigned char index,
							char *buf,
							unsigned char len);

DESCRIPTION: Uses the EEPROM scheme to write data to slave
          	 Sends START, slave address, index and then data, STOP
             Generic interface that may be used to communicate with another
				 processor
             Waits for slave to respond. EEPROM does not respond while
             internal write takes place.

PARAMETER1: unsigned char slave - slave address
PARAMETER2: unsigned char index - index in in EEPROM to write to
PARAMETER3: char *buf        - buffer with data
PARAMETER4: unsigned char len  - lengt of data to send

RETURN VALUE: 0 or error code (see code)
END DESCRIPTION **********************************************************/

__nodebug int I2CWrite(unsigned char slave,
				  		   unsigned char index,
				 			char *buf,
				 			unsigned char len)
{
   auto short int err;
   #ifndef I2C_USE_RABBIT_HW
      // Not Rabbit 6000 or greater, use software library
      auto unsigned char cnt;
      if (err=i2c_startw_tx())
      {
         i2c_stop_tx();
         return -10+err; // Return too long stretching
      }
      if (err=i2c_wr_wait(slave))
      {
         i2c_stop_tx();
         return -20+err; // Return no ack on slave (retried)
      }
      if (err=i2c_write_char(index))
      {
         i2c_stop_tx();
         return -30+err; // Return no ack on index
      }
      for (cnt=0;cnt<len;cnt++)
      {
         i2c_write_char(buf[cnt]);
      }
      i2c_stop_tx();
   #else
      // Use the Rabbit 6000 or greater I2C hardware

      // Write the index of the data we want to read
      err = I2C_WriteToSlave(
                        slave,    // Slave's I2C address
                        &index,   // Buffer to read from (1-byte index)
                        1,        // Len of buffer (1-byte index)
                        1,        // Blocking mode (blocking)
                        0);       // No timeout
      if (err) return err;

      // Read from the EEPROM, starting at index
      err = I2C_ReadFromSlave(
                        slave,   // Slave's I2C address
                        buf,     // Buffer to write to
                        len,     // Number of bytes to read from device
                        1,       // Blocking mode (blocking)
                        0);      // No timeout
      if (err) return err;
   #endif // ndef I2C_USE_RABBIT_HW
	return 0;
}

/*** BeginHeader I2CRead */
int I2CRead(unsigned char slave,
				unsigned char index,
				char *buf,
				unsigned char len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
I2CRead            <I2C.LIB>
SYNTAX: int I2CRead(unsigned char slave,
						  unsigned char index,
						  char *buf,
						  unsigned char len);

DESCRIPTION: Uses the EEPROM scheme to read data from slave
             Sends  START, slave address, index START,
             slave address +1,
             reads data (sending ACKs and NAK on last data) STOP
             Generic interface that may be used to communicate with another
				 processor
             Waits for slave to respond. EEPROM does not respond while
             internal write takes place.

PARAMETER1: unsigned char slave - slave address
PARAMETER2: unsigned char index - index in in EEPROM to read from
PARAMETER3: char *buf          - buffer for data
PARAMETER4: unsigned char len   - size of data buffer

RETURN VALUE: 0 or error code (see code)
END DESCRIPTION **********************************************************/

__nodebug int I2CRead(unsigned char slave,
					     unsigned char index,
			   	 	  char *buf,
			   		  unsigned char len)
{
	auto short int err;

   #ifndef I2C_USE_RABBIT_HW
      auto unsigned char cnt;

      // Not Rabbit 6000 or greater, use software library
      if (err=i2c_startw_tx())
      {
         i2c_stop_tx();
         return -10+err; // Return too long stretching
      }
      if (err=i2c_wr_wait(slave))
      {
         i2c_stop_tx();
         return -20+err; // Return no ack on slave
      }
      if (err=i2c_write_char(index))
      {
         i2c_stop_tx();
         return -30+err; // Return no ack on index
      }
      //i2c_Delay(10);
      if (err=i2c_startw_tx())
      {
         i2c_stop_tx();
         return -40+err; // Return too long stretch on read
      }
      if (err=i2c_wr_wait(slave+1))
      {
         i2c_stop_tx();
         return -50+err; // Send read to slave - no ack (retried) return -5
      }
      for (cnt=0;cnt<len;cnt++)
      {
         err=i2c_read_char(&buf[cnt]);
         if (err)
         {
            i2c_stop_tx();
            return -60+err;
         }
         if (cnt==(len-1))
         {
            i2c_send_nak();
         }
         else
         {
            i2c_send_ack();
         }
      }
      i2c_stop_tx();
   #else
      // Use the Rabbit 6000 or greater I2C hardware

      // Write the index of the data we want to read
      err = I2C_WriteToSlave(
                        slave,    // Slave's I2C address
                        &index,   // Buffer to read from (1-byte index)
                        1,        // Len of buffer (1-byte index)
                        1,        // Blocking mode (blocking)
                        0);       // No timeout
      if (err) return err;

      // Read from the EEPROM, starting at index
      err = I2C_ReadFromSlave(
                        slave,   // Slave's I2C address
                        buf,     // Buffer to write to
                        len,     // Number of bytes to read from device
                        1,       // Blocking mode (blocking)
                        0);      // No timeout
      if (err) return err;
   #endif // ndef I2C_USE_RABBIT_HW
	return 0;
}

/*** BeginHeader XL24C08_put */
void XL24C08_put(unsigned int index,char content);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
XL24C08_put            <I2C.LIB>

SYNTAX: void XL24C08_put(unsigned int index,char content);

KEYWORDS: i2c

DESCRIPTION: Writes a char to a 24C08 on the I2C bus

PARAMETER1: unsigned char index - index in in EEPROM to write to
PARAMETER2: char content         - char to write to EEPROM

RETURN VALUE: none
END DESCRIPTION **********************************************************/

__nodebug void XL24C08_put(unsigned int index, char content)
{
	auto unsigned char res;
	//Send control word + page NUM
	res=(((unsigned char)(index>>7))&0x0E)|0xA0;
	I2CWrite(res,index&0x00FF,&content,1);
}

/*** BeginHeader XL24C08_get */
unsigned char XL24C08_get(unsigned int index);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
XL24C08_get            <I2C.LIB>
SYNTAX: unsigned char XL24C08_get(unsigned int index);

KEYWORDS: i2c

DESCRIPTION: Reads a char from 24C08 on the I2C bus

PARAMETER1: unsigned char index - index in in EEPROM to write to

RETURN VALUE: value read from EEPROM
END DESCRIPTION **********************************************************/

__nodebug unsigned char XL24C08_get(unsigned int index)
{
	auto unsigned char res;
	//Send control word + page NUM
	res=(((unsigned char)(index>>7))&0x0E)|0xA0;
	I2CRead(res,index&0x00FF,&res,1);
	return res;
}

/*** BeginHeader WriteEEPROM */
void WriteEEPROM(unsigned int index,
					  unsigned char * data,
					  unsigned int length);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
WriteEEPROM           <I2C.LIB>

SYNTAX: void WriteEEPROM(unsigned int index,
								 unsigned char *data,
								 unsigned int length);

KEYWORDS: i2c

DESCRIPTION: Writes data to a 24C08 on the I2C bus one byte at a time

PARAMETER1: unsigned char index - index in in EEPROM to write to
PARAMETER2: unsigned char * data - data to write
PARAMETER3: unsigned int length - length of data

RETURN VALUE: none
END DESCRIPTION **********************************************************/

__nodebug void WriteEEPROM(unsigned int index,
					  unsigned char *data,
					  unsigned int length)
{
	auto unsigned i;
	for (i=0;i<length;i++)
	{
		XL24C08_put(index,*data);
		index++;
		data++;
	}
}

/*** BeginHeader ReadEEPROM */
void ReadEEPROM(unsigned char * data,
					 unsigned int index,
					 unsigned int length);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ReadEEPROM           <I2C.LIB>

SYNTAX: void ReadEEPROM(unsigned char *data,unsigned int index,unsigned
int length);


KEYWORDS: i2c


DESCRIPTION: Reads data from a 24C08 on the I2C bus one byte at a time


PARAMETER1: unsigned char * data - data to write
PARAMETER2: unsigned char index - index in in EEPROM to write to
PARAMETER3: unsigned int length - length of data

RETURN VALUE: none
END DESCRIPTION **********************************************************/


__nodebug void ReadEEPROM(unsigned char * data,
								unsigned int index,
								unsigned int length)
{
	auto unsigned i;
	for (i=0;i<length;i++)
	{
		*data=XL24C08_get(index);
		index++;
		data++;
	}
}


/*** BeginHeader I2CSetDAC */
int I2CSetDAC(char address, char channel, char setting);
/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
I2CSetDAC           <I2C.LIB>

SYNTAX: int I2CSetDAC(char address, char channel, char setting);

KEYWORDS: i2c

DESCRIPTION: Sends a set channel command to a Maxim MAX517/518/519
				 series ADC.


PARAMETER1: address - I2C address of slave device
PARAMETER2: channel - which DAC channel to set (0 or 1)
PARAMETER3: setting - new value for DAC channel

RETURN VALUE: 0 or error code
END DESCRIPTION **********************************************************/

__nodebug int I2CSetDAC(char address, char channel, char setting)
{
   #ifndef I2C_USE_RABBIT_HW
   // Not Rabbit 6000 or greater, use software libary
      if(i2c_startw_tx())
      {
         return -1;
      }
      //7 bit address in shifted 1 bit
      if(i2c_write_char(address*2))
      {
         return -1;
      }
      if(i2c_write_char(channel))
      {
         return -1;
      }
      if(i2c_write_char(setting))
      {
         return -1;
      }
      i2c_stop_tx();
   #else
      {  // Rabbit 6000 or greater

         // Return code from read or write, non-zero for error
         int err = 0;

         // Create a buffer containing the data to write (channel and setting
         // bytes
         auto unsigned char channel_and_setting[2];
         channel_and_setting[0] = channel;
         channel_and_setting[1] = setting;
         err = I2C_WriteToSlave(
                           address*2,            // Slave device's address
                           channel_and_setting,  // Data to write
                           2,                    // Number of bytes to write
                           1,                    // Blocking mode (blocking)
                           0);                   // No timeout
         if (err) return err;
      }
   #endif // ndef I2C_USE_RABBIT_HW
	return 0;
}

/*** BeginHeader */
#endif
/*** EndHeader */


