/* START LIBRARY DESCRIPTION ***************************************************
math.lib
	Copyright (c) 2006, Rabbit Semiconductor.

DESCRIPTION: Math functions for Rabbit

SUPPORT LIBRARIES: several
END DESCRIPTION ***************************************************************/

/*
******** Math Library Discussion *******

Functions included in math libaries

Basic floating point functions - these are computed from first principles

 pow2(x) - 2 to the power x
 log2(x) - logarithm of x base 2

 atan(x) - arc tangent
 sin(x) - sine
 sqrt(x) - square root
 ceil(x) - smallest integer greater than or equal to x
 fabs(x) - absolute value x
 floor(x) - largest integer less than or equal to x
 fmod(x,&n) - integer and fractional parts

Derrivitive floating point functions (derrived from combinations of basic functions)

 acos(x) - arc cosine of x
 asin(x) - arc sine of x
 atan2(y,x) - arctan of y/x
 cos(x) - cosine of x
 tan(x)- tangent of x
 cosh(x) - hyperbolic cosine of x
 sinh(x) - hyperbolic sine of x
 tanh(x) - hyperbolic tangent of x
 exp(x) - e to the x power
 log(x) - logarithm of x base e
 log10(x) - logarithm of x base 10
 pow(x,y) - x to y power

Discussion of Accuracy

 Generally the basic functions are accurate within 1-3 counts of the floating mantissa. However, in
 certain ranges of certain functions the relative accuracy is much less do to the intrinsic properties of
 floating point math. Accuracy expressed in counts of the floating mantissa is relative acccuracy -
 i.e. relative to the size of the number. Absolute accuracy is the absolute size of the error - e.g.
 .00001. The derivative functions, computed as combinations of the basic functions, typically
 have larger error because the errors of 2 or more basic functions are added together in some fashion.

 If the value of the function depends on the value of the difference of 2 floating point numbers that are
 close to each other in value, the relative error generally becomes large, although the absolute error
 may remain well bounded. Examples are the logs of numbers near 1 and the sine of numbers near pi.
 For example, if the argument of the sine function is a floating point number is close to pi, say
 5 counts of the mantissa away from pi and it is subtracted from pi the result will be a number with
 only 3 significent bits. The relative error in the sine result will be very large, but the absolute
 error will still be very small. Functions with steep slopes, such as the exponent of larger numbers
 will show a large relative error, since the relative error in the argument is magnified by the slope.

Discussion of execution speed

 Floating add, subtract and multiply require approximately 350 clocks worst case on the Rabbit 2000
 microprocessor. Divide and square root require approximately 900 clocks. Sine and pow2, pow10 or exp
 require about 3200 clocks. Log, log2, log (base e), and atan need about 4000 clocks. Functions
 derrived from these functions often require 5000 or more clocks.

Exceptions - range errors

 Certain values will result in an exception. If debugging is in process this will result in an error message.
 If the exception takes place in a program in the field the response is entry into the error log
 (planned) and a watchdog timeout. Exceptions occur for:

 1) Square root of a negative number
 2) argument of exponent type function too large (x>129.9).
 3) Log of a negative number.



*/

/*** BeginHeader */
#include <math.h>
/*** EndHeader */

/*** BeginHeader powf */
#define powf(x,y)		pow(x,y)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
powf                                                              <math.h>

SYNTAX:			float powf(float x, float y);

Defined as a macro to pow(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (powf)(float x, float y)
{
	return pow(x, y);
}

/*** BeginHeader pow */
/*** EndHeader */

/*
 *      Raise X to the Yth Power
 *
 *  Range and Domain Error Generated by pow2() and log2()
 *                                               y
 *      Method :   y * log2(x)     log2(x )     y
 *                2          =    2         = x
 */
/* START FUNCTION DESCRIPTION ********************************************
pow                                                               <math.h>

SYNTAX:        double pow(double x, double y);
					float powf(float x, float y);

PARAMETER1:    Floating point number to be raised to the y power.

PARAMETER2:    Floating point power to which x is to be raised.

KEYWORDS:      math

DESCRIPTION:   Raises x to the yth power.

RETURN VALUE:	See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double pow(double x, double y)
{
	//handle base of 0
	if (x==0.0 )
	{
		if(y == 0.0)
		{
			return 1.0;
		}
		else if(y < 0.0)
		{
			exception(-ERR_DOMAIN);
			return 0.0;
		}
		else
		{
			return 0.0;
		}
	}
	if ( x == 0.0 && y == 1. )
		return 0.0;

	// if y is an integer, it's ok for x to be less than zero; but
	// log2 will choke on it...  so let's avoid that.
	if ((x < 0) && (y == (int)y)) {
		if ((int)(y)%2 == 0)
			return(pow2(y * log2(-x)));
		else
			return(-pow2(y * log2(-x)));
	}

	return(pow2(y * log2(x)));
}


/*** BeginHeader fx2 */
__root float fx2(float);
/*** EndHeader */
// private helper function -- multiply a float by 2?
#asm

fx2::

	ld		a,b					; 4  save the sign
	or		a						; 2  clear carry

	rl		c						; 4  roll the exponent into b
	rl		b						; 4
	inc	b						; 2  2 * exponent

	or		a						; 2  clear carry
	rr		b						; 4  restore exponent
	rr		c						; 4  restore mantissa

	bit	7,a					; 4
	jr		Z,.fx2Pos				; 5
	set	7,b					; 4

.fx2Pos:

	ret

#endasm


/*** BeginHeader f2bd */
__root unsigned long f2bd(float);
/*** EndHeader */
// private helper function -- convert a float to a ??
#asm __nodebug

f2bd::

	; Get the sign

	ld		a,b					; 2
	ex		af,af'				; 2  (8)

	; Get the exponent

	or		a						; 2  Clear carry
	rl		b						; 4
	bit	7,c					; 4
	jr		Z,.f2bd_Shift		; 5
	set	0,b					; 4  (19)

.f2bd_Shift:

	set	7,c					; 4  Set the implied 1

	; Shift the mantissa appropriately

	ld		a,127					; 4  Exponent bias = 0
	sub	a,b					; 2
	cp		a,8					; 4
	jr		C,.f2bd_rl			; 5  a < 8
	jp		Z,.f2bd_NoShift		; 5  (24)

	cp		a,24					; 4  Is the number too small to represent?
	jr		C,.f2bd_rr			; 5
	ld		bc,0					; 6
	ld		de,0					; 6
	jr		.f2bd_Exit			; 5  Make the number 0

.f2bd_rr:
	sub	a,8					; 4  Get the number of bits to shift right
	cp		a,8					; 4  Is this a byte shift? a >= 8
	jr		NC,.f2bd_rr8			; 5

	ld		b,0					; 4
.f2bd_rrN:						;    Perform an N bit shift
	ld		hl,bc					; 2
	bit	2,a					; 4
	jr		Z,.f2bd_rr2			; 5
	rr		hl						; 2  Perform a 4 bit shift
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
.f2bd_rr2:
	bit	1,a					; 4
	jr		Z,.f2bd_rr1			; 5
	rr		hl						; 2  Perform a 2 bit shift
	rr		de						; 2
	rr		hl						; 2
	rr		de						; 2
.f2bd_rr1:
	bit	0,a					; 4
	jr		Z,.f2bd_rrdone		; 5
	rr		hl						; 2  Perform a 1 bit shift
	rr		de						; 2
.f2bd_rrdone:
	ld		b,0					; 4
	ld		c,l					; 2

	jp		.f2bd_NoShift		; 7  (45 for 1 bit, 69 for 7 bits, 104 for 15 bits, 97 for 23 bits)
									;    (27+4n for this method versus 15n for a simple loop.)
.f2bd_rr8:
	cp		a,16					; 4  Is this a two byte shift?
	jr		NC,.f2bd_rr16		; 5  a >= 16
	sub	a,8					; 4
	ld		e,d					; 2  Perform a one byte shift to the right
	ld		d,c					; 2
	ld		bc,0					; 6
	jr		Z,.f2bd_Sign			; 5  if a = 8, set sign and exit
	jr		.f2bd_rrN				; 5  (35)

.f2bd_rr16:
	sub	a,16					; 4
	ld		e,c					; 2  Perform a two byte shift to the right
	ld		bc,0					; 6
	ld		d,0					; 4
	jr		Z,.f2bd_Sign			; 5  if a = 16, set sign and exit
	jr		.f2bd_rrN				; 5  (28)

.f2bd_rl:
	neg							; 2  Roll the number left by 8-a bits
	add	a,8					; 4
	ld		b,0					; 4
	or		a						; 2  Clear carry

.f2bd_rlN:
	rl		1, bcde				; 4
	dec	a						; 2
	jr		NZ,.f2bd_rlN			; 5  (29 min, 131 max)
	jr		.f2bd_Sign			; 5

.f2bd_NoShift:

	ld		b,0					; 4

.f2bd_Sign:

	; Replace the sign bit

	ex		af,af'				; 2
	bit	7,a					; 4
	jr		Z,.f2bd_Exit			; 5  (11)

	; Calculate the twos complement if the number is negative

	or		a						; 2 Clear the carry flag
	clr	hl						; 6
	sbc	hl,de					; 4 Subtract 0 from low word
	ld		de,hl					; 2
	clr	hl						; 6
	sbc	hl,bc					; 4 Subtract 0 from high word with carry
	ld		bc,hl					; 2

.f2bd_Exit:

	ret							; 8  (31)

#endasm


/*** BeginHeader bdSeries */
__useix unsigned long bdSeries(char, const unsigned long *, unsigned long);
/*** EndHeader */
//; total execution time 76+ (N-1)*201 clocks
__nodebug
__useix unsigned long bdSeries(char N, const unsigned long *A, unsigned long X)

{
#asm xmemok
	ld		hl,(sp+N) 			; 9
	ld 	a,l       			; 2
	dec 	a  					;2 N-1 steps
	ex 	af,af'    			; 2 count in a'
	ld 	ix,(sp+A) 			; 11 pointer to coeficients
	ld 	iy,(sp+X) 			; 11 least of X
	ld 	hl,(sp+X+2) 		; 9 most of X
	ex 	de',hl    			;2 most of X in de'
	ld 	hl,iy 				; 4 -- 51
	ld 	bc,hl 				; 2 Xl in bc
	ld 	hl,(ix+2) 			; 8 Au
	ex 	de,hl     			; 2 Au to de
	ld 	hl,(ix)  			; 9 Al to hl
	ex 	de,hl  				;2
	ld 	bc',de 				;4
	ex 	de,hl   				;2
; total to here  74 clocks (1-time)
;
; setup at top of loop
; - Au Xl   iy=Xl
; - Xu Al   ix=*a
; result
;
.fr_psloop:
	ld 	a,b 					; 2 sign of Xl
	exx  							; 2
	xor 	b 						; 2 compare to sign of Al
	jp 	p,.fr_signsame  	; 7 if different/same signs

; signs are different here
; 13 to here
; signs different, see which neg
	xor 	b         			; 2 reverse previous xor to reveal sign of Xl
	jp 	p,.fr_Xlpos 			; 7 if alt regs have neg in bc

; - Xu Al   ix=*a
; - Au Xl   iy=Xl
;
; 22 to here Xl is negative, Al is positive
.fr_Xlneg:
	mul 							; 12
	exx 							; 2
	mul 							; 12
	add 	hl,de 				; 2 adjust
	ex 	de,hl' 				; 4
	or 	a 						; 2
	adc 	hl,de 				; 4 partial sum - possible overflow
	jr 	.frmul_2 				; 5 43+22=65 to _2

; 22 to here  Xl pos, Al neg
.fr_Xlpos:
	mul 							; 12
	add 	hl,de 				;2 adjust for neg
	exx 							;2
	mul 							; 12
	ex 	de,hl' 				; 4
	or 	a 						; clc
	adc 	hl,de  				; Yu*Xl+Yl*Xu -  possible overflow
	jr 	.frmul_2 				; 61 to _2

; - Xu Al   ix=*a
; - Au Xl   iy=Xl
;
; 13 to here
.fr_signsame:
	xor 	b  					; reverse xor find out what sign of Al is
	jp 	m,.fr_Alneg
; both positive 22 to here
	mul
	exx
	mul
	ex 	de,hl'
	adc 	hl,de 				; C clear   Yu*Xl+Yl*Xu -  possible overflow
	jr 	.frmul_2 				; 37+22=59 to _2


.fr_Alneg:
	mul
	add 	hl,de
	exx
	mul
	add 	hl,de
	ex 	de,hl'
	or 	a ; clc
	adc 	hl,de 				; 22+34=56   Yu*Xl+Yl*Xu - possible overflow
; continue

; 65 to here worst
;
; result entering here
; (Au*Xl)u + (Xu*Al)u    --       --   ix=*a
;  Au                     Xu      --   iy=Xl
;
	.frmul_2: 					; 65 to here from fr_psloop
	exx
	ld 	bc,hl   				; move Au to BC
	mul 							; 65+18=83 create Xu*Au most product
; (Au*Xu)u               Xu     (Au*Xu)l
; (Au*Xl)u + (Xu*Al)u    --      --
; hl:bc has number, need to add hl'
	ld 	de',bc 				; 4
	exx
; 83+6=89
; (Au*Xl)u + (Xu*Al)u   (Au*Xu)l      --
;  (Au*Xu)u               Xu     (Au*Xu)l(deletable)
	jp 	ovf,.fr_ovfpath 	; 31+65=96 overflow still set from 4 mul paths (adc hl,de) above
; non overflow path
; L1  L2  --
; U2  Xu  --  					; must compute sign extension of L1
	ld 	a,h 					; sign of L1
	exx
	ld 	bc,hl 				; save U2 in BC
	rla 							; sign to carry
	jr 	.fr_ovflpath1 		; 15+96=111 continue in overflow path
;
	.fr_ovfpath:
	ld 	a,h 					; sign of L1
	exx
	ld 	bc,hl 				; save U2 in BC
	rla 							; sign to carry
	ccf 							; due to overflow sign wrong
.fr_ovflpath1: 					; 111
	sbc 	hl,hl 				; hl has sign extension
	exx
; L1  L2  --
; U1  Xu  U2
	add 	hl,de 				; leasts
	exx
	adc 	hl,bc 				; mosts
; result in hl:hl'
; Pu  Xu  --
; Pl  --  --
; now do left shift
	exx
	add 	hl,hl
	exx
	adc 	hl,hl 				; 24+111= 135 left shift complete
	ld 	bc,4 					; step pointer
	add 	ix,bc 				; by 4 in table of coef
;
; Pu  Xu  --
; Pl  --  --
;
	ld 	bc,hl
	ld 	hl,(ix+2) 			; most coef
	exx
	ex 	de,hl
	ld 	hl,(ix)
	add 	hl,de  				; least sum
	exx
	adc 	hl,bc  				; most sum
; Sm  Xu  --
; Sl  --  --
; 38+125=163

;
;
	ex 	af,af' 				; check count
	dec 	a
	jr 	z,.fr_done 			; 172
	ex 	af,af'
; setup at top of loop
; - Au Xl   iy=Xl
; - Xu Al   ix=*a
	ex 	de',hl
; -- Xu --
; Al Au --
;
	exx
; Al Au --
; -- Xu --
	ld 	bc,hl
	ld 	bc',bc
; -- Au --
; -- Xu Al
	ld 	hl,iy
	ld 	bc,hl
; -- Au Xl
; -- Xu Al
	jp 	.fr_psloop 			; loop again 38+163=201 loop time
;
.fr_done:  						; -29 one time
; return result in bc:de
	ex 	de,hl
	ld 	bc',de 				; most
	exx
	ex 	de,hl
; now return, restoring ix
	ld 	ix,0
	add 	ix,sp 				; restore ix -9  ;Grand total 74 + N*201
#endasm
}



/*** BeginHeader bd2f */
float bd2f(unsigned long);
/*** EndHeader */
// helper function -- opposite of f2bd
__nodebug float bd2f(unsigned long x){

#asm xmemok
   ; make positive
   ld 	a,b 					; get sign
   ex 	af,af' 				; save it
   ld 	a,b
   or 	a
   jp 	p,.noneg
   ; negate here
   neg	bcde
.noneg:
	xor 	a 						; clear a
	or 	b  					; check for which byte has bit
	jr 	nz,.bbit
	or 	c
	jr 	nz,.cbit
	or 	d
	jr 	nz,.dbit
	or 	e
	jp 	nz,.ebit
	; here number is zero
	jp .bdexit ; done, number zero returned as floating zero
; each test sets c with count, a with least part to shift
.bbit: jp novf,.bbit4 		; if upper 4 bits are zero
   ; here upper 4 bits has bit, shift right 8 and left 1-3
   ld 	a,e ; very least
   ld 	e,d
   ld 	d,c
   ld 	l,b
   ld 	h,0
   ld 	c,127 				; exponent
   jr 	.shiftleft 			; go shift left 1-3 and dec exp
.bbit4:
   ; shift right 1 to 4
   ld 	hl,bc
   ld 	c,120 				; exponent
   xor 	a
   jr 	.shiftright 			; shift hl:de right 1 to 3
.cbit:
   jp 	novf,.cbit4 			; if upper 4 bits zero
   ; shift 0 right and left 0-3
   ld 	hl,bc
   xor 	a
   ld 	c,119
   jr 	.shiftleft
.cbit4:
   ; shift left 8 and  right 1-4
   ld	 	h,c
   ld 	l,d
   ld 	d,e
   ld 	e,0
   ld 	c,112
   xor 	a
   jr .shiftright
.dbit:
   jp 	novf,.dbit4 			; if upper 4 bits zero
   ; shift left 8 and left 1-3
   ld 	l,d
   ld 	d,e
   ld 	h,0
   ld 	e,0
   xor 	a
   ld 	c,111
   jr 	.shiftleft
.dbit4:
   ; shift left 16 and right 1-4
   ex 	de,hl
   ld 	de,0
   xor 	a
   ld 	c,104
   jr 	.shiftright
.ebit:
   jp 	novf,.ebit4
   ; shift left 16 and left 1-3
   ex 	de,hl
   ld 	de,0
   xor 	a
   ld 	c,103
   jr 	.shiftleft
.ebit4:
   ; shift left 24 and right 104
   ld 	h,e
   ld 	l,0
   ld 	de,0
   ld 	c,96
   xor 	a
   jr 	.shiftright

   ; shift left up to 3 until 7,L is a 1 register is hl:de:a  count c
.shiftleft:
   bit 	7,l
   jr 	nz,.shiftleft3
   rla
   rl 	de
   adc 	hl,hl 				; one shift guaranteed
   dec 	c
   bit 	7,l
   jr 	nz,.shiftleft3
   rla
   rl 	de
   adc 	hl,hl
   dec 	c
   bit 	7,l
   jr 	nz,.shiftleft3
   rla
   rl 	de
   adc 	hl,hl
   dec 	c
   jr 	.spack
.shiftleft3:
   or 	a
   jr 	z,.shiftleft4
   set 	0,e 					; or in lost bit
.shiftleft4:
   jr 	.spack 				; go pack it up
   ;
.shiftright:
   ; shift right 1-4 hl:de till h is zero
   or 	a
   rr 	hl
   rr 	de
   rra  							; save shifted off
   inc 	h
   dec 	h 						; test h
   jr 	z,.shiftr3
   or 	a
   rr 	hl
   rr 	de
   rra
   inc 	c
   inc 	h
   dec 	h 						; test h
   jr 	z,.shiftr3
   or 	a
   rr 	hl
   rr 	de
   rra
   inc 	c
   inc 	h
   dec 	h ; test h
   jr 	z,.shiftr3
   or 	a
   rr 	hl
   rr 	de
   rra
   inc 	c
.shiftr3:

; pack number hl:de has mantissa, c has exp, af' has sign, a has bits shifted off
.spack:
	or 	a
	jr 	z,.spack1
	set 	0,e 					; or in least
.spack1:
	rl 	l  					; lose hidden bit
	ex 	af,af'
	rla 							; sign to c to c
	rr 	c
	rr 	l
	ld 	b,c 					; exp and sign
	ld 	c,l
; result in bc:de
.bdexit:
#endasm
}



/*** BeginHeader pow2 */
float pow2(float x);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
pow2                                                              <math.h>

SYNTAX:       float pow2(float x);

PARAMETER1:   Floating point power to which 2 is to be raised. Error if
              x>128.9. Zero returned if x<-127.

KEYWORDS:     math

DESCRIPTION:  2 to the power of "x"
              Timing positive numbers  2400 clocks or 80 us at 30 MHz
              Timing negative numbers  3600 clocks or 120 us at 30 MHz

RETURN VALUE: See description.
END DESCRIPTION **********************************************************/

/*
 * POW2
 *
 * Purpose:
 *              Generate 2 to the x.
 *
 */
/*
   Method: divide number into an integer and a binary fraction x=n+f
   This is done by unpacking the floating point number. The fraction must be in
   the range 0<=f<1. Pow2 of f is computed using formula 1043 from Hart &
   Cheney, a power series in x. The final result is 2^(n+f)=(2^n)*(2^f). n is
   the exponent of the floating result, 2^f is the mantissa and has a value
   between 1 and 2. An exception occurs if x is greater than 128.9.

*/

__nodebug float pow2(float x) {

	auto float temp;
	auto long  int t1;
	auto int   ti,sgn;
// table contains coeficients divided by 4
	const static unsigned long int coefs[]={ 116513L, 667851L, 5196288L, 29787392L, 128972411L, 372130453L, 536870913L};

#asm xmemok
 ; if positive make error if out of range >128.9
   bit 	7,b
   jr 	nz,.perr2
   ld 	hl,4300h 			; 128.9
   or 	a
   sbc 	hl,bc 				;see if larger than 128.9
   jr 	nc,.perr2
	;; note: small negative ==> exception on divide by zero
	ld		hl, _cexpr(-ERR_RANGE)
	push	hl
	call	exception
   jr 	.perr3
.perr2:
 ; here is negative
   ld 	hl,0c2fdh
   or 	a
   sbc 	hl,bc
   jr 	nc,.perr3
 ; here return zero
   jp 	__DC_powretzero 			; go return a zero
.perr3:
   ld 	a,b
   rla 							; get sign to carry
   sbc 	hl,hl 				; -1 if negative, else zero
   ld 	(sp+@sp+sgn),hl 	; save sign
   res 	7,b 					; clear sign
   ld 	hl,bc 				; hl is most, least in de
   adc 	hl,hl 				; rl hl
   ld 	a,h 					; exp
   scf
   rr 	l 						; set hidden bit
   ld 	h,0 					; clear h
; A has exponent 0-255

   cp 	a,135 				; if a> 134 overflow
   jp 	nc,__DC_pwrovr 			; !c if >= if too big
   cp 	a,126
   jr 	nc,.pow126 			; .ge. 126 jump - x>=.5
   ld 	h,l
   ld 	l,d
   ld 	d,e
   ld 	e,0 					; left by 8
 ; a is 125 or less
   cp 	a,103 				;
   jr 	nc,.pows0 			; if 24 or less shifts
 ; here 25 or more
   bool 	hl
   rr 	hl
   ld 	d,h
   ld 	e,h  					; zero hl
   jr 	.pows6 				; and continue
.pows0:
   sub 	a,127
   dec 	a  					; complement of number of right shifts, minimum 2
   rra 							; shift 1
   jr 	c,.pows2
   rr 	hl
   rr 	de
.pows2:
	rra
   jr 	c,.pows3
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
.pows3:
	rra
   jr 	c,.pows4
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
   rr 	hl
   rr 	de
.pows4:
   rra
   jr 	c,.pows5 				; if not shift by 8
   ld 	e,d
   ld 	d,l
   ld 	l,h 					; shift by 8
   ld 	h,0
.pows5:
	rra 							; checkshift by 16
   jr 	c,.pows6
   ld 	de,hl
   clr 	hl
.pows6:
   ld 	a,0
   jr 	.pow2_2a 				; continue with calc
;
; here for x>=.5
.pow126:
 	sub 	a,126 				; if a>126 shift left to get integer part in h
   jr 	z,.pow2_2 			; jp if .5<=x<1.
 ; here to shift left up to 8
   ld 	b,a 					;count
   or 	a
.pow2_1:
   rl 	de
   adc 	hl,hl
   djnz 	.pow2_1 				;
; now have integer in h and fraction in l:d:e
   ld 	a,h 					; integer part in A
.pow2_2:
   ld 	h,l
   ld 	l,d
   ld 	d,e
   ld 	e,0 					; make into fraction in range .5-1.
   or 	a
   rr 	hl
   rr 	de 					; fraction in range .5 to 1. ready
.pow2_2a:
   push 	af 					; save exp
 ; bdSeries(7,coefs,x);
   ld 	bc,hl
   ld 	(sp+@sp+t1+2),hl 	; most
   ex 	de,hl
   ld 	(sp+@sp+t1),hl 	; least
 c t1=bdSeries(7,coefs,t1)	; // call bdseries
 ; result in bc:de is .25* 2^x in range of .35 to .5
 c bd2f(t1); 				// ; compute
   pop 	af 					; get exp back
   add 	a,2 					; adjustment because coefs are /4
 ; exp 	in a, bc:de has floating w/o exponent
   or 	a
;	jr 	z,.pow2exit 			; if exponent zero
   ld 	hl,bc
   add 	hl,hl
   rr 	b 						; save carry (sign)
   add 	a,h 					; f carry overflow
;	jr 	c,powovr 			; impossible?
   rl 	b 						; get sign
   rra
   rr 	l
   ld 	b,a
   ld 	c,l
;
.pow2exit:
   ex 	de,hl
   ld 	(sp+@sp+temp),hl 	; least
   ld 	hl,bc
   ld 	(sp+@sp+temp+2),hl ; most
#endasm

	if(!sgn)return temp; else return 1./temp;
__DC_pwrovr:
	if(!sgn)
		return HUGE_VAL;
	else
__DC_powretzero:
		return 0.;
__DC_powretone:
	return 1.;
}

/*** BeginHeader expf */
#define expf(x)		exp(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
expf                                                              <math.h>

SYNTAX:       float expf(float x);

Defined as a macro to exp(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (expf)(float x)
{
	return exp(x);
}

/*** BeginHeader exp */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
exp                                                               <math.h>

SYNTAX:       double exp(double x);
              float expf(float x);

PARAMETER1:   Floating point power to which e is to be raised.

KEYWORDS:     math

DESCRIPTION:  e to the power of "x"
              Timing positive numbers  3000 clocks or 100 us at 30 MHz
              Timing negative numbers  3900 clocks or 130 us at 30 MHz

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/

/*
   Method: e^x  = 2^(log2(e)*x)
*/
__nodebug
double exp(double x)
{
 return pow2(1.442695040889*x);

}


/*** BeginHeader frMul */
unsigned long int frMul(long int X, long int A);
/*** EndHeader */

// utility routine to aid in integer math
// multiplies 2 32-bit fractions and returns result
// bit 30 has value 1/2 - close to 200 clocks

__nodebug unsigned long int frMul(long int X, long int A) {

#asm xmemok
	ld 	hl,(sp+@sp+X+2) 	; Xu
	ex 	de',hl
	ld 	hl,(sp+@sp+A) 		; Al
	ex 	de,hl
	ld 	bc',de 				; Al
	ld 	hl,(sp+@sp+A+2) 	; Au
	ex 	de,hl
	ld 	hl,(sp+@sp+X) 		; Xl
	ld 	bc,hl
; 14+36= 50 clocks to here

; setup at top of loop
; - Au Xl
; - Xu Al
; result
;
.fr_psloop:
	ld 	a,b 					; 2 sign of Xl
	exx  							; 2
	xor 	b 						; 2 compare to sign of Al
	jp 	p,.fr_signsame  	; 7 if different/same signs

; signs are different here
; 63 to here
; signs different, see which neg
	xor 	b         			; (clear carry) 2 reverse previous xor to reveal sign of Xl
	jp 	p,.fr_Xlpos 			; 7 if alt regs have neg in bc


; - Xu Al   (hl  de  bc}
; - Au Xl   (hl' de' bc')
;
; 72 to here Xl is negative, Al is positive
.fr_Xlneg:
	mul
	exx
	mul
	add 	hl,de 				; adjust
	ex 	de,hl'
	or 	a 						; clear carry
	adc 	hl,de 				; partial sum
	jr 	.frmul_2 				; 43+72=115

; 72 to here  Xl pos, Al neg
.fr_Xlpos:
	mul 							; 12
	add 	hl,de 				;2 adjust for neg
	exx 							;2
	mul 							; 12
	ex 	de,hl' 				; 4
	or 	a 						; clear C
	adc 	hl,de  				;(C is clear) Yu*Xl+Yl*Xu
	jr 	.frmul_2 				; 43+72=115 to _2

; - Xu Al   ix=*a
; - Au Xl   iy=Xl
;
; 63 to here
.fr_signsame:
	xor 	b  					; (clear C) reverse xor find out what sign of Al is
	jp 	m,.fr_Alneg
; both positive 72 to here
	mul
	exx
	mul
	ex 	de,hl'
	adc 	hl,de 				; C is clear
	jr 	.frmul_2 				; 41+72=113

; 72 to here
.fr_Alneg:
	mul
	add 	hl,de
	exx
	mul
	add 	hl,de
	ex 	de,hl'
	or 	a 						; clear C
	adc 	hl,de 				; 40+72=112 overflow possible here
; continue

; 115 to here worst
; - Xu Al
; - Au Xl
; becomes
;
; result entering here
; (Au*Xl)u + (Xu*Al)u    --       --   ix=*a
;  Au                     Xu      --   iy=Xl
;
; 115 to here
.frmul_2:
	exx
	ld 	bc,hl
	mul ; 111+18=129
; (Au*Xu)u               Xu     (Au*Xu)l
; (Au*Xl)u + (Xu*Al)u    --      --
; hl:bc has number, need to add hl'
	ld 	de',bc 			; 4
	exx
; (Au*Xl)u + (Xu*Al)u  (Au*Xu)l  --
;     (Au*Xu)u          Xu       --
; 24+115=139
	jp 	ovf,.fr_ovfpath
; no overflow path
; L1 L2 -
; U2 Xu -  need to get sign extension of L1
	ld 	a,h 					; sign in bit 7
	exx
	ex 	de,hl
	rla
	jr 	.fr_ovrpath1  		; continue

.fr_ovfpath: 					; must correct overflow
; L1 L2 -
; U2 Xu -  						; neet to get sign extension of L1
	ld 	a,h 					; sign in bit 7
	exx
	ex 	de,hl
	rla
	ccf  							; invert sign due to overflow
;
.fr_ovrpath1:
	sbc 	hl,hl 				; sign extension in hl
; U1 U2 -
; L1 L2
;
	exx
	add 	hl,de 				; lower sum
	exx
	adc 	hl,de 				; upper sum
	ex 	de,hl' 				; lower sum to de
; result in hl:de
; scale by shift
	rl 	de
	adc 	hl,hl
	ld 	bc,hl					; return in bc
;
; 187 to here worst case
#endasm

}



/*** BeginHeader log2 */
float log2(float x);
/*** EndHeader */

/* Algorithm
 From Cheney & Hart
 log(x)= z*P(z^2), z=(x-1)/(x+1)
 using table 2662 and adjusting coeficients by factor of (1./log(2)) to
 get log2.

 log2(x)= (z*4)*( (A[0]/4.) + (A[1]/4.)*z + (A[2]/4.)*z*z + (A[3]/4.)*z*z*z )
 Permitted range of x is .707<x<1.41

*/
 __nodebug float log2(float fX) {

// coeficients are: 2.885390073,0.961800759,0.576584541,0.434255941
// in array A[] they are divided by 4 (2^31==1) and reverse order
	const static unsigned long int A[]=
		{233139383,309551469,516362851,1549082000};

	auto int iexp;
	auto unsigned long int z,z4;

#asm xmemok
	ld    de,0
	ld    a,0
	ld 	hl,(sp+@sp+fX) 	; least signif of fX
	scf
	ccf							; clear carry flag
	adc   hl,de
	jr    nz,.log2_LSnot_zero
	ld    a,1					; use A to indicate LSBs 0
.log2_LSnot_zero:
	ld 	hl,(sp+@sp+fX+2) 	; most signif of fX
	adc   hl,de
	jr    nz,.log2_MSnot_zero
	and   0x01
	jr    nz,.log2_dom_err	; if all zeros, dom. error
.log2_MSnot_zero:
	add	hl,hl 				; left
	jr 	nc,.domok
; here attempt to take log of negative
.log2_dom_err:
	ld		hl, _cexpr(-ERR_DOMAIN)
	push	hl
	call	exception
.domok:
	rr 	a 						; sign to a
	ld 	e,h 					; exponent to de
	ld 	d,0 					; in de
	ld 	h,d 					; zero h
	or 	a 						; clc
	rr 	l 						; mantissa hidden bit clr
	ex 	af,af'
	ld 	a,53
	cp 	l 						; if 53>=L then in range of x<1.4
	ld 	a,127 				; trial exp
	jr 	nc,.log2_1
	inc 	de 					; exponent larger
	dec 	a 						; 127->126
.log2_1:
	ld 	hl,(sp+@sp+fX+2)
	rl 	l
	rl 	h
	ld 	h,a 					; new exp
	rr		h
	rr 	l
	ld 	(sp+@sp+fX+2),hl 	; put back with new exp
	ex 	de,hl
	ld 	(sp+@sp+iexp),hl 	; put away integer exponent
#endasm
// now fX is in range .707 to 1.41 and remainder is in iexp which is 127 high
	z=f2bd((fX-1.)/(fX+1.))	; //f2bd takes 35 us at 14.7 mhz or 500 clocks
// computing entire above expression requires 126 clocks
#asm xmemok
	ld 	hl,(sp+@sp+z+2) 	; most
	ex 	de,hl
	ld 	hl,(sp+@sp+z) 		; least
	add 	hl,hl
	rl 	de
	add 	hl,hl
	rl 	de  					; x4
	ld 	(sp+@sp+z4),hl 	; least
	ex 	de,hl
	ld 	(sp+@sp+z4+2),hl 	; most
#endasm

//z=
	frMul(z4, bdSeries( 4,A,frMul(z,z) )  ); // 111 us at 14.7 mhz- 1630 clocks
// add the result of above operation to (iexp-1)
#asm xmemok
	ld 	hl,bc 				; move result to hl:de
;
	ld 	a,e  					; shift fraction
	ex 	af,af' 				; least part of fraction in a'
	ld 	e,d
	ld 	d,l
	ld 	l,h
	rl 	h
	sbc 	a,a 					; set bits of A to match sign of fraction
	ld 	h,a 					; sign extension - now have hl:de as signed fraction shifted 8 right
	ex 	af,af' 				; sign extension in a'
	exx
	ld 	hl,(sp+@sp+iexp) 	; exponent
	rr 	hl
	ld 	h,l
	ld 	l,0
	rr 	l  					; put iexp in top 9 bits
	ld 	de,03f80h 			; 127 in top 9 bits
	or 	a
	sbc 	hl,de 				; iexp-127 -can be 0x80 which must be treated as +128
	or 	a
	ex 	de,hl
	ld 	bc',de
	exx
	add 	hl,bc 				; add integer part
	ld 	bc,hl 					; now set up bc:de
	call 	bd2f 					; convert, return result in bc:de, add 7 to exponent
	ld 	hl,0400h 			; 8
	add 	hl,bc
	ld 	bc,hl
#endasm



//return (iexp-127)+bd2f(z); //result (z is between -.5 and +.5 approx)
// return 75 us at 14.7 MHz or 1100 clocks
// bd2f is 56 us at 14.7 MHz or 800 clocks
}


/*** BeginHeader logf */
#define logf(x)		log(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
logf                                                              <math.h>

SYNTAX:			float logf(float x);

Defined as a macro to log(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (logf)(float x)
{
	return log(x);
}

/*** BeginHeader log */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
log                                                               <math.h>

SYNTAX:       double log(double x);
              float logf(float x);

PARAMETER1:   Floating number to take natural log of

KEYWORDS:     math

DESCRIPTION:  exp(log(x))==x
              Timing positive numbers  4500 clocks or 135 us at 30 MHz


RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/

// computes log base e from log base 2 of x
__nodebug
double log(double x)
{
  return log2(x)*0.693147180560;
}


/*** BeginHeader log10f */
#define log10f(x)		log10(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
log10f                                                            <math.h>

SYNTAX:			float log10f(float x);

Defined as a macro to log10(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (log10f)(float x)
{
	return log10(x);
}

/*** BeginHeader log10 */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
log10                                                             <math.h>

SYNTAX:       double log10(double x);
              float log10f(float x);

PARAMETER1:   Number to take log base 10 of

KEYWORDS:     math

DESCRIPTION:  10^log10(x) == x
              Timing positive numbers  4500 clocks or 135 us at 30 MHz


RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/

// computes log base 10 from log base 2
__nodebug
double log10(double x)
{
	return log2(x)*0.301029995664;
}


/*** BeginHeader sinf */
#define sinf(x)		sin(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sinf                                                              <math.h>

SYNTAX:			float sinf(float x);

Defined as a macro to sin(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (sinf)(float x)
{
	return sin(x);
}


/*** BeginHeader sin */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sin                                                               <math.h>

SYNTAX:       double sin( double fX)
              float sinf( float fX)

DESCRIPTION:  The sine function in fixed-point math using the floating
              point parameter 'fX'. 'fX' is not restricted. However, best
              performance is obtained by restricting 'fX' to [0,2pi], or
              [0,pi/2]. Timing: Approx 3600 clocks or 120 us on 30 MHz
              system.

RETURN VALUE: The floating point result.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/

__nodebug __xmem
double sin( double fX)
{
const static unsigned long bd_sine0coefP2[] = {
   0x0B8F, 0xfffcbfcd, 0x00888888, 0xf5555550, 0x40000000};

const static unsigned long bd_sine2coefP2[] = {
	0xFFFFFED8,0x00006806, 0xffe93e94, 0x02aaaaac, 0xe0000000, 0x40000000};
	auto int sign;
	auto float n;
	auto unsigned long bdsine,bdsine2;
	auto float sine,sine2;
	auto union {float x; int nx[2]; } un;

//	if(fX<0) {
//		sign=1;
//		fX=-fX;
//	} else {
//		sign=0;
//	}



#asm
	ld 	hl,(sp+@sp+fX+2) 		; most
	ex 	de,hl
	rl 	de
	sbc 	hl,hl 					; -1 if carry on
	bool 	hl
	ld 	(sp+@sp+sign),hl 		; set sign
	rr 	de
	ex 	de,hl
	ld 	(sp+@sp+fX+2),hl 		; restore with sign zero
#endasm

	un.x=fX; // place arg in union for access to parts

__DC_beginswitch:

	if(un.nx[1]> 0x404A)
	{  // if greater than 3.16

		un.x=fX=fX-3.14159265; sign=!sign;
 	}

	if(un.nx[1]<0x3F49)
	{   // less than pi/4=.78
  		if(un.nx[1] < 0x3c80) {
  			sine=(fX-.1666666666*fX*fX*fX);
  			goto __DC_sexit;
  		}  // for small angles

   // 0 to .4 .707 radian
__DC_c2a:
  	   bdsine=f2bd(fX);
	   bdsine2=frMul(bdSeries(5,bd_sine0coefP2, frMul(bdsine,bdsine) ),bdsine);
	   sine=fx2(bd2f(bdsine2));
      goto __DC_sexit;
	}

	else if(un.nx[1]<0x4016)
	{																						// less than (3/4) pi (2.35) greater then pi/4

		fX=fX-1.570796325;  															// fx-pi/2
  		bdsine = f2bd( fX );															// Convert "frac" from float to binary decimal
		bdsine = bdSeries( 6, bd_sine2coefP2,frMul(bdsine, bdsine));	// Evaluate the sine
		sine = fx2( bd2f( bdsine ) );												// Convert from binary decimal to float
      goto __DC_sexit;
   }

	else if(un.nx[1]<0x4055)
	{  																					// less than 3.14159+0.2

      fX=3.14159265-fX; goto __DC_c2a;
  	}

	else
	{

		fX = fX * 0.1591549430919;													//  * 1/(2*pi) Scale to 0 < fX < 2pi (~900 clocks)
		fX = modf( fX, &n );
		un.x=fX = 6.2831853071796 * fX; 											// *2*pi
		goto __DC_beginswitch;

  }


__DC_sexit:																					// 50 < clocks < 1400
	if( sign )
	{
		return -sine;
	}
	else
	{
		return sine;
	}
}


/*** BeginHeader atanf */
#define atanf(x)		atan(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
atanf                                                             <math.h>

SYNTAX:			float atanf(float x);

Defined as a macro to atan(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (atanf)(float x)
{
	return atan(x);
}


/*** BeginHeader atan */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
atan                                                              <math.h>

SYNTAX:       double atan(double x);
              float atanf(float x);

PARAMETER1:   Floating point input for arctangent computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arctangent of real float value x. x is assumed
              between -INF and +INF.
              Timing: for |x| < 1. 3800 clocks 125 us at 30 MHz
                      for |x| > 1. 5200 clocks 175 us at 30 MHz

RETURN VALUE: The arctangent of the argument.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/

  // compute arc tangent of x
// Hart and Cheney formula 4992 for arctan over the interval [0,1]
// arctan(x)= xP(x*x)
// range reduction for x>1 by using: arctan(x) = pi/2 - arctan (1/x)
// and arctan(-x)=-arctan(x)

__nodebug
double atan(double x)
{

// coeficients for power series are stored as 1/2 actual values as integer fractions

/* coefs a0.. a8
  0.999999985
 -0.333330733
  0.199926194
 -0.142036445
  0.10640934
 -0.075042945
  0.042691519
 -0.0160686289604
  0.00284989
*/

const static unsigned long int coef[]={3060046,-17253559,45839670,-80576749,114256159,-152510471,214669116,-357911150,1073741808};

auto sgn,adj; //logical variables
auto float temp;
auto unsigned long ti;

//sgn=adj=0;
#asm xmemok
	clr 	hl
	ld 	(sp+@sp+sgn),hl 	; zero
	ld 	(sp+@sp+adj),hl 	; zero
#endasm

//if(x<0.) {x=-x; sgn=1;}
//if(x>1.) {x=1./x; adj=1;}
//if(x==1.) return 0.785398163; // pi/4

// if(x<.02) if(sgn) return -x*(1-.33333333*x*x); else return x*(1-.33333333*x*x);

#asm xmemok
	ld 	hl,(sp+@sp+x+2) 	; most of x
	add 	hl,hl
	jr 	nc,.atan_2
	ccf
	ex 	de,hl
	ld 	hl,8000h
	ld 	(sp+@sp+sgn),hl   ; sgn=8000
	ex 	de,hl
.atan_2:
	rr 	hl                ; restore hl w/o sign
	ld 	bc,hl             ; most to bc
	ld 	(sp+@sp+x+2),hl   ; most, with positive sign
; check for very small
	ld 	de',bc            ; most
	exx
	ld 	hl,03d00h         ; 1/32
	or 	a
	sbc 	hl,de             ; 1/32-value
	jp 	nc,__DC_atansmall      ; on very small exit
	exx
; 1. in floating is 3f800000
	ld 	de,03f80h
	or 	a
	sbc 	hl,de             ; nc means >=
	jr 	z,.__atan_ueq
	jp 	c,.atan_Lt1        ; if x < 1.
	jr 	.__atan_recip        ; if x > 1.
.__atan_ueq:
; upper parts equal, if lower 0 is exactly 1.
	ld 	hl,(sp+@sp+x)     ; least part
	bool 	hl
	jr   nz,.__atan_notpiovr4
   ld   hl,(sp+@sp+sgn)
   bool hl
   rr   hl
   jp   nc,__DC_atan_retpiovr4
   jp   __DC_atan_negpiovr4
.__atan_notpiovr4:
; here take 1/x
.__atan_recip:
c x=1./x;
	ld 	hl,1
	ld 	(sp+@sp+adj),hl 	; set adj=1;
;
	.atan_Lt1: 					; here x is less than 1
#endasm
	ti=f2bd(x); 																	// get integer representation

	temp = fx2( bd2f(frMul(ti, bdSeries(9,coef,frMul(ti,ti)))));  	// 2*x*P(x*x)

	if(adj)
	{
		temp = 1.570796327 - temp; 											// pi/2-arctan(1/x)
	}

// if(sgn) temp=-temp;
__DC_atanexit:
#asm xmemok
	ld 	iy,@sp
	add 	iy,sp
	ld 	a,(iy+sgn+1) 		; 80 or 00
	xor 	a,(iy+temp+3) 		; sign of floating number
	ld 	(iy+temp+3),a
#endasm


	return temp;
__DC_atan_retpiovr4:
	return 0.785398163;
__DC_atan_negpiovr4:
	return -0.785398163;
__DC_atansmall:
	temp=x*(1.-.33333333333*x*x);
	goto __DC_atanexit;
}



/*** BeginHeader asinf */
#define asinf(x)		asin(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
asinf                                                             <math.h>

SYNTAX:			float asinf(float x);

Defined as a macro to asin(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (asinf)(float x)
{
	return asin(x);
}


/*** BeginHeader asin */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
asin                                                              <math.h>

SYNTAX:       double asin(double x);
              float asinf(float x);

PARAMETER1:   Floating point input for arcsine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arcsine of real float value x. x is assumed
              between -1 and +1.

RETURN VALUE: The arcsine of the argument.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double asin(double x)
{
	auto float y;

	if ((y = x * x) > 1.0)
	{
		exception(-ERR_DOMAIN);
		return 0.0;
	}

	if (x == - 1.0)
	{
		return - PIbyTWO;
	}

	if (y == 1.0)
	{
		return PIbyTWO;
	}

	return (atan(x / sqrt(1.0 - y)));
}


/*** BeginHeader acosf */
#define acosf(x)		acos(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
acosf                                                             <math.h>

SYNTAX:			float acosf(float x);

Defined as a macro to acos(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (acosf)(float x)
{
	return acos(x);
}

/*** BeginHeader acos */
/*** EndHeader */
/*
 * ACOS
 *
 * Purpose:
 *              Compute the arccosine of real float value x
 *              The value x is assumed between -1 and 1
 * Returns:
 *              0       Range error, set errno = EDOM
 *              angle   No error, answer in radians 0..PI
 * Method:
 *              acos(x) = PI/2 - asin(x)
 */

/* START FUNCTION DESCRIPTION ********************************************
acos                                                              <math.h>

SYNTAX:       double acos(double x);
              float acosf(float x);

PARAMETER1:   Floating point input for arccosine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the arccosine of real float value x.  x is assumed
              between -1 and 1.

RETURN VALUE: Arccosine of the argument.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double acos(double x)
{
	auto float y;

	if ((y = x * x) > 1.0)
	{
		exception(-ERR_DOMAIN);
		return 0.0;
	}
	if (x == - 1.0)
		return PI;
	if (y == 1.0)
		return 0.0;
	return (PIbyTWO - atan(x / sqrt(1.0 - y)));
}


/*** BeginHeader atan2f */
#define atan2f(y,x)		atan2(y,x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
atan2f                                                             <math.h>

SYNTAX:			float atan2f(float y, float x);

Defined as a macro to atan2(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (atan2f)(float y, float x)
{
	return atan2(y, x);
}

/*** BeginHeader atan2 */
/*** EndHeader */
/*
 * ATAN2
 *
 * Purpose:
 *              Compute the arctangent of real float value y/x
 *              to find the angle in radians between the x-axis
 *              and the ray through (0,0) and (x,y).
 * Returns:
 *              0       Error x=y=0, errno = ERR_DOMAIN
 *              angle   answer in radians -PI .. PI approx
 *              PI/2    x=0, y>0
 *             -PI/2    x=0, y<0
 *              0       x>0, y=0
 *              PI      x<0, y=0
 *
 *  Recoded 10-Sept-88 after math test failure.
 *  There were problems! The results in Q-II and Q-III were wrong.
 */
/* START FUNCTION DESCRIPTION ********************************************
atan2                                                             <math.h>

SYNTAX:       double atan2(double y, double x);
              float atan2f(float y, float x);

PARAMETER1:   y coordinate of point (x,y).

PARAMETER2:   x coordinate of point (x,y).

KEYWORDS:     math

DESCRIPTION:  Computes the arctangent of real float value y/x to find the
              angle in radians between the x-axis and the ray through (0,0)
              and (x,y).

RETURN VALUE: Arctangent of y/x.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double atan2(double y, double x)
{
	auto float z;

	if (x == 0.0)
	{
		if (y == 0.0)
		{
			exception(-ERR_DOMAIN);
			return 0.0;
		}
		return ((y > 0.0) ? PIbyTWO : - PIbyTWO);
	}
	if (y == 0.0)
		return ((x > 0.0) ? 0.0 : - PI);
	z = atan(y / x);
	if (x > 0.0)
		return z;
	return (z + ((y > 0.0) ? PI : - PI));
}

/*** BeginHeader ceilf */
#define ceilf(x)		ceil(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
ceilf                                                             <math.h>

SYNTAX:			float ceilf(float x);

Defined as a macro to ceil(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (ceilf)(float x)
{
	return ceil(x);
}

/*** BeginHeader ceil */
/*** EndHeader */
/*
 * CEIL
 *
 * Purpose:
 *              Compute float ceiling, the smallest integer greater
 *              than or equal to the given number.
 * Argument:
 *              ceil(f)
 *              f               float number
 * Returns:
 *              g               Where g is a whole number, signed,
 *                              with f <= g and g-1 < f.
 * Notes:
 *              o No overflow check.
 *              o No auto conversion to float.
 */
/* START FUNCTION DESCRIPTION ********************************************
ceil                                                              <math.h>

SYNTAX:       double ceil(double x);
              float ceilf(float x);

PARAMETER1:   Floating point input for ceiling computation.

KEYWORDS:     math

DESCRIPTION:  Computes the smallest integer greater than or equal to the
              given number.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double ceil(double f)
{
	auto long i;

	i = (long) f;
	if ((float) i < f)
		++i;
	return ((float) i);
}


/*** BeginHeader cosf */
#define cosf(x)		cos(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
cosf                                                              <math.h>

SYNTAX:			float cosf(float x);

Defined as a macro to cos(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (cosf)(float x)
{
	return cos(x);
}

/*** BeginHeader cos */
/*** EndHeader */
/*
 * COS
 *
 * Purpose:
 *              Compute the cosine of real float value x
 *              The value x is assumed in radians (not degrees)
 *              Use deg() and rad() for conversions.
 * Returns:
 *              number          answer between -1 and 1
 *                              No error checking for large x
 * Method:
 *              cos(x) = sin(x + PI/2)
 */
/* START FUNCTION DESCRIPTION ********************************************
cos                                                               <math.h>

SYNTAX:       double cos(double x);
              float cosf(float x);

PARAMETER1:   Floating point input for cosine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the cosine of real float value x (radians).

RETURN VALUE: Cosine of the argument.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double cos(double x)
{
	return (sin(x + PIbyTWO));
}


/*** BeginHeader coshf */
#define coshf(x)		cosh(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
coshf                                                             <math.h>

SYNTAX:			float coshf(float x);

Defined as a macro to cosh(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (coshf)(float x)
{
	return cosh(x);
}

/*** BeginHeader cosh */
/*** EndHeader */
/*
 * COSH
 *
 * Purpose:
 *              Compute the hyperbolic cosine of real float value x
 * Returns:
 *              number          x in range
 *              HUGE_VAL (INF)  x too large positive
 *             -HUGE_VAL (-INF) x too large negative
 *                              errno = -ERR_RANGE returned to flag error
 * Method:
 *              cosh(x) = (exp(x) + exp(-x))/2.0
 * Notes:
 *              o The value of EXPLARGE was found by solving the
 *                equation exp(x) = 1.0e39.
 */

/* START FUNCTION DESCRIPTION ********************************************
cosh                                                              <math.h>

SYNTAX:       double cosh(double x);
              float coshf(float x);

PARAMETER1:   Floating point input for hyperbolic cosine computation.

KEYWORDS:     math

DESCRIPTION:  Computes the hyperbolic cosine of real float value x.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double cosh(double x)
{
	if (fabs(x) > EXPLARGE)
	{
		exception(-ERR_RANGE);
		return x > 0 ? HUGE_VAL : -HUGE_VAL;
	}
	return (exp(x) + exp(- x)) / 2.0;
}


/*** BeginHeader fabsf */
#define fabsf(x)		fabs(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
fabsf                                                             <math.h>

SYNTAX:			float fabsf(float x);

Defined as a macro to fabs(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (fabsf)(float x)
{
	return fabs(x);
}

/*** BeginHeader fabs */
/*** EndHeader */

/*
 * FABS
 *
 * Purpose:
 *              Compute the float absolute value of float x
 * Returns:
 *              arg     if arg >= 0
 *             -arg     if arg < 0
 */

/* START FUNCTION DESCRIPTION ********************************************
fabs                                                              <math.h>

SYNTAX:       double fabs(double x);
              float fabsf(float x);

PARAMETER1:   Floating point value for which absolute value is to be returned.

KEYWORDS:     math

DESCRIPTION:  Computes the float absolute value of float x.

RETURN VALUE:  x, if x >= 0; else -x.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
#asm  __nodebug
fabs::
	   res      7,b                  ; clear sign bit
	   ret
#endasm


/*** BeginHeader floorf */
#define floorf(x)		floor(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
floorf                                                            <math.h>

SYNTAX:			float floorf(float x);

Defined as a macro to floor(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (floorf)(float x)
{
	return floor(x);
}

/*** BeginHeader floor */
/*** EndHeader */
/*
 * FLOOR
 *
 * Purpose:
 *              Compute float floor, the largest integer less
 *              than or equal to the given number.
 * Argument:
 *              floor(f)
 *              f               float number
 * Returns:
 *              g               Where g is a whole number, signed,
 *                              with g <= f and f < g+1.
 * Notes:
 *              o No overflow check.
 *              o No auto conversion to float.
 */

/* START FUNCTION DESCRIPTION ********************************************
floor                                                             <math.h>

SYNTAX:       double floor(double x);
              float floorf(float x);

PARAMETER1:   Floating point input for floor computation.

KEYWORDS:     math

DESCRIPTION:  Computes the largest integer less than or equal to the given
              number.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double floor(double f)
{
	auto long i;

	i = (long) f;
	if (f < 0.0)
	{
		if (f != (float)i)
		{
			i--;
		}
	}
	return ( (float)i );
}


/*** BeginHeader fmodf */
#define fmodf(x, y)		fmod(x, y)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
fmodf                                                             <math.h>

SYNTAX:			float fmodf(float x, float y);

Defined as a macro to fmod(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (fmodf)(float x, float y)
{
	return fmod(x, y);
}

/*** BeginHeader fmod */
/*** EndHeader */
/*
 * FMOD
 *
 * Purpose:
 *              Solves for float f in the equation x = k*y + f
 *              such that x*f >= 0, fabs(f) < fabs(y), for some
 *              long integer k.
 * Returns:
 *              f       as computed above, a remainder (not a modulus)
 * Notes:
 *              o This works because the float library converts
 *                to integer by truncation. If it didn't, then
 *                it would be much more difficult to write.
 */

/* START FUNCTION DESCRIPTION ********************************************
fmod                                                              <math.h>

SYNTAX:       double fmod(double x, double y);
              float fmodf(float x, float y);

PARAMETER1:   Floating point numerator of ratio for modulo computation.

PARAMETER2:   Floating point denominator of ratio for modulo computation.

KEYWORDS:     math

DESCRIPTION:  Floating point modulo math.

RETURN VALUE: Returns the remainder of x/y.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double fmod(double x, double y)
{
	auto long k;
   auto float d;

	if (y == 0.0)
	{
		exception(-ERR_RANGE);
		return 0.0;
	}
	k = (long)(x / y); // Note: In some cases, d may be zero.
   d = x - (float)k * y;
   return d >= y ? d - y : d;
}


/*** BeginHeader frexpf */
#define frexpf(x, n)		frexp(x, n)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
frexpf                                                            <math.h>

SYNTAX:			float frexpf(float x, int *n);

Defined as a macro to frexp(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (frexpf)(float x, int *n)
{
	return frexp(x, n);
}

/*** BeginHeader frexp */
/*** EndHeader */
/*
 * FREXP
 *
 * Purpose:
 *              Splits x into x = f*(radix**n) where n is an integer
 *              and 0.5 <= f < 1.0. The value of radix is 2 for this
 *              library.
 * Returns:
 *              f               the fraction, a float
 *              n               via *nptr = n;
 * Notes:
 *              o The float library is radix 2.
 *              o There is always a better way to do this calculation
 *                based on knowledge of the float representation.
 *              o The exponent in this float library is given by
 *                r = ((int)255 & (int)x.c[3]) - (int)128.
 */

/* START FUNCTION DESCRIPTION ********************************************
frexp                                                             <math.h>

SYNTAX:       double frexp(double x, int *n);
              float frexpf(float x, int *n);

PARAMETER1:   Floating point input for return as mantissa and exponent.

PARAMETER2:   Address of an integer where returned exponent will be placed.

KEYWORDS:     math

DESCRIPTION:  Splits x into x = f*(radix**n), where n is an integer and
              0.5 <= f < 1.0.  Radix = 2 for this library.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double frexp(double f, int *nptr)
{
	auto union { float f; char c[4]; } x;

	x.f = f;
	if (x.f == 0.0)
	{
		*nptr = 0;
		return (0.0);
	}
	*nptr = ((0x7f & (int) x.c[3]) << 1) +
	((0x80 & (int) x.c[2]) >> 7) - 126;// exponent

	x.c[3] &= 0xbf;
	x.c[3] |= 0x3f;
	x.c[2] |= 0x80;

	return (x.f * 0.5);
}


/*** BeginHeader ldexpf */
#define ldexpf(x, exp)		ldexp(x, exp)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
ldexpf                                                            <math.h>

SYNTAX:			float ldexpf(float x, int exp);

Defined as a macro to ldexp(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (ldexpf)(float x, int exp)
{
	return ldexp(x, exp);
}

/*** BeginHeader ldexp */
/*** EndHeader */

/*
 * LDEXP
 *
 * Purpose:
 *              computes  x*(radix**n) where n is an integer
 *              and typically 0.5 <= x < 1.0
 * Returns:
 *              product         a float
 * Notes:
 *              o The float exponent in this library is
 *                r = ((int)255 & (int)x.c[3]) - (int)128.
 *              o A portable version of ldexp() that can be used
 *                to check an implementation appears below.
 *
 *      float ldexp(x,n)
 *      float x;
 *      int n;
 *      {
 *      int i;
 *      float f;
 *              i = n; f = x;
 *              if(i < 0) while(i++ < 0) f = f/2.0;
 *              else      while(i-- > 0) f += f;
 *              return f;
 *      }
 */

/* START FUNCTION DESCRIPTION ********************************************
ldexp                                                             <math.h>

SYNTAX:       double ldexp(double x, int exp);
              float ldexpf(float x, int exp);

KEYWORDS:     math

PARAMETER1:   Floating point mantissa for ldexp computation.

PARAMETER2:   Integer power of 2 exponent for ldexp computation.

DESCRIPTION:  Computes x*(radix**n), where n is an integer and
              0.5 <= x < 1.0.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double ldexp(double f, int n)
{
	auto int r;
	auto union { float f; char c[4]; } x;

	x.f = f;

	r = ((0x7f & (int) x.c[3]) << 1) +
	((0x80 & (int) x.c[2]) >> 7) + n;// exponent

	x.c[3] = (x.c[3] & 0x80) | (r >> 1);
	x.c[2] |= (r & 0x01 ? 0x80 : 0);

	return x.f;
}


/*** BeginHeader modff */
#define modff(value,iptr)		modf(value,iptr)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
modff                                                             <math.h>

SYNTAX:			float modff(float x, float *iptr);

Defined as a macro to modf(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (modff)(float value, float *iptr)
{
	return modf(value, iptr);
}

/*** BeginHeader modf */
/*** EndHeader */
/*
 * MODF
 *
 * Purpose:
 *              Splits float x = f + n, where n is an integer
 *              and float f satisfies fabs(f) < 1.0
 * Returns:
 *              f               the fraction, a float remainder
 *              n               via *nptr = n;
 */

/* START FUNCTION DESCRIPTION ********************************************
modf                                                              <math.h>

SYNTAX:        double modf(double x, double *n);
               float modff(float x, float *n);


WARNING:	Previous versions of Dynamic C defined this function as:

					float modf(float x, int *n);

			This version of Dynamic C uses the C89/C90 definition instead.

PARAMETER1:    Floating point input for modf computation.

PARAMETER2:    Address of a double (float) where integer part of return will be
               placed.

KEYWORDS:      math

DESCRIPTION:   Splits x into f + n, where n is an integer and float f
               satisfies fabs(f) < 1.0.

RETURN VALUE:	See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double modf(double x, double *nptr)
{
	auto int i;
	auto float f;

	i = (int)x;
	f = x - (float)i;
	if (fabs(f) < 1.0)
	{
		*nptr = i;
		return f;
	}
	exception(-ERR_RANGE);
	return 0.0;
}


/*** BeginHeader sinhf */
#define sinhf(x)		sinh(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sinhf                                                             <math.h>

SYNTAX:			float sinhf(float x);

Defined as a macro to sinh(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (sinhf)(float x)
{
	return sinh(x);
}

/*** BeginHeader sinh */
/*** EndHeader */
/*
 * SINH
 *
 * Purpose:
 *              Compute the hyperbolic sine of real float value x
 * Returns:
 *              number          x in range
 *              HUGE_VAL (INF)  x too large positive
 *             -HUGE_VAL (-INF) x too large negative
 *                              errno = -ERR_RANGE returned to flag error
 * Method:
 *              sinh(x) = (exp(x) - exp(-x))/2.0
 * Notes:
 *              o The value of EXPLARGE was found by solving the
 *                equation exp(x) = 1.0e39.
 */

/* START FUNCTION DESCRIPTION ********************************************
sinh                                                              <math.h>

SYNTAX:       double sinh(double x);
              float sinhf(float x);

PARAMETER1:   Floating point input for hyperbolic sin computation.

KEYWORDS:     math

DESCRIPTION:  Hyperbolic sine of x.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double sinh(double x)
{
	if (x > EXPLARGE)
	{
		exception(-ERR_RANGE);
		return HUGE_VAL;
	}
	if (x < - EXPLARGE)
	{
		exception(-ERR_RANGE);
		return -HUGE_VAL;
	}
	return (exp(x) - exp(- x)) / 2.0;
}


/*** BeginHeader sqrtf */
#define sqrtf(x)		sqrt(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sqrtf                                                             <math.h>

SYNTAX:			float sqrtf(float x);

Defined as a macro to sqrt(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (sqrtf)(float x)
{
	return sqrt(x);
}

/*** BeginHeader sqrt */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
sqrt                                                              <math.h>

SYNTAX:       double sqrt(double x);
              float sqrtf(float x);

PARAMETER1:   Floating point input for square root computation.

KEYWORDS:     math

DESCRIPTION:  Square root of x.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
// useix nodebug float sqrt(float y);

const char sqrt_table[] = {
   127 , 125 ,	123 ,	122 ,	120 ,	118 ,	117 ,	115,
   114 , 112 ,	111 ,	110 ,	109 ,	107 ,	106 ,	105,
   104 , 103 ,	102 ,	101 ,	100 ,	99	 ,	98	 ,	97,
   96  , 95  ,	95  ,	94	 ,	93	 ,	92	 ,	92	 ,	91,
   90  , 88  ,	87  ,	86	 ,	85	 ,	84	 ,	83	 ,	81,
   80  , 79  ,	79  ,	78	 ,	77	 ,	76	 ,	75	 ,	74,
   74  , 73  ,	72  ,	71	 ,	71	 ,	70	 ,	69	 ,	69,
   68  , 68  ,	67  ,	66	 ,	66	 ,	65	 ,	65	 ,	64 };

#asm __nodebug

;	0x7f, 0x7d, 0x7b, 0x79, 0x77, 0x76, 0x74, 0x73 ; about 1/sqrt(x)
;	0x71, 0x70, 0x6f, 0x6d, 0x6c, 0x6b, 0x6a, 0x69
;	0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x62, 0x61
;	0x60, 0x5f, 0x5e, 0x5d, 0x5d, 0x5c, 0x5b, 0x5a
;	0x59, 0x58, 0x57, 0x55, 0x54, 0x53, 0x52, 0x51
;	0x50, 0x4f, 0x4e, 0x4d, 0x4c, 0x4b, 0x4b, 0x4a
;	0x49, 0x48, 0x48, 0x47, 0x46, 0x45, 0x45, 0x44
;	0x44, 0x43, 0x42, 0x42, 0x41, 0x41, 0x40, 0x40

;
; sqrt
;
;	sqrt(x) can be iteratively estimated by newton iterations
;  based on the following:
;
;	estimate 1/sqrt(x) by:
;	w[i+1]=w[i]*1/2*(3-w[i]*w[i]*x) where w[0] approx 1/sqrt(x)
;
;  sqrt(x) = 1/sqrt(x) * x
;
;  w[0] is found by looking in a table that uses the lsb of the
;	exponent and the 5 msbs of the mantissa (excluding implicit bit).
;
; worst case = 880 clocks
;

.__fsqzero:					;    zero
	xor	a					; 2
	ld		bcde, 0
	pop	ix
	ret						; 8

.__fsdivneg:					;    negative number return NAN
	pop	ix
	ld		a,h				;    negative number
	or		a
	jr		nz,.__fsdivneg2

	ld		bc,0x8000		; 	  return -0.0 if sqrt(-0.0)
	clr	hl
	ret

.__fsdivneg2:
	ld		hl, _cexpr(-ERR_DOMAIN)
	push	hl
	call	exception
	ret

sqrt::
	push	ix
	ld		hl,bc				; 2
	add	hl,hl				; 2, check the sign and unpack exponent
	jr		c,.__fsdivneg	; 5
; wc=11
	scf						; 2
	rr		l					; 4, restore implicit bit

	ld		a,h				; 2

	or		a					; 2, is number == 0 (yes: return 0)
	jr		z,.__fsqzero		; 5
; wc=11+15=26
	push	hl					; 10, save exponent/mantissa
	push	de					; 10

	ld		h,l				; 2, store the number into hl:de
	ld		l,d				; 2
	ld		d,e				; 2
	ld		e,0				; 4

	ld		a,c				; 2, make the initial guess by looking at lsb
								;    of exponent and the 5 msb of mantissa
; wc=26+32=58
	;
	; x       = x.mantissa/0x800000 * 2^(x.exp-0x7f)
	; sqrt(x) = sqrt(x.mantissa/0x800000) * 2^(0.5 * (x.exp-0x7f))
	;
	; When the exponent is even, subtracting 0x7f then dividing by 2
	; leaves a remainder.  This remainder is expressed as a sqrt(2)
	; multiple on the final result.
	;
	; During the calculation numbers with an even exponent are left
	; aligned on bit 23.  This alignment has the effect of multiplying
	; the result by sqrt(2).  Numbers with an odd exponent are shifed
	; right once in the beginning of the calculation and left once at
	; the end of the calculation so they will be free of the sqrt(2).
	;

	rra						; 2, shift off bits not needed for table lookup
	xor	0x40				; 4, reverse lsb of exponent and clear carry flag
	rra						; 2

	cp		a,0x20			; 4, check if exponent is odd
	jr		nc,.__fs0			; 5
	or		a					; 2, clear carry flag
	rr		hl					; 2
	rr		de					; 2

.__fs0:
; wc=58+23=81
	exx						; 2

	bool	hl					; 2, lookup estimate in the table
	ld		l,a				; 2
	ld		de,sqrt_table	; 6
	add	hl,de				; 2

	ld		a,(hl)			; 5, w[0] about 1/sqrt(x)

	;
	; first iteration w[0]->w[1] = 5 bits accuracy -> 8 bits
	;
	; w[0]*w[0]  =  8x8  -> 16 multiply
	; w[0]^2 * x = 16x16 -> 16 multiply
	;

	ld		b,a				; 2, bc=de=w[0]
	ld		d,a				; 2
	ld		c,0				; 4
	ld		e,c				; 2
; wc=81+28=109
	mul						; 12
	add	hl,hl				; 2, hl = w[0]^2

	ex		de,hl'			; 4
	ex		de,hl				; 2
	ld		bc,hl				; 2

	ld		bc',bc			; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs1			; 5
	add	hl,de				; 2

.__fs1:
; wc=109+51=160
	add	hl,hl				; 2, w[0]^2*x

	ex		de,hl				; 2
	ld		hl,0xc000		; 6
	sbc	hl,de			 	; 4, 3 - w[0]^2*x

	ld		bc,hl				; 2

	ld		d,a				; 2
	ld		e,0				; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs1a			; 5
	add	hl,de				; 2

.__fs1a:
; wc=160+47=207
	add	hl,hl				; 2, w[1] 8 bits of accuracy

	ex		de,hl				; 2
	ld		b,d				; 2
	ld		c,e				; 2

	mul						; 12
	rr		b					; 4
	add	hl,hl				; 2, w[1]^2

	ex		de,hl'			; 4
	exx						; 2
	ld		bc',bc			; 4
	exx						; 2

	ex		de,hl				; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs2			; 5
	add	hl,de				; 2

.__fs2:
; wc=207+63=270
	rl		b					; 4
	adc	hl,hl				; 4, w[1]^2*x

	ex		de,hl				; 2
	ld		hl,0xc000		; 6
	sbc	hl,de				; 4
	ld		bc,hl				; 2
	ex		de,hl'			; 4

	mul						; 12
	add	hl,de				; 2
	rr		b					; 4
	adc	hl,hl				; 4, w[2] 14 bits of accuracy

; wc=270+50=320

;	ex		de,hl				; 2  *********bug repaired 12/4/98
	ld		b,d				; 2
	ld		c,e				; 2
	mul						; 12
	rl		c					; 4
	rl		b					; 4
	adc	hl,hl				; 4, w[2]^2 hl:bc

	push	de					; 10, save w[2]

	ex		de',hl			; 2
	exx						; 2
	ld		de',bc			; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs3			; 5
	add	hl,de				; 2

.__fs3:
; wc=320+71=391
	xor	a					; 2, clear a to store carry
	ld		iy,0				; 8, use iy it accumulate the sum of products
	add	iy,bc				; 4
	exx						; 2

	ex		de,hl				; 2
	ld		bc',de			; 4
	ex		de,hl				; 2

	ld		ix,0
	bit	7,d				; 4
	jr		z,.__fs4			; 5
	add	ix,bc				; 4, correction for signed -> unsigned multiply

.__fs4:
; wc=391+37=428
	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs5			; 4
	add	hl,de				; 4, correction for signed -> unsigned multiply

.__fs5:
; wc=428+24=452
	ex		de,hl				; 2
	add	ix,de
	ex		de,hl
	ld		hl,ix
	ex		de,hl

	add	iy,de
	adc	a,0

	exx						; 2
	ex		de',hl			; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs6			; 5
	add	hl,de				; 2, correction for signed -> unsigned multiply

.__fs6:
; wc=452+35=487
	ex		de,hl				; 2
	ld		hl,iy				; 4, accumulate sum of products
	add	hl,de				; 2
	adc	a,0

	exx						; 2

	add	a,e				; 2
	ld		e,a				; 2
	jr		nc,.__fs8			; 5
	inc	d					; 4

;.__fs7:
; wc=487+17=504
;	or		a					; 2
;	jr		z,.__fs8			; 5
;	inc	de					; 2

.__fs8:
; wc=504+9=513
	exx						; 2
	add	hl,hl				; 2
	exx						; 2

	rl		de					; 2
	exx						; 2
	ex		de,hl				; 2
	clr	hl					; 2
	sbc	hl,de				; 4
	exx						; 2
	ld		hl,0xc000		; 6
	sbc	hl,de				; 4, 3-w[2]^2*x hl:hl'

	ld		bc,hl				; 2
	pop	de					; 7
	ld		de',de			; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs9			; 5
	add	hl,de				; 2

.__fs9:
; wc=513+70=583
	exx						; 2
	ld		bc,hl				; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs10			; 5
	add	hl,de				; 2

.__fs10:
; wc=583+29=612
	ex		de',hl			; 2
	exx						; 2
	ex		de,hl				; 2
	add	hl,bc				; 2
	jr		nc,.__fs11		; 5
	inc	de					; 2

.__fs11:
; wc=612+15=627
	add	hl,hl				; 2
	rl		de					; 2, w[3] 28 bits accuracy

	exx						; 2

	pop	de					; 7, retrieve x
	pop	bc					; 7

	ld		a',b				; 4, save exponent
	ld		b,c				; 2
	ld		c,d				; 2
	ld		a,e				; 2

	ld		bc',bc			; 4
	exx						; 2
	ex		de',hl			; 2

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs12			; 5
	add	hl,de				; 2

.__fs12:
; wc=627+61=688
	exx						; 2
	ld		iy,0x0000		; 8
	bit	7,d				; 4
	jr		z,.__fs13			; 5
	add	iy,bc				; 4

.__fs13:
; wc=688+23=711
	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs14			; 5
	add	hl,de				; 2

.__fs14:
; wc=711+23=734
	ex		de,hl				; 2
	ld		hl,iy				; 4
	add	hl,de				; 2

	ex		de,hl'			; 4

	exx						; 2

	ld		bc',bc			; 4
	ld		b,a				; 2
	ld		c,0				; 4

	bit	7,b				; 4
	mul						; 12
	jr		z,.__fs15			; 5
	add	hl,de				; 2

.__fs15:
; wc=734+47=781
	ex		de,hl'			; 4
	add	hl,de				; 2
	ex		de,hl				; 2
	exx						; 2
	jr		nc,.__fs16		; 5
	inc	de					; 2

.__fs16:
; wc=781+17=798
	ex		de',hl			; 2
	add	hl,bc				; 2
	jr		nc,.__fs17		; 5
	inc	de					; 2

.__fs17:
; wc=798+11=809
	add	hl,hl				; 2
	rl		de					; 2

	ex		af,af'			; 2
	sub	a,0x7f			; 4
	sra	a					; 4
	jr		nc,.__fs18		; 5
	add	hl,hl				; 2
	rl		de					; 2

.__fs18:
; wc=809+23=832
	ld		bc,0x003f		; 6
	add	hl,bc				; 2
	jr		nc,.__fs19		; 5
	inc	de					; 2

.__fs19:
; wc=832+15=847
	ld		c,d				; 2
	ld		d,e				; 2
	ld		e,h				; 2

	add	a,0x7f			; 4
	or		a					; 2, clear carry flag
	rra						; 2
	ld		b,a				; 2
	jr		c,.__fs20			; 5
	res	7,c				; 4

.__fs20:
; wc=847+25=872
	pop	ix
	ret						; 8
; wc=880...

#endasm


/*** BeginHeader tanf */
#define tanf(x)		tan(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
tanf                                                              <math.h>

SYNTAX:			float tanf(float x);

Defined as a macro to tan(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (tanf)(float x)
{
	return tan(x);
}

/*** BeginHeader tan */
/*** EndHeader */

/*
 * TAN
 *
 * Purpose:
 *              Compute the tangent of real float value x
 *              The value x is assumed in radians (not degrees)
 *              Use deg() and rad() for conversions.
 * Returns:
 *              number          answer between -INF and +INF
 *                              errno = 0
 *              HUGE_VAL (INF)  x approx (2n+1)PI/2 error
 *                              errno = -ERR_RANGE
 *              0.0             Argument too large negative or
 *                              positive ( greater than 8*PI).
 *                              errno = ERR_DOMAIN
 * Method:
 *              tan(x) = sin(x)/cos(x)  for x not within .01 of
 *                                      a multiple of PI/2
 *              tan(x) = new approx     otherwise
 *
 * Current problems:
 *
 *      First, if fabs(x) > 25.13, then we probably can't
 *      compute it at all. The number 25.13 comes from
 *
 *              8*PI = 25.13274123 (12-digits)
 *              8*3.14159 = 25.13272 (6-digits)
 *              error = -2.12288e-05
 *              So to maintain 6-digit accuracy restrains
 *              computation to -8PI < x < 8PI.
 *
 *      Let us assume 0 <= x <= pi/2. Let u = pi/2 - x. If
 *      u is too close to zero, then computation fails:
 *
 *      sin(x)/cos(x) = sin(x)/cos(pi/2-u)
 *                    = sin(x)/sin(u)
 *                    = cos(u)/sin(u)
 *                    = 1./u approximately
 *
 *      This is cured by using a different rational function
 *      near pi/2, namely a Taylor expansion:
 *
 *                         2       4           2      4
 *      tan x = (1/u)(1 - u  /2 + u /24)/(1 - u /6 + u /120)
 *
 *      At u = .009999, tan x = 100.006668, but 1/u = 100.010001.
 *      For 0 <= x < BADTAN, sin(x)/cos(x) is a good approximation.
 *      It looks like we need the above rational, but perhaps a
 *      better choice of BADTAN would allow use of 1/u.
 */

/* START FUNCTION DESCRIPTION ********************************************
tan                                                               <math.h>

SYNTAX:       double tan(double x);
              float tanf(float x);

PARAMETER1:   Floating point input for tangent computation.

KEYWORDS:     math

DESCRIPTION:  Compute the tangent of the argument.

RETURN VALUE: See description.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double tan(double x)
{
	const static float p[] =
	{
		1.0, -0.5, 0.0416666666
	};
	const static float q[] =
	{
		1.0, -0.1666666667, 0.0083333333
	};
	auto float z, w;
	auto int c;

	c = (int)(x * TWObyPI);
	if (abs(c) >= 16)
	{
		exception(-ERR_DOMAIN);
		return 0.0;
	}
	z = x - c * PIbyTWO;
	if (c & 1)
		z += ((z < 0.0) ? PIbyTWO : - PIbyTWO);
	if (c = (z < 0.0))
		z = - z;
	if (z == PIbyTWO)
	{
		exception(-ERR_RANGE);
		return HUGE_VAL;
	}
	if (z > BADTAN)
	{
		z = PIbyTWO - z;
		w = z * z;
		z = (poly(w, 2, p) / poly(w, 2, q)) / z;
	}
	else
	{
		z = sin(z) / cos(z);
	}
	return (c ? - z : z);
}


/*** BeginHeader tanhf */
#define tanhf(x)		tanh(x)
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
tanhf                                                             <math.h>

SYNTAX:			float tanhf(float x);

Defined as a macro to tanh(), since float and double have the same precision.

END DESCRIPTION **********************************************************/
__nodebug
float (tanhf)(float x)
{
	return tanh(x);
}

/*** BeginHeader tanh */
/*** EndHeader */
/*
 * TANH
 *
 * Purpose:
 *              Compute the hyperbolic tangent of real float value x
 * Returns:
 *              number          x in range
 *              1.0             x too large positive
 *             -1.0             x too large negative
 *                              errno = -ERR_RANGE returned to flag error
 * Method:
 *              tanh(x) = (exp(x) - exp(-x))/(exp(x) + exp(-x))
 * Notes:
 *              o Find EXPLARGE by solving exp(x)=1.0e39=INF
 */

/* START FUNCTION DESCRIPTION ********************************************
tanh                                                              <math.h>

SYNTAX:       double tanh(double x);
              float tanhf(float x);

PARAMETER1:   Floating point input for hyperbolic tangent computation.

KEYWORDS:

DESCRIPTION:  Computes the hyperbolic tangent of argument.

RETURN VALUE: Returns the hyperbolic tangent of x.  If x > 49.9 (approx.),
				  the function returns 1.0.
				  If x < 49.9 (approx.), the function returns -1.0.

(Note that the float and double types have the same 32 bits of precision.)

END DESCRIPTION **********************************************************/
__nodebug
double tanh(double x)
{
	auto float y;

	y = x + x;
	if (y > EXPLARGE)
	{
		return 1.0;
	}
	if (y < - EXPLARGE)
	{
		return - 1.0;
	}
	y = exp(y);
	return ((y - 1.0) / (y + 1.0));
}


