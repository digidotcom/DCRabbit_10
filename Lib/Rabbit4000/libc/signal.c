/*
	signal.c

	Copyright (c) 2010 Digi International Inc., All Rights Reserved

	This software contains proprietary and confidential information of Digi
	International Inc.  By accepting transfer of this copy, Recipient agrees
	to retain this software in confidence, to prevent disclosure to others,
	and to make no use of this software other than that for which it was
	delivered.  This is a published copyrighted work of Digi International
	Inc.  Except as permitted by federal law, 17 USC 117, copying is strictly
	prohibited.

	Restricted Rights Legend

	Use, duplication, or disclosure by the Government is subject to
	restrictions set forth in sub-paragraph (c)(1)(ii) of The Rights in
	Technical Data and Computer Software clause at DFARS 252.227-7031 or
	subparagraphs (c)(1) and (2) of the Commercial Computer Software -
	Restricted Rights at 48 CFR 52.227-19, as applicable.

	Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343
*/

/*** BeginHeader */
#ifdef SIGNAL_DEBUG
	#define _signal_debug __debug
#else
	#define _signal_debug __nodebug
#endif
#include <signal.h>
/*** EndHeader */

/*** BeginHeader _signal_table */
/*** EndHeader */
// Initialize _signal_table to all zeros (SIG_DFL).  ANSI C would do this
// automatically without an initializer.  We cheat by setting the first
// element and having Dynamic C filling the remaining bytes with 0.
//_signal_func *_signal_table[_SIGNAL_COUNT] = { SIG_DFL };
_signal_func_ptr _signal_table[_SIGNAL_COUNT] = { SIG_DFL };

/*** BeginHeader signal */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
signal                                                          <signal.h>

SYNTAX:	void (*signal( int sig, void (*func)(int)))(int)

DESCRIPTION:	Chooses one of three ways to handle receipt of a given signal.

					If <func> is SIG_DFL, default handling will occur.

					If <func> is SIG_IGN, the signal is ignored.

					Otherwise, <func> should point to a function to be called when
					that signal occurs.  Such a function is called a signal handler.

					When a signal occurs, if <func> points to a function, the
					following occurs:

						1) The equivalent of signal( sig, SIG_DFL) is executed.
						2) <func> is called with <sig> as the parameter.
						3) <func> can return and execution will continue at the
							point it was interrupted, or it can terminate by calling
							abort(), exit() or longjmp().  Of course, the SIGABRT
							handler should not call abort().

PARAMETER 1:	Signal to handle.  Must be one of the following:

					SIGABRT:	Abnormal termination, such as initiated by abort().
					SIGFPE:	Floating-point exception (e.g., div by zero, overflow).
					SIGILL:	Illegal instruction.
					SIGINT:	Interactive attention signal.
					SIGSEGV:	Invalid access to storage.
					SIGTERM:	Termination request sent to program.

					The current version of Dynamic C does not generate any signals.
					Future versions may send SIGABRT when abort() is called and
					floating-point errors may call SIGFPE instead of generating
					exceptions.

PARAMETER 2:	Either SIG_DFL (for default handling), SIG_IGN (to ignore) or
					the address of a function to handle the signal.  Such a function
					should accept a single integer parameter (the signal generated)
					and return nothing.

					If the signal was not generated by calling abort() or raise(),
					this function shouldn't call any standard library functions
					except the signal function itself (with the same signal number
					as passed to the signal handler).  It should not refer to any
					global variables other than those declared as type
					"volatile sig_atomic_t".

RETURN VALUE:	On success, returns the previous handler for the signal (which
					could be SIG_DFL or SIG_IGN).
					On failure, sets <errno> to EINVAL and returns SIG_ERR.

SEE ALSO:	raise

END DESCRIPTION **********************************************************/
/*
	DEVNOTE: eventually would like to have this be true:
					Note that on the Rabbit platform, only SIGFPE signals are
					generated within the libraries.  The other signals will only
					be generated by a call to the signal() function.
*/
_signal_debug
// Dynamic C can't handle standard declaration:
// void (*signal( int sig, void (*func)(int)))(int)
_signal_func *signal( int sig, _signal_func *func)
{
	_signal_func *handler;

	if (sig < 0 || sig >= _SIGNAL_COUNT || func == SIG_ERR)
	{
		errno = EINVAL;
		return SIG_ERR;
	}
	handler = _signal_table[sig];
	_signal_table[sig] = func;

	return handler;
}

/*** BeginHeader raise */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
raise                                                           <signal.h>

SYNTAX:	int raise( int sig)

DESCRIPTION:	Sends signal <sig> to the program.  If a signal handler has
					been registered with signal(), raise() will set the handler
					back to SIG_DFL before calling the registered handler.

PARAMETER 1:	Signal to send, must be one of the following:

					SIGABRT:	Abnormal termination, such as initiated by abort().
					SIGFPE:	Floating-point exception (e.g., div by zero, overflow).
					SIGILL:	Illegal instruction.
					SIGINT:	Interactive attention signal.
					SIGSEGV:	Invalid access to storage.
					SIGTERM:	Termination request sent to program.

RETURN VALUE:	0 on success, -EINVAL if <sig> is invalid.

SEE ALSO:	signal

END DESCRIPTION **********************************************************/
_signal_debug
int raise( int sig)
{
	_signal_func *handler;

	if (sig < 0 || sig >= _SIGNAL_COUNT)
	{
		return -EINVAL;
	}

	handler = _signal_table[sig];
	if (handler == SIG_IGN)			// ignore signal
	{
		// nothing
	}
	else if (handler == SIG_DFL)		// default handler
	{
		// no default behaviors for now
	}
	else
	{
		// revert to default and call the registered handler
		_signal_table[sig] = SIG_DFL;
		handler(sig);
	}

	return 0;
}