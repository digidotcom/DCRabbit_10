/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** Beginheader */
#ifndef __RS232_LIB
#define __RS232_LIB
#define RS232_FAIL -1
#define RS232_CR   13
#define RS232_LF   10
#define RS232_BASEFREQ 614400.0

#define PARAM_8BIT  		 0x0000
#define PARAM_7BIT		 0x0001

#define PARAM_NOPARITY   0x0000
#define PARAM_EPARITY    0x0001
#define PARAM_OPARITY    0x0002
#define PARAM_SPARITY    0x0004
#define PARAM_MPARITY	 0x0005

#define PARAM_1STOP		 0x0006
#define PARAM_2STOP		 0x0003

#define SER_PARITY_ERROR 	0x01
#define SER_OVERRUN_ERROR 	0x02
#define SER_OVERFLOW_ERROR 0x04

#ifdef RS232_DEBUG
	#define _rs232_debug __debug
#else
	#define _rs232_debug __nodebug
#endif

/* START LIBRARY DESCRIPTION *********************************************
RS232.LIB

OVERVIEW
   The interface is designed to to provide the users with a set of functions
   that send and receive entire blocks of data without yielding to other
   tasks, and a set of single user cofunctions that send and receive data,
   but yield to other tasks.

   To enable DMA transfers for serial, call serXdmaOn after serXopen
   (where X is A-F).

   DMA Trasmit:
   -----------
   General description:
      * When a serial function is called to transmit data, a DMA transfer
      begins. The length of that transfer is either the length requested, or
      the rest of the transmit buffer size from the current position.  An
      interrupt is fired at the end of the trasmit at which time another
      transmit is set up if more data is ready to go.

   Flowcontrol Details:
      * When using flowcontrol, the DMA uses the built in external request
      functionality. This limits the available CTS pins to PD2, PD3, PE2, PE3,
      PE6 and PE7.  In addition, only 2 DMA channels can use external requests
      at a time, and they must be divided so that one uses PD2, PE2 or PE6 and
      the other uses PD3, PE3 or PE7.

   Parity Details:
      * DMA Trasmit supports parity bit operation.

   DMA Receive:
   -----------
   General description:
      * When a serXdmaOn is called, a continuous chain of DMA transfers begins
      sending any data received on the serial line to the circular buffer.

   Flowcontrol Details:
      * With flowcontrol on, the DMA transfers are segmented, and there is an
      interrupt after each segment.  The situation below is what turns off
      flowcontrol.

      Here is a snapshot of the receive circular buffer when the ISR occurs:
      ----
      x = unread data
      . = empty buffer

                     ISR               Current head (reading would start here)
                      V                    V
      |xxxxxxxxxxxxxxx|...............|....xxxxxxxxxxx|xxxxxxxxxxxxxxx|
        Segment 0        Segment 1       Segment 2       Segment 3

      Because the head is in the following segment, the RTS pin is toggled to
      tell the other device to stop transmitting.  Then, segment 1 is set to be
      be the last transfer instead of continuing to segment 2. This prevents
      overwritting of data in cases where the other device might not react to
      the RTS pin in time. When we read enough data to clear out segment 2,
      RTSon will be called and the DMA tranfers will continue.

   Parity Details:
      * DMA receive does _NOT_ support parity bit checking because there is no
      interrupt after each byte.

OPTIMIZATIONS
   There are several defines available for optimization. It is recommended that
   they are placed in the project-options' defines box when applicable.

   SER_NO_FLOWCONTROL - This compiles out all flowcontrol code and variables
   to save space and time during execution if not using flowcontrol.

   SER_DMA_DISABLE - This disables DMA (automatic for older boards without DMA)
   If it is necessary to not use DMA because of a need for parity checking,
   this optimization is recommended.

   SER_DMA_ONLY - This compiles out all the non-DMA isr code. This is
   recommended if using DMA.

NAMING CONVENTION
   The naming convention is serXfn:
   ser - serial
   X   - the port being used: A,B,C, or D
   fn  - the function being implemented
   Example: serBgetc() is the serial port B function getc(), which returns a
    character.

   It is now also possible, but not necessary, to call most functions with a
   generic function name.

   Example:
   	serAopen(...);
      serXputc(SER_PORT_A, ...);
      serXgetc(SER_PORT_A, ...);
      serAclose();

   The functions that must be called with specific names are:
   	open
      close
      txBreak
      flowcontrolOn

DEFINING BUFFER SIZES AND OPTIONAL CONFIGURATIONS
   xINBUFSIZE   - read buffer size where x is A,B,C,D,E or F
   xOUTBUFSIZE  - write buffer size where x is A,B,C,D,E or F
   The user must define the buffer sizes for each port being used to be
   a power of 2 minus 1 with a macro, e.g. #define DINBUFSIZE 31.
   The size of 2^n - 1 enables masking for fast roll over calculations.
   The value affects how frequently control yields to other tasks in
   cofunctions. If no value of 2^n - 1 is defined, a default of 31 is used,
   and a compiler warning is given.

DEFINING RTS/CTS PINS FOR FLOW CONTROL
	Multiple macros control which pins are used for hardware flow control.
	RTS (Request To Send) is an output set by the Rabbit and CTS (Clear To Send)
	is an input (signal set by the remote device).

	The default settings are for all serial ports to use PC2 for RTS and PC3 for
	CTS.  This shared default obviously won't work if you're using flow control
	on more than one serial port.

	SERx_RTS_PORT - Port for RTS signal, typically PBDR, PCDR, PDDR or PEDR
	SERx_RTS_SHADOW - Shadow register for SERx_RTS_PORT
	SERx_RTS_BIT - Bit (0-7) on SERx_RTS_PORT to use for RTS

	SERx_CTS_PORT - Port for CTS input, typically PBDR, PCDR, PDDR or PEDR
	SERx_CTS_BIT - Bit (0-7) on SERx_CTS_PORT to use for CTS

	If SERx_RTS_PORT is set to PBDR, PCDR, PDDR or PEDR, serXflowcontrolOn will
	automatically configure the pin as an output.  It assumes that the CTS pin
	still has its default configuration of being an input.

	SERx_RTS_EXTERNAL - Define if the RTS signal for serial port X is hosted
	on external I/O instead of a direct processor port.

	SERx_CTS_EXTERNAL - Define if the CTS signal for serial port X is hosted
	on external I/O instead of a direct processor port.

	SER_RTS_EXTERNAL (deprecated macro) - If defined, all RTS signals are
	considered to be external.  Replace with one or more SERx_RTS_EXTERNAL
	macros.

DESCRIPTION:
   This library contains serial interface functions for the Rabbit.
   It contains 4 types of interface functions:
     1) Blocking Functions
       a) Complete their entire serial tasks before returning.
       b) Do not require the use of costatements or cofunctions.
       c) Simple to use but can hog the processor.

       int serXgetc(void);
       int serXread(void far *data, int length, unsigned long tmout);
       int serXputc(int c);
       int serXputs(const char far *s);
       int serXwrite(const void far *data, int length);
       int serXfastwrite(const void far *data, int length);

     2) Single-User Cofunctions
       a) Yield to other tasks whenever circular buffer is full or empty.
       b) Must be called within costatements.
       c) May be called by different parts of the application without ensuring
          that execution doesn't overlap. In this case, subsequent caller(s)
          wait for completion of the initial call.
       d) Require more learning to use properly but share processing better.

       scofunc int  cof_serA..Fgetc(void);
       scofunc int  cof_serA..Fgets(char far *str, int length,
                                    unsigned long tmout);
       scofunc int  cof_serA..Fread(void far *data, int length,
                                    unsigned long tmout);
       scofunc void cof_serA..Fputc(int c);
       scofunc void cof_serA..Fputs(const char far *str);
       scofunc void cof_serA..Fwrite(const void far *data, int length);

     3) Indexed Cofunctions (implemented as macros for ease of calling)
       a) Yield to other tasks whenever circular buffer is full or empty.
       b) Must be called within costatements.
       c) Must not be called by different parts of the application unless it is
          guaranteed that execution of the particular indexed cofunction doesn't
          overlap with another invocation of itself. In particular, note that
          the cof_serA..F*() functions are implemented as wrappers around
          cof_serX*(). Thus, mixing cof_serA..F*() and cof_serX*() function
          calls in an application requires guaranteed non-overlapped execution.
       d) Require more learning to use properly but share processing better.

       cofunc int  cof_serXgetc(int n);
       cofunc int  cof_serXgets(int n, char *str, int len, unsigned long tmout);
       cofunc int  cof_serXread(int n, void *dat, int len, unsigned long tmout);
       cofunc void cof_serXputc(int n, int c);
       cofunc void cof_serXputs(int n, char *str);
       cofunc void cof_serXwrite(int n, void *data, int len);

     4) Buffer Functions
       These functions act upon or report status of the circular
       transmit/receive buffers.

       int  serXpeek(void);
       void serXrdFlush(void);
       void serXwrFlush(void);
       int  serXrdFree(void);
       int  serXwrFree(void);
       int  serXrdUsed(void);
       int  serXwrUsed(void);
       int  serXsending(int serport);

SUPPORT LIBS:
	CBUF.LIB
   COFUNC.LIB
   VDRIVER.LIB
END DESCRIPTION **********************************************************/


#define SER_PORT_A 0
#define SER_PORT_B 1
#define SER_PORT_C 2
#define SER_PORT_D 3
#define SER_PORT_E 4
#define SER_PORT_F 5
// Number of serial ports. Used for indexed cofunc arrays.
#define SER_PORT_N 6

// Port offsets used for assembly.
#define SxDR_OFS 0
#define SxAR_OFS SAAR-SADR
#define SxLR_OFS SALR-SADR
#define SxSR_OFS SASR-SADR
#define SxCR_OFS SACR-SADR
#define SxER_OFS SAER-SADR

#ifndef RS232_INT_LEVEL
	#define RS232_INT_LEVEL 1
#endif

// Certain variables are written to within ISRs as well as outside ISRs, such
// as dma_flags.  These are used to prevent dma ISRs from corrupting data.
#ifdef SER_DMA_DISABLE
 #if 1 == RS232_INT_LEVEL
	#define RS232_ENTER_CRITICAL asm ipset 2
 #elif 2 == RS232_INT_LEVEL || 3 == RS232_INT_LEVEL
	#define RS232_ENTER_CRITICAL asm ipset 3
 #else
	// 0 is disallowed due to serial character ISR requirements.
	// Are you certain that you want to force a different RS232_INT_LEVEL value?
	#fatal "Invalid RS232_INT_LEVEL macro value (must be one of 1, 2 or 3)."
 #endif
#else
 #if 1 == RS232_INT_LEVEL
	#define RS232_ENTER_CRITICAL asm ipset 2
 #elif 2 == RS232_INT_LEVEL
	#define RS232_ENTER_CRITICAL asm ipset 3
 #else
	// 0 is disallowed due to serial character ISR requirements.
	// 3 is disallowed due to non-maskable interrupt DMA behavior.
	// Are you certain that you want to force a different RS232_INT_LEVEL value?
	#fatal "Invalid RS232_INT_LEVEL macro value (must be either 1 or 2)."
 #endif
#endif
#define RS232_EXIT_CRITICAL asm ipres

// This structure contains all the serial port specific data. An array of six
// pointers is used to reference the data structures for each port. This
// allows the initialization of data structures to be limited to only the
// serial ports being used.
struct _sxd {
   // registers and shadows
   unsigned int sxdr;         // Serial port Data register
   char *sxcrshadow;          // Serial port control register shadow
#ifndef SER_DMA_ONLY          // These are only needed in the old ISR
   char xdrive_txd;           // #define xDRIVE_TXD  n
   char *pxfrshadow;
#endif // ifndef SER_DMA_ONLY

   int  ibufsize;   // #define xINBUFSIZE  n
   int  obufsize;   // #define xOUTBUFSIZE n
   // buffers - these are pointers to the global buffers only compiled with
   // the port specific serial open functions.
   cbuf_t __far *inbuf;
   cbuf_t __far *outbuf;

   // Note that all functions pointed to must use assembly, since they are
   // called from ISRs.  It's OK for them to modify HL, DE and A, but other
   // registers should be preserved and restored.
   void (*xEnable)(/*void*/);                   // enable serial port
   void (*xDisable)(/*void*/);                  // disable serial port
#ifndef SER_NO_FLOWCONTROL
   //pointers to flow control functions
#ifndef SER_DMA_ONLY
   int  (*xCheckCTS)(/*void*/);			// called from ISR, must use assembly
#endif
   void (*xRTSoff)(/*void*/);				// called from ISR, must use assembly
   void (*xRTSon)(/*void*/);				// called from ISR, must use assembly
#endif // ifndef SER_NO_FLOWCONTROL

   // flow control and parity internal BITS/flags
   #define SER_BIT_RTSCTS			0		// flow-control ON/OFF
   #define SER_BIT_PARITY			1     // parity checking ON/OFF - deprecated
   #define SER_BIT_SEVENBIT		2     // seven bit
   #define SER_BIT_TWOSTOP			3     // two stop
   #define SER_BIT_LONGSTOP		4     // long stop - deprecated (never set)
   #define SER_BIT_PARITYERROR	5     // error - parity
   #define SER_BIT_OVERRUN			6     // error - overrun
   #define SER_BIT_OVERFLOW		7     // error - overflow

	// To prevent potential problems with customer code using these legacy macros
	// in assembly code, they are defined as byte values instead of using the
	// calculation shown in comments (which could result in an indirect load
	// instead of a direct load.  For example, [ld a, SER_FLAG_RTSCTS] is wrong
	// as [ld a, (1<<SER_BIT_RTSCTS)].  Note that we can't use _cexpr() because
	// the macro might be used in C code.
   #define SER_FLAG_RTSCTS  		0x01	// (1<<SER_BIT_RTSCTS)
   #define SER_FLAG_PARITY       0x02	// (1<<SER_BIT_PARITY)
   #define SER_FLAG_SEVENBIT     0x04	// (1<<SER_BIT_SEVENBIT)
   #define SER_FLAG_TWOSTOP      0x08	// (1<<SER_BIT_TWOSTOP)
   #define SER_FLAG_LONGSTOP     0x10	// (1<<SER_BIT_LONGSTOP)
   #define SER_FLAG_PARITYERROR  0x20	// (1<<SER_BIT_PARITYERROR)
   #define SER_FLAG_OVERRUN      0x40	// (1<<SER_BIT_OVERRUN)
   #define SER_FLAG_OVERFLOW     0x80	// (1<<SER_BIT_OVERFLOW)

   char ser_flags;

   // Dual function variables:
   // With DMA, these are the head and tail markers for the receive buffer.
   // If flowcontrol is off, there is only 1 buffer and these are unnecessary.
   // Without DMA, these are the buffer sizes allowed before flow control is
   // turned on.
#ifndef SER_NO_FLOWCONTROL
   int  rtsLo;
   int  rtsHi;
#endif

   // dma variables
#ifndef SER_DMA_DISABLE
   // Divisions for flowcontrol receive buffer (inbuf), must be power of 2.
   #define SER_DMA_DIVISIONS 4
   int  dma_divsize;    // xINBUFSIZE / SER_DMA_DIVISIONS, or xINBUFSIZE

   // DMA internal flags:
   #define SER_DMA_ON			0x10 // DMA enabled for this serial port
   #define SER_DMA_ISR			0x20 // An ISR has occurred
   #define SER_DMA_BUSY  		0x40 // DMA transmit underway
   #define SER_DMA_STOP			0x80 // RTS is off (flow control)
   // CTS defines
   #define SER_DMA_PPD23		0x04 // values to write to DMR0CR or DMR1CR,
   #define SER_DMA_PPE23		0x08 //  used in combination with SER_DMA_ODD
   #define SER_DMA_PPE67		0x0C //  if using PD3, PE3 or PE7.
   // used to determine which register (DMR0CR or DMR1CR) to write to for CTS
   #define SER_DMA_ODD        0x02
   char dma_flags;

   // These are used for dma transmission.
   unsigned int dma_pos;           // start position for next trasmission
   unsigned int dma_len;           // length of next transmission

   // DMA handles for in and out
   dma_chan_t dma_ihandle;
   dma_chan_t dma_ohandle;

   // pointer to DMA buffer descriptor
   DMABufDesc *dma_rx_bd;
   DMABufDesc *dma_tx_bd;

   // DMA isr function pointers.
   void (*xDMAisrTX)(/*void*/);
 #ifndef SER_NO_FLOWCONTROL
   void (*xDMAisrRX)(/*void*/);
 #endif
#endif

#ifdef SER_FLAG_LINEBREAK
   char sxsrcopy;                  // Temporary copy of SxSR, updated each time
                                   //  the ISR is executed.
   char isLineBreak;               // ISR sets non-zero when line break is
                                   //  detected. Application is responsible for
                                   //  resetting to zero after detection.
#endif
};

typedef struct _sxd serXdata;

// Assembly Helper Macros
#define _CALL_(x)              \
   ld    hl, (ix+_sxd+x)      $\
   call  (hl)

#define _READ_FLAG_(x)            \
   ld		a, (ix+_sxd+ser_flags)  $\
   and	_cexpr(x)

#define _CLEAR_FLAG_(x)           \
   ld		a, (ix+_sxd+ser_flags)  $\
   and	_cexpr(~(x))            $\
   ld		(ix+_sxd+ser_flags), a

#define _SET_FLAG_(x)             \
   ld		a, (ix+_sxd+ser_flags)  $\
   or		_cexpr(x)               $\
   ld		(ix+_sxd+ser_flags), a

#define _READ_BIT_(x)	bit	x, (ix+_sxd+ser_flags)
#define _CLEAR_BIT_(x)	res	x, (ix+_sxd+ser_flags)
#define _SET_BIT_(x)		set	x, (ix+_sxd+ser_flags)

#define RS232_IO(REG, SHADOW, AND_VAL, OR_VAL)  \
   ld    hl, SHADOW           $\
   ld    de, REG              $\
   ld    a, _cexpr(OR_VAL)    $\
   ioi   cbm _cexpr(AND_VAL)

#define RS232_EXIO(REG, SHADOW, AND_VAL, OR_VAL)  \
	ld		hl, SHADOW				$\
	ld		de, REG					$\
	ld		a, _cexpr(OR_VAL)		$\
	ioe	cbm _cexpr(AND_VAL)

// support old macro for configuring ALL RTS pins as external
#ifdef SER_RTS_EXTERNAL
 #define RS232_HS(R, S, A, O) RS232_EXIO(R, S, A, O)
#else
 #define RS232_HS(R, S, A, O) RS232_IO(R, S, A, O)
#endif


// The following are redefined to generic functions.
#ifndef SER_DMA_DISABLE
	#define serXdmaOn(n, a, b)		_serXdmaOn(sxd[n], a, b)
	#define serXdmaOff(n)			_serXdmaOff(sxd[n])
#endif
#define serXgetError(n) 			_serXgetError(sxd[n])
#define serXgetc(n) 					_serXgetc(sxd[n])
#define serXread(n, a, b, c) 		_serXread(sxd[n], a, b, c)
#define serXpeek(n) 					_serXpeek(sxd[n])
#define serXputc(n, a) 				_serXputc(sxd[n], a)
#define serXputs(n, a) 				_serXputs(sxd[n], a)
#define serXwrite(n, a, b) 		_serXwrite(sxd[n], a, b)
#define serXfastwrite(n, a, b) 	_serXfastwrite(sxd[n], a, b)
#define cof_serXgetc(n) 			_cof_serXgetc[n](sxd[n])
#define cof_serXgets(n, a, b, c) _cof_serXgets[n](sxd[n], a, b, c)
#define cof_serXread(n, a, b, c) _cof_serXread[n](sxd[n], a, b, c)
#define cof_serXputc(n, a) 		_cof_serXputc[n](sxd[n], a)
#define cof_serXputs(n, a) 		_cof_serXwrite[n](sxd[n], a, strlen(a))
#define cof_serXwrite(n, a, b) 	_cof_serXwrite[n](sxd[n], a, b)
#define serXflowcontrolOff(n) 	_serXflowcontrolOff(sxd[n])
#define serXparity(n, a) 			_serXparity(sxd[n], a)
#define serXdatabits(n, a) 		_serXdatabits(sxd[n], a)
#define serXrdFree(n) 				_serXrdFree(sxd[n])
#define serXwrFree(n) 				_serXwrFree(sxd[n])
#define serXrdUsed(n) 				_serXrdUsed(sxd[n])
#define serXwrUsed(n) 				_serXwrUsed(sxd[n])
#define serXrdFlush(n) 				_serXrdFlush(sxd[n])
#define serXwrFlush(n) 				_serXwrFlush(sxd[n])
#define serXsending(n)				_serXsending(sxd[n])
/*** endheader */

// Six pointers, one for each serial port. The instance of each data structure
// is created in the serial open function. If the open function is never called
// then the data structure is never created. This saves root variable space.

/*** Beginheader sxd */
serXdata *sxd[SER_PORT_N];
/*** Endheader */

/*** Beginheader _RS232_echo */
void _RS232_echo(serXdata *port, char __far *data, int length, char *hdr);
#if defined(RS232_MONITOR)			\
	|| defined(RS232_MONITOR_A)	\
	|| defined(RS232_MONITOR_B)	\
	|| defined(RS232_MONITOR_C)	\
	|| defined(RS232_MONITOR_D)	\
	|| defined(RS232_MONITOR_E)	\
	|| defined(RS232_MONITOR_F)
	#define RS232_ECHO(p, d, l, h)	_RS232_echo(p, d, l, h)
#else
	#define RS232_ECHO(p, d, l, h)
#endif
/*** endheader */

_rs232_debug
void _RS232_echo(serXdata *port, char __far *data, int length, char *hdr)
{
	char linebuf[80];
	char *p, *q, *hex, *chars;
   char ch;
   int i, port_num;

	// If RS232_MONITOR is defined, match for all serial ports
	// Otherwise, only echo if monitoring is enabled for the port.

	for (port_num = 0; port_num < SER_PORT_N; ++port_num)
	{
		if (port == sxd[port_num])
		{
			#ifdef RS232_MONITOR
				break;
			#endif
			#ifdef RS232_MONITOR_A
				if (port_num == SER_PORT_A) break;
			#endif
			#ifdef RS232_MONITOR_B
				if (port_num == SER_PORT_B) break;
			#endif
			#ifdef RS232_MONITOR_C
				if (port_num == SER_PORT_C) break;
			#endif
			#ifdef RS232_MONITOR_D
				if (port_num == SER_PORT_D) break;
			#endif
			#ifdef RS232_MONITOR_E
				if (port_num == SER_PORT_E) break;
			#endif
			#ifdef RS232_MONITOR_F
				if (port_num == SER_PORT_F) break;
			#endif
		}
	}

	if (port_num == SER_PORT_N)
	{
		// did not match the port
		return;
	}

   // insert header at start of linebuf; start printing HEX at position <hex>
   hex = linebuf;
   hex += sprintf( hex, "%s%c:\t", hdr, 'A' + port_num);
   // start printing ASCII characters at position <chars>
   chars = hex + 16 * 3 + 3;
   for(i = 0; i < length; )
   {
   	p = hex;
   	q = chars;
      do {
      	ch = *data++;
      	if ((i & 15) == 8)
      	{
      		// insert space between two sets of 8 bytes
				*p++ = ' ';
				*q++ = ' ';
      	}
      	*p++ = _hexits_lower[ch >> 4];
      	*p++ = _hexits_lower[ch & 0x0F];
      	*p++ = ' ';
         *q++ = isprint(ch) ? ch : '.';
      } while ((++i < length) && (i & 15));
		// add missing spaces between hex and printed chars
		memset( p, ' ', chars - p);
		*q = '\0';
      printf( "%s\n", linebuf);
   }
}

//************************************************************************
//****************************** PORT A **********************************
//************************************************************************

/*** Beginheader serAopen, serAtxBreak, serAclose */
int  serAopen(long baud);
int  serAtxBreak(int type);
void serAclose(void);

void spa_init(void);
__root void aDisable(void);
__root void aEnable(void);
extern serXdata serAdata;
/*** Endheader */

// SERIAL PORT A TX and RX PIN AND PORT SETUP
#ifdef SERA_USEPORTD
	#define ADRIVE_TXD  6
	#define ADRIVE_RXD  7
	#define SERA_TXPORT PDDR
	#define SERA_RXPORT PDDR
#endif

#ifndef ADRIVE_TXD
   #define ADRIVE_TXD 6
#endif

#ifndef ADRIVE_RXD
   #define ADRIVE_RXD 7
#endif

#ifndef SERA_TXPORT
   #define SERA_TXPORT PCDR
#endif

#ifndef SERA_RXPORT
   #define SERA_RXPORT PCDR
#endif

#if SERA_TXPORT == PCDR
   #define SPA_TX PC
#elif SERA_TXPORT == PDDR
   #define SPA_TX PD
#endif

// Port Verification
#if SERA_TXPORT != PCDR && SERA_TXPORT != PDDR
	#fatal "SERA_TXPORT must be PCDR or PDDR"
#endif
#if SERA_RXPORT != PCDR && SERA_RXPORT != PDDR && SERA_RXPORT != PEDR
	#fatal "SERA_RXPORT must be PCDR, PDDR or PEDR"
#endif
// End Verification

#define SERA_TX_PxDR				CONCAT(SPA_TX, DR)
#define SERA_TX_PxFR				CONCAT(SPA_TX, FR)
#define SERA_TX_PxDRShadow		CONCAT(SPA_TX, DRShadow)
#define SERA_TX_PxFRShadow		CONCAT(SPA_TX, FRShadow)

#define SERA_TX_PxDDR			CONCAT(SPA_TX, DDR)
#define SERA_TX_PxDCR			CONCAT(SPA_TX, DCR)
#define SERA_TX_PxDDRShadow	CONCAT(SPA_TX, DDRShadow)
#define SERA_TX_PxDCRShadow	CONCAT(SPA_TX, DCRShadow)

#undef  AINBUFOK
#ifndef AINBUFSIZE
	#define AINBUFSIZE 31
	#warnt "AINBUFSIZE undefined, defaulting to 31"
#endif

#if (AINBUFSIZE & (AINBUFSIZE+1)) == 0
	#define AINBUFOK 1
#endif

#ifndef AINBUFOK
	#undef  AINBUFSIZE
	#define AINBUFSIZE 31
	#warnt "AINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef  AOUTBUFOK
#ifndef AOUTBUFSIZE
	#define AOUTBUFSIZE 31
	#warnt "AOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (AOUTBUFSIZE & (AOUTBUFSIZE+1)) == 0
	#define AOUTBUFOK 1
#endif

#ifndef AOUTBUFOK
	#undef  AOUTBUFSIZE
	#define AOUTBUFSIZE 31
	#warnt "AOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char __far AINBUF[AINBUFSIZE+CBUF_OVERHEAD];
char __far AOUTBUF[AOUTBUFSIZE+CBUF_OVERHEAD];
serXdata serAdata;

#ifndef SER_DMA_DISABLE
#ifdef SER_NO_FLOWCONTROL
DMABufDesc serArxbd[1];							// only one buffer descriptor
#else
DMABufDesc serArxbd[SER_DMA_DIVISIONS];	// one buffer descriptor for each div
void spa_rx_isr(void);
#endif
DMABufDesc serAtxbd[2];							// TX Ping-Pong buffers
void spa_tx_isr(void);
#endif

/* START FUNCTION DESCRIPTION ********************************************
serAopen                      <RS232.LIB>

SYNTAX:
   int serAopen(long baud);

DESCRIPTION:
   Opens the A serial port.  To use DMA for transfers, call serAdmaOn
   after calling this function.  serAopen is non-reentrant.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

RETURN VALUE:
   1 - The Rabbit's bps setting is within 5% of the input baud.
   0 - The Rabbit's bps setting differs by more than 5% of the input baud.

RELATED WORDS:
   serAgetc, serAread, serApeek, serAputs, serAwrite, cof_serAgetc,
   cof_serAgets, cof_serAread, cof_serAputc, cof_serAputs, cof_serAwrite,
   serAclose

MACRO INFO:
   If either or both of RS232_NOCHARASSYINBRK or RS232_NOCHARASSYINBRK_A
   are defined then asynchronous character assembly is disabled during
   an RS-232 line break condition. Defining either of these macros may
   be appropriate for an application which has no need of asynchronous
   line break recognition, especially where a disconnected or non-driven
   RXA input is possible. Note that RS232_NOCHARASSYINBRK affects all
   RS232.LIB serial ports but RS232_NOCHARASSYINBRK_A affects only
   serial port A.

   If SPA_USE_TIMERA is defined, Port A uses Timer A4.  Otherwise, it will
   use the dedicated timer for SPA

   Pin Layout:
   	TX pins: PC6 (default), PC7, PD6
   	RX pins: PC7 (default), PD7, PE7

   The user must define the following if not using the default settings:

   ADRIVE_TXD		// Defaults to 6
  *ADRIVE_RXD		// Defaults to 7
   SERA_TXPORT		// Defaults to PCDR
   SERA_RXPORT		// Defaults to PCDR
   AINBUFSIZE		// Defaults to 31
   AOUTBUFSIZE		// Defaults to 31

   Note:
   ----
  *ADRIVE_RXD is always 7.
   For backwards compatibility, SERA_USEPORTD is supported.

END DESCRIPTION **********************************************************/
_rs232_debug
int serAopen(long baud)
{
   auto long actual_bps;

#ifndef SER_DMA_DISABLE
   #GLOBAL_INIT { serAdata.dma_flags = 0; }
   // turn off the DMA if the serial port was previously open
   if(serAdata.dma_flags)
   	serAdmaOff();
   serAdata.dma_rx_bd = serArxbd;
   serAdata.dma_tx_bd = serAtxbd;
   serAdata.xDMAisrTX = spa_tx_isr;
#ifndef SER_NO_FLOWCONTROL
   serAdata.xDMAisrRX = spa_rx_isr;
   serAdata.dma_divsize = (AINBUFSIZE + 1) / SER_DMA_DIVISIONS;
#else
   serAdata.dma_divsize = AINBUFSIZE + 1;
#endif
#endif // ifndef SER_DMA_DISABLE

   // set sxd pointer to our global structure.
   sxd[SER_PORT_A] = &serAdata;

   // The following values are needed by the generic serXfunctions.
   serAdata.sxdr = SADR;
   serAdata.sxcrshadow = &SACRShadow;

#ifndef SER_DMA_ONLY
   serAdata.xdrive_txd = 1 << ADRIVE_TXD;
   serAdata.pxfrshadow = &SERA_TX_PxFRShadow;
#endif // ifndef SER_DMA_ONLY

#ifdef SER_FLAG_LINEBREAK
   serAdata.isLineBreak = 0;
#endif

   serAdata.xEnable = aEnable;
   serAdata.xDisable = aDisable;

	_serXopen_common_init( &serAdata, AINBUF, AINBUFSIZE, AOUTBUF, AOUTBUFSIZE);

#if defined RS232_NOCHARASSYINBRK || defined RS232_NOCHARASSYINBRK_A
	// Board has no pull-up on serial Rx line and application has possibility of
	//  disconnected or non-driven Rx line.
	// Application has no need of asynchronous line break recognition and has
	//  chosen to disable character assembly during line break condition to
	//  prevent possible spurious line break interrupts.
	WrPortI(SAER, &SAERShadow, 0x02 | RdPortI(SAER));
#endif

#ifndef SPA_USE_TIMERA
	actual_bps = serXsetDividers( baud, SADHR, SADLR);
#else
	actual_bps = SetSerialTATxRValues( baud, NULL, TAT4R);
#endif

   spa_init();

	return _serXopen_common_ret( &serAdata, baud, actual_bps);
}

// spa_rx_isr
//
//	This isr is for DMA flowcontrol use only. Whenever a DMA receive action
// ends, an interrupt is performed to sync the circular buffer and check to see
// if the buffer is full.

#ifndef SER_DMA_DISABLE
#ifndef SER_NO_FLOWCONTROL
#asm __root
spa_rx_isr::
	push	ix
	ld		ix, serAdata
	jp		spx_dma_rx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_NO_FLOWCONTROL

// spa_tx_isr
//
//	This isr is for DMA use only.  This isr occurs after a DMA transfer finishes
// At that point, if there is more data to send, it is sent immediately.

#asm __root
spa_tx_isr::
	push	ix
	ld		ix, serAdata
	jp		spx_dma_tx_isr
#endasm
#endif // ifndef SER_DMA_DISABLE

#asm __root
// interrupt routine to be copied into interrupt table
spaisr_start::   			; pass serAdata and SADR to the isr
#ifndef SER_DMA_ONLY
   push	ix						; 2 bytes
   push	iy						; 2 bytes
   ld		ix, serAdata		; 4 bytes
   ld		iy, SADR				; 4 bytes
   jp		spx_isr				; 3 bytes = 15 bytes total (fits in 16 bytes max)
#else
   ret
#endif

#endasm

#asm __xmem
spa_init::
   ld		de, INTVEC_BASE + SERA_OFS
   ld		hl, spaisr_start
   ld		bc, 16     ; copy 16 bytes from spaisr_start into interrupt table
   ipset RS232_INT_LEVEL

   #if __SEPARATE_INST_DATA__
      call inst2data_ldir
   #else
      ldir
   #endif

// Tx should initially be idle high
RS232_IO(SERA_TX_PxDR, SERA_TX_PxDRShadow, (1<<ADRIVE_TXD), (1<<ADRIVE_TXD))
RS232_IO(SERA_TX_PxFR, SERA_TX_PxFRShadow, (1<<ADRIVE_TXD), (1<<ADRIVE_TXD))
#ifdef SERA_TX_PxDCR // enable push-pull instead of open-drain.
RS232_IO(SERA_TX_PxDCR, SERA_TX_PxDCRShadow, (1<<ADRIVE_TXD), 0)
#endif
#ifdef SERA_TX_PxDDR
RS232_IO(SERA_TX_PxDDR, SERA_TX_PxDDRShadow, (1<<ADRIVE_TXD), (1<<ADRIVE_TXD))
#endif

#if SERA_RXPORT == PEDR
	   ld    a, _cexpr(0x20 | RS232_INT_LEVEL)
#elif SERA_RXPORT == PDDR
	   ld    a, _cexpr(0x10 | RS232_INT_LEVEL)
#else
	   ld    a, _cexpr(0x00 | RS232_INT_LEVEL)
#endif

#ifdef SER_DMA_ONLY
	   and	0xFC
#endif

	   ld    (SACRShadow),a
ioi	ld		(SACR), a      ; enable interrupts and select rx port.
	   ipres
	   lret

#endasm

#asm __root
aDisable:: // make sure Tx is high(idle)
RS232_IO(SERA_TX_PxDR, SERA_TX_PxDRShadow, (1<<ADRIVE_TXD), (1<<ADRIVE_TXD))
RS232_IO(SERA_TX_PxFR, SERA_TX_PxFRShadow, (1<<ADRIVE_TXD), 0)
	   ret

aEnable::
RS232_IO(SERA_TX_PxFR, SERA_TX_PxFRShadow, (1<<ADRIVE_TXD), (1<<ADRIVE_TXD))
	   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serAtxBreak                                                    <RS232.LIB>

SYNTAX:			int serAtxBreak( int type);

DESCRIPTION:	Generate a serial "break" by disabling the transmit pin for
					serial port A and pulling it low.

PARAMETER 1:   If 0, hold the break until another function sends data or
					calls serAopen.

					If 1, generate a character break (hold the break condition
					for the time it would take to send a single character) and
					then return the transmit pin to its idle state (high).

RETURN VALUE:	0 if able to generate the break
					-EIO if the serial port is not idle (i.e., sending bytes)
					-EINVAL if <type> is a value other than 0 or 1

END DESCRIPTION **********************************************************/
// DEVNOTE: Could add support for a 2-character break by setting a flag
// (long break?) and updating the ISR to check for that flag.  If it's set,
// load another dummy character into SADR and then clear the flag.
_rs232_debug
int serAtxBreak( int type)
{
	if (BitRdPortI( SASR, 2))
	{
		// can't generate break if we're sending a byte
		return -EIO;
	}
	if (type < 0 || type > 1)
	{
		return -EINVAL;
	}

	// Set TX pin low, then change the function register to "normal output"
	BitWrPortI( SERA_TX_PxDR, &SERA_TX_PxDRShadow, 0, ADRIVE_TXD);
	BitWrPortI( SERA_TX_PxFR, &SERA_TX_PxFRShadow, 0, ADRIVE_TXD);

	if (type == 1)
	{
		// character break -- load dummy byte so ISR will end the break
		WrPortI( SADR, NULL, 0);
	}

	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
serAclose                   <RS232.LIB>

SYNTAX:		   void serAclose(void);

DESCRIPTION:   Disables serial port A. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm __xmem
serAclose::
	   ld 	a, 0xC9 // RET
	   ipset RS232_INT_LEVEL
	   ld		(INTVEC_BASE + SERA_OFS), a	; ret in first byte of spaisr_start
	   xor   a
	   ld    (SACRShadow), a					; disable interrupts for port
ioi	ld		(SACR), a

#ifdef SPA_USE_TIMERA
      c TAT1R_SetValue( TAT1R_A4TIMER_REQ, TAT1R_RELEASE_REQ);
#endif

// return to normal output
RS232_IO(SERA_TX_PxFR, SERA_TX_PxFRShadow, (1<<ADRIVE_TXD), 0)
   	ipres
   	lret
#endasm

/*** Beginheader serAflowcontrolOn */
void serAflowcontrolOn(void);
/*** endheader */

#ifdef SER_NO_FLOWCONTROL
	#fatal "Can't use serAflowcontrolOn if SER_NO_FLOWCONTROL has been defined."
#endif

//defaults for flow control RTS/CTS
#ifndef SERA_RTS_PORT
	#define SERA_RTS_PORT PCDR
	#warnt "SERA_RTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERA_RTS_SHADOW
	#define SERA_RTS_SHADOW PCDRShadow
	#warnt "SERA_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERA_RTS_BIT
	#define SERA_RTS_BIT 2
	#warnt "SERA_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERA_CTS_PORT
	#define SERA_CTS_PORT PCDR
	#warnt "SERA_CTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERA_CTS_BIT
	#define SERA_CTS_BIT 3
	#warnt "SERA_CTS_BIT not defined: defaulting to 3"
#endif

int spa_checkcts_fc();
void spa_rtsoff_fc();
void spa_rtson_fc();

#asm __root
#ifndef SER_DMA_ONLY
spa_checkcts_fc::
   bool 	hl
   #ifdef SERA_CTS_EXTERNAL
		ioe ld	a, (SERA_CTS_PORT)
	#else
		ioi ld	a, (SERA_CTS_PORT)
	#endif
   and  	1 << SERA_CTS_BIT
   ld   	L, a
   ret
#endif

spa_rtsoff_fc::
// set RTS high (inactive)
#ifdef SERA_RTS_EXTERNAL
RS232_EXIO(SERA_RTS_PORT, SERA_RTS_SHADOW, (1<<SERA_RTS_BIT), (1<<SERA_RTS_BIT))
#else
RS232_HS(SERA_RTS_PORT, SERA_RTS_SHADOW, (1<<SERA_RTS_BIT), (1<<SERA_RTS_BIT))
#endif
#ifndef SER_DMA_DISABLE
   ld    a, (serAdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtsoff
   push	iy
   ld		iy, serAdata
   call  spx_dma_rtsoff
   pop	iy
.rtsoff:
#endif // ifndef SER_DMA_DISABLE
   ret

spa_rtson_fc::
#ifndef SER_DMA_DISABLE
   ; only execute this code if we are using DMA
   ld    a, (serAdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtson

   push	iy
   ld		iy, serAdata
   call	spx_dma_rtson
   pop	iy
.rtson:
#endif // ifndef SER_DMA_DISABLE
// set RTS low (active)
#ifdef SERA_RTS_EXTERNAL
RS232_EXIO(SERA_RTS_PORT, SERA_RTS_SHADOW, (1<<SERA_RTS_BIT), 0)
#else
RS232_HS(SERA_RTS_PORT, SERA_RTS_SHADOW, (1<<SERA_RTS_BIT), 0)
#endif
   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serAflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serAflowcontrolOn(void);

DESCRIPTION:   Turns on hardware flow control for channel A. This enables two
   				digital lines that handle flow control, CTS(clear to send)
   				and RTS(ready to send).
   				CTS is an input that will be pulled active low by the other
   				system when it is ready to receive data. The RTS signal
   				is an output that the system uses to indicate that it is
   				ready to receive data. It is driven low when data can be
   				received.
   				If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERA_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERA_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERA_RTS_BIT - the bit number for the RTS line
					SERA_RTS_EXTERNAL - Define if the RTS signal is hosted on
						external I/O instead of a direct processor port.

 					SERA_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERA_CTS_BIT - the bit number for the CTS line
					SERA_CTS_EXTERNAL - Define if the CTS signal is hosted on
						external I/O instead of a direct processor port.

               Important Note:
               ---------------
               The DMA options supports flow control, but the ports and pins
               for CTS are limited to the following:

               PD2, PD3, PE2, PE3, PE6, PE7.

               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  One
               can use PD2, PE2, or PE6, and the other can use PD3, PE3 or PE7.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void serAflowcontrolOn(void)
{
   //set flow control ISR functions
#ifndef SER_DMA_ONLY
   serAdata.xCheckCTS = spa_checkcts_fc;
#endif
   serAdata.xRTSoff = spa_rtsoff_fc;
   serAdata.xRTSon = spa_rtson_fc;

	_serXflow_enable( &serAdata,	SERA_RTS_PORT, SERA_RTS_BIT,
											SERA_CTS_PORT, SERA_CTS_BIT);
}

//************************************************************************
//****************************** PORT B **********************************
//************************************************************************



/*** Beginheader serBopen, serBtxBreak, serBclose */
int  serBopen(long baud);
int  serBtxBreak(int type);
void serBclose(void);

void spb_init(void);
__root void bDisable(void);
__root void bEnable(void);
extern serXdata serBdata;
/*** Endheader */

// SERIAL PORT B TX and RX PIN AND PORT SETUP
#ifdef SERB_USEPORTD
	#define BDRIVE_TXD  4
	#define BDRIVE_RXD  5
	#define SERB_TXPORT PDDR
	#define SERB_RXPORT PDDR
#endif

#ifndef BDRIVE_TXD
   #define BDRIVE_TXD 4
#endif

#ifndef BDRIVE_RXD
   #define BDRIVE_RXD 5
#endif

#ifndef SERB_TXPORT
   #define SERB_TXPORT PCDR
#endif

#ifndef SERB_RXPORT
   #define SERB_RXPORT PCDR
#endif

#if SERB_TXPORT == PDDR
   #define SPB_TX PD
#else
   #define SPB_TX PC
#endif

// Port Verification
#if SERB_TXPORT != PCDR && SERB_TXPORT != PDDR
	#fatal "SERB_TXPORT must be PCDR or PDDR"
#endif
#if SERB_RXPORT != PCDR && SERB_RXPORT != PDDR && SERB_RXPORT != PEDR
	#fatal "SERB_RXPORT must be PCDR, PDDR or PEDR"
#endif
// End Verification

#define SERB_TX_PxDR				CONCAT(SPB_TX, DR)
#define SERB_TX_PxFR				CONCAT(SPB_TX, FR)
#define SERB_TX_PxDRShadow		CONCAT(SPB_TX, DRShadow)
#define SERB_TX_PxFRShadow		CONCAT(SPB_TX, FRShadow)

#define SERB_TX_PxDDR			CONCAT(SPB_TX, DDR)
#define SERB_TX_PxDCR			CONCAT(SPB_TX, DCR)
#define SERB_TX_PxDDRShadow	CONCAT(SPB_TX, DDRShadow)
#define SERB_TX_PxDCRShadow	CONCAT(SPB_TX, DCRShadow)

#undef  BINBUFOK
#ifndef BINBUFSIZE
	#define BINBUFSIZE 31
	#warnt "BINBUFSIZE undefined, defaulting to 31"
#endif

#if (BINBUFSIZE & (BINBUFSIZE+1)) == 0
	#define BINBUFOK 1
#endif

#ifndef BINBUFOK
	#undef  BINBUFSIZE
	#define BINBUFSIZE 31
	#warnt "BINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef  BOUTBUFOK
#ifndef BOUTBUFSIZE
	#define BOUTBUFSIZE 31
	#warnt "BOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (BOUTBUFSIZE & (BOUTBUFSIZE+1)) == 0
	#define BOUTBUFOK 1
#endif

#ifndef BOUTBUFOK
	#undef  BOUTBUFSIZE
	#define BOUTBUFSIZE 31
	#warnt "BOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char __far BINBUF[BINBUFSIZE+CBUF_OVERHEAD];
char __far BOUTBUF[BOUTBUFSIZE+CBUF_OVERHEAD];
serXdata serBdata;

#ifndef SER_DMA_DISABLE
#ifdef SER_NO_FLOWCONTROL
DMABufDesc serBrxbd[1];							// only one buffer descriptor
#else
DMABufDesc serBrxbd[SER_DMA_DIVISIONS];	// one buffer descriptor for each div
void spb_rx_isr(void);
#endif
DMABufDesc serBtxbd[2];							// TX Ping-Pong buffers
void spb_tx_isr(void);
#endif

/* START FUNCTION DESCRIPTION ********************************************
serBopen                      <RS232.LIB>

SYNTAX:
   int serBopen(long baud);

DESCRIPTION:
   Opens the B serial port.  To use DMA for transfers, call serBdmaOn
   after calling this function.  serBopen is non-reentrant.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

RETURN VALUE:
   1 - The Rabbit's bps setting is within 5% of the input baud.
   0 - The Rabbit's bps setting differs by more than 5% of the input baud.

RELATED WORDS:
   serBgetc, serBread, serBpeek, serBputs, serBwrite, cof_serBgetc,
   cof_serBgets, cof_serBread, cof_serBputc, cof_serBputs, cof_serBwrite,
   serBclose

MACRO INFO:
   If either or both of RS232_NOCHARASSYINBRK or RS232_NOCHARASSYINBRK_B
   are defined then asynchronous character assembly is disabled during
   an RS-232 line break condition. Defining either of these macros may
   be appropriate for an application which has no need of asynchronous
   line break recognition, especially where a disconnected or non-driven
   RXB input is possible. Note that RS232_NOCHARASSYINBRK affects all
   RS232.LIB serial ports but RS232_NOCHARASSYINBRK_B affects only
   serial port B.

   If SPB_USE_TIMERA is defined, Port B uses Timer A5.  Otherwise, it will
   use the dedicated timer for SPB

   Pin Layout:
   	TX pins: PC4 (Default), PC5, PD4
      RX pins: PC5 (Default), PD5, PE5

   The user must define the following if not using the default settings:

   BDRIVE_TXD  // Defaults to 4
  *BDRIVE_RXD  // Defaults to 5
   SERB_TXPORT // Defaults to PCDR
   SERB_RXPORT // Defaults to PCDR
   BINBUFSIZE  // Defaults to 31
   BOUTBUFSIZE // Defaults to 31

   Note:
   ----
  *BDRIVE_RXD is always 5.
   For backwards compatibility, SERB_USEPORTD is supported.

END DESCRIPTION **********************************************************/
_rs232_debug
int serBopen(long baud)
{
   auto long actual_bps;

#ifndef SER_DMA_DISABLE
   #GLOBAL_INIT { serBdata.dma_flags = 0; }
   // turn off the DMA if the serial port was previously open
   if(serBdata.dma_flags)
   	serBdmaOff();
   serBdata.dma_rx_bd = serBrxbd;
   serBdata.dma_tx_bd = serBtxbd;
   serBdata.xDMAisrTX = spb_tx_isr;
#ifndef SER_NO_FLOWCONTROL
   serBdata.xDMAisrRX = spb_rx_isr;
   serBdata.dma_divsize = (BINBUFSIZE + 1) / SER_DMA_DIVISIONS;
#else
   serBdata.dma_divsize = BINBUFSIZE + 1;
#endif
#endif // ifndef SER_DMA_DISABLE

   // set sxd pointer to our global structure.
   sxd[SER_PORT_B] = &serBdata;

   // The following values are needed by the generic serXfunctions.
   serBdata.sxdr = SBDR;
   serBdata.sxcrshadow = &SBCRShadow;

#ifndef SER_DMA_ONLY
   serBdata.xdrive_txd = 1 << BDRIVE_TXD;
   serBdata.pxfrshadow = &SERB_TX_PxFRShadow;
#endif // ifndef SER_DMA_ONLY

#ifdef SER_FLAG_LINEBREAK
   serBdata.isLineBreak = 0;
#endif

   serBdata.xEnable = bEnable;
   serBdata.xDisable = bDisable;

	_serXopen_common_init( &serBdata, BINBUF, BINBUFSIZE, BOUTBUF, BOUTBUFSIZE);

#if defined RS232_NOCHARASSYINBRK || defined RS232_NOCHARASSYINBRK_B
	// Board has no pull-up on serial Rx line and application has possibility of
	//  disconnected or non-driven Rx line.
	// Application has no need of asynchronous line break recognition and has
	//  chosen to disable character assembly during line break condition to
	//  prevent possible spurious line break interrupts.
	WrPortI(SBER, &SBERShadow, 0x02 | RdPortI(SBER));
#endif

#ifndef SPB_USE_TIMERA
	actual_bps = serXsetDividers( baud, SBDHR, SBDLR);
#else
	actual_bps = SetSerialTATxRValues( baud, NULL, TAT5R);
#endif

	// if port B was previously synchronous
	if (RdPortI( SBCR) & 0x08)
	{
		// switch to async, disable receiver and interrupts
	   WrPortI( SBCR, &SBCRShadow, 0x30);
	   WrPortI( SBDR, NULL, 0xFF);     // write a byte to clear the UART
	   while (BitRdPortI( SBSR, 3));   // wait for Tx data reg empty
	   while (BitRdPortI( SBSR, 2));   // wait for byte done
	}

   spb_init();

   return _serXopen_common_ret( &serBdata, baud, actual_bps);
}

// spb_rx_isr
//
//	This isr is for DMA flowcontrol use only. Whenever a DMA receive action
// ends, an interrupt is performed to sync the circular buffer and check to see
// if the buffer is full.

#ifndef SER_DMA_DISABLE
#ifndef SER_NO_FLOWCONTROL
#asm __root
spb_rx_isr::
	push	ix
	ld		ix, serBdata
	jp		spx_dma_rx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_NO_FLOWCONTROL

// spb_tx_isr
//
//	This isr is for DMA use only.  This isr occurs after a DMA transfer finishes
// At that point, if there is more data to send, it is sent immediately.

#asm __root
spb_tx_isr::
	push	ix
	ld		ix, serBdata
	jp		spx_dma_tx_isr
#endasm
#endif // ifndef SER_DMA_DISABLE

#asm __root
// interrupt routine to be copied into interrupt table
spbisr_start::   			; pass serBdata and SBDR to the isr
#ifndef SER_DMA_ONLY
   push	ix						; 2 bytes
   push	iy						; 2 bytes
   ld		ix, serBdata		; 4 bytes
   ld		iy, SBDR				; 4 bytes
   jp		spx_isr				; 3 bytes = 15 bytes total (fits in 16 bytes max)
#else
   ret
#endif

#endasm

#asm __xmem
spb_init::
   ld    de, INTVEC_BASE + SERB_OFS
   ld    hl, spbisr_start
   ld    bc, 16     ; copy 16 bytes from spbisr_start into interrupt table
   ipset RS232_INT_LEVEL

   #if __SEPARATE_INST_DATA__
      call inst2data_ldir
   #else
      ldir
   #endif

// Tx should initially be idle high
RS232_IO(SERB_TX_PxDR, SERB_TX_PxDRShadow, (1<<BDRIVE_TXD), (1<<BDRIVE_TXD))
RS232_IO(SERB_TX_PxFR, SERB_TX_PxFRShadow, (1<<BDRIVE_TXD), (1<<BDRIVE_TXD))
#ifdef SERB_TX_PxDCR // enable push-pull instead of open-drain.
RS232_IO(SERB_TX_PxDCR, SERB_TX_PxDCRShadow, (1<<BDRIVE_TXD), 0)
#endif
#ifdef SERB_TX_PxDDR
RS232_IO(SERB_TX_PxDDR, SERB_TX_PxDDRShadow, (1<<BDRIVE_TXD), (1<<BDRIVE_TXD))
#endif

#if SERB_RXPORT == PEDR
	   ld    a, _cexpr(0x20 | RS232_INT_LEVEL)
#elif SERB_RXPORT == PDDR
	   ld    a, _cexpr(0x10 | RS232_INT_LEVEL)
#else
	   ld    a, _cexpr(0x00 | RS232_INT_LEVEL)
#endif

#ifdef SER_DMA_ONLY
	   and	0xFC
#endif

	   ld    (SBCRShadow),a
ioi	ld		(SBCR), a      ; enable interrupts and select rx port.
	   ipres
	   lret

#endasm

#asm __root
bDisable:: // make sure Tx is high(idle)
RS232_IO(SERB_TX_PxDR, SERB_TX_PxDRShadow, (1<<BDRIVE_TXD), (1<<BDRIVE_TXD))
RS232_IO(SERB_TX_PxFR, SERB_TX_PxFRShadow, (1<<BDRIVE_TXD), 0)
	   ret

bEnable::
RS232_IO(SERB_TX_PxFR, SERB_TX_PxFRShadow, (1<<BDRIVE_TXD), (1<<BDRIVE_TXD))
	   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serBtxBreak                                                    <RS232.LIB>

SYNTAX:			int serBtxBreak( int type);

DESCRIPTION:	Generate a serial "break" by disabling the transmit pin for
					serial port B and pulling it low.

PARAMETER 1:   If 0, hold the break until another function sends data or
					calls serBopen.

					If 1, generate a character break (hold the break condition
					for the time it would take to send a single character) and
					then return the transmit pin to its idle state (high).

RETURN VALUE:	0 if able to generate the break
					-EIO if the serial port is not idle (i.e., sending bytes)
					-EINVAL if <type> is a value other than 0 or 1

END DESCRIPTION **********************************************************/
_rs232_debug
int serBtxBreak( int type)
{
	if (BitRdPortI( SBSR, 2))
	{
		// can't generate break if we're sending a byte
		return -EIO;
	}
	if (type < 0 || type > 1)
	{
		return -EINVAL;
	}

	// Set TX pin low, then change the function register to "normal output"
	BitWrPortI( SERB_TX_PxDR, &SERB_TX_PxDRShadow, 0, BDRIVE_TXD);
	BitWrPortI( SERB_TX_PxFR, &SERB_TX_PxFRShadow, 0, BDRIVE_TXD);

	if (type == 1)
	{
		// character break -- load dummy byte so ISR will end the break
		WrPortI( SBDR, NULL, 0);
	}

	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
serBclose                   <RS232.LIB>

SYNTAX:		   void serBclose(void);

DESCRIPTION:   Disables serial port B. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm __xmem
serBclose::
	   ld 	a, 0xC9 // RET
	   ipset RS232_INT_LEVEL
	   ld		(INTVEC_BASE + SERB_OFS), a	; ret in first byte of spbisr_start
	   xor   a
	   ld    (SBCRShadow), a					; disable interrupts for port
ioi	ld		(SBCR), a

#ifdef SPB_USE_TIMERA
      c TAT1R_SetValue( TAT1R_A5TIMER_REQ, TAT1R_RELEASE_REQ);
#endif
// return to normal output
RS232_IO(SERB_TX_PxFR, SERB_TX_PxFRShadow, (1<<BDRIVE_TXD), 0)
	   ipres
	   lret
#endasm

/*** Beginheader serBflowcontrolOn */
void serBflowcontrolOn(void);
/*** endheader */

#ifdef SER_NO_FLOWCONTROL
	#fatal "Can't use serBflowcontrolOn if SER_NO_FLOWCONTROL has been defined."
#endif

//defaults for flow control RTS/CTS
#ifndef SERB_RTS_PORT
	#define SERB_RTS_PORT PCDR
	#warnt "SERB_RTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERB_RTS_SHADOW
	#define SERB_RTS_SHADOW PCDRShadow
	#warnt "SERB_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERB_RTS_BIT
	#define SERB_RTS_BIT 2
	#warnt "SERB_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERB_CTS_PORT
	#define SERB_CTS_PORT PCDR
	#warnt "SERB_CTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERB_CTS_BIT
	#define SERB_CTS_BIT 3
	#warnt "SERB_CTS_BIT not defined: defaulting to 3"
#endif

int spb_checkcts_fc();
void spb_rtsoff_fc();
void spb_rtson_fc();

#asm __root
#ifndef SER_DMA_ONLY
spb_checkcts_fc::
   bool 	hl
   #ifdef SERB_CTS_EXTERNAL
		ioe ld	a, (SERB_CTS_PORT)
	#else
		ioi ld	a, (SERB_CTS_PORT)
	#endif
   and  	1 << SERB_CTS_BIT
   ld   	L, a
   ret
#endif

spb_rtsoff_fc::
// set RTS high (inactive)
#ifdef SERB_RTS_EXTERNAL
RS232_EXIO(SERB_RTS_PORT, SERB_RTS_SHADOW, (1<<SERB_RTS_BIT), (1<<SERB_RTS_BIT))
#else
RS232_HS(SERB_RTS_PORT, SERB_RTS_SHADOW, (1<<SERB_RTS_BIT), (1<<SERB_RTS_BIT))
#endif
#ifndef SER_DMA_DISABLE
   ld    a, (serBdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtsoff
   push	iy
   ld		iy, serBdata
   call  spx_dma_rtsoff
   pop	iy
.rtsoff:
#endif // ifndef SER_DMA_DISABLE
   ret

spb_rtson_fc::
#ifndef SER_DMA_DISABLE
   ; only execute this code if we are using DMA
   ld    a, (serBdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtson

   push	iy
   ld		iy, serBdata
   call	spx_dma_rtson
   pop	iy
.rtson:
#endif // ifndef SER_DMA_DISABLE
// set RTS low (active)
#ifdef SERB_RTS_EXTERNAL
RS232_EXIO(SERB_RTS_PORT, SERB_RTS_SHADOW, (1<<SERB_RTS_BIT), 0)
#else
RS232_HS(SERB_RTS_PORT, SERB_RTS_SHADOW, (1<<SERB_RTS_BIT), 0)
#endif
   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serBflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serBflowcontrolOn(void);

DESCRIPTION:   Turns on hardware flow control for channel B. This enables two
   				digital lines that handle flow control, CTS(clear to send)
   				and RTS(ready to send).
   				CTS is an input that will be pulled active low by the other
   				system when it is ready to receive data. The RTS signal
   				is an output that the system uses to indicate that it is
   				ready to receive data. It is driven low when data can be
   				received.
   				If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERB_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERB_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERB_RTS_BIT - the bit number for the RTS line
					SERB_RTS_EXTERNAL - Define if the RTS signal is hosted on
						external I/O instead of a direct processor port.

 					SERB_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERB_CTS_BIT - the bit number for the CTS line
					SERB_CTS_EXTERNAL - Define if the CTS signal is hosted on
						external I/O instead of a direct processor port.

               Important Note:
               ---------------
               The DMA options supports flow control, but the ports and pins
               for CTS are limited to the following:

               PD2, PD3, PE2, PE3, PE6, PE7.

               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  One
               can use PD2, PE2, or PE6, and the other can use PD3, PE3 or PE7.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void serBflowcontrolOn(void)
{
   //set flow control ISR functions
#ifndef SER_DMA_ONLY
   serBdata.xCheckCTS = spb_checkcts_fc;
#endif
   serBdata.xRTSoff = spb_rtsoff_fc;
   serBdata.xRTSon = spb_rtson_fc;

	_serXflow_enable( &serBdata,	SERB_RTS_PORT, SERB_RTS_BIT,
											SERB_CTS_PORT, SERB_CTS_BIT);
}

//************************************************************************
//****************************** PORT C **********************************
//************************************************************************

/*** Beginheader serCopen, serCtxBreak, serCclose */
int  serCopen(long baud);
int  serCtxBreak(int type);
void serCclose(void);

void spc_init(void);
__root void cDisable(void);
__root void cEnable(void);
extern serXdata serCdata;
/*** Endheader */

// SERIAL PORT C TX and RX PIN AND PORT SETUP
#ifndef CDRIVE_TXD
   #define CDRIVE_TXD 2
#endif

#ifndef CDRIVE_RXD
   #define CDRIVE_RXD 3
#endif

#ifndef SERC_TXPORT
   #define SERC_TXPORT PCDR
#endif

#ifndef SERC_RXPORT
   #define SERC_RXPORT PCDR
#endif

#define SPC_TX PC

// Port Verification
#if SERC_TXPORT != PCDR
	#fatal "SERC_TXPORT must be PCDR"
#endif
#if SERC_RXPORT != PCDR && SERC_RXPORT != PDDR && SERC_RXPORT != PEDR
	#fatal "SERC_RXPORT must be PCDR, PDDR or PEDR"
#endif
// End Verification

#define SERC_TX_PxDR				CONCAT(SPC_TX, DR)
#define SERC_TX_PxFR				CONCAT(SPC_TX, FR)
#define SERC_TX_PxDRShadow		CONCAT(SPC_TX, DRShadow)
#define SERC_TX_PxFRShadow		CONCAT(SPC_TX, FRShadow)

#define SERC_TX_PxDDR			CONCAT(SPC_TX, DDR)
#define SERC_TX_PxDCR			CONCAT(SPC_TX, DCR)
#define SERC_TX_PxDDRShadow	CONCAT(SPC_TX, DDRShadow)
#define SERC_TX_PxDCRShadow	CONCAT(SPC_TX, DCRShadow)

#undef  CINBUFOK
#ifndef CINBUFSIZE
	#define CINBUFSIZE 31
	#warnt "CINBUFSIZE undefined, defaulting to 31"
#endif

#if (CINBUFSIZE & (CINBUFSIZE+1)) == 0
	#define CINBUFOK 1
#endif

#ifndef CINBUFOK
	#undef  CINBUFSIZE
	#define CINBUFSIZE 31
	#warnt "CINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef  COUTBUFOK
#ifndef COUTBUFSIZE
	#define COUTBUFSIZE 31
	#warnt "COUTBUFSIZE undefined, defaulting to 31"
#endif

#if (COUTBUFSIZE & (COUTBUFSIZE+1)) == 0
	#define COUTBUFOK 1
#endif

#ifndef COUTBUFOK
	#undef  COUTBUFSIZE
	#define COUTBUFSIZE 31
	#warnt "COUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char __far CINBUF[CINBUFSIZE+CBUF_OVERHEAD];
char __far COUTBUF[COUTBUFSIZE+CBUF_OVERHEAD];
serXdata serCdata;

#ifndef SER_DMA_DISABLE
#ifdef SER_NO_FLOWCONTROL
DMABufDesc serCrxbd[1];							// only one buffer descriptor
#else
DMABufDesc serCrxbd[SER_DMA_DIVISIONS];	// one buffer descriptor for each div
void spc_rx_isr(void);
#endif
DMABufDesc serCtxbd[2];							// TX Ping-Pong buffers
void spc_tx_isr(void);
#endif

/* START FUNCTION DESCRIPTION ********************************************
serCopen                      <RS232.LIB>

SYNTAX:
   int serCopen(long baud);

DESCRIPTION:
   Opens the C serial port.  To use DMA for transfers, call serCdmaOn
   after calling this function.  serCopen is non-reentrant.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

RETURN VALUE:
   1 - The Rabbit's bps setting is within 5% of the input baud.
   0 - The Rabbit's bps setting differs by more than 5% of the input baud.

RELATED WORDS:
   serCgetc, serCread, serCpeek, serCputs, serCwrite, cof_serCgetc,
   cof_serCgets, cof_serCread, cof_serCputc, cof_serCputs, cof_serCwrite,
   serCclose

MACRO INFO:
   If either or both of RS232_NOCHARASSYINBRK or RS232_NOCHARASSYINBRK_C
   are defined then asynchronous character assembly is disabled during
   an RS-232 line break condition. Defining either of these macros may
   be appropriate for an application which has no need of asynchronous
   line break recognition, especially where a disconnected or non-driven
   RXC input is possible. Note that RS232_NOCHARASSYINBRK affects all
   RS232.LIB serial ports but RS232_NOCHARASSYINBRK_C affects only
   serial port C.

   If SPC_USE_TIMERA is defined, Port C uses Timer A6.  Otherwise, it will
   use the dedicated timer for SPC

   Pin Layout:
   	TX pins: PC2 (Default), PC3
      RX pins: PC3 (Default), PD3, PE3

   The user must define the following if not using the default settings:

   CDRIVE_TXD  // Defaults to 2
  *CDRIVE_RXD  // Defaults to 3
 **SERC_TXPORT // Defaults to PCDR
   SERC_RXPORT // Defaults to PCDR
   CINBUFSIZE  // Defaults to 31
   COUTBUFSIZE // Defaults to 31

   Note:
   ----
  *CDRIVE_RXD is always 3.
 **SERC_TXPORT is always PCDR.

END DESCRIPTION **********************************************************/
_rs232_debug
int serCopen(long baud)
{
   auto long actual_bps;

#ifndef SER_DMA_DISABLE
   #GLOBAL_INIT { serCdata.dma_flags = 0; }
   // turn off the DMA if the serial port was previously open
   if(serCdata.dma_flags)
   	serCdmaOff();
   serCdata.dma_rx_bd = serCrxbd;
   serCdata.dma_tx_bd = serCtxbd;
   serCdata.xDMAisrTX = spc_tx_isr;
#ifndef SER_NO_FLOWCONTROL
   serCdata.xDMAisrRX = spc_rx_isr;
   serCdata.dma_divsize = (CINBUFSIZE + 1) / SER_DMA_DIVISIONS;
#else
   serCdata.dma_divsize = CINBUFSIZE + 1;
#endif
#endif // ifndef SER_DMA_DISABLE

   // set sxd pointer to our global structure.
   sxd[SER_PORT_C] = &serCdata;

   // The following values are needed by the generic serXfunctions.
   serCdata.sxdr = SCDR;
   serCdata.sxcrshadow = &SCCRShadow;

#ifndef SER_DMA_ONLY
   serCdata.xdrive_txd = 1 << CDRIVE_TXD;
   serCdata.pxfrshadow = &SERC_TX_PxFRShadow;
#endif // ifndef SER_DMA_ONLY

#ifdef SER_FLAG_LINEBREAK
   serCdata.isLineBreak = 0;
#endif

   serCdata.xEnable = cEnable;
   serCdata.xDisable = cDisable;

	_serXopen_common_init( &serCdata, CINBUF, CINBUFSIZE, COUTBUF, COUTBUFSIZE);

#if defined RS232_NOCHARASSYINBRK || defined RS232_NOCHARASSYINBRK_C
	// Board has no pull-up on serial Rx line and application has possibility of
	//  disconnected or non-driven Rx line.
	// Application has no need of asynchronous line break recognition and has
	//  chosen to disable character assembly during line break condition to
	//  prevent possible spurious line break interrupts.
	WrPortI(SCER, &SCERShadow, 0x02 | RdPortI(SCER));
#endif

#ifndef SPC_USE_TIMERA
	actual_bps = serXsetDividers( baud, SCDHR, SCDLR);
#else
	actual_bps = SetSerialTATxRValues( baud, NULL, TAT6R);
#endif

   spc_init();

   return _serXopen_common_ret( &serCdata, baud, actual_bps);
}

// spc_rx_isr
//
//	This isr is for DMA flowcontrol use only. Whenever a DMA receive action
// ends, an interrupt is performed to sync the circular buffer and check to see
// if the buffer is full.

#ifndef SER_DMA_DISABLE
#ifndef SER_NO_FLOWCONTROL
#asm __root
spc_rx_isr::
	push	ix
	ld		ix, serCdata
	jp		spx_dma_rx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_NO_FLOWCONTROL

// spc_tx_isr
//
//	This isr is for DMA use only.  This isr occurs after a DMA transfer finishes
// At that point, if there is more data to send, it is sent immediately.

#asm __root
spc_tx_isr::
	push	ix
	ld		ix, serCdata
	jp		spx_dma_tx_isr
#endasm
#endif // ifndef SER_DMA_DISABLE

#asm __root
// interrupt routine to be copied into interrupt table
spcisr_start::   			; pass serCdata and SCDR to the isr
#ifndef SER_DMA_ONLY
   push	ix						; 2 bytes
   push	iy						; 2 bytes
   ld		ix, serCdata		; 4 bytes
   ld		iy, SCDR				; 4 bytes
   jp		spx_isr				; 3 bytes = 15 bytes total (fits in 16 bytes max)
#else
   ret
#endif

#endasm

#asm __xmem
spc_init::
   ld    de, INTVEC_BASE + SERC_OFS
   ld    hl, spcisr_start
   ld    bc, 16     ; copy 16 bytes from spcisr_start into interrupt table
   ipset RS232_INT_LEVEL

   #if __SEPARATE_INST_DATA__
      call inst2data_ldir
   #else
      ldir
   #endif

// Tx should initially be idle high
RS232_IO(SERC_TX_PxDR, SERC_TX_PxDRShadow, (1<<CDRIVE_TXD), (1<<CDRIVE_TXD))
RS232_IO(SERC_TX_PxFR, SERC_TX_PxFRShadow, (1<<CDRIVE_TXD), (1<<CDRIVE_TXD))
#ifdef SERC_TX_PxDCR // enable push-pull instead of open-drain.
RS232_IO(SERC_TX_PxDCR, SERC_TX_PxDCRShadow, (1<<CDRIVE_TXD), 0)
#endif
#ifdef SERC_TX_PxDDR
RS232_IO(SERC_TX_PxDDR, SERC_TX_PxDDRShadow, (1<<CDRIVE_TXD), (1<<CDRIVE_TXD))
#endif

#if SERC_RXPORT == PEDR
	   ld    a, _cexpr(0x20 | RS232_INT_LEVEL)
#elif SERC_RXPORT == PDDR
	   ld    a, _cexpr(0x10 | RS232_INT_LEVEL)
#else
	   ld    a, _cexpr(0x00 | RS232_INT_LEVEL)
#endif

#ifdef SER_DMA_ONLY
	   and	0xFC
#endif

	   ld    (SCCRShadow),a
ioi	ld		(SCCR), a      ; enable interrupts and select rx port.
	   ipres
	   lret

#endasm

#asm __root
cDisable:: // make sure Tx is high(idle)
RS232_IO(SERC_TX_PxDR, SERC_TX_PxDRShadow, (1<<CDRIVE_TXD), (1<<CDRIVE_TXD))
RS232_IO(SERC_TX_PxFR, SERC_TX_PxFRShadow, (1<<CDRIVE_TXD), 0)
	   ret

cEnable::
RS232_IO(SERC_TX_PxFR, SERC_TX_PxFRShadow, (1<<CDRIVE_TXD), (1<<CDRIVE_TXD))
	   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serCtxBreak                                                    <RS232.LIB>

SYNTAX:			int serCtxBreak( int type);

DESCRIPTION:	Generate a serial "break" by disabling the transmit pin for
					serial port C and pulling it low.

PARAMETER 1:   If 0, hold the break until another function sends data or
					calls serCopen.

					If 1, generate a character break (hold the break condition
					for the time it would take to send a single character) and
					then return the transmit pin to its idle state (high).

RETURN VALUE:	0 if able to generate the break
					-EIO if the serial port is not idle (i.e., sending bytes)
					-EINVAL if <type> is a value other than 0 or 1

END DESCRIPTION **********************************************************/
_rs232_debug
int serCtxBreak( int type)
{
	if (BitRdPortI( SCSR, 2))
	{
		// can't generate break if we're sending a byte
		return -EIO;
	}
	if (type < 0 || type > 1)
	{
		return -EINVAL;
	}

	// Set TX pin low, then change the function register to "normal output"
	BitWrPortI( SERC_TX_PxDR, &SERC_TX_PxDRShadow, 0, CDRIVE_TXD);
	BitWrPortI( SERC_TX_PxFR, &SERC_TX_PxFRShadow, 0, CDRIVE_TXD);

	if (type == 1)
	{
		// character break -- load dummy byte so ISR will end the break
		WrPortI( SCDR, NULL, 0);
	}

	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
serCclose                   <RS232.LIB>

SYNTAX:		   void serCclose(void);

DESCRIPTION:   Disables serial port C. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm __xmem
serCclose::
	   ld 	a, 0xC9 // RET
	   ipset RS232_INT_LEVEL
	   ld		(INTVEC_BASE + SERC_OFS), a	; ret in first byte of spcisr_start
	   xor   a
	   ld    (SCCRShadow), a					; disable interrupts for port
ioi	ld		(SCCR), a

#ifdef SPC_USE_TIMERA
      c TAT1R_SetValue( TAT1R_A6TIMER_REQ, TAT1R_RELEASE_REQ);
#endif

// return to normal output
RS232_IO(SERC_TX_PxFR, SERC_TX_PxFRShadow, (1<<CDRIVE_TXD), 0)
	   ipres
	   lret
#endasm

/*** BeginHeader serCflowcontrolOn */
void serCflowcontrolOn(void);
/*** EndHeader */

#ifdef SER_NO_FLOWCONTROL
	#fatal "Can't use serCflowcontrolOn if SER_NO_FLOWCONTROL has been defined."
#endif

//defaults for flow control RTS/CTS
#ifndef SERC_RTS_PORT
	#if SERC_TXPORT == PCDR
		#fatal "Can't default SERC_RTS_PORT to PC2, already used for TxC."
	#else
		#define SERC_RTS_PORT PCDR
		#warnt "SERC_RTS_PORT not defined: defaulting to PCDR"
	#endif
#endif

#ifndef SERC_RTS_SHADOW
	#define SERC_RTS_SHADOW PCDRShadow
	#warnt "SERC_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERC_RTS_BIT
	#define SERC_RTS_BIT 2
	#warnt "SERC_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERC_CTS_PORT
	#if SERC_RXPORT == PCDR
		#fatal "Can't default SERC_CTS_PORT to PC3, already used for RxC."
	#else
		#define SERC_CTS_PORT PCDR
		#warnt "SERC_CTS_PORT not defined: defaulting to PCDR"
	#endif
#endif

#ifndef SERC_CTS_BIT
	#define SERC_CTS_BIT 3
	#warnt "SERC_CTS_BIT not defined: defaulting to 3"
#endif

int spc_checkcts_fc();
void spc_rtsoff_fc();
void spc_rtson_fc();

#asm __root
#ifndef SER_DMA_ONLY
spc_checkcts_fc::
   bool 	hl
   #ifdef SERC_CTS_EXTERNAL
		ioe ld	a, (SERC_CTS_PORT)
	#else
		ioi ld	a, (SERC_CTS_PORT)
	#endif
   and  	1 << SERC_CTS_BIT
   ld   	L, a
   ret
#endif

spc_rtsoff_fc::
// set RTS high (inactive)
#ifdef SERC_RTS_EXTERNAL
RS232_EXIO(SERC_RTS_PORT, SERC_RTS_SHADOW, (1<<SERC_RTS_BIT), (1<<SERC_RTS_BIT))
#else
RS232_HS(SERC_RTS_PORT, SERC_RTS_SHADOW, (1<<SERC_RTS_BIT), (1<<SERC_RTS_BIT))
#endif
#ifndef SER_DMA_DISABLE
   ld    a, (serCdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtsoff
   push	iy
   ld		iy, serCdata
   call  spx_dma_rtsoff
   pop	iy
.rtsoff:
#endif // ifndef SER_DMA_DISABLE
   ret

spc_rtson_fc::
#ifndef SER_DMA_DISABLE
   ; only execute this code if we are using DMA
   ld    a, (serCdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtson

   push	iy
   ld		iy, serCdata
   call	spx_dma_rtson
   pop	iy
.rtson:
#endif // ifndef SER_DMA_DISABLE
// set RTS low (active)
#ifdef SERC_RTS_EXTERNAL
RS232_EXIO(SERC_RTS_PORT, SERC_RTS_SHADOW, (1<<SERC_RTS_BIT), 0)
#else
RS232_HS(SERC_RTS_PORT, SERC_RTS_SHADOW, (1<<SERC_RTS_BIT), 0)
#endif
   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serCflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serCflowcontrolOn(void);

DESCRIPTION:   Turns on hardware flow control for channel C. This enables two
   				digital lines that handle flow control, CTS(clear to send)
   				and RTS(ready to send).
   				CTS is an input that will be pulled active low by the other
   				system when it is ready to receive data. The RTS signal
   				is an output that the system uses to indicate that it is
   				ready to receive data. It is driven low when data can be
   				received.
   				If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERC_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERC_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERC_RTS_BIT - the bit number for the RTS line
					SERC_RTS_EXTERNAL - Define if the RTS signal is hosted on
						external I/O instead of a direct processor port.

 					SERC_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERC_CTS_BIT - the bit number for the CTS line
					SERC_CTS_EXTERNAL - Define if the CTS signal is hosted on
						external I/O instead of a direct processor port.

               Important Note:
               ---------------
               The DMA options supports flow control, but the ports and pins
               for CTS are limited to the following:

               PD2, PD3, PE2, PE3, PE6, PE7.

               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  One
               can use PD2, PE2, or PE6, and the other can use PD3, PE3 or PE7.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void serCflowcontrolOn(void)
{
   //set flow control ISR functions
#ifndef SER_DMA_ONLY
   serCdata.xCheckCTS = spc_checkcts_fc;
#endif
   serCdata.xRTSoff = spc_rtsoff_fc;
   serCdata.xRTSon = spc_rtson_fc;

	_serXflow_enable( &serCdata,	SERC_RTS_PORT, SERC_RTS_BIT,
											SERC_CTS_PORT, SERC_CTS_BIT);
}

//************************************************************************
//****************************** PORT D **********************************
//************************************************************************



/*** Beginheader serDopen, serDtxBreak, serDclose */
int  serDopen(long baud);
int  serDtxBreak(int type);
void serDclose(void);

void spd_init(void);
__root void dDisable(void);
__root void dEnable(void);
extern serXdata serDdata;
/*** Endheader */

// SERIAL PORT D TX and RX PIN AND PORT SETUP
#ifndef DDRIVE_TXD
   #define DDRIVE_TXD 0
#endif

#ifndef DDRIVE_RXD
   #define DDRIVE_RXD 1
#endif

#ifndef SERD_TXPORT
   #define SERD_TXPORT PCDR
#endif

#ifndef SERD_RXPORT
   #define SERD_RXPORT PCDR
#endif

#define SPD_TX PC

// Port Verification
#if SERD_TXPORT != PCDR
	#fatal "SERD_TXPORT must be PCDR"
#endif
#if SERD_RXPORT != PCDR && SERD_RXPORT != PDDR && SERD_RXPORT != PEDR
	#fatal "SERD_RXPORT must be PCDR, PDDR or PEDR"
#endif
// End Verification

#define SERD_TX_PxDR				CONCAT(SPD_TX, DR)
#define SERD_TX_PxFR				CONCAT(SPD_TX, FR)
#define SERD_TX_PxDRShadow		CONCAT(SPD_TX, DRShadow)
#define SERD_TX_PxFRShadow		CONCAT(SPD_TX, FRShadow)

#define SERD_TX_PxDDR			CONCAT(SPD_TX, DDR)
#define SERD_TX_PxDCR			CONCAT(SPD_TX, DCR)
#define SERD_TX_PxDDRShadow	CONCAT(SPD_TX, DDRShadow)
#define SERD_TX_PxDCRShadow	CONCAT(SPD_TX, DCRShadow)

#undef  DINBUFOK
#ifndef DINBUFSIZE
	#define DINBUFSIZE 31
	#warnt "DINBUFSIZE undefined, defaulting to 31"
#endif

#if (DINBUFSIZE & (DINBUFSIZE+1)) == 0
	#define DINBUFOK 1
#endif

#ifndef DINBUFOK
	#undef  DINBUFSIZE
	#define DINBUFSIZE 31
	#warnt "DINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef  DOUTBUFOK
#ifndef DOUTBUFSIZE
	#define DOUTBUFSIZE 31
	#warnt "DOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (DOUTBUFSIZE & (DOUTBUFSIZE+1)) == 0
	#define DOUTBUFOK 1
#endif

#ifndef DOUTBUFOK
	#undef  DOUTBUFSIZE
	#define DOUTBUFSIZE 31
	#warnt "DOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char __far DINBUF[DINBUFSIZE+CBUF_OVERHEAD];
char __far DOUTBUF[DOUTBUFSIZE+CBUF_OVERHEAD];
serXdata serDdata;

#ifndef SER_DMA_DISABLE
#ifdef SER_NO_FLOWCONTROL
DMABufDesc serDrxbd[1];							// only one buffer descriptor
#else
DMABufDesc serDrxbd[SER_DMA_DIVISIONS];	// one buffer descriptor for each div
void spd_rx_isr(void);
#endif
DMABufDesc serDtxbd[2];							// TX Ping-Pong buffers
void spd_tx_isr(void);
#endif

/* START FUNCTION DESCRIPTION ********************************************
serDopen                      <RS232.LIB>

SYNTAX:
   int serDopen(long baud);

DESCRIPTION:
   Opens the D serial port.  To use DMA for transfers, call serDdmaOn
   after calling this function.  serDopen is non-reentrant.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

RETURN VALUE:
   1 - The Rabbit's bps setting is within 5% of the input baud.
   0 - The Rabbit's bps setting differs by more than 5% of the input baud.

RELATED WORDS:
   serDgetc, serDread, serDpeek, serDputs, serDwrite, cof_serDgetc,
   cof_serDgets, cof_serDread, cof_serDputc, cof_serDputs, cof_serDwrite,
   serDclose

MACRO INFO:
   If either or both of RS232_NOCHARASSYINBRK or RS232_NOCHARASSYINBRK_D
   are defined then asynchronous character assembly is disabled during
   an RS-232 line break condition. Defining either of these macros may
   be appropriate for an application which has no need of asynchronous
   line break recognition, especially where a disconnected or non-driven
   RXD input is possible. Note that RS232_NOCHARASSYINBRK affects all
   RS232.LIB serial ports but RS232_NOCHARASSYINBRK_D affects only
   serial port D.

   If SPD_USE_TIMERA is defined, Port D uses Timer A7.  Otherwise, it will
   use the dedicated timer for SPD

   Pin Layout:
   	TX pins: PC0 (Default), PC1
      RX pins: PC1 (Default), PD1, PE1

   The user must define the following if not using the default settings:

   DDRIVE_TXD  // Defaults to 0
  *DDRIVE_RXD  // Defaults to 1
 **SERD_TXPORT // Defaults to PCDR
   SERD_RXPORT // Defaults to PCDR
   DINBUFSIZE  // Defaults to 31
   DOUTBUFSIZE // Defaults to 31

   Note:
   ----
  *DDRIVE_RXD is always 1.
 **SERD_TXPORT is always PCDR.

END DESCRIPTION **********************************************************/
_rs232_debug
int serDopen(long baud)
{
   auto long actual_bps;

#ifndef SER_DMA_DISABLE
   #GLOBAL_INIT { serDdata.dma_flags = 0; }
   // turn off the DMA if the serial port was previously open
   if(serDdata.dma_flags)
   	serDdmaOff();
   serDdata.dma_rx_bd = serDrxbd;
   serDdata.dma_tx_bd = serDtxbd;
   serDdata.xDMAisrTX = spd_tx_isr;
#ifndef SER_NO_FLOWCONTROL
   serDdata.xDMAisrRX = spd_rx_isr;
   serDdata.dma_divsize = (DINBUFSIZE + 1) / SER_DMA_DIVISIONS;
#else
   serDdata.dma_divsize = DINBUFSIZE + 1;
#endif
#endif // ifndef SER_DMA_DISABLE

   // set sxd pointer to our global structure.
   sxd[SER_PORT_D] = &serDdata;

   // The following values are needed by the generic serXfunctions.
   serDdata.sxdr = SDDR;
   serDdata.sxcrshadow = &SDCRShadow;

#ifndef SER_DMA_ONLY
   serDdata.xdrive_txd = 1 << DDRIVE_TXD;
   serDdata.pxfrshadow = &SERD_TX_PxFRShadow;
#endif // ifndef SER_DMA_ONLY

#ifdef SER_FLAG_LINEBREAK
   serDdata.isLineBreak = 0;
#endif

   serDdata.xEnable = dEnable;
   serDdata.xDisable = dDisable;

	_serXopen_common_init( &serDdata, DINBUF, DINBUFSIZE, DOUTBUF, DOUTBUFSIZE);

#if defined RS232_NOCHARASSYINBRK || defined RS232_NOCHARASSYINBRK_D
	// Board has no pull-up on serial Rx line and application has possibility of
	//  disconnected or non-driven Rx line.
	// Application has no need of asynchronous line break recognition and has
	//  chosen to disable character assembly during line break condition to
	//  prevent possible spurious line break interrupts.
	WrPortI(SDER, &SDERShadow, 0x02 | RdPortI(SDER));
#endif

#ifndef SPD_USE_TIMERA
	actual_bps = serXsetDividers( baud, SDDHR, SDDLR);
#else
	actual_bps = SetSerialTATxRValues( baud, NULL, TAT7R);
#endif

   spd_init();

   return _serXopen_common_ret( &serDdata, baud, actual_bps);
}

// spd_rx_isr
//
//	This isr is for DMA flowcontrol use only. Whenever a DMA receive action
// ends, an interrupt is performed to sync the circular buffer and check to see
// if the buffer is full.

#ifndef SER_DMA_DISABLE
#ifndef SER_NO_FLOWCONTROL
#asm __root
spd_rx_isr::
	push	ix
	ld		ix, serDdata
	jp		spx_dma_rx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_NO_FLOWCONTROL

// spd_tx_isr
//
//	This isr is for DMA use only.  This isr occurs after a DMA transfer finishes
// At that point, if there is more data to send, it is sent immediately.

#asm __root
spd_tx_isr::
	push	ix
	ld		ix, serDdata
	jp		spx_dma_tx_isr
#endasm
#endif // ifndef SER_DMA_DISABLE

#asm __root
// interrupt routine to be copied into interrupt table
spdisr_start::   			; pass serDdata and SDDR to the isr
#ifndef SER_DMA_ONLY
   push	ix						; 2 bytes
   push	iy						; 2 bytes
   ld		ix, serDdata		; 4 bytes
   ld		iy, SDDR				; 4 bytes
   jp		spx_isr				; 3 bytes = 15 bytes total (fits in 16 bytes max)
#else
   ret
#endif

#endasm

#asm __xmem
spd_init::
   ld    de, INTVEC_BASE + SERD_OFS
   ld    hl, spdisr_start
   ld    bc, 16     ; copy 16 bytes from spdisr_start into interrupt table
   ipset RS232_INT_LEVEL

   #if __SEPARATE_INST_DATA__
      call inst2data_ldir
   #else
      ldir
   #endif

// Tx should initially be idle high
RS232_IO(SERD_TX_PxDR, SERD_TX_PxDRShadow, (1<<DDRIVE_TXD), (1<<DDRIVE_TXD))
RS232_IO(SERD_TX_PxFR, SERD_TX_PxFRShadow, (1<<DDRIVE_TXD), (1<<DDRIVE_TXD))
#ifdef SERD_TX_PxDCR // enable push-pull instead of open-drain.
RS232_IO(SERD_TX_PxDCR, SERD_TX_PxDCRShadow, (1<<DDRIVE_TXD), 0)
#endif
#ifdef SERD_TX_PxDDR
RS232_IO(SERD_TX_PxDDR, SERD_TX_PxDDRShadow, (1<<DDRIVE_TXD), (1<<DDRIVE_TXD))
#endif

#if SERD_RXPORT == PEDR
	   ld    a, _cexpr(0x20 | RS232_INT_LEVEL)
#elif SERD_RXPORT == PDDR
	   ld    a, _cexpr(0x10 | RS232_INT_LEVEL)
#else
	   ld    a, _cexpr(0x00 | RS232_INT_LEVEL)
#endif

#ifdef SER_DMA_ONLY
	   and	0xFC
#endif

	   ld    (SDCRShadow),a
ioi	ld		(SDCR), a      ; enable interrupts and select rx port.
	   ipres
	   lret

#endasm

#asm __root
dDisable:: // make sure Tx is high(idle)
RS232_IO(SERD_TX_PxDR, SERD_TX_PxDRShadow, (1<<DDRIVE_TXD), (1<<DDRIVE_TXD))
RS232_IO(SERD_TX_PxFR, SERD_TX_PxFRShadow, (1<<DDRIVE_TXD), 0)
	   ret

dEnable::
RS232_IO(SERD_TX_PxFR, SERD_TX_PxFRShadow, (1<<DDRIVE_TXD), (1<<DDRIVE_TXD))
	   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serDtxBreak                                                    <RS232.LIB>

SYNTAX:			int serDtxBreak( int type);

DESCRIPTION:	Generate a serial "break" by disabling the transmit pin for
					serial port D and pulling it low.

PARAMETER 1:   If 0, hold the break until another function sends data or
					calls serDopen.

					If 1, generate a character break (hold the break condition
					for the time it would take to send a single character) and
					then return the transmit pin to its idle state (high).

RETURN VALUE:	0 if able to generate the break
					-EIO if the serial port is not idle (i.e., sending bytes)
					-EINVAL if <type> is a value other than 0 or 1

END DESCRIPTION **********************************************************/
_rs232_debug
int serDtxBreak( int type)
{
	if (BitRdPortI( SDSR, 2))
	{
		// can't generate break if we're sending a byte
		return -EIO;
	}
	if (type < 0 || type > 1)
	{
		return -EINVAL;
	}

	// Set TX pin low, then change the function register to "normal output"
	BitWrPortI( SERD_TX_PxDR, &SERD_TX_PxDRShadow, 0, DDRIVE_TXD);
	BitWrPortI( SERD_TX_PxFR, &SERD_TX_PxFRShadow, 0, DDRIVE_TXD);

	if (type == 1)
	{
		// character break -- load dummy byte so ISR will end the break
		WrPortI( SDDR, NULL, 0);
	}

	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
serDclose                   <RS232.LIB>

SYNTAX:		   void serDclose(void);

DESCRIPTION:   Disables serial port D. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm __xmem
serDclose::
	   ld 	a, 0xC9 // RET
	   ipset RS232_INT_LEVEL
	   ld		(INTVEC_BASE + SERD_OFS), a	; ret in first byte of spdisr_start
	   xor   a
	   ld    (SDCRShadow), a					; disable interrupts for port
ioi	ld		(SDCR), a

#ifdef SPD_USE_TIMERA
      c TAT1R_SetValue( TAT1R_A7TIMER_REQ, TAT1R_RELEASE_REQ);
#endif

// return to normal output
RS232_IO(SERD_TX_PxFR, SERD_TX_PxFRShadow, (1<<DDRIVE_TXD), 0)
	   ipres
	   lret
#endasm

/*** BeginHeader serDflowcontrolOn */
void serDflowcontrolOn(void);
/*** EndHeader */

#ifdef SER_NO_FLOWCONTROL
	#fatal "Can't use serDflowcontrolOn if SER_NO_FLOWCONTROL has been defined."
#endif

//defaults for flow control RTS/CTS
#ifndef SERD_RTS_PORT
	#define SERD_RTS_PORT PCDR
	#warnt "SERD_RTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERD_RTS_SHADOW
	#define SERD_RTS_SHADOW PCDRShadow
	#warnt "SERD_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERD_RTS_BIT
	#define SERD_RTS_BIT 2
	#warnt "SERD_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERD_CTS_PORT
	#define SERD_CTS_PORT PCDR
	#warnt "SERD_CTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERD_CTS_BIT
	#define SERD_CTS_BIT 3
	#warnt "SERD_CTS_BIT not defined: defaulting to 3"
#endif

int spd_checkcts_fc();
void spd_rtsoff_fc();
void spd_rtson_fc();

#asm __root
#ifndef SER_DMA_ONLY
spd_checkcts_fc::
   bool 	hl
   #ifdef SERD_CTS_EXTERNAL
		ioe ld	a, (SERD_CTS_PORT)
	#else
		ioi ld	a, (SERD_CTS_PORT)
	#endif
   and  	1 << SERD_CTS_BIT
   ld   	L, a
   ret
#endif

spd_rtsoff_fc::
// set RTS high (inactive)
#ifdef SERD_RTS_EXTERNAL
RS232_EXIO(SERD_RTS_PORT, SERD_RTS_SHADOW, (1<<SERD_RTS_BIT), (1<<SERD_RTS_BIT))
#else
RS232_HS(SERD_RTS_PORT, SERD_RTS_SHADOW, (1<<SERD_RTS_BIT), (1<<SERD_RTS_BIT))
#endif
#ifndef SER_DMA_DISABLE
   ld    a, (serDdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtsoff
   push	iy
   ld		iy, serDdata
   call  spx_dma_rtsoff
   pop	iy
.rtsoff:
#endif // ifndef SER_DMA_DISABLE
   ret

spd_rtson_fc::
#ifndef SER_DMA_DISABLE
   ; only execute this code if we are using DMA
   ld    a, (serDdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtson

   push	iy
   ld		iy, serDdata
   call	spx_dma_rtson
   pop	iy
.rtson:
#endif // ifndef SER_DMA_DISABLE
// set RTS low (active)
#ifdef SERD_RTS_EXTERNAL
RS232_EXIO(SERD_RTS_PORT, SERD_RTS_SHADOW, (1<<SERD_RTS_BIT), 0)
#else
RS232_HS(SERD_RTS_PORT, SERD_RTS_SHADOW, (1<<SERD_RTS_BIT), 0)
#endif
   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serDflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serDflowcontrolOn(void);

DESCRIPTION:   Turns on hardware flow control for channel D. This enables two
   				digital lines that handle flow control, CTS(clear to send)
   				and RTS(ready to send).
   				CTS is an input that will be pulled active low by the other
   				system when it is ready to receive data. The RTS signal
   				is an output that the system uses to indicate that it is
   				ready to receive data. It is driven low when data can be
   				received.
   				If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERD_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERD_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERD_RTS_BIT - the bit number for the RTS line
					SERD_RTS_EXTERNAL - Define if the RTS signal is hosted on
						external I/O instead of a direct processor port.

 					SERD_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERD_CTS_BIT - the bit number for the CTS line
					SERD_CTS_EXTERNAL - Define if the CTS signal is hosted on
						external I/O instead of a direct processor port.

               Important Note:
               ---------------
               The DMA options supports flow control, but the ports and pins
               for CTS are limited to the following:

               PD2, PD3, PE2, PE3, PE6, PE7.

               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  One
               can use PD2, PE2, or PE6, and the other can use PD3, PE3 or PE7.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void serDflowcontrolOn(void)
{
   //set flow control ISR functions
#ifndef SER_DMA_ONLY
   serDdata.xCheckCTS = spd_checkcts_fc;
#endif
   serDdata.xRTSoff = spd_rtsoff_fc;
   serDdata.xRTSon = spd_rtson_fc;

	_serXflow_enable( &serDdata,	SERD_RTS_PORT, SERD_RTS_BIT,
											SERD_CTS_PORT, SERD_CTS_BIT);
}

//************************************************************************
//****************************** PORT E **********************************
//************************************************************************



/*** Beginheader serEopen, serEtxBreak, serEclose */
int  serEopen(long baud);
int  serEtxBreak(int type);
void serEclose(void);

void spe_init(void);
__root void eDisable(void);
__root void eEnable(void);
extern serXdata serEdata;
/*** Endheader */

// SERIAL PORT E TX and RX PIN AND PORT SETUP
#ifndef EDRIVE_TXD
   #define EDRIVE_TXD 6
#endif

#ifndef EDRIVE_RXD
   #define EDRIVE_RXD 7
#endif

#ifndef SERE_TXPORT
   #define SERE_TXPORT PCDR
#endif

#ifndef SERE_RXPORT
   #define SERE_RXPORT PCDR
#endif

#if SERE_TXPORT == PEDR
   #define SPE_TX PE
#elif SERE_TXPORT == PDDR
   #define SPE_TX PD
#else
   #define SPE_TX PC
#endif

// Port Verification
#if SERE_TXPORT != PCDR && SERE_TXPORT != PDDR && SERE_TXPORT != PEDR
	#fatal "SERE_TXPORT must be PCDR, PDDR or PEDR"
#endif
#if SERE_RXPORT != PCDR && SERE_RXPORT != PDDR && SERE_RXPORT != PEDR
	#fatal "SERE_RXPORT must be PCDR, PDDR or PEDR"
#endif
// End Verification

// Alternate output register
#define SERE_TX_ALTREG     CONCAT(SPE_TX, AHR)
#define SERE_TX_ALTShadow  CONCAT(SPE_TX, AHRShadow)
#define EDRIVE_ALT         0x30

#define SERE_TX_PxDR				CONCAT(SPE_TX, DR)
#define SERE_TX_PxFR				CONCAT(SPE_TX, FR)
#define SERE_TX_PxDRShadow		CONCAT(SPE_TX, DRShadow)
#define SERE_TX_PxFRShadow		CONCAT(SPE_TX, FRShadow)

#define SERE_TX_PxDDR			CONCAT(SPE_TX, DDR)
#define SERE_TX_PxDDRShadow	CONCAT(SPE_TX, DDRShadow)
#define SERE_TX_PxDCR			CONCAT(SPE_TX, DCR)
#define SERE_TX_PxDCRShadow	CONCAT(SPE_TX, DCRShadow)

#undef  EINBUFOK
#ifndef EINBUFSIZE
	#define EINBUFSIZE 31
	#warnt "EINBUFSIZE undefined, defaulting to 31"
#endif

#if (EINBUFSIZE & (EINBUFSIZE+1)) == 0
	#define EINBUFOK 1
#endif

#ifndef EINBUFOK
	#undef  EINBUFSIZE
	#define EINBUFSIZE 31
	#warnt "EINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef  EOUTBUFOK
#ifndef EOUTBUFSIZE
	#define EOUTBUFSIZE 31
	#warnt "EOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (EOUTBUFSIZE & (EOUTBUFSIZE+1)) == 0
	#define EOUTBUFOK 1
#endif

#ifndef EOUTBUFOK
	#undef  EOUTBUFSIZE
	#define EOUTBUFSIZE 31
	#warnt "EOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char __far EINBUF[EINBUFSIZE+CBUF_OVERHEAD];
char __far EOUTBUF[EOUTBUFSIZE+CBUF_OVERHEAD];
serXdata serEdata;

#ifndef SER_DMA_DISABLE
#ifdef SER_NO_FLOWCONTROL
DMABufDesc serErxbd[1];							// only one buffer descriptor
#else
DMABufDesc serErxbd[SER_DMA_DIVISIONS];	// one buffer descriptor for each div
void spe_rx_isr(void);
#endif
DMABufDesc serEtxbd[2];							// TX Ping-Pong buffers
void spe_tx_isr(void);
#endif

/* START FUNCTION DESCRIPTION ********************************************
serEopen                      <RS232.LIB>

SYNTAX:
   int serEopen(long baud);

DESCRIPTION:
   Opens the E serial port.  To use DMA for transfers, call serEdmaOn
   after calling this function.  serEopen is non-reentrant.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

RETURN VALUE:
   1 - The Rabbit's bps setting is within 5% of the input baud.
   0 - The Rabbit's bps setting differs by more than 5% of the input baud.

RELATED WORDS:
   serEgetc, serEread, serEpeek, serEputs, serEwrite, cof_serEgetc,
   cof_serEgets, cof_serEread, cof_serEputc, cof_serEputs, cof_serEwrite,
   serEclose

MACRO INFO:
   If either or both of RS232_NOCHARASSYINBRK or RS232_NOCHARASSYINBRK_E
   are defined then asynchronous character assembly is disabled during
   an RS-232 line break condition. Defining either of these macros may
   be appropriate for an application which has no need of asynchronous
   line break recognition, especially where a disconnected or non-driven
   RXE input is possible. Note that RS232_NOCHARASSYINBRK affects all
   RS232.LIB serial ports but RS232_NOCHARASSYINBRK_E affects only
   serial port E.

   If SPE_USE_TIMERA is defined, Port E uses Timer A2.  Otherwise, it will
   use the dedicated timer for SPE

   Pin Layout:
   	TX pins: PC6 (Default), PD6, PE6
      RX pins: PC7 (Default), PD7, PE7

   The user must define the following if not using the default settings:

  *EDRIVE_TXD  // Defaults to 6
 **EDRIVE_RXD  // Defaults to 7
   SERE_TXPORT // Defaults to PCDR
   SERE_RXPORT // Defaults to PCDR
   EINBUFSIZE  // Defaults to 31
   EOUTBUFSIZE // Defaults to 31

   Note:
   ----
  *EDRIVE_TXD is always 6.
 **EDRIVE_RXD is always 7.

PROGRAMMING PORT INFO:
   The default pin setup of Serial Port E uses parallel port C pins
   which conflict with the programming port. Opening serial port E
   with the default settings while in debug mode will therefore kill
   PC host/target communication..

   The user must #define the following if not using the default
   (PCDR) settings:

   SERE_TXPORT  define to PEDR or PDDR
   SERE_RXPORT  define to PEDR or PDDR

END DESCRIPTION **********************************************************/
_rs232_debug
int serEopen(long baud)
{
   auto long actual_bps;

#ifndef SER_DMA_DISABLE
   #GLOBAL_INIT { serEdata.dma_flags = 0; }
   // turn off the DMA if the serial port was previously open
   if(serEdata.dma_flags)
   	serEdmaOff();
   serEdata.dma_rx_bd = serErxbd;
   serEdata.dma_tx_bd = serEtxbd;
   serEdata.xDMAisrTX = spe_tx_isr;
#ifndef SER_NO_FLOWCONTROL
   serEdata.xDMAisrRX = spe_rx_isr;
   serEdata.dma_divsize = (EINBUFSIZE + 1) / SER_DMA_DIVISIONS;
#else
   serEdata.dma_divsize = EINBUFSIZE + 1;
#endif
#endif // ifndef SER_DMA_DISABLE

   // set sxd pointer to our global structure.
   sxd[SER_PORT_E] = &serEdata;

   // The following values are needed by the generic serXfunctions.
   serEdata.sxdr = SEDR;
   serEdata.sxcrshadow = &SECRShadow;

#ifndef SER_DMA_ONLY
   serEdata.xdrive_txd = 1 << EDRIVE_TXD;
   serEdata.pxfrshadow = &SERE_TX_PxFRShadow;
#endif // ifndef SER_DMA_ONLY

#ifdef SER_FLAG_LINEBREAK
   serEdata.isLineBreak = 0;
#endif

   serEdata.xEnable = eEnable;
   serEdata.xDisable = eDisable;

	_serXopen_common_init( &serEdata, EINBUF, EINBUFSIZE, EOUTBUF, EOUTBUFSIZE);

#if defined RS232_NOCHARASSYINBRK || defined RS232_NOCHARASSYINBRK_E
	// Board has no pull-up on serial Rx line and application has possibility of
	//  disconnected or non-driven Rx line.
	// Application has no need of asynchronous line break recognition and has
	//  chosen to disable character assembly during line break condition to
	//  prevent possible spurious line break interrupts.
	WrPortI(SEER, &SEERShadow, 0x02 | RdPortI(SEER));
#endif

#ifndef SPE_USE_TIMERA
	actual_bps = serXsetDividers( baud, SEDHR, SEDLR);
#else
	actual_bps = SetSerialTATxRValues( baud, NULL, TAT2R);
#endif

   spe_init();

   return _serXopen_common_ret( &serEdata, baud, actual_bps);
}

// spe_rx_isr
//
//	This isr is for DMA flowcontrol use only. Whenever a DMA receive action
// ends, an interrupt is performed to sync the circular buffer and check to see
// if the buffer is full.

#ifndef SER_DMA_DISABLE
#ifndef SER_NO_FLOWCONTROL
#asm __root
spe_rx_isr::
	push	ix
	ld		ix, serEdata
	jp		spx_dma_rx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_NO_FLOWCONTROL

// spe_tx_isr
//
//	This isr is for DMA use only.  This isr occurs after a DMA transfer finishes
// At that point, if there is more data to send, it is sent immediately.

#asm __root
spe_tx_isr::
	push	ix
	ld		ix, serEdata
	jp		spx_dma_tx_isr
#endasm
#endif // ifndef SER_DMA_DISABLE

#asm __root
// interrupt routine to be copied into interrupt table
speisr_start::   			; pass serEdata and SEDR to the isr
#ifndef SER_DMA_ONLY
   push	ix						; 2 bytes
   push	iy						; 2 bytes
   ld		ix, serEdata		; 4 bytes
   ld		iy, SEDR				; 4 bytes
   jp		spx_isr				; 3 bytes = 15 bytes total (fits in 16 bytes max)
#else
   ret
#endif

#endasm

#asm __xmem
spe_init::
   ld    de, INTVEC_BASE + SERE_OFS
   ld    hl, speisr_start
   ld    bc, 16     ; copy 16 bytes from speisr_start into interrupt table
   ipset RS232_INT_LEVEL

   #if __SEPARATE_INST_DATA__
      call inst2data_ldir
   #else
      ldir
   #endif

// Tx should initially be idle high
RS232_IO(SERE_TX_PxDR, SERE_TX_PxDRShadow, (1<<EDRIVE_TXD), (1<<EDRIVE_TXD))
RS232_IO(SERE_TX_PxFR, SERE_TX_PxFRShadow, (1<<EDRIVE_TXD), (1<<EDRIVE_TXD))
#ifdef SERE_TX_ALTREG // enable alternate output
RS232_IO(SERE_TX_ALTREG, SERE_TX_ALTShadow, EDRIVE_ALT, EDRIVE_ALT)
#endif
#ifdef SERE_TX_PxDCR // enable push-pull instead of open-drain.
RS232_IO(SERE_TX_PxDCR, SERE_TX_PxDCRShadow, (1<<EDRIVE_TXD), 0)
#endif
#ifdef SERE_TX_PxDDR
RS232_IO(SERE_TX_PxDDR, SERE_TX_PxDDRShadow, (1<<EDRIVE_TXD), (1<<EDRIVE_TXD))
#endif

#if SERE_RXPORT == PEDR
	   ld    a, _cexpr(0x20 | RS232_INT_LEVEL)
#elif SERE_RXPORT == PDDR
	   ld    a, _cexpr(0x10 | RS232_INT_LEVEL)
#else // PGDR or PCDR
	   ld    a, _cexpr(0x00 | RS232_INT_LEVEL)
#endif

#ifdef SER_DMA_ONLY
	   and	0xFC
#endif

	   ld    (SECRShadow),a
ioi	ld		(SECR), a      ; enable interrupts and select rx port.
	   ipres
	   lret

#endasm

#asm __root
eDisable:: // make sure Tx is high(idle)
RS232_IO(SERE_TX_PxDR, SERE_TX_PxDRShadow, (1<<EDRIVE_TXD), (1<<EDRIVE_TXD))
RS232_IO(SERE_TX_PxFR, SERE_TX_PxFRShadow, (1<<EDRIVE_TXD), 0)
	    ret

eEnable::
RS232_IO(SERE_TX_PxFR, SERE_TX_PxFRShadow, (1<<EDRIVE_TXD), (1<<EDRIVE_TXD))
	    ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serEtxBreak                                                    <RS232.LIB>

SYNTAX:			int serEtxBreak( int type);

DESCRIPTION:	Generate a serial "break" by disabling the transmit pin for
					serial port E and pulling it low.

PARAMETER 1:   If 0, hold the break until another function sends data or
					calls serEopen.

					If 1, generate a character break (hold the break condition
					for the time it would take to send a single character) and
					then return the transmit pin to its idle state (high).

RETURN VALUE:	0 if able to generate the break
					-EIO if the serial port is not idle (i.e., sending bytes)
					-EINVAL if <type> is a value other than 0 or 1

END DESCRIPTION **********************************************************/
_rs232_debug
int serEtxBreak( int type)
{
	if (BitRdPortI( SESR, 2))
	{
		// can't generate break if we're sending a byte
		return -EIO;
	}
	if (type < 0 || type > 1)
	{
		return -EINVAL;
	}

	// Set TX pin low, then change the function register to "normal output"
	BitWrPortI( SERE_TX_PxDR, &SERE_TX_PxDRShadow, 0, EDRIVE_TXD);
	BitWrPortI( SERE_TX_PxFR, &SERE_TX_PxFRShadow, 0, EDRIVE_TXD);

	if (type == 1)
	{
		// character break -- load dummy byte so ISR will end the break
		WrPortI( SEDR, NULL, 0);
	}

	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
serEclose                   <RS232.LIB>

SYNTAX:		   void serEclose(void);

DESCRIPTION:   Disables serial port E. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm __xmem
serEclose::
		ld 	a, 0xC9 // RET
		ipset RS232_INT_LEVEL
		ld		(INTVEC_BASE + SERE_OFS), a	; ret in first byte of speisr_start
		xor   a
		ld    (SECRShadow), a					; disable interrupts for port
ioi	ld		(SECR), a

#ifdef SPE_USE_TIMERA
      c TAT1R_SetValue( TAT1R_A2TIMER_REQ, TAT1R_RELEASE_REQ);
#endif
// return to normal output
RS232_IO(SERE_TX_PxFR, SERE_TX_PxFRShadow, (1<<EDRIVE_TXD), 0)
   	ipres
   	lret
#endasm

/*** BeginHeader serEflowcontrolOn */
void serEflowcontrolOn(void);
/*** EndHeader */

#ifdef SER_NO_FLOWCONTROL
	#fatal "Can't use serEflowcontrolOn if SER_NO_FLOWCONTROL has been defined."
#endif

//defaults for flow control RTS/CTS
#ifndef SERE_RTS_PORT
	#define SERE_RTS_PORT PCDR
	#warnt "SERE_RTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERE_RTS_SHADOW
	#define SERE_RTS_SHADOW PCDRShadow
	#warnt "SERE_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERE_RTS_BIT
	#define SERE_RTS_BIT 2
	#warnt "SERE_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERE_CTS_PORT
	#define SERE_CTS_PORT PCDR
	#warnt "SERE_CTS_PORT not defined: defaulting to PCDR"
#endif

#ifndef SERE_CTS_BIT
	#define SERE_CTS_BIT 3
	#warnt "SERE_CTS_BIT not defined: defaulting to 3"
#endif

int spe_checkcts_fc();
void spe_rtsoff_fc();
void spe_rtson_fc();

#asm __root
#ifndef SER_DMA_ONLY
spe_checkcts_fc::
   bool 	hl
   #ifdef SERE_CTS_EXTERNAL
		ioe ld	a, (SERE_CTS_PORT)
	#else
		ioi ld	a, (SERE_CTS_PORT)
	#endif
   and  	1 << SERE_CTS_BIT
   ld   	L, a
   ret
#endif

spe_rtsoff_fc::
// set RTS high (inactive)
#ifdef SERE_RTS_EXTERNAL
RS232_EXIO(SERE_RTS_PORT, SERE_RTS_SHADOW, (1<<SERE_RTS_BIT), (1<<SERE_RTS_BIT))
#else
RS232_HS(SERE_RTS_PORT, SERE_RTS_SHADOW, (1<<SERE_RTS_BIT), (1<<SERE_RTS_BIT))
#endif
#ifndef SER_DMA_DISABLE
   ld    a, (serEdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtsoff
   push	iy
   ld		iy, serEdata
   call  spx_dma_rtsoff
   pop	iy
.rtsoff:
#endif // ifndef SER_DMA_DISABLE
   ret

spe_rtson_fc::
#ifndef SER_DMA_DISABLE
   ; only execute this code if we are using DMA
   ld    a, (serEdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtson

   push	iy
   ld		iy, serEdata
   call	spx_dma_rtson
   pop	iy
.rtson:
#endif // ifndef SER_DMA_DISABLE
// set RTS low (active)
#ifdef SERE_RTS_EXTERNAL
RS232_EXIO(SERE_RTS_PORT, SERE_RTS_SHADOW, (1<<SERE_RTS_BIT), 0)
#else
RS232_HS(SERE_RTS_PORT, SERE_RTS_SHADOW, (1<<SERE_RTS_BIT), 0)
#endif
   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serEflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serEflowcontrolOn(void);

DESCRIPTION:   Turns on hardware flow control for channel E. This enables two
   				digital lines that handle flow control, CTS(clear to send)
   				and RTS(ready to send).
   				CTS is an input that will be pulled active low by the other
   				system when it is ready to receive data. The RTS signal
   				is an output that the system uses to indicate that it is
   				ready to receive data. It is driven low when data can be
   				received.
   				If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERE_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERE_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERE_RTS_BIT - the bit number for the RTS line
					SERE_RTS_EXTERNAL - Define if the RTS signal is hosted on
						external I/O instead of a direct processor port.

 					SERE_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERE_CTS_BIT - the bit number for the CTS line
					SERE_CTS_EXTERNAL - Define if the CTS signal is hosted on
						external I/O instead of a direct processor port.

               Important Note:
               ---------------
               The DMA options supports flow control, but the ports and pins
               for CTS are limited to the following:

               PD2, PD3, PE2, PE3, PE6, PE7.

               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  One
               can use PD2, PE2, or PE6, and the other can use PD3, PE3 or PE7.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void serEflowcontrolOn(void)
{
   //set flow control ISR functions
#ifndef SER_DMA_ONLY
   serEdata.xCheckCTS = spe_checkcts_fc;
#endif
   serEdata.xRTSoff = spe_rtsoff_fc;
   serEdata.xRTSon = spe_rtson_fc;

	_serXflow_enable( &serEdata,	SERE_RTS_PORT, SERE_RTS_BIT,
											SERE_CTS_PORT, SERE_CTS_BIT);
}

//************************************************************************
//****************************** PORT F **********************************
//************************************************************************



/*** Beginheader serFopen, serFtxBreak, serFclose */
int  serFopen(long baud);
int  serFtxBreak(int type);
void serFclose(void);

void spf_init(void);
__root void fDisable(void);
__root void fEnable(void);
extern serXdata serFdata;
/*** Endheader */

// SERIAL PORT F TX and RX PIN AND PORT SETUP
#ifndef FDRIVE_TXD
   #define FDRIVE_TXD 2
#endif

#ifndef FDRIVE_RXD
   #define FDRIVE_RXD 3
#endif

#ifndef SERF_TXPORT
   #define SERF_TXPORT PCDR
#endif

#ifndef SERF_RXPORT
   #define SERF_RXPORT PCDR
#endif

#if SERF_TXPORT == PEDR
   #define SPF_TX PE
#elif SERF_TXPORT == PDDR
   #define SPF_TX PD
#else
   #define SPF_TX PC
#endif

// Port Verification
#if SERF_TXPORT != PCDR && SERF_TXPORT != PDDR && SERF_TXPORT != PEDR
	#fatal "SERF_TXPORT must be PCDR, PDDR or PEDR"
#endif
#if SERF_RXPORT != PCDR && SERF_RXPORT != PDDR && SERF_RXPORT != PEDR
	#fatal "SERF_RXPORT must be PCDR, PDDR or PEDR"
#endif
// End Verification

// Alternate output register
#define SERF_TX_ALTREG     CONCAT(SPF_TX, ALR)
#define SERF_TX_ALTShadow  CONCAT(SPF_TX, ALRShadow)
#define FDRIVE_ALT         0x30

#define SERF_TX_PxDR				CONCAT(SPF_TX, DR)
#define SERF_TX_PxFR				CONCAT(SPF_TX, FR)
#define SERF_TX_PxDRShadow		CONCAT(SPF_TX, DRShadow)
#define SERF_TX_PxFRShadow		CONCAT(SPF_TX, FRShadow)

// There is no PCDDRShadow
#define SERF_TX_PxDDR			CONCAT(SPF_TX, DDR)
#define SERF_TX_PxDDRShadow	CONCAT(SPF_TX, DDRShadow)
// PDDCRShadow and PGDCRShadow are the only DCR Shadows
#define SERF_TX_PxDCR			CONCAT(SPF_TX, DCR)
#define SERF_TX_PxDCRShadow	CONCAT(SPF_TX, DCRShadow)

#undef  FINBUFOK
#ifndef FINBUFSIZE
	#define FINBUFSIZE 31
	#warnt "FINBUFSIZE undefined, defaulting to 31"
#endif

#if (FINBUFSIZE & (FINBUFSIZE+1)) == 0
	#define FINBUFOK 1
#endif

#ifndef FINBUFOK
	#undef  FINBUFSIZE
	#define FINBUFSIZE 31
	#warnt "FINBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

#undef  FOUTBUFOK
#ifndef FOUTBUFSIZE
	#define FOUTBUFSIZE 31
	#warnt "FOUTBUFSIZE undefined, defaulting to 31"
#endif

#if (FOUTBUFSIZE & (FOUTBUFSIZE+1)) == 0
	#define FOUTBUFOK 1
#endif

#ifndef FOUTBUFOK
	#undef  FOUTBUFSIZE
	#define FOUTBUFSIZE 31
	#warnt "FOUTBUFSIZE must be 2^n - 1 (1,3,7,15...), defaulting to 31"
#endif

char __far FINBUF[FINBUFSIZE+CBUF_OVERHEAD];
char __far FOUTBUF[FOUTBUFSIZE+CBUF_OVERHEAD];
serXdata serFdata;

#ifndef SER_DMA_DISABLE
#ifdef SER_NO_FLOWCONTROL
DMABufDesc serFrxbd[1];							// only one buffer descriptor
#else
DMABufDesc serFrxbd[SER_DMA_DIVISIONS];	// one buffer descriptor for each div
void spf_rx_isr(void);
#endif
DMABufDesc serFtxbd[2];							// TX Ping-Pong buffers
void spf_tx_isr(void);
#endif

/* START FUNCTION DESCRIPTION ********************************************
serFopen                      <RS232.LIB>

SYNTAX:
   int serFopen(long baud);

DESCRIPTION:
   Opens the F serial port.  To use DMA for transfers, call serFdmaOn
   after calling this function.  serFopen is non-reentrant.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

RETURN VALUE:
   1 - The Rabbit's bps setting is within 5% of the input baud.
   0 - The Rabbit's bps setting differs by more than 5% of the input baud.

RELATED WORDS:
   serFgetc, serFread, serFpeek, serFputs, serFwrite, cof_serFgetc,
   cof_serFgets, cof_serFread, cof_serFputc, cof_serFputs, cof_serFwrite,
   serFclose

MACRO INFO:
   If either or both of RS232_NOCHARASSYINBRK or RS232_NOCHARASSYINBRK_F
   are defined then asynchronous character assembly is disabled during
   an RS-232 line break condition. Defining either of these macros may
   be appropriate for an application which has no need of asynchronous
   line break recognition, especially where a disconnected or non-driven
   RXF input is possible. Note that RS232_NOCHARASSYINBRK affects all
   RS232.LIB serial ports but RS232_NOCHARASSYINBRK_F affects only
   serial port F.

   If SPF_USE_TIMERA is defined, Port F uses Timer A3.  Otherwise, it will
   use the dedicated timer for SPF

   Pin Layout:
   	TX pins: PC2 (Default), PD2, PE2
      RX pins: PC3 (Default), PD3, PE3

   The user must define the following if not using the default settings:

  *FDRIVE_TXD  // Defaults to 2
 **FDRIVE_RXD  // Defaults to 3
   SERF_TXPORT // Defaults to PCDR
   SERF_RXPORT // Defaults to PCDR
   FINBUFSIZE  // Defaults to 31
   FOUTBUFSIZE // Defaults to 31

   Note:
   ----
  *FDRIVE_TXD is always 2.
 **FDRIVE_RXD is always 3.

END DESCRIPTION **********************************************************/
_rs232_debug
int serFopen(long baud)
{
   auto long actual_bps;

#ifndef SER_DMA_DISABLE
   #GLOBAL_INIT { serFdata.dma_flags = 0; }
   // turn off the DMA if the serial port was previously open
   if(serFdata.dma_flags)
   	serFdmaOff();
   serFdata.dma_rx_bd = serFrxbd;
   serFdata.dma_tx_bd = serFtxbd;
   serFdata.xDMAisrTX = spf_tx_isr;
#ifndef SER_NO_FLOWCONTROL
   serFdata.xDMAisrRX = spf_rx_isr;
   serFdata.dma_divsize = (FINBUFSIZE + 1) / SER_DMA_DIVISIONS;
#else
   serFdata.dma_divsize = FINBUFSIZE + 1;
#endif
#endif // ifndef SER_DMA_DISABLE

   // set sxd pointer to our global structure.
   sxd[SER_PORT_F] = &serFdata;

   // The following values are needed by the generic serXfunctions.
   serFdata.sxdr = SFDR;
   serFdata.sxcrshadow = &SFCRShadow;

#ifndef SER_DMA_ONLY
   serFdata.xdrive_txd = 1 << FDRIVE_TXD;
   serFdata.pxfrshadow = &SERF_TX_PxFRShadow;
#endif // ifndef SER_DMA_ONLY

#ifdef SER_FLAG_LINEBREAK
   serFdata.isLineBreak = 0;
#endif

   serFdata.xEnable = fEnable;
   serFdata.xDisable = fDisable;

	_serXopen_common_init( &serFdata, FINBUF, FINBUFSIZE, FOUTBUF, FOUTBUFSIZE);

#if defined RS232_NOCHARASSYINBRK || defined RS232_NOCHARASSYINBRK_F
	// Board has no pull-up on serial Rx line and application has possibility of
	//  disconnected or non-driven Rx line.
	// Application has no need of asynchronous line break recognition and has
	//  chosen to disable character assembly during line break condition to
	//  prevent possible spurious line break interrupts.
	WrPortI(SFER, &SFERShadow, 0x02 | RdPortI(SFER));
#endif

#ifndef SPF_USE_TIMERA
	actual_bps = serXsetDividers( baud, SFDHR, SFDLR);
#else
	actual_bps = SetSerialTATxRValues( baud, NULL, TAT3R);
#endif

   spf_init();

   return _serXopen_common_ret( &serFdata, baud, actual_bps);
}

// spf_rx_isr
//
//	This isr is for DMA flowcontrol use only. Whenever a DMA receive action
// ends, an interrupt is performed to sync the circular buffer and check to see
// if the buffer is full.

#ifndef SER_DMA_DISABLE
#ifndef SER_NO_FLOWCONTROL
#asm __root
spf_rx_isr::
	push	ix
	ld		ix, serFdata
	jp		spx_dma_rx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_NO_FLOWCONTROL

// spf_tx_isr
//
//	This isr is for DMA use only.  This isr occurs after a DMA transfer finishes
// At that point, if there is more data to send, it is sent immediately.

#asm __root
spf_tx_isr::
	push	ix
	ld		ix, serFdata
	jp		spx_dma_tx_isr			; jump to common code, passing serXdata in IX
#endasm
#endif // ifndef SER_DMA_DISABLE

#asm __root
// interrupt routine to be copied into interrupt table
spfisr_start::   			; pass serFdata and SFDR to the isr
#ifndef SER_DMA_ONLY
   push	ix						; 2 bytes
   push	iy						; 2 bytes
   ld		ix, serFdata		; 4 bytes
   ld		iy, SFDR				; 4 bytes
   jp		spx_isr				; 3 bytes = 15 bytes total (fits in 16 bytes max)
#else
   ret
#endif

#endasm

#asm __xmem
spf_init::
   ld		de, INTVEC_BASE + SERF_OFS
   ld		hl, spfisr_start
   ld		bc, 16     ; copy 16 bytes from spfisr_start into interrupt table
   ipset RS232_INT_LEVEL

   #if __SEPARATE_INST_DATA__
      call inst2data_ldir
   #else
      ldir
   #endif

// Tx should initially be idle high
RS232_IO(SERF_TX_PxDR, SERF_TX_PxDRShadow, (1<<FDRIVE_TXD), (1<<FDRIVE_TXD))
RS232_IO(SERF_TX_PxFR, SERF_TX_PxFRShadow, (1<<FDRIVE_TXD), (1<<FDRIVE_TXD))
#ifdef SERF_TX_ALTREG // enable alternate output
RS232_IO(SERF_TX_ALTREG, SERF_TX_ALTShadow, FDRIVE_ALT, FDRIVE_ALT)
#endif
#ifdef SERF_TX_PxDCR // enable push-pull instead of open-drain.
RS232_IO(SERF_TX_PxDCR, SERF_TX_PxDCRShadow, (1<<FDRIVE_TXD), 0)
#endif
#ifdef SERF_TX_PxDDR
RS232_IO(SERF_TX_PxDDR, SERF_TX_PxDDRShadow, (1<<FDRIVE_TXD), (1<<FDRIVE_TXD))
#endif

#if SERF_RXPORT == PEDR
		ld    a, _cexpr(0x20 | RS232_INT_LEVEL)
#elif SERF_RXPORT == PDDR
		ld    a, _cexpr(0x10 | RS232_INT_LEVEL)
#else // PGDR or PCDR
		ld    a, _cexpr(0x00 | RS232_INT_LEVEL)
#endif

#ifdef SER_DMA_ONLY
	   and	0xFC
#endif

		ld    (SFCRShadow),a
ioi	ld		(SFCR), a      ; enable interrupts and select rx port.
		ipres
		lret

#endasm

#asm __root
fDisable:: // make sure Tx is high(idle)
RS232_IO(SERF_TX_PxDR, SERF_TX_PxDRShadow, (1<<FDRIVE_TXD), (1<<FDRIVE_TXD))
RS232_IO(SERF_TX_PxFR, SERF_TX_PxFRShadow, (1<<FDRIVE_TXD), 0)
	   ret

fEnable::
RS232_IO(SERF_TX_PxFR, SERF_TX_PxFRShadow, (1<<FDRIVE_TXD), (1<<FDRIVE_TXD))
	   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serFtxBreak                                                    <RS232.LIB>

SYNTAX:			int serFtxBreak( int type);

DESCRIPTION:	Generate a serial "break" by disabling the transmit pin for
					serial port F and pulling it low.

PARAMETER 1:   If 0, hold the break until another function sends data or
					calls serFopen.

					If 1, generate a character break (hold the break condition
					for the time it would take to send a single character) and
					then return the transmit pin to its idle state (high).

RETURN VALUE:	0 if able to generate the break
					-EIO if the serial port is not idle (i.e., sending bytes)
					-EINVAL if <type> is a value other than 0 or 1

END DESCRIPTION **********************************************************/
_rs232_debug
int serFtxBreak( int type)
{
	if (BitRdPortI( SFSR, 2))
	{
		// can't generate break if we're sending a byte
		return -EIO;
	}
	if (type < 0 || type > 1)
	{
		return -EINVAL;
	}

	// Set TX pin low, then change the function register to "normal output"
	BitWrPortI( SERF_TX_PxDR, &SERF_TX_PxDRShadow, 0, FDRIVE_TXD);
	BitWrPortI( SERF_TX_PxFR, &SERF_TX_PxFRShadow, 0, FDRIVE_TXD);

	if (type == 1)
	{
		// character break -- load dummy byte so ISR will end the break
		WrPortI( SFDR, NULL, 0);
	}

	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
serFclose                   <RS232.LIB>

SYNTAX:		   void serFclose(void);

DESCRIPTION:   Disables serial port F. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	1

END DESCRIPTION **********************************************************/

#asm __xmem
serFclose::
	   ld 	a, 0xC9 // RET
	   ipset RS232_INT_LEVEL
	   ld		(INTVEC_BASE + SERF_OFS), a	; ret in first byte of spfisr_start
	   xor   a
	   ld    (SFCRShadow), a					; disable interrupts for port
ioi	ld		(SFCR), a

#ifdef SPF_USE_TIMERA
      c TAT1R_SetValue( TAT1R_A3TIMER_REQ, TAT1R_RELEASE_REQ);
#endif
// return to normal output
RS232_IO(SERF_TX_PxFR, SERF_TX_PxFRShadow, (1<<FDRIVE_TXD), 0)
	   ipres
	   lret
#endasm

/*** BeginHeader serFflowcontrolOn */
void serFflowcontrolOn(void);
/*** EndHeader */

#ifdef SER_NO_FLOWCONTROL
	#fatal "Can't use serFflowcontrolOn if SER_NO_FLOWCONTROL has been defined."
#endif

//defaults for flow control RTS/CTS
#ifndef SERF_RTS_PORT
	#if SERF_TXPORT == PCDR
		#fatal "Can't default SERF_RTS_PORT to PC2, already used for TxF."
	#else
		#define SERF_RTS_PORT PCDR
		#warnt "SERF_RTS_PORT not defined: defaulting to PCDR"
	#endif
#endif

#ifndef SERF_RTS_SHADOW
	#define SERF_RTS_SHADOW PCDRShadow
	#warnt "SERF_RTS_SHADOW not defined: defaulting to PCDRShadow"
#endif

#ifndef SERF_RTS_BIT
	#define SERF_RTS_BIT 2
	#warnt "SERF_RTS_BIT not defined: defaulting to 2"
#endif

#ifndef SERF_CTS_PORT
	#if SERF_RXPORT == PCDR
		#fatal "Can't default SERF_CTS_PORT to PC3, already used for RxF."
	#else
		#define SERF_CTS_PORT PCDR
		#warnt "SERF_CTS_PORT not defined: defaulting to PCDR"
	#endif
#endif

#ifndef SERF_CTS_BIT
	#define SERF_CTS_BIT 3
	#warnt "SERF_CTS_BIT not defined: defaulting to 3"
#endif

int spf_checkcts_fc();
void spf_rtsoff_fc();
void spf_rtson_fc();

#asm __root
#ifndef SER_DMA_ONLY
spf_checkcts_fc::
   bool 	hl
   #ifdef SERF_CTS_EXTERNAL
		ioe ld	a, (SERF_CTS_PORT)
	#else
		ioi ld	a, (SERF_CTS_PORT)
	#endif
   and  	1 << SERF_CTS_BIT
   ld   	L, a
   ret
#endif

spf_rtsoff_fc::
// set RTS high (inactive)
#ifdef SERF_RTS_EXTERNAL
RS232_EXIO(SERF_RTS_PORT, SERF_RTS_SHADOW, (1<<SERF_RTS_BIT), (1<<SERF_RTS_BIT))
#else
RS232_HS(SERF_RTS_PORT, SERF_RTS_SHADOW, (1<<SERF_RTS_BIT), (1<<SERF_RTS_BIT))
#endif
#ifndef SER_DMA_DISABLE
   ld    a, (serFdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtsoff
   push	iy
   ld		iy, serFdata
   call  spx_dma_rtsoff
   pop	iy
.rtsoff:
#endif // ifndef SER_DMA_DISABLE
   ret

spf_rtson_fc::
#ifndef SER_DMA_DISABLE
   ; only execute this code if we are using DMA
   ld    a, (serFdata+_sxd+dma_flags)
   and   SER_DMA_ON
   jr    z, .rtson

   push	iy
   ld		iy, serFdata
   call	spx_dma_rtson
   pop	iy
.rtson:
#endif // ifndef SER_DMA_DISABLE
// set RTS low (active)
#ifdef SERF_RTS_EXTERNAL
RS232_EXIO(SERF_RTS_PORT, SERF_RTS_SHADOW, (1<<SERF_RTS_BIT), 0)
#else
RS232_HS(SERF_RTS_PORT, SERF_RTS_SHADOW, (1<<SERF_RTS_BIT), 0)
#endif
   ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
serFflowcontrolOn                   <RS232.LIB>

SYNTAX:		   void serFflowcontrolOn(void);

DESCRIPTION:   Turns on hardware flow control for channel F. This enables two
   				digital lines that handle flow control, CTS(clear to send)
   				and RTS(ready to send).
   				CTS is an input that will be pulled active low by the other
   				system when it is ready to receive data. The RTS signal
   				is an output that the system uses to indicate that it is
   				ready to receive data. It is driven low when data can be
   				received.
   				If pins for the flow control lines are not expicitly defined,
 					defaults will be used and compiler warnings will be issued.
 					The locations of the flow control lines are specified using
 					a set of 5 macros.  This function is non-reentrant.

 					SERF_RTS_PORT - the name of the data register for the
 						parallel port that the RTS	line is on. e.g. PCDR
 					SERF_RTS_SHADOW - the name of the shadow register for the
 						RTS line's parallel port. e.g. PCDRShadow
 					SERF_RTS_BIT - the bit number for the RTS line
					SERF_RTS_EXTERNAL - Define if the RTS signal is hosted on
						external I/O instead of a direct processor port.

 					SERF_CTS_PORT - the name of the data register for the
 						parallel port that the CTS line is on
 					SERF_CTS_BIT - the bit number for the CTS line
					SERF_CTS_EXTERNAL - Define if the CTS signal is hosted on
						external I/O instead of a direct processor port.

               Important Note:
               ---------------
               The DMA options supports flow control, but the ports and pins
               for CTS are limited to the following:

               PD2, PD3, PE2, PE3, PE6, PE7.

               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  One
               can use PD2, PE2, or PE6, and the other can use PD3, PE3 or PE7.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void serFflowcontrolOn(void)
{
   //set flow control ISR functions
#ifndef SER_DMA_ONLY
   serFdata.xCheckCTS = spf_checkcts_fc;
#endif
   serFdata.xRTSoff = spf_rtsoff_fc;
   serFdata.xRTSon = spf_rtson_fc;

	_serXflow_enable( &serFdata,	SERF_RTS_PORT, SERF_RTS_BIT,
											SERF_CTS_PORT, SERF_CTS_BIT);
}

//************************************************************************
//****************************** PORT X **********************************
//************************************************************************

/*** BeginHeader spx_dma_rtson, spx_dma_rtsoff */
#ifndef SER_DMA_DISABLE
void spx_dma_rtson(void);
void spx_dma_rtsoff(void);
#endif
/*** EndHeader */

#asm __root
// This function is for internal use only. It makes the current transfer the
// last.  This prevents too much received data from overwritting the buffer.

// iy should equal serXdata
// uses af, hl, iy
#ifndef SER_DMA_DISABLE
spx_dma_rtsoff::
		ld		a, (iy+_sxd+dma_flags)
		ld		L, a
		or		SER_DMA_STOP
		cp		L
		jr		z, .rtsoff						; DMA_STOP flag already set

		ld		(iy+_sxd+dma_flags), a
		// write to control register - DMA_LAST_DESC
		ld		a, (iy+_sxd+dma_ihandle)
		ld		hl, D0CR							; default to DMA channels 0-7 basis
 #if CPU_ID_MASK(_CPU_ID_) >= R6000
		cp		8									; is channel < 8?
		jr		c, .is_ch0to7a					; if yes (Carry set), keep default basis

		ld		hl, D8CR							; switch to DMA channels 8-15 basis
		and	0x07								; make index within channels 8-15 block
.is_ch0to7a:
 #endif
		sla a $ sla a $ sla a $ sla a
		add	a, L
		ld		L, a
ioi	ld		a, (hl)
		or		DMA_LAST_DESC					; fix DxCR so we are the last descriptor
ioi	ld		(hl), a
.rtsoff:
		ret
#endif // ifndef SER_DMA_DISABLE

// This is an internal-use function only. It re-enables DMA for the RX channel.

// iy should equal serXdata
// uses af, hl, iy
#ifndef SER_DMA_DISABLE
spx_dma_rtson::
		ld		a, (iy+_sxd+dma_flags)
		ld		L, a
		and	~SER_DMA_STOP					; clear STOP flag
		cp		L
		jr		z, .rtson						; DMA_STOP flag was not set

		ld		(iy+_sxd+dma_flags), a
		ld		a, (iy+_sxd+dma_ihandle)	; assumes valid handle
		ld		hl, D0CR							; default to DMA channels 0-7 basis
 #if CPU_ID_MASK(_CPU_ID_) >= R6000
		cp		8									; is channel < 8?
		jr		c, .is_ch0to7b					; if yes (Carry set), keep default basis

		ld		hl, D8CR							; switch to DMA channels 8-15 basis
		and	0x07								; make index within channels 8-15 block
.is_ch0to7b:
 #endif
		sla a $ sla a $ sla a $ sla a
		add	a, L
		ld		L, a
ioi	ld		a, (hl)
		and	~DMA_LAST_DESC					; fix DxCR so we aren't the last descr.
ioi	ld		(hl), a
		; change a number into a mask (1 << x)
		ld		a, (iy+_sxd+dma_ihandle)	; assumes valid handle
		and	0x0F								; restrict channel number to 0-15 range
		inc	a									; convert channel number into loop count
		clr	hl									; initially, reset all DMA channel bits
		scf										; set Carry flag (for rotation into HL)
.loopon:
		rl		hl									; rotate DMA channel bit up one place
		dec	a									; DMA channel bit placement done?
		jr		nz, .loopon						; if no (Zero reset), go loop again

 #if CPU_ID_MASK(_CPU_ID_) >= R6000
ioi	ld		(DMCSLR), hl					; start or restart DMA
 #else
		ld		a, L
ioi	ld		(DMCSR), a						; start or restart DMA
 #endif
.rtson:
		ret
#endif // ifndef SER_DMA_DISABLE
#endasm

/*** BeginHeader _serXdmaOn */
#ifndef SER_DMA_DISABLE
int _serXdmaOn(serXdata *port, int tcmask, int rcmask);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
serXdmaOn							<RS232.LIB>

SYNTAX:        int serXdmaOn(int port, int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serXopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
					any available channel.
PARAMETER3:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
					any available channel.

RETURN VALUE:	DMA error code or 0 for success.

END DESCRIPTION **********************************************************/

#ifndef SER_DMA_DISABLE
_rs232_debug
int _serXdmaOn(serXdata *port, int tcmask, int rcmask)
{
   auto int rc, channel, i, flags, num_div, vector_index_offset;
   static int dummy;
   static DMABufDesc dummyBD;
#ifdef SER_NO_FLOWCONTROL
   static dma_addr_t bufPtr[1], dummyPtr;
#else
   static dma_addr_t bufPtr[SER_DMA_DIVISIONS], dummyPtr;
#endif

#ifndef SER_DMA_ONLY
   // turn off serial interrupts
  	WrPortI(port->sxdr+SxCR_OFS, port->sxcrshadow, *(port->sxcrshadow) & 0xFC);
#endif

	// SJH: Use priority 2, regardless of library's priority level.
   rc = DMAsetParameters( 2, 2, DMA_IDP_FIXED, 32, 0);

#if defined DMAETH_RXCHAN && defined DMAETH_TXCHAN
	#define _SER_DMA_ETH_MASK ((1 << DMAETH_RXCHAN) | (1 << DMAETH_TXCHAN))
#elif defined DMAETH100_RXCHAN && defined DMAETH100_TXCHAN
	#define _SER_DMA_ETH_MASK ((1 << DMAETH100_RXCHAN) | (1 << DMAETH100_TXCHAN))
#endif
#if defined _SER_DMA_ETH_MASK
   // ensure we don't use the ethernet channels.
   tcmask = tcmask & (DMA_CHANNEL_ANY & ~_SER_DMA_ETH_MASK);
   rcmask = rcmask & (DMA_CHANNEL_ANY & ~_SER_DMA_ETH_MASK);
#endif

   port->dma_flags = SER_DMA_ON;

   // RECEIVE SETUP
   port->dma_ihandle = DMAalloc(rcmask, 0);
   channel = DMAhandle2chan(port->dma_ihandle);
   if(channel == DMA_CHANNEL_NONE) {
      return -EINVAL;
   }

#ifdef SER_NO_FLOWCONTROL
   flags = DMA_SRC_IOI | DMA_DEST_MEM | DMA_LINK_DESC;
   num_div = 1;
#else
   flags = DMA_SRC_IOI | DMA_DEST_MEM | DMA_LINK_DESC | DMA_F_INTERRUPT;

 #if CPU_ID_MASK(_CPU_ID_) >= R6000
   // Rabbit 6000+:
   //  - DMA channels 0-7 are located in a block starting at offset 0x80 (index
   //    0x08) in the external interrupt vectors table.
   //  - DMA channels 8-15 are located in a block starting at offset 0x180
   //    (index 0x18, or 0x10+channel) in the external interrupt vectors table.
   vector_index_offset = (8 > channel) ? 0x08 : 0x10;
 #else
   // Rabbit 4000, 5000:
   //  - DMA channels 0-7 are located in a block starting at offset 0x80 (index
   //    0x08) in the external interrupt vectors table.
   vector_index_offset = 0x08;
 #endif

   if (!SetVectExtern(vector_index_offset + channel, port->xDMAisrRX))
   {
      return -EINVAL;
   }
   num_div = SER_DMA_DIVISIONS;
#endif

   for(i = 0; i < num_div; i++) {
   	bufPtr[i] = paddr(&(port->dma_rx_bd[i]));
   }
   dummyPtr = paddr(&dummyBD);

   // Set dummy buffer descriptor to allow polling
   rc = DMAsetBufDesc(DMA_SRC_MEM | DMA_DEST_MEM | DMA_LINK_DESC, 1,
        paddr(&dummy), paddr(&dummy), bufPtr[0], dummyPtr, 16);
   if(rc) {
      return rc;
   }

   // Set real buffer descriptors
   for(i = 0; i < num_div; i++) {
      rc = DMAsetBufDesc(flags, port->dma_divsize, port->sxdr,
      	  (long) paddr_far (port->inbuf->buffer)
      	  + (port->ibufsize * i) / num_div,
           bufPtr[(i + 1) % num_div], bufPtr[i], 16);
      if(rc) {
   	   return rc;
      }
   }

   DMAloadBufDesc(channel, &dummyPtr);
   DMAstartAuto(channel);
   // Clear out the channel, in case there were any odd bits received prior
   // to enabling DMA.
	#ifndef SER_DMA_DISABLE
      if(port->dma_flags & SER_DMA_ON) {
         while(ser_bufUpdate(port));
 	   }
	#endif // ifndef SER_DMA_DISABLE
 	while(_serXgetc(port) >= 0);


   // TRANSMIT SETUP
   port->dma_len = 0;
   port->dma_pos = 0;
   port->dma_ohandle = DMAalloc(tcmask, 1);
   channel = DMAhandle2chan(port->dma_ohandle);
   if(channel == DMA_CHANNEL_NONE) {
      return -EINVAL;
   }

   // one-time setup.  These do not need to be rewritten for each transfer.
   // The other settings will be written in spx_dma_start
   port->dma_tx_bd[0].destAddress = port->sxdr;
   port->dma_tx_bd[0].linkAddress = paddr(&(port->dma_tx_bd[1]));
   port->dma_tx_bd[1].destAddress = port->sxdr;

#if CPU_ID_MASK(_CPU_ID_) >= R6000
   // Rabbit 6000+:
   //  - DMA channels 0-7 are located in a block starting at offset 0x80 (index
   //    0x08) in the external interrupt vectors table.
   //  - DMA channels 8-15 are located in a block starting at offset 0x180
   //    (index 0x18, or 0x10+channel) in the external interrupt vectors table.
   vector_index_offset = (8 > channel) ? 0x08 : 0x10;
#else
   // Rabbit 4000, 5000:
   //  - DMA channels 0-7 are located in a block starting at offset 0x80 (index
   //    0x08) in the external interrupt vectors table.
   vector_index_offset = 0x08;
#endif

   if (!SetVectExtern(vector_index_offset + channel, port->xDMAisrTX))
   {
      return -EINVAL;
   }
   return rc;
}
#endif // ifndef SER_DMA_DISABLE

/*** BeginHeader _serXdmaOff */
#ifndef SER_DMA_DISABLE
int _serXdmaOff(serXdata *port);
#endif
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXdmaOff							<RS232.LIB>

SYNTAX:			int serXdmaOff(int port);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupt capability.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serXdmaOn
END DESCRIPTION **********************************************************/

#ifndef SER_DMA_DISABLE
_rs232_debug
int _serXdmaOff(serXdata *port)
{
   auto int rc;
   rc = 0;
   if(port->dma_flags & SER_DMA_ON)
   {
   	rc = DMAstop(port->dma_ohandle);
      if(rc)
      	return rc;
   	rc = DMAunalloc(port->dma_ohandle);
      if(rc)
      	return rc;
   }

   if(port->dma_flags & SER_DMA_ON)
   {
   	rc = DMAstop(port->dma_ihandle);
      if(rc)
      	return rc;
   	rc = DMAunalloc(port->dma_ihandle);
      if(rc)
      	return rc;
   }

   port->dma_flags = 0;

   // re-enable serial interrupts
#ifndef SER_DMA_ONLY
  	WrPortI(port->sxdr+SxCR_OFS, port->sxcrshadow,
  													*(port->sxcrshadow) | RS232_INT_LEVEL);
#endif

   return 0;
}
#endif // ifndef SER_DMA_DISABLE

/*** BeginHeader spx_dma_start */
#ifndef SER_DMA_DISABLE
__root void spx_dma_start(serXdata *port);
#endif
/*** EndHeader */

#ifndef SER_DMA_DISABLE
_rs232_debug
__root void spx_dma_start(serXdata *port)
{
	static int channel;
	static DMABufDesc * bufdesc;
	static dma_addr_t bufptr;

 #ifndef SER_NO_FLOWCONTROL
	if (port->ser_flags & SER_FLAG_RTSCTS)
	{
		// setup external request (active low) for flow control
		if(port->dma_flags & SER_DMA_ODD)
		{
			WrPortI(DMR1CR, NULL, (port->dma_flags << 4 & 0xC0) |
			DMAhandle2chan(port->dma_ohandle) | 0x10);
		}
		else
		{
			WrPortI(DMR0CR, NULL, (port->dma_flags << 4 & 0xC0) |
			DMAhandle2chan(port->dma_ohandle) | 0x10);
		}
	}
 #endif

	if (port->dma_len <= port->obufsize - port->dma_pos)
	{
		// data fits into circular buffer without wrapping
		bufdesc = &(port->dma_tx_bd[0]);
		bufdesc->frameStatus = 0x00;	// enable R6K's automatic mode selection
		bufdesc->chanControl =
		             DMA_SRC_MEM | DMA_DEST_IOI | DMA_LAST_DESC | DMA_F_INTERRUPT;
		bufdesc->bufLength = port->dma_len;
		bufdesc->srcAddress =
		                   (long) paddr_far(port->outbuf->buffer + port->dma_pos);
	}
	else
	{
		// data must be wrapped - first, fill data to end of circular buffer
		bufdesc = &(port->dma_tx_bd[0]);
		bufdesc->frameStatus = 0x00;	// enable R6K's automatic mode selection
		bufdesc->chanControl = DMA_SRC_MEM | DMA_DEST_IOI | DMA_LINK_DESC;
		bufdesc->bufLength = port->obufsize - port->dma_pos;
		bufdesc->srcAddress =
		                   (long) paddr_far(port->outbuf->buffer + port->dma_pos);

		// wrap around to front of circular buffer
		bufdesc = &(port->dma_tx_bd[1]);
		bufdesc->frameStatus = 0x00;	// enable R6K's automatic mode selection
		bufdesc->chanControl =
		             DMA_SRC_MEM | DMA_DEST_IOI | DMA_LAST_DESC | DMA_F_INTERRUPT;
		bufdesc->bufLength = (port->dma_pos + port->dma_len) % port->obufsize;
		bufdesc->srcAddress = (long) paddr_far(port->outbuf->buffer);
	}

	port->dma_pos = (port->dma_pos + port->dma_len) % port->obufsize;
	port->dma_len = 0;
	RS232_ENTER_CRITICAL
	port->dma_flags |= SER_DMA_BUSY;
	RS232_EXIT_CRITICAL

	channel = DMAhandle2chan(port->dma_ohandle);
	bufptr = paddr(&(port->dma_tx_bd[0]));
	DMAloadBufDesc(channel, &bufptr);
	DMAstartAuto(channel);
}
#endif // ifndef SER_DMA_DISABLE

/*** BeginHeader serXsetDividers */
long serXsetDividers( long baud, int sxdhr, int sxdlr);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
serXsetDividers                                                   <RS232.LIB>

SYNTAX:
	long serXsetDividers( long baud, int sxdhr, int sxdlr)

DESCRIPTION:
   Sets the SxDHR and SxDLR registers for a given baud rate.

PARAMETER1:
   baud - Bits per second of serial data transfer speed.

PARAMETER2:
	sxdhr - Address of SxDHR register to set.

PARAMETER3:
	sxdlr - Address of SxDLR register to set.

RETURN VALUE:
   0 - Invalid baud rate requested (must be > 0)
	> 0 - exact baud rate for programmed divider registers

END DESCRIPTION **********************************************************/
_rs232_debug
long serXsetDividers( long baud, int sxdhr, int sxdlr)
{
	auto long divisor;

	// baud rate must be > 0
	if (baud <= 0)
	{
		return 0;
	}

   // the 19200 baud (w/ peripheral clock divided by 2) divider value is
   //  stored in the BIOS variable "freq_divider"
   divisor = (((long) freq_divider * 19200L * 2L) + ((baud + 1) >> 1)) / baud;

   // SxDxR register pair value is an N+1 divider, similar to TATxR,
   //  so we decrement the calculated divisor value before using it
   --divisor;

   // sanity check the N+1 divisor value to make sure we don't overflow
   //  or underflow the SADxR register pair's unsigned 15-bit divider limit
   if (0L > divisor)
   {
      divisor = 0L;  // prevent divisor from going negative
   }
   else if (0x7FFFL < divisor)
   {
      divisor = 0x7FFFL;   // restrict divisor to maximum 15-bits count
   }
   WrPortI( sxdlr, NULL, (char)divisor);
   WrPortI( sxdhr, NULL, (char)(divisor >> 8) | 0x80);

   // return the actual BPS rate we've achieved
   return (long) freq_divider * 19200L * 2L / (divisor + 1L);
}

/*** BeginHeader _serXopen_common_init, _serXopen_common_ret */
void _serXopen_common_init( serXdata *ser, char __far *in, int insize,
	char __far *out, int outsize);
int _serXopen_common_ret( serXdata *ser, long req_bps, long actual_bps);
/*** EndHeader */

// dummy function to use with unused function pointers
__root void spx_void_dummyfunc();
__root int spx_int_dummyfunc();
#asm __root
spx_int_dummyfunc::
	clr hl
spx_void_dummyfunc::
   ret
#endasm

// initialization code common to all serXopen functions
// private API will likely change in future release of Dynamic C
_rs232_debug
void _serXopen_common_init( serXdata *ser, char __far *in, int insize,
	char __far *out, int outsize)
{
	// Could potentially use xalloc here to create the in and out buffers
	// (once per run) instead of having buffers created at compile-time.

	// The ser->.bufsize values account for the existence of the circular
	//  buffers' data area separator byte.
	ser->ibufsize = insize + 1;
	ser->obufsize = outsize + 1;
	buffer_init( ser->inbuf = (cbuf_t __far *) in, insize);
	buffer_init( ser->outbuf = (cbuf_t __far *) out, outsize);

	//use the dummy versions of the flow control functions
   //all they do is return. They are placeholders in case flow control
   //enabled
#ifndef SER_NO_FLOWCONTROL
#ifndef SER_DMA_ONLY
   ser->xCheckCTS = spx_int_dummyfunc;
#endif
   ser->xRTSoff = spx_void_dummyfunc;
   ser->xRTSon = spx_void_dummyfunc;
   ser->rtsHi = 0;
   ser->rtsLo = 0;
#endif // ifndef SER_NO_FLOWCONTROL
   ser->ser_flags = 0;
}

// finish code common to all serXopen functions
_rs232_debug
int _serXopen_common_ret( serXdata *ser, long req_bps, long actual_bps)
{
   auto unsigned long t;
   auto unsigned long timeout;
   auto unsigned long baud_diff;

   // let baud timer time out before using port
   timeout = 10000ul / (unsigned long) (actual_bps ? actual_bps : 1L);
   t = MS_TIMER;
   while (MS_TIMER - t < timeout);

	// flush any characters read into the buffer
	buffer_flush( ser->inbuf);

   // now calculate the absolute difference between actual BPS and input baud
   baud_diff = labs( actual_bps - req_bps);
   // returns 1 if either an exact match or within 5% (baud:diff >= 20:1)
   // returns 0 otherwise
   return !baud_diff || (req_bps / baud_diff >= 20);
}

/*** BeginHeader _serXflow_enable */
// only called if SER_NO_FLOWCONTROL is not defined
void _serXflow_enable( serXdata *port, int rtsport, int rtsbit,
													int ctsport, int ctsbit);
/*** EndHeader */
// common code from serXflowcontrolOn functions
_rs232_debug
void _serXflow_enable( serXdata *port, int rtsport, int rtsbit,
													int ctsport, int ctsbit)
{
	auto int threshold;

   port->ser_flags |= SER_FLAG_RTSCTS;
	switch (rtsport) {
		case PBDR:
			// data direction register, output
			BitWrPortI (PBDDR, &PBDDRShadow, 1, rtsbit);
			// Port B does not have a drive control register (DCR) or
			// function register (FR) to set
			break;

		case PCDR:
			// data direction register, output
			BitWrPortI (PCDDR, &PCDDRShadow, 1, rtsbit);
			// drive control register, high/low (not open drain)
			BitWrPortI (PCDCR, &PCDCRShadow, 0, rtsbit);
			// function register, bit functions as I/O
			BitWrPortI (PCFR, &PCFRShadow, 0, rtsbit);
			break;

		case PDDR:
			// data direction register, output
			BitWrPortI (PDDDR, &PDDDRShadow, 1, rtsbit);
			// drive control register, high/low (not open drain)
			BitWrPortI (PDDCR, &PDDCRShadow, 0, rtsbit);
			// function register, bit functions as I/O
			BitWrPortI (PDFR, &PDFRShadow, 0, rtsbit);
			break;

		case PEDR:
			// data direction register, output
			BitWrPortI (PEDDR, &PEDDRShadow, 1, rtsbit);
			// drive control register, high/low (not open drain)
			BitWrPortI (PEDCR, &PEDCRShadow, 0, rtsbit);
			// function register, bit functions as I/O
			BitWrPortI (PEFR, &PEFRShadow, 0, rtsbit);
			break;

#ifdef NAPCR
		case NAPCR:
			// nothing to do, already an output
			break;
#endif

		default:
			// port we can't handle, don't do anything
	}

#ifndef SER_DMA_DISABLE
   if(port->dma_flags & SER_DMA_ON)
   {
   	// validate CTS (D2, D3, E2, E3, E6 or E7)
      port->dma_flags &= 0xF0;
      if (ctsbit & 1)
      {
      	port->dma_flags |= SER_DMA_ODD;
      }
      switch (ctsport)
      {
         case PEDR:
            if (ctsbit == 2 || ctsbit == 3)
            {
            	port->dma_flags |= SER_DMA_PPE23;
               break;
            }
            else if (ctsbit == 6 || ctsbit == 7)
            {
            	port->dma_flags |= SER_DMA_PPE67;
               break;
            }
            exception(-ERR_BADPARAMETER);
            return;
         case PDDR:
            if (ctsbit == 2 || ctsbit == 3)
            {
            	port->dma_flags |= SER_DMA_PPD23;
   				break;
            }
         default:
            exception(-ERR_BADPARAMETER);
            return;
      }
      port->rtsLo = port->inbuf->head / port->dma_divsize;		// head
      port->rtsHi = port->inbuf->tail / port->dma_divsize;		// tail

      if(port->rtsLo != port->rtsHi+1) {		// if head != tail+1
         port->xRTSon();
      } else {
         port->xRTSoff();
   	}
   	return;
   }
#endif // ifndef SER_DMA_DISABLE

#ifndef SER_DMA_ONLY
	// The previous method of setting thresholds used 80% to deassert and
	// 20% to reassert.  A technique that wasn't very efficient.  This new
	// technique uses 75% for deassert and 50% for reassert, with a maximum
	// of 16 bytes free on deassert and 32 bytes free on reassert.
	threshold = (int)(port->ibufsize >> 1);			// calculate 50% threshold
	if (threshold > 32)
	{
		threshold = 32;	// reassert RTS when there's room for at least 32 bytes
	}
   port->rtsLo = (int)(port->ibufsize - threshold);
   port->rtsHi = (int)(port->ibufsize - (threshold >> 1));

   // Assert RTS (we're accepting bytes) if we haven't hit rtsHi.
   if (_serXrdUsed( port) < port->rtsHi)
   {
      port->xRTSon();
   }
#endif
}

/*** BeginHeader _serXrts_update */
void _serXrts_update( serXdata *port);
#ifdef SER_NO_FLOWCONTROL
	// if no flow control, null out the serXrts_update() function
	#define serXrts_update(port)
#else
	#define serXrts_update(port)	_serXrts_update(port)
#endif
/*** EndHeader */
// common code from functions that read from the Rx buffer
_rs232_debug
void _serXrts_update( serXdata *port)
{
	if(port->ser_flags & SER_FLAG_RTSCTS)
	{
	   #ifndef SER_DMA_DISABLE
	      if(port->dma_flags & SER_DMA_ON)
	      {
	         // rtsLo = read position / division size
	         port->rtsLo = port->inbuf->head / port->dma_divsize;
	         if(port->rtsLo != ((port->rtsHi+1) % SER_DMA_DIVISIONS) &&
	            (port->dma_flags & SER_DMA_STOP))
	         {
	            RS232_ENTER_CRITICAL
	            port->xRTSon();
	            RS232_EXIT_CRITICAL
	         }
	         return;
	      }
	   #endif // ifndef SER_DMA_DISABLE
	   #ifndef SER_DMA_ONLY
	      if(buffer_used(port->inbuf) <= port->rtsLo)
	      {
	         port->xRTSon();
	      }
	   #endif // ifndef SER_DMA_ONLY
	}
}

/*** BeginHeader spx_starttx */
__root void spx_starttx(serXdata *port);
/*** EndHeader */
_rs232_debug
__root void spx_starttx(serXdata *port)
{
#asm _rs232_debug
; called by C put routines to start up interrupt loop if tx is idle
		push	ix
		push	iy
		ipset	RS232_INT_LEVEL

		ld		ix, hl					; ix points to serXdata
		ld		hl, (ix+_sxd+sxdr)	; hl is SxDR
		ld		iy, hl					; iy points to base register (SxDR)

ioi	bit	2, (iy+SxSR_OFS)
		jr	 	nz, .exit				; if tx is busy then ISR will fire

#ifndef SER_NO_FLOWCONTROL
		_READ_BIT_(SER_BIT_RTSCTS)
		jr	 	z, .load					; not using flow control, OK to send
		_CALL_(xCheckCTS)
		bool	hl
		jr		z, .load					; receiver says it's clear to send

		_CALL_(xDisable) 				; xDisable disables the transmitter pin
		jr		.send						; will send a dummy byte to kick-start ISR
#endif // SER_NO_FLOWCONTROL

.load:
		_CALL_(xEnable)				; xEnable enables the transmitter pin

		; calculate address of outbuf and pass to buffer_getch()
		ldl	px, ix
		ld		px, (px+_sxd+outbuf)
		;push	px
		lcall	buffer_getch			; buffer_getch() uses PX, doesn't require push
		;add	sp, 4
		bit   7, h           		; was there a character?
		jr		nz, .exit
											; will send byte from buffer_getch (in L)
.send:
		_READ_BIT_(SER_BIT_TWOSTOP)
		jr	 	z, .normal_stop
ioi	ld		(iy+SxLR_OFS), L			; send with an extra stop bit
		jr	 	.load_done

.normal_stop:
ioi	ld		(iy+SxDR_OFS), L			; normal send

.load_done:

.exit:
		ipres
		pop	iy
		pop	ix
#endasm
}

/*** BeginHeader spx_dma_rx_isr */
// Assembly ISR -- not C callable
/*** EndHeader */
#asm __root
; Common code for DMA Receive Interrupts.  Expects pointer to serXdata
; structure passed in IX.  Calling function should JUMP here instead of CALL.
spx_dma_rx_isr::
   push	af
   push	hl
   ld		hl, lxpc
   push	hl
   push	bcde
	push	px

   ld		a, (ix+_sxd+dma_flags)
   or		SER_DMA_ISR
   ld		(ix+_sxd+dma_flags), a

   ; increment tail pointer, and check RTSCTS flag
   ld		a, (ix+_sxd+rtsHi)
   inc	a								; tail = (tail + 1) % SER_DMA_DIVISIONS
   and   SER_DMA_DIVISIONS-1
   ld		(ix+_sxd+rtsHi), a
   inc	a
   and   SER_DMA_DIVISIONS-1
   ld		L, a

   ; if flowcontrol is off, we are done.
   _READ_BIT_(SER_BIT_RTSCTS)
   jr		z, .done

   ; Check to see if head == tail + 1.
   ld		a, (ix+_sxd+rtsLo)
   cp		L 								; L == rtsHi + 1
   jr		nz, .turnon					; ready to transmit

   ; they are equal, so call xRTSoff, and stop the DMA
.turnoff:
   _CALL_(xRTSoff)
   jr		.done

.turnon:
   ; only turn on if off in the first place
   ld		a, (ix+_sxd+dma_flags)
   and	SER_DMA_STOP
   jr		nz, .done

   ; only turn on if head != tail (assumes > 2 divisions)
   ld		a, (ix+_sxd+rtsLo)
   cp		(ix+_sxd+rtsHi)
   jr		z, .done

	_CALL_(xRTSon)

.done:
   ld		bcde, 0
   ld		e, (ix+_sxd+rtsHi)
   ld    hl, (ix+_sxd+dma_divsize)
   ld		bc, hl
   mul

	; save the updated tail
	ldl	px, ix
	ld		px, (px+_sxd+inbuf)
   ld		(px+[cbuf_t]+tail), bc

   pop	px
   pop	bcde
   pop	hl
   ld		lxpc, hl
   pop	hl
   pop	af
   pop	ix			; IX was pushed by ser[abcdef]_rx_isr before jumping here
   ipres
   ret
#endasm
/*** BeginHeader spx_dma_tx_isr */
// Assembly ISR -- not C callable
/*** EndHeader */
#asm __root
; Common code for DMA Transmit Interrupts.  Expects pointer to serXdata
; structure passed in IX.  Calling function should JUMP here instead of CALL.
spx_dma_tx_isr::
	   push  af
	   push  hl
	   push	px

	   ; clear busy flag
	   ld    a, (ix+_sxd+dma_flags)
	   and   ~SER_DMA_BUSY
	   ld    (ix+_sxd+dma_flags), a

	   ; update the circular buffer; copy dma_pos to circular buffer's head
	   ldl	px, ix
	   ld		px, (px+_sxd+outbuf)
	   ld    hl, (ix+_sxd+dma_pos)
	   ld		(px+[cbuf_t]+head), hl

.done:
	   pop	px
	   pop   hl
	   pop   af
	   pop	ix			; IX was pushed by ser[abcdef]_tx_isr before jumping here
	   ipres
	   ret
#endasm

/*** BeginHeader spx_isr */
// Assembly ISR -- not C callable
/*** EndHeader */

#asm __root
; common ISR for all serial ports, ix points to the serXdata structure
spx_isr::
		; the interrupt vector routine has already pushed IX & IY at this point
		push	af					; save registers needed by isr
		push	bcde
		push	hl
		ld		hl, lxpc
		push	hl

		; IX = serXdata, IY = SxDR
ioi	ld		a, (iy+SxSR_OFS)

#ifdef SER_FLAG_LINEBREAK
		ld		(ix+_sxd+sxsrcopy), a
#endif

		rla
		jp		c, spx_rx_isr

;;;;;		TX interrupt		;;;;;

spx_tx_isr:
		ld		b, (ix+_sxd+ser_flags)	; store copy of ser_flags in b

		bit	3, a							; Tx busy? (bit 2 of SxSR, shifted by RLA)
		jr		nz, .tx_busy

.tx_idle:             					; Tx idle, safe for en/disable transition

#ifndef SER_NO_FLOWCONTROL
		bit	SER_BIT_RTSCTS, b
		jr		z, .tx_enable
		_CALL_(xCheckCTS)
		bool	hl
		jr		z, .tx_enable				; CTS is on, we can start sending
.tx_disable:
		_CALL_(xDisable)
ioi	ld		(iy+SxDR_OFS), a			; load dummy byte into SxDR,
												; to keep the interrupt loop going
		jr		.tx_isr_done
#endif // SER_NO_FLOWCONTROL

.tx_enable:
		_CALL_(xEnable)
		jr		.tx_load

.tx_busy:
		; check to make sure tx is enabled
		; if not, dummy character still needs to clear out
		ld		a, (ix+_sxd+xdrive_txd)
		ld		hl, (ix+_sxd+pxfrshadow)
		and	(hl)
		jr		z, .tx_isr_done

#ifndef SER_NO_FLOWCONTROL
		bit	SER_BIT_RTSCTS, b        ; are we using CTS?
		jr		z, .tx_load
		_CALL_(xCheckCTS)
		bool	hl
		jr		nz, .tx_isr_done			; CTS is off, don't fill SxDR
#endif // SER_NO_FLOWCONTROL

.tx_load:
		push	px
		push	py

		; inlined call to spx_txload
		; calculate address of outbuf and pass to buffer_getch()
		ldl	px, ix
		ld		px, (px+_sxd+outbuf)

		; buffer_getch() optimized to use PX directly, doesn't require push
		; note that it does NOT modify BC, so it's safe to use B after the call
		lcall	buffer_getch

		bit   7, h           		; was there a character?
		jr		nz, .nobyte

.tx_sendbyte:
		bit	SER_BIT_TWOSTOP, b
		jr		z, .normal_stop
ioi	ld		(iy+SxLR_OFS), L			; send with an extra stop bit
		jr		.load_done

.normal_stop:
ioi	ld		(iy+SxDR_OFS), L			; normal send

.load_done:
.nobyte:
    	pop	py
    	pop	px

.tx_isr_done:
ioi	ld		(iy+SxSR_OFS), a     	; clear interrupt source (TX only)

		jr		.isr_exit

;;;;;		RX interrupt		;;;;;

spx_rx_isr:
		push	px
		push	py

		; spx_rx_isr requires specific bit positions for overrun and parity
		#if (SER_BIT_OVERRUN != 6) || (SER_BIT_PARITYERROR != 5)
			#fatal "Bad bits for ser_flags -- overrun != 6 or parity != 5"
		#endif

		; Register A contains SxSR shifted one bit to the left.  We can OR bits
		; 5 and 6 of A with ser_flags to set the PARITY and OVERRUN error bits.
		and	0x60
   	or 	(ix+_sxd+ser_flags)		; keep ser_flags in b for fast check/update
		ld		b, a							; b = ((SxSR << 1) & 0x60) | ser_flags

   	clr	hl
ioi	ld		l, (iy+SxDR_OFS)			; receive the character into HL

#ifdef SER_FLAG_LINEBREAK
		;; No need to preserve register A's content, it soon gets trashed by the
		;;  buffer_putch call in code below.
		ld		a, L
		or		a								; is Rx data a NUL character?
		jr		nz, .notLineBreak			; if no (Z reset) then not a line break

		ld		a, (ix+_sxd+sxsrcopy)
		bit	6, a							; is a framing error reported?
		jr		z, .notLineBreak			; if no (Z set) then not a line break

		ld		(ix+_sxd+isLineBreak), a	; bit 6 set guarantees flag is non-zero
		jr		.rx_isr_exit				; do not buffer any Rx NUL character during
												;  a line break
.notLineBreak:
#endif

		bit	SER_BIT_SEVENBIT, b
		jr		z, .rx_eightbit
		res	7, L							; mask out MSB for 7 bit data
		; (unfortunately, the Rabbit 4000 doesn't automatically mask out bit 7)
.rx_eightbit:
		push	hl
		ldl	px, ix							; px points to serXdata
		ld		px, (px+_sxd+inbuf)			; px is inbuf pointer
		push	px
		lcall	buffer_putch		; modifies AF, HL, DE & PY but not BC, IX, or PX
		add	sp, 6
		bool	hl
		jr		nz, .rx_no_overflow
		set	SER_BIT_OVERFLOW, b			; overflowed the receive buffer
.rx_no_overflow:
		bit	SER_BIT_RTSCTS, b				; set z flag for later compare
		ld		(ix+_sxd+ser_flags), b		; copy updated ser_flags back to serXdata
#ifndef SER_NO_FLOWCONTROL
		jr		z, .rx_isr_exit
		; inline buffer_used() from cbuf.lib
		ld		hl, (px+[cbuf_t]+tail)		; hl = tail
		ld		de, (px+[cbuf_t]+head)		; de = head
		sub	hl, de							; hl = tail - head
		ld		de, (px+[cbuf_t]+mask)
		and	hl, de							; hl = (tail - head) & mask
		; end of inlined code
		ld		de, hl							; de = number of bytes used
		ld		hl, (ix+_sxd+rtsHi)			; hl = rtsHi watermark (80% of full)
		cp		hl, de
		jr		nc, .rx_isr_exit				; nc flag set if buffer_used <= rtsHi
		_CALL_(xRTSoff)						; turn off the RTS line
#endif // SER_NO_FLOWCONTROL

.rx_isr_exit:		; exit point if px and py were pushed onto stack
		pop	py
		pop	px

.isr_exit:
		; restore registers used by isr
		pop	hl
		ld		lxpc, hl
		pop	hl
		pop	bcde
		pop	af
		pop	iy		; pushed by interrupt vector
		pop	ix		; pushed by interrupt vector
		ipres
		ret
#endasm

/*** Beginheader _serXgetError */
char _serXgetError(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXgetError                   <RS232.LIB>

SYNTAX:		   char serXgetError(int port);

DESCRIPTION:   Returns the error flags byte for serial channel X
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant for a given serial port.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

					Parity Error: Byte received with incorrect parity.
					Overrun Error: ISR unable to retrieve byte from serial register
							before next byte arrived.
					Overflow Error: Byte arrived when receive buffer was full.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	Error flags

END DESCRIPTION **********************************************************/

_rs232_debug
char _serXgetError(serXdata *port)
{
   auto char error_flags;

   error_flags = 0;
   if(port->ser_flags & SER_FLAG_OVERRUN)
   {
   	error_flags |= SER_OVERRUN_ERROR;
   	port->ser_flags &= ~SER_FLAG_OVERRUN;
   }
   if(port->ser_flags & SER_FLAG_PARITYERROR)
   {
   	error_flags |= SER_PARITY_ERROR;
   	port->ser_flags &= ~SER_FLAG_PARITYERROR;
   }
   if(port->ser_flags & SER_FLAG_OVERFLOW)
   {
   	error_flags |= SER_OVERFLOW_ERROR;
   	port->ser_flags &= ~SER_FLAG_OVERFLOW;
   }
   return error_flags;
}

/*** Beginheader ser_bufUpdate */
int ser_bufUpdate(serXdata *port);
/*** Endheader */

/*****************************************************************************\

   This function updates the inbuf tail location based on the value from
   the polled DMA. This should only be called internally.

   The ibuf circular buffer contains the head (ibuf[1]) and tail (ibuf[2]) of
   the unread data in the buffer.  The DMA transfers write to the end, but
   do not update the tail value until the end of each transfer.  This function
   updates that value by polling the DMA to see how far along it is.

   Example with SER_DMA_DIVISIONS = 4:
   The section from Y to X is unread data in the buffer.  Y represends ibuf[1],
   and X represents ibuf[2].  The current DMA transfer is from T to the end of
   the buffer (currently at X, according to the poll function), and the next
   read of cbuf will start at Y.  This function will update ibuf[2] so the read
   functions will know how much data is available.

   	Key:
      ----
      '-' represents empty buffer space
      '=' represents full buffer space
      H (head) = rtsLo = 2 (unused)
      T (tail) = rtsHi = 3
      P (poll) = poll value
      S (size) = divsize = bufsize / divisions
      Y = icbuf[1]
      X = icbuf[2] = S*T + (S-P) = S*(T+1) - P

            S                                 P
      |<-------->|          H          T  |<----->|
      |----------|----------|--Y=======|==X-------| = ibuf
      0          1          2          3          ^
                                                S*(T+1)

\*****************************************************************************/

_rs232_debug int ser_bufUpdate(serXdata *port)
{
   auto unsigned int dummy, X;

   RS232_ENTER_CRITICAL
   port->dma_flags &= ~SER_DMA_ISR;
   RS232_EXIT_CRITICAL

   // X = S*(T+1) - P
#ifndef SER_NO_FLOWCONTROL
   X = (port->dma_divsize) * (port->rtsHi + 1) -
      DMApoll(DMAhandle2chan(port->dma_ihandle), &dummy);
#else  // Only 1 division without flowcontrol
   X = port->dma_divsize - DMApoll(DMAhandle2chan(port->dma_ihandle), &dummy);
#endif

   if(!(port->dma_flags & SER_DMA_ISR)) {
      RS232_ENTER_CRITICAL
      port->inbuf->tail = X;
      RS232_EXIT_CRITICAL
      return 0;
   }

   return 1;
}

/*** Beginheader _serXgetc */
int _serXgetc(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXgetc                      <RS232.LIB>

SYNTAX:        int serXgetc(int port);

DESCRIPTION:   Get next available character from serial port X read
               buffer. This function is non-reentrant for a given serial port.

PARAMETER1:    The port number. Valid inputs are SER_PORT_A through
               SER_PORT_F. This function is defined (through macros) to
               use this value and select the appropriate serial port data
               structure.

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.
END DESCRIPTION *********************************************************/

_rs232_debug
int _serXgetc(serXdata *port)
{
   auto int n;
   auto cbuf_t __far *icbuf;

   icbuf = port->inbuf;

   if(buffer_rdlock(icbuf)) {
#ifndef SER_DMA_DISABLE
      if(port->dma_flags & SER_DMA_ON) {
         while(ser_bufUpdate(port));
 	   }
#endif // ifndef SER_DMA_DISABLE
      n = buffer_getch(icbuf);
      if (n >= 0)
      {
      	RS232_ECHO(port, (char *)&n, 1, "RX-");
      }
		serXrts_update(port);
      buffer_rdunlock(icbuf);
   }
   else {
      n = -1;
   }

   return n;
}


/*** Beginheader _serXread */
int _serXread(serXdata *port, void __far *dest, int length, unsigned long tmout);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXread                   <RS232.LIB>

SYNTAX: int serXread(int port, void far *dest, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, X, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant for a given
               serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    data  : data structure to read from serial port X
PARAMETER3:    length: number of bytes to read
PARAMETER4:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port X

END DESCRIPTION **********************************************************/

_rs232_debug
int _serXread(serXdata *port, void __far *dest, int length, unsigned long tmout)
{
   auto int  n, nread;
   auto char __far *p;
   auto cbuf_t __far *icbuf;
   auto unsigned long chtm;

   icbuf = port->inbuf;
   nread = 0;

   if (buffer_rdlock(icbuf))
   {
		p = (char __far *)dest;
      chtm = MS_TIMER;
      while (length > 0)
      {
#ifndef SER_DMA_DISABLE
         if (port->dma_flags & SER_DMA_ON)
         {
            while(ser_bufUpdate(port));
         }
#endif // ifndef SER_DMA_DISABLE

      	// once in, finish or timeout
      	n = buffer_get(icbuf, p, length);
         if (n > 0)
         {
				serXrts_update(port);
            nread += n;
				if ( ! tmout)
				{
					// optimize the common case of "read what's available and return"
					break;
				}
            p += n;
            length -= n;
            chtm = MS_TIMER;
         }
         else if (!nread || MS_TIMER - chtm >= tmout)
         {
         	// no bytes on first read, or timeout waiting for more bytes
         	break;
         }
      }
      buffer_rdunlock(icbuf);
		RS232_ECHO(port, (char __far *)dest, nread, "RX-");
   }

   return nread;
}

/*** Beginheader _serXpeek */
int _serXpeek(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXpeek                   <RS232.LIB>

SYNTAX:		   int serXpeek(int port);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not
END DESCRIPTION **********************************************************/

_rs232_debug
int _serXpeek(serXdata *port)
{
	return buffer_peek(port->inbuf);
}

/*** Beginheader _serXDMArestart */
int _serXDMArestart(serXdata *port);
/*** Endheader */
_rs232_debug
int _serXDMArestart(serXdata *port)
{
	auto word T;

	T = _SET_SHORT_TIMEOUT(1000);
	while (port->dma_flags & SER_DMA_BUSY) {
		if (_CHK_SHORT_TIMEOUT(T)) {
			RS232_ENTER_CRITICAL
			port->dma_flags &= ~SER_DMA_BUSY;
			RS232_EXIT_CRITICAL
			return 1;
		}
	}
	spx_dma_start(port);
	return 0;
}

/*** Beginheader _serXputc */
int _serXputc(serXdata *port, int c);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXputc                     <RS232.LIB>

SYNTAX:	      int serXputc(int port, char c);

DESCRIPTION:   Write a character to the serial port X write buffer.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    c: Character to write to serial port X write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

END DESCRIPTION **********************************************************/

_rs232_debug
int _serXputc(serXdata *port, int c)
{
   auto int n;
   auto cbuf_t __far *ocbuf;

   ocbuf = port->outbuf;

   if(buffer_wrlock(ocbuf)) {
      n = buffer_putch(ocbuf, c);
      if(n) {
#ifndef SER_DMA_DISABLE
   		if(port->dma_flags & SER_DMA_ON) {
            port->dma_len++;
				_serXDMArestart(port);
         }
         else
#endif // ifndef SER_DMA_DISABLE
			{
#ifndef SER_DMA_ONLY
         	spx_starttx(port);
#endif // ifndef SER_DMA_ONLY
         }
			RS232_ECHO(port, (char *) &c, 1, "TX-");
   	}
      buffer_wrunlock(ocbuf);
   }
   else {
      n = 0;
   }
   return n;
}

/*** Beginheader _serXputs */
int _serXputs(serXdata *port, const char __far *s);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXputs                     <RS232.LIB>

SYNTAX:     	int serXputs(int port, const char far *s);

DESCRIPTION:   Calls serXwrite(port, s, strlen(s)); does not send null
					terminator.  This function is non-reentrant for a given serial
					port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port X.

END DESCRIPTION **********************************************************/

_rs232_debug
int _serXputs(serXdata *port, const char __far *s)
{
   return _serXwrite(port, s, strlen(s));
}

/*** Beginheader _serXwrite */
int _serXwrite(serXdata *port, const void __far *data, int length);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXwrite                   <RS232.LIB>

SYNTAX:		   int serXwrite(int port, const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port X.  This function will
					block until it has loaded the serial buffer with all of the
					bytes requested.

               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    data  : data structure to write to serial port X
PARAMETER3:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port X.
					Since this function blocks, it will either return 0 (if it
					can't get the write lock) or <length>.

END DESCRIPTION **********************************************************/

_rs232_debug
int _serXwrite(serXdata *port, const void __far *data, int length)
{
   auto int bytesleft, byteswritten, sent;
   auto char __far *p;
   auto cbuf_t __far *ocbuf;

   ocbuf = port->outbuf;
	sent = 0;

   if(buffer_wrlock(ocbuf)) {
		p = (char __far *)data;
		bytesleft = length;
      while(bytesleft) {
         byteswritten = buffer_put(ocbuf, p, bytesleft);
         if (byteswritten) {
	         bytesleft -= byteswritten;
	         sent += byteswritten;
	         p += byteswritten;
#ifndef SER_DMA_DISABLE
	         if(port->dma_flags & SER_DMA_ON) {
	            port->dma_len += byteswritten;
	            _serXDMArestart(port);
	         }
	         else
#endif // ifndef SER_DMA_DISABLE
				{
#ifndef SER_DMA_ONLY
	            spx_starttx(port);
#endif // ifndef SER_DMA_ONLY
	         }
			}
      }

#ifndef SER_DMA_DISABLE
      // if there is anything left, send it now.
      if((port->dma_flags & SER_DMA_ON) && (port->dma_len > 0)) {
         _serXDMArestart(port);
      }
#endif // ifndef SER_DMA_DISABLE

      buffer_wrunlock(ocbuf);
		RS232_ECHO(port, (char __far *)data, sent, "TX-");
   }

   return sent;
}

/*** Beginheader _serXfastwrite */
int _serXfastwrite(serXdata *port, const void __far *data, int length);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXfastwrite                   <RS232.LIB>

SYNTAX:		   int serXfastwrite(int port, const void far *data, int length);

DESCRIPTION:   Transmits up to length bytes to serial port X.  If the outbound
					serial buffer is full, it may be an incomplete write.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    data  : data structure to write to serial port X
PARAMETER3:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port X.
					This will be a value between 0 and <length>.

END DESCRIPTION **********************************************************/

_rs232_debug
int _serXfastwrite(serXdata *port, const void __far *data, int length)
{
   auto int byteswritten;
   auto cbuf_t __far *ocbuf;

   ocbuf = port->outbuf;
   if (buffer_wrlock(ocbuf))
   {
      byteswritten = buffer_put(ocbuf, (char __far *)data, length);
      if (byteswritten)
      {
#ifndef SER_DMA_DISABLE
	      if(port->dma_flags & SER_DMA_ON)
	      {
	         port->dma_len += byteswritten;
	         _serXDMArestart(port);
	      }
	      else
#endif // ifndef SER_DMA_DISABLE
			{
#ifndef SER_DMA_ONLY
	         spx_starttx(port);
#endif // ifndef SER_DMA_ONLY
	      }

			RS232_ECHO(port, (char __far *)data, byteswritten, "TX-");
		}
      buffer_wrunlock(ocbuf);
   }

   return byteswritten;
}

/*** Beginheader _cof_serXgetc */
__cofunc int _cof_serXgetc[SER_PORT_N](serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serXgetc                   <RS232.LIB>

SYNTAX:		   int cof_serXgetc(int port);

DESCRIPTION:   Yields to other tasks until a character is read from port X.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	The character read from serial port X

END DESCRIPTION **********************************************************/

_rs232_debug
__cofunc int _cof_serXgetc[SER_PORT_N](serXdata *port)
{
	auto int c;

	__waitfor (buffer_rdlock(port->inbuf));

#ifndef SER_DMA_DISABLE
   if(port->dma_flags & SER_DMA_ON) {
      while(ser_bufUpdate(port));
   }
#endif // ifndef SER_DMA_DISABLE

   __waitfor((c = buffer_getch(port->inbuf)) != -1);

	serXrts_update(port);
   buffer_rdunlock(port->inbuf);
   return c;
}

/*** Beginheader _cof_serXgets */
__cofunc int _cof_serXgets[SER_PORT_N](serXdata *port, char __far *s, int max,
   unsigned long tmout);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serXgets                   <RS232.LIB>

SYNTAX:	int cof_serXgets(int port, char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port X until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant for a given serial
   				port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER3:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER4:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

END DESCRIPTION **********************************************************/

_rs232_debug
__cofunc int _cof_serXgets[SER_PORT_N](serXdata *port, char __far *s, int max,
   unsigned long tmout)
{
   auto int  c, started, timedOut;
   auto char __far *p;
   auto unsigned long chtm;

   __waitfor(buffer_rdlock(port->inbuf));

   p = s;
   c = started = timedOut = 0;

   while(c != RS232_CR && p-s < max && !timedOut) {
#ifndef SER_DMA_DISABLE
      if(port->dma_flags & SER_DMA_ON) {
         while(ser_bufUpdate(port));
 	   }
#endif // ifndef SER_DMA_DISABLE
      if((c = buffer_getch(port->inbuf)) != -1) {
         switch(c) {
            case  8: if (p > s) --p; break;
            case  0:
            case RS232_LF: c = RS232_CR;
            case RS232_CR: break;
            default: *p++ = c; break;
         }

			serXrts_update(port);
         started = 1;
         chtm = MS_TIMER;  // timeout starts anew
      }
      else {
         if(started && (MS_TIMER - chtm) >= tmout) {
            timedOut = 1;
         }
         else {
            __yield;
         }
      }
   }

   *p=0;  // null terminate whether timed out, max length, or normal
   buffer_rdunlock(port->inbuf);

	RS232_ECHO(port, s, p - s, "RX-");

   return !timedOut;
}

/*** Beginheader _cof_serXread */
__cofunc int _cof_serXread[SER_PORT_N](serXdata *port, void __far *dest,
	int length, unsigned long tmout);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serXread                   <RS232.LIB>

SYNTAX: int cof_serXread(int port, void far *dest, int length,
																		unsigned long tmout);

DESCRIPTION:   Reads length characters from port X or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    data  : Data structure into which characters are read.
PARAMETER3:    length: The number of characters to read into data.
PARAMETER4:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

END DESCRIPTION **********************************************************/

_rs232_debug
__cofunc int _cof_serXread[SER_PORT_N](serXdata *port, void __far *dest,
	int length, unsigned long tmout)
{
   auto int n, nread, timedOut;
   auto char __far *p;
   auto unsigned long chtm;

   p = (char __far *)dest;
   __waitfor(buffer_rdlock(port->inbuf));

   n = nread = timedOut = 0;
   chtm = MS_TIMER;
   while(nread < length && !timedOut) {
#ifndef SER_DMA_DISABLE
      if(port->dma_flags & SER_DMA_ON) {
         while(ser_bufUpdate(port));
      }
#endif // ifndef SER_DMA_DISABLE
      if((n = buffer_get(port->inbuf, p + nread, length - nread)) > 0) {
         nread += n;
			serXrts_update(port);
         if(nread < length) {
            __yield;
            chtm = MS_TIMER;      // timeout starts anew
         }
      }
      else {
         if(nread && (MS_TIMER - chtm) >= tmout) {
         	timedOut = 1;
         }
         else {
            __yield;
         }
      }
   }

   buffer_rdunlock(port->inbuf);

	RS232_ECHO(port, p, nread, "RX-");

   return nread;
}

/*** Beginheader _cof_serXputc */
__cofunc void _cof_serXputc[SER_PORT_N](serXdata *port, int c);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serXputc                   <RS232.LIB>

SYNTAX:		   void cof_serXputc(int port, int c);

DESCRIPTION:   Writes a character to the X port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    c: Character to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

_rs232_debug
__cofunc void _cof_serXputc[SER_PORT_N](serXdata *port, int c)
{
	__waitfor (buffer_wrlock(port->outbuf));

	__waitfor (buffer_putch(port->outbuf, c));

#ifndef SER_DMA_DISABLE
   if(port->dma_flags & SER_DMA_ON) {
      port->dma_len++;
      _serXDMArestart(port);
   }
   else
#endif // ifndef SER_DMA_DISABLE
	{
#ifndef SER_DMA_ONLY
      spx_starttx(port);
#endif // ifndef SER_DMA_ONLY
   }
   buffer_wrunlock(port->outbuf);
}

/*** Beginheader _cof_serXwrite */
__cofunc void _cof_serXwrite[SER_PORT_N](serXdata *port, const void __far *data,
	int length);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
cof_serXputs                   <RS232.LIB>

SYNTAX:		   void cof_serXputs(int port, const char far *str);

DESCRIPTION:   Writes a null terminated string to the X port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    s: Null terminated character string to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
cof_serXwrite                   <RS232.LIB>

SYNTAX:		   void cof_serXwrite(int port, const void far *data, int length);

DESCRIPTION:   Writes length bytes to the X port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant
               for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:    data  : Data structure to write.
PARAMETER3:    length: Number of bytes in data to write.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/

_rs232_debug
__cofunc void _cof_serXwrite[SER_PORT_N](serXdata *port, const void __far *data,
	int length)
{
   auto int bytesleft, byteswritten;
   auto char __far *v;

   __waitfor(buffer_wrlock(port->outbuf));

   v = (char __far *)data;
   bytesleft = length;
   while(bytesleft > 0) {
      byteswritten = buffer_put(port->outbuf, v + (length - bytesleft), bytesleft);
      bytesleft -= byteswritten;
#ifndef SER_DMA_DISABLE
      if(port->dma_flags & SER_DMA_ON) {
         port->dma_len += byteswritten;
         _serXDMArestart(port);
      }
      else
#endif // ifndef SER_DMA_DISABLE
		{
#ifndef SER_DMA_ONLY
         spx_starttx(port);
#endif // ifndef SER_DMA_ONLY
   	}
   	if(bytesleft) {
         __yield;
      }
   }

#ifndef SER_DMA_DISABLE
   // if there is anything left, send it now.
   if((port->dma_flags & SER_DMA_ON) && (port->dma_len > 0)) {
   	_serXDMArestart(port);
   }
#endif // ifndef SER_DMA_DISABLE

   buffer_wrunlock(port->outbuf);

	RS232_ECHO(port, v, length, "TX-");
}

/*** Beginheader _serXflowcontrolOff */
void _serXflowcontrolOff(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serXflowcontrolOff(int port);

DESCRIPTION:   Turns off hardware flow control for channel X.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void _serXflowcontrolOff(serXdata *port)
{
   // This will start the free flow of data.
#ifndef SER_DMA_DISABLE
   if(port->dma_flags & SER_DMA_ON) {
      RS232_ENTER_CRITICAL
      port->xRTSon();
      RS232_EXIT_CRITICAL
   }
#endif // ifndef SER_DMA_DISABLE

   port->ser_flags &= ~SER_FLAG_RTSCTS;
}

/*** Beginheader _serXparity */
void _serXparity(serXdata *port, int state);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXparity                   <RS232.LIB>

SYNTAX:		   void serXparity(int port, int state);

DESCRIPTION:   Sets parity type for channel X. This function is non-reentrant
					for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

PARAMETER2:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void _serXparity(serXdata *port, int state)
{
   auto int ptype, sxer;

   switch (state)
   {
		case PARAM_NOPARITY:
			ptype = 0x00;
			break;

   	case PARAM_OPARITY:
         ptype = 0xA0;
         break;

   	case PARAM_EPARITY:
   		ptype = 0x80;
			break;

   	case PARAM_SPARITY:
   		ptype = 0xC0;
			break;

      case PARAM_MPARITY:
         ptype = 0xE0;
			break;

      case PARAM_1STOP:
      	// clear the TWOSTOP flag, don't change sxer
      	port->ser_flags &= ~(1<<SER_BIT_TWOSTOP);
			return;

      case PARAM_2STOP:
      	// set the TWOSTOP flag, don't change sxer
      	port->ser_flags |= (1<<SER_BIT_TWOSTOP);
			return;

      default:
			// invalid setting, ignore
			return;
   }

	sxer = port->sxdr+SxER_OFS;
   WrPortI(sxer, NULL, (RdPortI(sxer) & 0x1F) | ptype);
}

/*** Beginheader _serXdatabits */
void _serXdatabits(serXdata *port, int state);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXdatabits                   <RS232.LIB>

SYNTAX:		   void serXdatabits(int port, int state);

DESCRIPTION:   Sets number of data bits to use for channel X.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.
PARAMETER2:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

_rs232_debug
void _serXdatabits(serXdata *port, int state)
{
   if (state == PARAM_7BIT) {
   	port->ser_flags |= SER_FLAG_SEVENBIT;
   	BitWrPortI(port->sxdr+SxCR_OFS, port->sxcrshadow, 1, 2);
   }
   else {
   	port->ser_flags &= ~SER_FLAG_SEVENBIT;
   	BitWrPortI(port->sxdr+SxCR_OFS, port->sxcrshadow, 0, 2);
   }
}

/*** Beginheader _serXrdFree */
int _serXrdFree(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXrdFree                   <RS232.LIB>

SYNTAX:		   int serXrdFree(int port);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port X input buffer. This function is non-reentrant for a given
               serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	the number of chars it would take to fill the X input buffer
END DESCRIPTION **********************************************************/

_rs232_debug
int _serXrdFree(serXdata *port)
{
#ifndef SER_DMA_DISABLE
   if(port->dma_flags & SER_DMA_ON) {
      if(buffer_rdlock(port->inbuf)) {
         while(ser_bufUpdate(port));
         buffer_rdunlock(port->inbuf);
      }
   }
#endif // ifndef SER_DMA_DISABLE

   return buffer_free(port->inbuf);
}

/*** Beginheader _serXwrFree */
int _serXwrFree(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXwrFree                   <RS232.LIB>

SYNTAX:		   int serXwrFree(int port);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port X transmit buffer. This function is non-reentrant for a
               given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	the number of chars it would take to fill the X transmit buffer
END DESCRIPTION **********************************************************/

_rs232_debug
int _serXwrFree(serXdata *port)
{
   return buffer_free( port->outbuf);
}

/*** Beginheader _serXrdUsed */
int _serXrdUsed(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXrdUsed                   <RS232.LIB>

SYNTAX:		   int serXrdUsed(int port);

DESCRIPTION:   Returns the number of characters in the X input buffer.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	the number of characters currently in the X input buffer
END DESCRIPTION **********************************************************/

_rs232_debug
int _serXrdUsed(serXdata *port)
{
#ifndef SER_DMA_DISABLE
   if(port->dma_flags & SER_DMA_ON) {
      if(buffer_rdlock(port->inbuf)) {
         while(ser_bufUpdate(port));
      	buffer_rdunlock(port->inbuf);
      }
   }
#endif // ifndef SER_DMA_DISABLE
   return buffer_used( port->inbuf);
}

/*** Beginheader _serXwrUsed */
int _serXwrUsed(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXwrUsed                   <RS232.LIB>

SYNTAX:		   int serXwrUsed(int port);

DESCRIPTION:   Returns the number of characters in the X output buffer.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	the number of characters currently in the X output buffer
END DESCRIPTION **********************************************************/

_rs232_debug
int _serXwrUsed(serXdata *port)
{
   return buffer_used( port->outbuf);
}

/*** Beginheader _serXrdFlush */
void _serXrdFlush(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXrdFlush                  <RS232.LIB>

SYNTAX:		   void serXrdFlush(int port);

DESCRIPTION:   Flushes the serial port X input buffer.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

_rs232_debug
void _serXrdFlush(serXdata *port)
{
	#ifndef SER_DMA_DISABLE
   if (port->dma_flags & SER_DMA_ON) {
		// DMA has pointer into circular buffer, just read all bytes in buffer
		while(_serXgetc(port) >= 0);
		return;
	}
	#endif

	#ifndef SER_DMA_ONLY
		// No DMA, reset circular buffer after disabling interrupts
		RS232_ENTER_CRITICAL
   	buffer_flush( port->inbuf);
   	RS232_EXIT_CRITICAL
   #endif
}

/*** Beginheader _serXwrFlush */
void _serXwrFlush(serXdata *port);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
serXwrFlush                  <RS232.LIB>

SYNTAX:		   void serXwrFlush(int port);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port X transmit
					buffer.
               This function is non-reentrant for a given serial port.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	None
END DESCRIPTION **********************************************************/

_rs232_debug
void _serXwrFlush(serXdata *port)
{
	#ifndef SER_DMA_DISABLE
   if (port->dma_flags & SER_DMA_ON) {
   	if (port->dma_flags & SER_DMA_BUSY) {
	      // Stop DMA, flush the circular buffer.
			// Bytes already in the transmit buffer will still be sent.
	      DMAstopDirect(DMAhandle2chan(port->dma_ohandle));
	      port->dma_flags &= ~SER_DMA_BUSY;
	      port->dma_pos = 0;
	      port->dma_len = 0;
		   buffer_flush( port->outbuf);
		}
		return;
	}
	#endif

	#ifndef SER_DMA_ONLY
		// DMA is not on, just reset circular buffer, after disabling interrupts
		RS232_ENTER_CRITICAL
		buffer_flush( port->outbuf);
   	RS232_EXIT_CRITICAL
   #endif
}

/*** BeginHeader _serXsending */
int _serXsending( serXdata *port);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
serXsending                  <RS232.LIB>

SYNTAX:		   int serXsending(int port)

DESCRIPTION:   Reports whether serial port X is busy sending data (either
					characters in the transmit buffer or the serial shift register).
					Useful when waiting for a transmission to complete before
					continuing:

					serXputs( SER_PORT_D, "The quick brown fox jumped");
					while (serXsending( SER_PORT_D))
					{
						// waiting for message to go out
					}
					// message sent, can now close port, change baud rate, etc.

PARAMETER1:		The port number. Valid inputs are SER_PORT_A through SER_PORT_F.
					This function is defined (through macros) to use this value and
					select the appropriate serial port data structure.

RETURN VALUE:	Zero if the port is not sending, non-zero if it is.

END DESCRIPTION **********************************************************/
_rs232_debug
int _serXsending( serXdata *port)
{
	// Check for bytes in buffer, or byte in CPU data register or shift register.
	return (buffer_used( port->outbuf)
											|| (RdPortI( port->sxdr + SxSR_OFS) & 0x0C));
}

//************************************************************************
//********************** Comments and Wrappers ***************************
//************************************************************************

//************************************************************************
//***************** SERIAL PORT A WRAPPERS AND COMMENTS ******************
//************************************************************************

/* START FUNCTION DESCRIPTION ********************************************
serAdmaOn							<RS232.LIB>

SYNTAX:			int serAdmaOn(int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serAopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
   				any available channel.
PARAMETER2:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
   				any available channel.

RETURN VALUE:	DMA error code or 0 for success.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOn
END DESCRIPTION **********************************************************/

/*** Beginheader serAdmaOn */
int serAdmaOn(int tcmask, int rcmask);
/*** Endheader */

#ifdef SER_DMA_DISABLE
	#fatal "Cannot use DMA with SER_DMA_DISABLE defined"
#endif

_rs232_debug
int serAdmaOn(int tcmask, int rcmask)
{
	return serXdmaOn(SER_PORT_A, tcmask, rcmask);
}

/* START FUNCTION DESCRIPTION ********************************************
serAdmaOff							<RS232.LIB>

SYNTAX:			int serAdmaOff(void);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupts just in case.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serAdmaOn

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOff
END DESCRIPTION **********************************************************/

/*** Beginheader serAdmaOff */
int serAdmaOff(void);
/*** Endheader */

_rs232_debug
int serAdmaOff(void)
{
	return serXdmaOff(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAgetError                   <RS232.LIB>

SYNTAX:		   char serAgetError(void);

DESCRIPTION:   Returns the error flags byte for serial channel A
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetError
END DESCRIPTION **********************************************************/

/*** Beginheader serAgetError */
char serAgetError(void);
/*** Endheader */

_rs232_debug
char serAgetError(void)
{
	return serXgetError(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAgetc                     <RS232.LIB>

SYNTAX:	      int serAgetc(void);

DESCRIPTION:   Get next available character from serial port A read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader serAgetc */
int serAgetc(void);
/*** Endheader */

_rs232_debug
int serAgetc(void)
{
	return serXgetc(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAread                   <RS232.LIB>

SYNTAX:		   int serAread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, A, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port A
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port A

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXread
END DESCRIPTION **********************************************************/

/*** Beginheader serAread */
int serAread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
int serAread(void __far *data, int length, unsigned long tmout)
{
	return serXread(SER_PORT_A, data, length, tmout);
}

/* START FUNCTION DESCRIPTION ********************************************
serApeek                   <RS232.LIB>

SYNTAX:		   int serApeek(void);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXpeek
END DESCRIPTION **********************************************************/

/*** Beginheader serApeek */
int serApeek(void);
/*** Endheader */

_rs232_debug
int serApeek(void)
{
	return serXpeek(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAputc                     <RS232.LIB>

SYNTAX:	      int serAputc(char c);

DESCRIPTION:   Write a character to the serial port A write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port A write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader serAputc */
int serAputc(char c);
/*** Endheader */

_rs232_debug
int serAputc(char c)
{
	return serXputc(SER_PORT_A, c);
}

/* START FUNCTION DESCRIPTION ********************************************
serAputs                     <RS232.LIB>

SYNTAX:     	int serAputs(const char far *s);

DESCRIPTION:   Calls serAwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port A.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader serAputs */
int serAputs(const char __far *s);
/*** Endheader */

_rs232_debug
int serAputs(const char __far *s)
{
	return serXwrite(SER_PORT_A, s, strlen(s));
}

/* START FUNCTION DESCRIPTION ********************************************
serAwrite                   <RS232.LIB>

SYNTAX:		   int serAwrite(const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port A.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port A
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port A.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader serAwrite */
int serAwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
int serAwrite(const void __far *data, int length)
{
	return serXwrite(SER_PORT_A, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serAgetc                   <RS232.LIB>

SYNTAX:		   int cof_serAgetc(void);

DESCRIPTION:   Yields to other tasks until a character is read from port A.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port A

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serAgetc */
__scofunc int cof_serAgetc(void);
/*** Endheader */

_rs232_debug
__scofunc int cof_serAgetc(void)
{
	auto int val;
	__wfd val = cof_serXgetc(SER_PORT_A);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serAgets                   <RS232.LIB>

SYNTAX:		   int cof_serAgets(char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port A until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgets
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serAgets */
__scofunc int cof_serAgets(char __far *s, int max, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serAgets(char __far *s, int max, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXgets(SER_PORT_A, s, max, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serAread                   <RS232.LIB>

SYNTAX:	int cof_serAread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port A or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXread
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serAread */
__scofunc int cof_serAread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serAread(void __far *data, int length, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXread(SER_PORT_A, data, length, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serAputc                   <RS232.LIB>

SYNTAX:		   void cof_serAputc(int c);

DESCRIPTION:   Writes a character to the A port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serAputc */
__scofunc void cof_serAputc(int c);
/*** Endheader */

_rs232_debug
__scofunc void cof_serAputc(int c)
{
	__wfd cof_serXputc(SER_PORT_A, c);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serAputs                   <RS232.LIB>

SYNTAX:		   void cof_serAputs(const char far *str);

DESCRIPTION:   Writes a null terminated string to the A port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serAputs */
__scofunc void cof_serAputs(const char __far *str);
/*** Endheader */

_rs232_debug
__scofunc void cof_serAputs(const char __far *str)
{
	__wfd cof_serXputs(SER_PORT_A, str);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serAwrite                   <RS232.LIB>

SYNTAX:		   void cof_serAwrite(const void far *data, int length);

DESCRIPTION:   Writes length bytes to the A port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serAwrite */
__scofunc void cof_serAwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
__scofunc void cof_serAwrite(const void __far *data, int length)
{
	__wfd cof_serXwrite(SER_PORT_A, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
serAflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serAflowcontrolOff(void);

DESCRIPTION:   Turns off hardware flow control for channel A.
               This function is non-reentrant.

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXflowcontrolOff
END DESCRIPTION **********************************************************/

/*** Beginheader serAflowcontrolOff */
void serAflowcontrolOff(void);
/*** Endheader */

_rs232_debug
void serAflowcontrolOff(void)
{
	serXflowcontrolOff(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAparity                   <RS232.LIB>

SYNTAX:		   void serAparity(int state);

DESCRIPTION:   Sets parity type for channel A. This function is non-reentrant.

PARAMETER1:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXparity
END DESCRIPTION **********************************************************/

/*** Beginheader serAparity*/
void serAparity(int state);
/*** Endheader */

_rs232_debug
void serAparity(int state)
{
	serXparity(SER_PORT_A, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serAdatabits                   <RS232.LIB>

SYNTAX:		   void serAdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel A.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdatabits
END DESCRIPTION **********************************************************/

/*** Beginheader serAdatabits */
void serAdatabits(int state);
/*** Endheader */

_rs232_debug
void serAdatabits(int state)
{
	serXdatabits(SER_PORT_A, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serArdFree                   <RS232.LIB>

SYNTAX:		   int serArdFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port A input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the A input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFree
END DESCRIPTION **********************************************************/

/*** Beginheader serArdFree */
int serArdFree(void);
/*** Endheader */

_rs232_debug
int serArdFree(void)
{
	return serXrdFree(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAwrFree                   <RS232.LIB>

SYNTAX:		   int serAwrFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port A transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the A transmit buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serX
END DESCRIPTION **********************************************************/

/*** Beginheader serAwrFree */
int serAwrFree(void);
/*** Endheader */

_rs232_debug
int serAwrFree(void)
{
	return serXwrFree(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serArdUsed                   <RS232.LIB>

SYNTAX:		   int serArdUsed(void);

DESCRIPTION:   Returns the number of characters in the A input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the A input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serArdUsed */
int serArdUsed(void);
/*** Endheader */

_rs232_debug
int serArdUsed(void)
{
	return serXrdUsed(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAwrUsed                   <RS232.LIB>

SYNTAX:		   int serAwrUsed(void);

DESCRIPTION:   Returns the number of characters in the A output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the A output buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serAwrUsed */
int serAwrUsed(void);
/*** Endheader */

_rs232_debug
int serAwrUsed(void)
{
	return serXwrUsed(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serArdFlush                  <RS232.LIB>

SYNTAX:		   void serArdFlush(void);

DESCRIPTION:   Flushes the serial port A input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serArdFlush */
void serArdFlush(void);
/*** Endheader */

_rs232_debug
void serArdFlush(void)
{
	serXrdFlush(SER_PORT_A);
}

/* START FUNCTION DESCRIPTION ********************************************
serAwrFlush                  <RS232.LIB>

SYNTAX:		   void serAwrFlush(void);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port A transmit
					buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serAwrFlush */
void serAwrFlush(void);
/*** Endheader */

_rs232_debug
void serAwrFlush(void)
{
	serXwrFlush(SER_PORT_A);
}

//************************************************************************
//***************** SERIAL PORT B WRAPPERS AND COMMENTS ******************
//************************************************************************

/* START FUNCTION DESCRIPTION ********************************************
serBdmaOn							<RS232.LIB>

SYNTAX:			int serBdmaOn(int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serBopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
   				any available channel.
PARAMETER2:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
   				any available channel.

RETURN VALUE:	DMA error code or 0 for success.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOn
END DESCRIPTION **********************************************************/

/*** Beginheader serBdmaOn */
int serBdmaOn(int tcmask, int rcmask);
/*** Endheader */

#ifdef SER_DMA_DISABLE
	#fatal "Cannot use DMA with SER_DMA_DISABLE defined"
#endif

_rs232_debug
int serBdmaOn(int tcmask, int rcmask)
{
	return serXdmaOn(SER_PORT_B, tcmask, rcmask);
}

/* START FUNCTION DESCRIPTION ********************************************
serBdmaOff							<RS232.LIB>

SYNTAX:			int serBdmaOff(void);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupts just in case.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serBdmaOn

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOff
END DESCRIPTION **********************************************************/

/*** Beginheader serBdmaOff */
int serBdmaOff(void);
/*** Endheader */

_rs232_debug
int serBdmaOff(void)
{
	return serXdmaOff(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBgetError                   <RS232.LIB>

SYNTAX:		   char serBgetError(void);

DESCRIPTION:   Returns the error flags byte for serial channel B
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetError
END DESCRIPTION **********************************************************/

/*** Beginheader serBgetError */
char serBgetError(void);
/*** Endheader */

_rs232_debug
char serBgetError(void)
{
	return serXgetError(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBgetc                     <RS232.LIB>

SYNTAX:	      int serBgetc(void);

DESCRIPTION:   Get next available character from serial port B read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader serBgetc */
int serBgetc(void);
/*** Endheader */

_rs232_debug
int serBgetc(void)
{
	return serXgetc(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBread                   <RS232.LIB>

SYNTAX:		   int serBread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, B, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port B
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port B

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXread
END DESCRIPTION **********************************************************/

/*** Beginheader serBread */
int serBread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
int serBread(void __far *data, int length, unsigned long tmout)
{
	return serXread(SER_PORT_B, data, length, tmout);
}

/* START FUNCTION DESCRIPTION ********************************************
serBpeek                   <RS232.LIB>

SYNTAX:		   int serBpeek(void);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXpeek
END DESCRIPTION **********************************************************/

/*** Beginheader serBpeek */
int serBpeek(void);
/*** Endheader */

_rs232_debug
int serBpeek(void)
{
	return serXpeek(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBputc                     <RS232.LIB>

SYNTAX:	      int serBputc(char c);

DESCRIPTION:   Write a character to the serial port B write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port B write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader serBputc */
int serBputc(char c);
/*** Endheader */

_rs232_debug
int serBputc(char c)
{
	return serXputc(SER_PORT_B, c);
}

/* START FUNCTION DESCRIPTION ********************************************
serBputs                     <RS232.LIB>

SYNTAX:     	int serBputs(const char far *s);

DESCRIPTION:   Calls serBwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port B.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader serBputs */
int serBputs(const char __far *s);
/*** Endheader */

_rs232_debug
int serBputs(const char __far *s)
{
	return serXwrite(SER_PORT_B, s, strlen(s));
}

/* START FUNCTION DESCRIPTION ********************************************
serBwrite                   <RS232.LIB>

SYNTAX:		   int serBwrite(const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port B.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port B
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port B.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader serBwrite */
int serBwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
int serBwrite(const void __far *data, int length)
{
	return serXwrite(SER_PORT_B, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serBgetc                   <RS232.LIB>

SYNTAX:		   int cof_serBgetc(void);

DESCRIPTION:   Yields to other tasks until a character is read from port B.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port B

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serBgetc */
__scofunc int cof_serBgetc(void);
/*** Endheader */

_rs232_debug
__scofunc int cof_serBgetc(void)
{
	int val;
	__wfd val = cof_serXgetc(SER_PORT_B);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serBgets                   <RS232.LIB>

SYNTAX:		   int cof_serBgets(char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port B until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgets
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serBgets */
__scofunc int cof_serBgets(char __far *s, int max, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serBgets(char __far *s, int max, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXgets(SER_PORT_B, s, max, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serBread                   <RS232.LIB>

SYNTAX:	int cof_serBread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port B or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXread
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serBread */
__scofunc int cof_serBread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serBread(void __far *data, int length, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXread(SER_PORT_B, data, length, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serBputc                   <RS232.LIB>

SYNTAX:		   void cof_serBputc(int c);

DESCRIPTION:   Writes a character to the B port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serBputc */
__scofunc void cof_serBputc(int c);
/*** Endheader */

_rs232_debug
__scofunc void cof_serBputc(int c)
{
	__wfd cof_serXputc(SER_PORT_B, c);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serBputs                   <RS232.LIB>

SYNTAX:		   void cof_serBputs(const char far *str);

DESCRIPTION:   Writes a null terminated string to the B port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serBputs */
__scofunc void cof_serBputs(const char __far *str);
/*** Endheader */

_rs232_debug
__scofunc void cof_serBputs(const char __far *str)
{
	__wfd cof_serXputs(SER_PORT_B, str);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serBwrite                   <RS232.LIB>

SYNTAX:		   void cof_serBwrite(const void far *data, int length);

DESCRIPTION:   Writes length bytes to the B port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serBwrite */
__scofunc void cof_serBwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
__scofunc void cof_serBwrite(const void __far *data, int length)
{
	__wfd cof_serXwrite(SER_PORT_B, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
serBflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serBflowcontrolOff(void);

DESCRIPTION:   Turns off hardware flow control for channel B.
               This function is non-reentrant.

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXflowcontrolOff
END DESCRIPTION **********************************************************/

/*** Beginheader serBflowcontrolOff */
void serBflowcontrolOff(void);
/*** Endheader */

_rs232_debug
void serBflowcontrolOff(void)
{
	serXflowcontrolOff(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBparity                   <RS232.LIB>

SYNTAX:		   void serBparity(int state);

DESCRIPTION:   Sets parity type for channel B. This function is non-reentrant.

PARAMETER1:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXparity
END DESCRIPTION **********************************************************/

/*** Beginheader serBparity*/
void serBparity(int state);
/*** Endheader */

_rs232_debug
void serBparity(int state)
{
	serXparity(SER_PORT_B, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serBdatabits                   <RS232.LIB>

SYNTAX:		   void serBdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel B.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdatabits
END DESCRIPTION **********************************************************/

/*** Beginheader serBdatabits */
void serBdatabits(int state);
/*** Endheader */

_rs232_debug
void serBdatabits(int state)
{
	serXdatabits(SER_PORT_B, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serBrdFree                   <RS232.LIB>

SYNTAX:		   int serBrdFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port B input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the B input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFree
END DESCRIPTION **********************************************************/

/*** Beginheader serBrdFree */
int serBrdFree(void);
/*** Endheader */

_rs232_debug
int serBrdFree(void)
{
	return serXrdFree(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBwrFree                   <RS232.LIB>

SYNTAX:		   int serBwrFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port B transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the B transmit buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serX
END DESCRIPTION **********************************************************/

/*** Beginheader serBwrFree */
int serBwrFree(void);
/*** Endheader */

_rs232_debug
int serBwrFree(void)
{
	return serXwrFree(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBrdUsed                   <RS232.LIB>

SYNTAX:		   int serBrdUsed(void);

DESCRIPTION:   Returns the number of characters in the B input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the B input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serBrdUsed */
int serBrdUsed(void);
/*** Endheader */

_rs232_debug
int serBrdUsed(void)
{
	return serXrdUsed(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBwrUsed                   <RS232.LIB>

SYNTAX:		   int serBwrUsed(void);

DESCRIPTION:   Returns the number of characters in the B output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the B output buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serBwrUsed */
int serBwrUsed(void);
/*** Endheader */

_rs232_debug
int serBwrUsed(void)
{
	return serXwrUsed(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBrdFlush                  <RS232.LIB>

SYNTAX:		   void serBrdFlush(void);

DESCRIPTION:   Flushes the serial port B input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serBrdFlush */
void serBrdFlush(void);
/*** Endheader */

_rs232_debug
void serBrdFlush(void)
{
	serXrdFlush(SER_PORT_B);
}

/* START FUNCTION DESCRIPTION ********************************************
serBwrFlush                  <RS232.LIB>

SYNTAX:		   void serBwrFlush(void);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port B transmit
					buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serBwrFlush */
void serBwrFlush(void);
/*** Endheader */

_rs232_debug
void serBwrFlush(void)
{
	serXwrFlush(SER_PORT_B);
}

//************************************************************************
//***************** SERIAL PORT C WRAPPERS AND COMMENTS ******************
//************************************************************************

/* START FUNCTION DESCRIPTION ********************************************
serCdmaOn							<RS232.LIB>

SYNTAX:			int serCdmaOn(int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serCopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
   				any available channel.
PARAMETER2:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
   				any available channel.

RETURN VALUE:	DMA error code or 0 for success.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOn
END DESCRIPTION **********************************************************/

/*** Beginheader serCdmaOn */
int serCdmaOn(int tcmask, int rcmask);
/*** Endheader */

#ifdef SER_DMA_DISABLE
	#fatal "Cannot use DMA with SER_DMA_DISABLE defined"
#endif

_rs232_debug
int serCdmaOn(int tcmask, int rcmask)
{
	return serXdmaOn(SER_PORT_C, tcmask, rcmask);
}

/* START FUNCTION DESCRIPTION ********************************************
serCdmaOff							<RS232.LIB>

SYNTAX:			int serCdmaOff(void);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupts just in case.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serCdmaOn

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOff
END DESCRIPTION **********************************************************/

/*** Beginheader serCdmaOff */
int serCdmaOff(void);
/*** Endheader */

_rs232_debug
int serCdmaOff(void)
{
	return serXdmaOff(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCgetError                   <RS232.LIB>

SYNTAX:		   char serCgetError(void);

DESCRIPTION:   Returns the error flags byte for serial channel C
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetError
END DESCRIPTION **********************************************************/

/*** Beginheader serCgetError */
char serCgetError(void);
/*** Endheader */

_rs232_debug
char serCgetError(void)
{
	return serXgetError(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCgetc                     <RS232.LIB>

SYNTAX:	      int serCgetc(void);

DESCRIPTION:   Get next available character from serial port C read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader serCgetc */
int serCgetc(void);
/*** Endheader */

_rs232_debug
int serCgetc(void)
{
	return serXgetc(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCread                   <RS232.LIB>

SYNTAX:		   int serCread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, C, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port C
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port C

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXread
END DESCRIPTION **********************************************************/

/*** Beginheader serCread */
int serCread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
int serCread(void __far *data, int length, unsigned long tmout)
{
	return serXread(SER_PORT_C, data, length, tmout);
}

/* START FUNCTION DESCRIPTION ********************************************
serCpeek                   <RS232.LIB>

SYNTAX:		   int serCpeek(void);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXpeek
END DESCRIPTION **********************************************************/

/*** Beginheader serCpeek */
int serCpeek(void);
/*** Endheader */

_rs232_debug
int serCpeek(void)
{
	return serXpeek(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCputc                     <RS232.LIB>

SYNTAX:	      int serCputc(char c);

DESCRIPTION:   Write a character to the serial port C write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port C write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader serCputc */
int serCputc(char c);
/*** Endheader */

_rs232_debug
int serCputc(char c)
{
	return serXputc(SER_PORT_C, c);
}

/* START FUNCTION DESCRIPTION ********************************************
serCputs                     <RS232.LIB>

SYNTAX:     	int serCputs(const char far *s);

DESCRIPTION:   Calls serCwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port C.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader serCputs */
int serCputs(const char __far *s);
/*** Endheader */

_rs232_debug
int serCputs(const char __far *s)
{
	return serXwrite(SER_PORT_C, s, strlen(s));
}

/* START FUNCTION DESCRIPTION ********************************************
serCwrite                   <RS232.LIB>

SYNTAX:		   int serCwrite(const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port C.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port C
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port C.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader serCwrite */
int serCwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
int serCwrite(const void __far *data, int length)
{
	return serXwrite(SER_PORT_C, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serCgetc                   <RS232.LIB>

SYNTAX:		   int cof_serCgetc(void);

DESCRIPTION:   Yields to other tasks until a character is read from port C.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port C

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serCgetc */
__scofunc int cof_serCgetc(void);
/*** Endheader */

_rs232_debug
__scofunc int cof_serCgetc(void)
{
	int val;
	__wfd val = cof_serXgetc(SER_PORT_C);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serCgets                   <RS232.LIB>

SYNTAX:		   int cof_serCgets(char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port C until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgets
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serCgets */
__scofunc int cof_serCgets(char __far *s, int max, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serCgets(char __far *s, int max, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXgets(SER_PORT_C, s, max, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serCread                   <RS232.LIB>

SYNTAX:	int cof_serCread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port C or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXread
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serCread */
__scofunc int cof_serCread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serCread(void __far *data, int length, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXread(SER_PORT_C, data, length, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serCputc                   <RS232.LIB>

SYNTAX:		   void cof_serCputc(int c);

DESCRIPTION:   Writes a character to the C port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serCputc */
__scofunc void cof_serCputc(int c);
/*** Endheader */

_rs232_debug
__scofunc void cof_serCputc(int c)
{
	__wfd cof_serXputc(SER_PORT_C, c);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serCputs                   <RS232.LIB>

SYNTAX:		   void cof_serCputs(const char far *str);

DESCRIPTION:   Writes a null terminated string to the C port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serCputs */
__scofunc void cof_serCputs(const char __far *str);
/*** Endheader */

_rs232_debug
__scofunc void cof_serCputs(const char __far *str)
{
	__wfd cof_serXputs(SER_PORT_C, str);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serCwrite                   <RS232.LIB>

SYNTAX:		   void cof_serCwrite(const void far *data, int length);

DESCRIPTION:   Writes length bytes to the C port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serCwrite */
__scofunc void cof_serCwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
__scofunc void cof_serCwrite(const void __far *data, int length)
{
	__wfd cof_serXwrite(SER_PORT_C, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
serCflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serCflowcontrolOff(void);

DESCRIPTION:   Turns off hardware flow control for channel C.
               This function is non-reentrant.

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXflowcontrolOff
END DESCRIPTION **********************************************************/

/*** Beginheader serCflowcontrolOff */
void serCflowcontrolOff(void);
/*** Endheader */

_rs232_debug
void serCflowcontrolOff(void)
{
	serXflowcontrolOff(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCparity                   <RS232.LIB>

SYNTAX:		   void serCparity(int state);

DESCRIPTION:   Sets parity type for channel C. This function is non-reentrant.

PARAMETER1:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXparity
END DESCRIPTION **********************************************************/

/*** Beginheader serCparity*/
void serCparity(int state);
/*** Endheader */

_rs232_debug
void serCparity(int state)
{
	serXparity(SER_PORT_C, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serCdatabits                   <RS232.LIB>

SYNTAX:		   void serCdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel C.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdatabits
END DESCRIPTION **********************************************************/

/*** Beginheader serCdatabits */
void serCdatabits(int state);
/*** Endheader */

_rs232_debug
void serCdatabits(int state)
{
	serXdatabits(SER_PORT_C, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serCrdFree                   <RS232.LIB>

SYNTAX:		   int serCrdFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port C input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the C input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFree
END DESCRIPTION **********************************************************/

/*** Beginheader serCrdFree */
int serCrdFree(void);
/*** Endheader */

_rs232_debug
int serCrdFree(void)
{
	return serXrdFree(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCwrFree                   <RS232.LIB>

SYNTAX:		   int serCwrFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port C transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the C transmit buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serX
END DESCRIPTION **********************************************************/

/*** Beginheader serCwrFree */
int serCwrFree(void);
/*** Endheader */

_rs232_debug
int serCwrFree(void)
{
	return serXwrFree(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCrdUsed                   <RS232.LIB>

SYNTAX:		   int serCrdUsed(void);

DESCRIPTION:   Returns the number of characters in the C input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the C input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serCrdUsed */
int serCrdUsed(void);
/*** Endheader */

_rs232_debug
int serCrdUsed(void)
{
	return serXrdUsed(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCwrUsed                   <RS232.LIB>

SYNTAX:		   int serCwrUsed(void);

DESCRIPTION:   Returns the number of characters in the C output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the C output buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serCwrUsed */
int serCwrUsed(void);
/*** Endheader */

_rs232_debug
int serCwrUsed(void)
{
	return serXwrUsed(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCrdFlush                  <RS232.LIB>

SYNTAX:		   void serCrdFlush(void);

DESCRIPTION:   Flushes the serial port C input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serCrdFlush */
void serCrdFlush(void);
/*** Endheader */

_rs232_debug
void serCrdFlush(void)
{
	serXrdFlush(SER_PORT_C);
}

/* START FUNCTION DESCRIPTION ********************************************
serCwrFlush                  <RS232.LIB>

SYNTAX:		   void serCwrFlush(void);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port C transmit
					buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serCwrFlush */
void serCwrFlush(void);
/*** Endheader */

_rs232_debug
void serCwrFlush(void)
{
	serXwrFlush(SER_PORT_C);
}

//************************************************************************
//***************** SERIAL PORT D WRAPPERS AND COMMENTS ******************
//************************************************************************

/* START FUNCTION DESCRIPTION ********************************************
serDdmaOn							<RS232.LIB>

SYNTAX:			int serDdmaOn(int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serDopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
   				any available channel.
PARAMETER2:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
   				any available channel.

RETURN VALUE:	DMA error code or 0 for success.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOn
END DESCRIPTION **********************************************************/

/*** Beginheader serDdmaOn */
int serDdmaOn(int tcmask, int rcmask);
/*** Endheader */

#ifdef SER_DMA_DISABLE
	#fatal "Cannot use DMA with SER_DMA_DISABLE defined"
#endif

_rs232_debug
int serDdmaOn(int tcmask, int rcmask)
{
	return serXdmaOn(SER_PORT_D, tcmask, rcmask);
}

/* START FUNCTION DESCRIPTION ********************************************
serDdmaOff							<RS232.LIB>

SYNTAX:			int serDdmaOff(void);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupts just in case.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serDdmaOn

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOff
END DESCRIPTION **********************************************************/

/*** Beginheader serDdmaOff */
int serDdmaOff(void);
/*** Endheader */

_rs232_debug
int serDdmaOff(void)
{
	return serXdmaOff(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDgetError                   <RS232.LIB>

SYNTAX:		   char serDgetError(void);

DESCRIPTION:   Returns the error flags byte for serial channel D
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetError
END DESCRIPTION **********************************************************/

/*** Beginheader serDgetError */
char serDgetError(void);
/*** Endheader */

_rs232_debug
char serDgetError(void)
{
	return serXgetError(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDgetc                     <RS232.LIB>

SYNTAX:	      int serDgetc(void);

DESCRIPTION:   Get next available character from serial port D read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader serDgetc */
int serDgetc(void);
/*** Endheader */

_rs232_debug
int serDgetc(void)
{
	return serXgetc(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDread                   <RS232.LIB>

SYNTAX:		   int serDread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, D, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port D
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port D

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXread
END DESCRIPTION **********************************************************/

/*** Beginheader serDread */
int serDread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
int serDread(void __far *data, int length, unsigned long tmout)
{
	return serXread(SER_PORT_D, data, length, tmout);
}

/* START FUNCTION DESCRIPTION ********************************************
serDpeek                   <RS232.LIB>

SYNTAX:		   int serDpeek(void);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXpeek
END DESCRIPTION **********************************************************/

/*** Beginheader serDpeek */
int serDpeek(void);
/*** Endheader */

_rs232_debug
int serDpeek(void)
{
	return serXpeek(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDputc                     <RS232.LIB>

SYNTAX:	      int serDputc(char c);

DESCRIPTION:   Write a character to the serial port D write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port D write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader serDputc */
int serDputc(char c);
/*** Endheader */

_rs232_debug
int serDputc(char c)
{
	return serXputc(SER_PORT_D, c);
}

/* START FUNCTION DESCRIPTION ********************************************
serDputs                     <RS232.LIB>

SYNTAX:     	int serDputs(const char far *s);

DESCRIPTION:   Calls serDwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port D.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader serDputs */
int serDputs(const char __far *s);
/*** Endheader */

_rs232_debug
int serDputs(const char __far *s)
{
	return serXwrite(SER_PORT_D, s, strlen(s));
}

/* START FUNCTION DESCRIPTION ********************************************
serDwrite                   <RS232.LIB>

SYNTAX:		   int serDwrite(const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port D.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port D
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port D.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader serDwrite */
int serDwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
int serDwrite(const void __far *data, int length)
{
	return serXwrite(SER_PORT_D, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serDgetc                   <RS232.LIB>

SYNTAX:		   int cof_serDgetc(void);

DESCRIPTION:   Yields to other tasks until a character is read from port D.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port D

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serDgetc */
__scofunc int cof_serDgetc(void);
/*** Endheader */

_rs232_debug
__scofunc int cof_serDgetc(void)
{
	int val;
	__wfd val = cof_serXgetc(SER_PORT_D);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serDgets                   <RS232.LIB>

SYNTAX:		   int cof_serDgets(char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port D until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgets
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serDgets */
__scofunc int cof_serDgets(char __far *s, int max, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serDgets(char __far *s, int max, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXgets(SER_PORT_D, s, max, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serDread                   <RS232.LIB>

SYNTAX:	int cof_serDread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port D or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXread
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serDread */
__scofunc int cof_serDread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serDread(void __far *data, int length, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXread(SER_PORT_D, data, length, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serDputc                   <RS232.LIB>

SYNTAX:		   void cof_serDputc(int c);

DESCRIPTION:   Writes a character to the D port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serDputc */
__scofunc void cof_serDputc(int c);
/*** Endheader */

_rs232_debug
__scofunc void cof_serDputc(int c)
{
	__wfd cof_serXputc(SER_PORT_D, c);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serDputs                   <RS232.LIB>

SYNTAX:		   void cof_serDputs(const char far *str);

DESCRIPTION:   Writes a null terminated string to the D port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serDputs */
__scofunc void cof_serDputs(const char __far *str);
/*** Endheader */

_rs232_debug
__scofunc void cof_serDputs(const char __far *str)
{
	__wfd cof_serXputs(SER_PORT_D, str);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serDwrite                   <RS232.LIB>

SYNTAX:		   void cof_serDwrite(const void far *data, int length);

DESCRIPTION:   Writes length bytes to the D port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serDwrite */
__scofunc void cof_serDwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
__scofunc void cof_serDwrite(const void __far *data, int length)
{
	__wfd cof_serXwrite(SER_PORT_D, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
serDflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serDflowcontrolOff(void);

DESCRIPTION:   Turns off hardware flow control for channel D.
               This function is non-reentrant.

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXflowcontrolOff
END DESCRIPTION **********************************************************/

/*** Beginheader serDflowcontrolOff */
void serDflowcontrolOff(void);
/*** Endheader */

_rs232_debug
void serDflowcontrolOff(void)
{
	serXflowcontrolOff(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDparity                   <RS232.LIB>

SYNTAX:		   void serDparity(int state);

DESCRIPTION:   Sets parity type for channel D. This function is non-reentrant.

PARAMETER1:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXparity
END DESCRIPTION **********************************************************/

/*** Beginheader serDparity*/
void serDparity(int state);
/*** Endheader */

_rs232_debug
void serDparity(int state)
{
	serXparity(SER_PORT_D, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serDdatabits                   <RS232.LIB>

SYNTAX:		   void serDdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel D.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdatabits
END DESCRIPTION **********************************************************/

/*** Beginheader serDdatabits */
void serDdatabits(int state);
/*** Endheader */

_rs232_debug
void serDdatabits(int state)
{
	serXdatabits(SER_PORT_D, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serDrdFree                   <RS232.LIB>

SYNTAX:		   int serDrdFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port D input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the D input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFree
END DESCRIPTION **********************************************************/

/*** Beginheader serDrdFree */
int serDrdFree(void);
/*** Endheader */

_rs232_debug
int serDrdFree(void)
{
	return serXrdFree(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDwrFree                   <RS232.LIB>

SYNTAX:		   int serDwrFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port D transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the D transmit buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serX
END DESCRIPTION **********************************************************/

/*** Beginheader serDwrFree */
int serDwrFree(void);
/*** Endheader */

_rs232_debug
int serDwrFree(void)
{
	return serXwrFree(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDrdUsed                   <RS232.LIB>

SYNTAX:		   int serDrdUsed(void);

DESCRIPTION:   Returns the number of characters in the D input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the D input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serDrdUsed */
int serDrdUsed(void);
/*** Endheader */

_rs232_debug
int serDrdUsed(void)
{
	return serXrdUsed(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDwrUsed                   <RS232.LIB>

SYNTAX:		   int serDwrUsed(void);

DESCRIPTION:   Returns the number of characters in the D output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the D output buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serDwrUsed */
int serDwrUsed(void);
/*** Endheader */

_rs232_debug
int serDwrUsed(void)
{
	return serXwrUsed(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDrdFlush                  <RS232.LIB>

SYNTAX:		   void serDrdFlush(void);

DESCRIPTION:   Flushes the serial port D input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serDrdFlush */
void serDrdFlush(void);
/*** Endheader */

_rs232_debug
void serDrdFlush(void)
{
	serXrdFlush(SER_PORT_D);
}

/* START FUNCTION DESCRIPTION ********************************************
serDwrFlush                  <RS232.LIB>

SYNTAX:		   void serDwrFlush(void);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port D transmit
					buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serDwrFlush */
void serDwrFlush(void);
/*** Endheader */

_rs232_debug
void serDwrFlush(void)
{
	serXwrFlush(SER_PORT_D);
}

//************************************************************************
//***************** SERIAL PORT E WRAPPERS AND COMMENTS ******************
//************************************************************************

/* START FUNCTION DESCRIPTION ********************************************
serEdmaOn							<RS232.LIB>

SYNTAX:			int serEdmaOn(int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serEopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
   				any available channel.
PARAMETER2:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
   				any available channel.

RETURN VALUE:	DMA error code or 0 for success.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOn
END DESCRIPTION **********************************************************/

/*** Beginheader serEdmaOn */
int serEdmaOn(int tcmask, int rcmask);
/*** Endheader */

#ifdef SER_DMA_DISABLE
	#fatal "Cannot use DMA with SER_DMA_DISABLE defined"
#endif

_rs232_debug
int serEdmaOn(int tcmask, int rcmask)
{
	return serXdmaOn(SER_PORT_E, tcmask, rcmask);
}

/* START FUNCTION DESCRIPTION ********************************************
serEdmaOff							<RS232.LIB>

SYNTAX:			int serEdmaOff(void);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupts just in case.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serEdmaOn

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOff
END DESCRIPTION **********************************************************/

/*** Beginheader serEdmaOff */
int serEdmaOff(void);
/*** Endheader */

_rs232_debug
int serEdmaOff(void)
{
	return serXdmaOff(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEgetError                   <RS232.LIB>

SYNTAX:		   char serEgetError(void);

DESCRIPTION:   Returns the error flags byte for serial channel E
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetError
END DESCRIPTION **********************************************************/

/*** Beginheader serEgetError */
char serEgetError(void);
/*** Endheader */

_rs232_debug
char serEgetError(void)
{
	return serXgetError(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEgetc                     <RS232.LIB>

SYNTAX:	      int serEgetc(void);

DESCRIPTION:   Get next available character from serial port E read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader serEgetc */
int serEgetc(void);
/*** Endheader */

_rs232_debug
int serEgetc(void)
{
	return serXgetc(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEread                   <RS232.LIB>

SYNTAX:		   int serEread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, E, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port E
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port E

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXread
END DESCRIPTION **********************************************************/

/*** Beginheader serEread */
int serEread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
int serEread(void __far *data, int length, unsigned long tmout)
{
	return serXread(SER_PORT_E, data, length, tmout);
}

/* START FUNCTION DESCRIPTION ********************************************
serEpeek                   <RS232.LIB>

SYNTAX:		   int serEpeek(void);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXpeek
END DESCRIPTION **********************************************************/

/*** Beginheader serEpeek */
int serEpeek(void);
/*** Endheader */

_rs232_debug
int serEpeek(void)
{
	return serXpeek(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEputc                     <RS232.LIB>

SYNTAX:	      int serEputc(char c);

DESCRIPTION:   Write a character to the serial port E write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port E write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader serEputc */
int serEputc(char c);
/*** Endheader */

_rs232_debug
int serEputc(char c)
{
	return serXputc(SER_PORT_E, c);
}

/* START FUNCTION DESCRIPTION ********************************************
serEputs                     <RS232.LIB>

SYNTAX:     	int serEputs(const char far *s);

DESCRIPTION:   Calls serEwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port E.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader serEputs */
int serEputs(const char __far *s);
/*** Endheader */

_rs232_debug
int serEputs(const char __far *s)
{
	return serXwrite(SER_PORT_E, s, strlen(s));
}

/* START FUNCTION DESCRIPTION ********************************************
serEwrite                   <RS232.LIB>

SYNTAX:		   int serEwrite(const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port E.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port E
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port E.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader serEwrite */
int serEwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
int serEwrite(const void __far *data, int length)
{
	return serXwrite(SER_PORT_E, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serEgetc                   <RS232.LIB>

SYNTAX:		   int cof_serEgetc(void);

DESCRIPTION:   Yields to other tasks until a character is read from port E.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port E

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serEgetc */
__scofunc int cof_serEgetc(void);
/*** Endheader */

_rs232_debug
__scofunc int cof_serEgetc(void)
{
	int val;
	__wfd val = cof_serXgetc(SER_PORT_E);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serEgets                   <RS232.LIB>

SYNTAX:		   int cof_serEgets(char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port E until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgets
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serEgets */
__scofunc int cof_serEgets(char __far *s, int max, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serEgets(char __far *s, int max, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXgets(SER_PORT_E, s, max, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serEread                   <RS232.LIB>

SYNTAX:	int cof_serEread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port E or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXread
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serEread */
__scofunc int cof_serEread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serEread(void __far *data, int length, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXread(SER_PORT_E, data, length, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serEputc                   <RS232.LIB>

SYNTAX:		   void cof_serEputc(int c);

DESCRIPTION:   Writes a character to the E port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serEputc */
__scofunc void cof_serEputc(int c);
/*** Endheader */

_rs232_debug
__scofunc void cof_serEputc(int c)
{
	__wfd cof_serXputc(SER_PORT_E, c);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serEputs                   <RS232.LIB>

SYNTAX:		   void cof_serEputs(const char far *str);

DESCRIPTION:   Writes a null terminated string to the E port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serEputs */
__scofunc void cof_serEputs(const char __far *str);
/*** Endheader */

_rs232_debug
__scofunc void cof_serEputs(const char __far *str)
{
	__wfd cof_serXputs(SER_PORT_E, str);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serEwrite                   <RS232.LIB>

SYNTAX:		   void cof_serEwrite(void far *data, int length);

DESCRIPTION:   Writes length bytes to the E port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serEwrite */
__scofunc void cof_serEwrite(void __far *data, int length);
/*** Endheader */

_rs232_debug
__scofunc void cof_serEwrite(void __far *data, int length)
{
	__wfd cof_serXwrite(SER_PORT_E, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
serEflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serEflowcontrolOff(void);

DESCRIPTION:   Turns off hardware flow control for channel E.
               This function is non-reentrant.

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXflowcontrolOff
END DESCRIPTION **********************************************************/

/*** Beginheader serEflowcontrolOff */
void serEflowcontrolOff(void);
/*** Endheader */

_rs232_debug
void serEflowcontrolOff(void)
{
	serXflowcontrolOff(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEparity                   <RS232.LIB>

SYNTAX:		   void serEparity(int state);

DESCRIPTION:   Sets parity type for channel E. This function is non-reentrant.

PARAMETER1:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXparity
END DESCRIPTION **********************************************************/

/*** Beginheader serEparity*/
void serEparity(int state);
/*** Endheader */

_rs232_debug
void serEparity(int state)
{
	serXparity(SER_PORT_E, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serEdatabits                   <RS232.LIB>

SYNTAX:		   void serEdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel E.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdatabits
END DESCRIPTION **********************************************************/

/*** Beginheader serEdatabits */
void serEdatabits(int state);
/*** Endheader */

_rs232_debug
void serEdatabits(int state)
{
	serXdatabits(SER_PORT_E, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serErdFree                   <RS232.LIB>

SYNTAX:		   int serErdFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port E input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the E input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFree
END DESCRIPTION **********************************************************/

/*** Beginheader serErdFree */
int serErdFree(void);
/*** Endheader */

_rs232_debug
int serErdFree(void)
{
	return serXrdFree(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEwrFree                   <RS232.LIB>

SYNTAX:		   int serEwrFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port E transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the E transmit buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serX
END DESCRIPTION **********************************************************/

/*** Beginheader serEwrFree */
int serEwrFree(void);
/*** Endheader */

_rs232_debug
int serEwrFree(void)
{
	return serXwrFree(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serErdUsed                   <RS232.LIB>

SYNTAX:		   int serErdUsed(void);

DESCRIPTION:   Returns the number of characters in the E input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the E input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serErdUsed */
int serErdUsed(void);
/*** Endheader */

_rs232_debug
int serErdUsed(void)
{
	return serXrdUsed(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEwrUsed                   <RS232.LIB>

SYNTAX:		   int serEwrUsed(void);

DESCRIPTION:   Returns the number of characters in the E output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the E output buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serEwrUsed */
int serEwrUsed(void);
/*** Endheader */

_rs232_debug
int serEwrUsed(void)
{
	return serXwrUsed(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serErdFlush                  <RS232.LIB>

SYNTAX:		   void serErdFlush(void);

DESCRIPTION:   Flushes the serial port E input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serErdFlush */
void serErdFlush(void);
/*** Endheader */

_rs232_debug
void serErdFlush(void)
{
	serXrdFlush(SER_PORT_E);
}

/* START FUNCTION DESCRIPTION ********************************************
serEwrFlush                  <RS232.LIB>

SYNTAX:		   void serEwrFlush(void);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port E transmit
					buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serEwrFlush */
void serEwrFlush(void);
/*** Endheader */

_rs232_debug
void serEwrFlush(void)
{
	serXwrFlush(SER_PORT_E);
}

//************************************************************************
//***************** SERIAL PORT F WRAPPERS AND COMMENTS ******************
//************************************************************************

/* START FUNCTION DESCRIPTION ********************************************
serFdmaOn							<RS232.LIB>

SYNTAX:			int serFdmaOn(int tcmask, int rcmask);

DESCRIPTION:   Enables DMA for serial send and receive.  This function should
               be called directly after serFopen.

               Important Flow Control Note:
               ----------------------------
               Because the DMA flowcontrol uses the external request feature,
               only 2 serial ports can use DMA flowcontrol at a time.  For
               the CTS pin, one can use PD2, PE2, or PE6, and the other can
               use PD3, PE3 or PE7.

               How DMA serial works:
               ---------------------
   				DMA Trasmit:
               When a serial function is called to transmit data, a DMA
               transfer begins.  The length of that transfer is either the
               length requested, or the rest of the transmit buffer size from
               the current position.  An interrupt is fired at the end of the
               trasmit at which time another transmit is set up if more data
               is ready to go.

               DMA Receive:
               When a serXdmaOn is called, a continuous chain of DMA transfers
               begins sending any data received on the serial line to the
               circular buffer. With flowcontrol on, there is an interrupt
               after each segment of the data transfer. At that point, if
               receiving another segment would overwrite data, the RTSoff
               function is called.

               For more details see the description at the beginning of this
               library or the Dynamic C manual.

PARAMETER1:		Channel mask for DMA transmit.  use DMA_CHANNEL_ANY to choose
   				any available channel.
PARAMETER2:		Channel mask for DMA receive.  use DMA_CHANNEL_ANY to choose
   				any available channel.

RETURN VALUE:	DMA error code or 0 for success.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOn
END DESCRIPTION **********************************************************/

/*** Beginheader serFdmaOn */
int serFdmaOn(int tcmask, int rcmask);
/*** Endheader */

#ifdef SER_DMA_DISABLE
	#fatal "Cannot use DMA with SER_DMA_DISABLE defined"
#endif

_rs232_debug
int serFdmaOn(int tcmask, int rcmask)
{
	return serXdmaOn(SER_PORT_F, tcmask, rcmask);
}

/* START FUNCTION DESCRIPTION ********************************************
serFdmaOff							<RS232.LIB>

SYNTAX:			int serFdmaOff(void);

DESCRIPTION:   Stops DMA transfers and unallocates the channels.
   				Restarts the serial interrupts just in case.

RETURN VALUE:	0 for success, DMA Error codes upon an error.

SEE ALSO:		serFdmaOn

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdmaOff
END DESCRIPTION **********************************************************/

/*** Beginheader serFdmaOff */
int serFdmaOff(void);
/*** Endheader */

_rs232_debug
int serFdmaOff(void)
{
	return serXdmaOff(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFgetError                   <RS232.LIB>

SYNTAX:		   char serFgetError(void);

DESCRIPTION:   Returns the error flags byte for serial channel F
   				This can then be compared against error bitmasks to determine
   				what errors occured. Additionally, any bits set in the returned
   				error flags will be automatically cleared. This function is
               non-reentrant.

   				Error bitmasks:
   					SER_PARITY_ERROR	0x01
   					SER_OVERRUN_ERROR 0x02
   					SER_OVERFLOW_ERROR 0x04

RETURN VALUE:	Error flags

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetError
END DESCRIPTION **********************************************************/

/*** Beginheader serFgetError */
char serFgetError(void);
/*** Endheader */

_rs232_debug
char serFgetError(void)
{
	return serXgetError(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFgetc                     <RS232.LIB>

SYNTAX:	      int serFgetc(void);

DESCRIPTION:   Get next available character from serial port F read buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:  If successful, the next character in the low byte and 0 in
               the high byte of the integer result;
               otherwise, the integer -1 which indicates either an empty
               or a locked receive buffer.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader serFgetc */
int serFgetc(void);
/*** Endheader */

_rs232_debug
int serFgetc(void)
{
	return serXgetc(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFread                   <RS232.LIB>

SYNTAX:		   int serFread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length bytes from any serial port, F, or until tmout
               milliseconds transpires between bytes. If there is no
               data available when the function is called it will
               return immediately. This function is non-reentrant.

PARAMETER1:    data  : data structure to read from serial port F
PARAMETER2:    length: number of bytes to read
PARAMETER3:    tmout : milliseconds max wait for any byte from previous one.

RETURN VALUE:	The number of bytes read from serial port F

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXread
END DESCRIPTION **********************************************************/

/*** Beginheader serFread */
int serFread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
int serFread(void __far *data, int length, unsigned long tmout)
{
	return serXread(SER_PORT_F, data, length, tmout);
}

/* START FUNCTION DESCRIPTION ********************************************
serFpeek                   <RS232.LIB>

SYNTAX:		   int serFpeek(void);

DESCRIPTION:   returns the 1st character of the data in the input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	-1 if the buffer is empty, the 1st character of the data if not

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXpeek
END DESCRIPTION **********************************************************/

/*** Beginheader serFpeek */
int serFpeek(void);
/*** Endheader */

_rs232_debug
int serFpeek(void)
{
	return serXpeek(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFputc                     <RS232.LIB>

SYNTAX:	      int serFputc(char c);

DESCRIPTION:   Write a character to the serial port F write buffer.
               This function is non-reentrant.

PARAMETER1:    c: Character to write to serial port F write buffer

RETURN VALUE:	0 if buffer locked or full, 1 if character sent

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader serFputc */
int serFputc(char c);
/*** Endheader */

_rs232_debug
int serFputc(char c)
{
	return serXputc(SER_PORT_F, c);
}

/* START FUNCTION DESCRIPTION ********************************************
serFputs                     <RS232.LIB>

SYNTAX:     	int serFputs(const char far *s);

DESCRIPTION:   Calls serFwrite(s, strlen(s)); does not write null terminator.
               This function is non-reentrant.

PARAMETER1:    s: Null terminated character string to write

RETURN VALUE:	The number of characters successfully written to serial port F.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader serFputs */
int serFputs(const char __far *s);
/*** Endheader */

_rs232_debug
int serFputs(const char __far *s)
{
	return serXwrite(SER_PORT_F, s, strlen(s));
}

/* START FUNCTION DESCRIPTION ********************************************
serFwrite                   <RS232.LIB>

SYNTAX:		   int serFwrite(const void far *data, int length);

DESCRIPTION:   Transmits length bytes to serial port F.
               This function is non-reentrant.

PARAMETER1:    data  : data structure to write to serial port F
PARAMETER2:    length: number of bytes to write

RETURN VALUE:	The number of bytes successfully written to serial port F.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader serFwrite */
int serFwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
int serFwrite(const void __far *data, int length)
{
	return serXwrite(SER_PORT_F, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serFgetc                   <RS232.LIB>

SYNTAX:		   int cof_serFgetc(void);

DESCRIPTION:   Yields to other tasks until a character is read from port F.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	The character read from serial port F

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgetc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serFgetc */
__scofunc int cof_serFgetc(void);
/*** Endheader */

_rs232_debug
__scofunc int cof_serFgetc(void)
{
	int val;
	__wfd val = cof_serXgetc(SER_PORT_F);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serFgets                   <RS232.LIB>

SYNTAX:		   int cof_serFgets(char far *s, int max, unsigned long tmout);

DESCRIPTION:   Reads characters from port F until a null terminator, carriage
   				return or linefeed is read, max characters are read, or until
   				tmout milliseconds transpires between characters after the
   				first one is read. It yields to other tasks for as long as
   				the input buffer is locked or whenever the buffer becomes
   				empty as characters are read. s will always be null terminated
   				upon return. This function is non-reentrant.


PARAMETER1:    s    : Character array into which a null terminated string is
   						 read.
PARAMETER2:    max  : The maximum number of characters to read into s, not
                      including the null terminator.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	0 - timed out before CR or max characters read, 1 - no timeout.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXgets
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serFgets */
__scofunc int cof_serFgets(char __far *s, int max, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serFgets(char __far *s, int max, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXgets(SER_PORT_F, s, max, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serFread                   <RS232.LIB>

SYNTAX:	int cof_serFread(void far *data, int length, unsigned long tmout);

DESCRIPTION:   Reads length characters from port F or until tmout milliseconds
               transpires between characters after the first one is read.
               It yields to other tasks for as long as the input buffer is
               locked or whenever the buffer becomes empty as characters
               are read. This function is non-reentrant.

PARAMETER1:    data  : Data structure into which characters are read.
PARAMETER2:    length: The number of characters to read into data.
PARAMETER3:    tmout: Millisecond wait period to allow between characters
                      before timing out.

RETURN VALUE:	Number of characters read into data.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXread
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serFread */
__scofunc int cof_serFread(void __far *data, int length, unsigned long tmout);
/*** Endheader */

_rs232_debug
__scofunc int cof_serFread(void __far *data, int length, unsigned long tmout)
{
	int val;
	__wfd val = cof_serXread(SER_PORT_F, data, length, tmout);
	return val;
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serFputc                   <RS232.LIB>

SYNTAX:		   void cof_serFputc(int c);

DESCRIPTION:   Writes a character to the F port. It yields to other tasks
               for as long as the output buffer may be locked or full.
               This function is non-reentrant.

PARAMETER1:    c: Character to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputc
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serFputc */
__scofunc void cof_serFputc(int c);
/*** Endheader */

_rs232_debug
__scofunc void cof_serFputc(int c)
{
	__wfd cof_serXputc(SER_PORT_F, c);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serFputs                   <RS232.LIB>

SYNTAX:		   void cof_serFputs(const char far *str);

DESCRIPTION:   Writes a null terminated string to the F port. It yields to
               other tasks for as long as the output buffer may be locked or
               becomes full as characters are written. This function is
               non-reentrant.

PARAMETER1:    s: Null terminated character string to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXputs
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serFputs */
__scofunc void cof_serFputs(const char __far *str);
/*** Endheader */

_rs232_debug
__scofunc void cof_serFputs(const char __far *str)
{
	__wfd cof_serXputs(SER_PORT_F, str);
}

/* START FUNCTION DESCRIPTION ********************************************
cof_serFwrite                   <RS232.LIB>

SYNTAX:		   void cof_serFwrite(const void far *data, int length);

DESCRIPTION:   Writes length bytes to the F port. It yields to other tasks
               for as long as the output buffer may be locked or becomes
               full as characters are written. This function is non-reentrant.

PARAMETER1:    data  : Data structure to write.
PARAMETER2:    length: Number of bytes in data to write.

RETURN VALUE:	None.

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see cof_serXwrite
END DESCRIPTION **********************************************************/

/*** Beginheader cof_serFwrite */
__scofunc void cof_serFwrite(const void __far *data, int length);
/*** Endheader */

_rs232_debug
__scofunc void cof_serFwrite(const void __far *data, int length)
{
	__wfd cof_serXwrite(SER_PORT_F, data, length);
}

/* START FUNCTION DESCRIPTION ********************************************
serFflowcontrolOff                   <RS232.LIB>

SYNTAX:		   void serFflowcontrolOff(void);

DESCRIPTION:   Turns off hardware flow control for channel F.
               This function is non-reentrant.

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXflowcontrolOff
END DESCRIPTION **********************************************************/

/*** Beginheader serFflowcontrolOff */
void serFflowcontrolOff(void);
/*** Endheader */

_rs232_debug
void serFflowcontrolOff(void)
{
	serXflowcontrolOff(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFparity                   <RS232.LIB>

SYNTAX:		   void serFparity(int state);

DESCRIPTION:   Sets parity type for channel F. This function is non-reentrant.

PARAMETER1:		Parity mode to use:
   					PARAM_NOPARITY
   					PARAM_EPARITY
   					PARAM_OPARITY
   					PARAM_MPARITY	(Mark, always 1)
   					PARAM_SPARITY	(Space, always 0)
					Stop bits:
						PARAM_1STOP		(send one stop bit, default setting)
   					PARAM_2STOP 	(send two stop bits)

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXparity
END DESCRIPTION **********************************************************/

/*** Beginheader serFparity*/
void serFparity(int state);
/*** Endheader */

_rs232_debug
void serFparity(int state)
{
	serXparity(SER_PORT_F, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serFdatabits                   <RS232.LIB>

SYNTAX:		   void serFdatabits(int state);

DESCRIPTION:   Sets number of data bits to use for channel F.
               This function is non-reentrant.

PARAMETER1:		A bit mask setting the number of bits used
   				PARAM_7BIT	0x01
   				PARAM_8BIT	0x00

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXdatabits
END DESCRIPTION **********************************************************/

/*** Beginheader serFdatabits */
void serFdatabits(int state);
/*** Endheader */

_rs232_debug
void serFdatabits(int state)
{
	serXdatabits(SER_PORT_F, state);
}

/* START FUNCTION DESCRIPTION ********************************************
serFrdFree                   <RS232.LIB>

SYNTAX:		   int serFrdFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port F input buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the F input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFree
END DESCRIPTION **********************************************************/

/*** Beginheader serFrdFree */
int serFrdFree(void);
/*** Endheader */

_rs232_debug
int serFrdFree(void)
{
	return serXrdFree(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFwrFree                   <RS232.LIB>

SYNTAX:		   int serFwrFree(void);

DESCRIPTION:   Returns the number of characters of unused data space in the
               port F transmit buffer. This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of chars it would take to fill the F transmit buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serX
END DESCRIPTION **********************************************************/

/*** Beginheader serFwrFree */
int serFwrFree(void);
/*** Endheader */

_rs232_debug
int serFwrFree(void)
{
	return serXwrFree(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFrdUsed                   <RS232.LIB>

SYNTAX:		   int serFrdUsed(void);

DESCRIPTION:   Returns the number of characters in the F input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the F input buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serFrdUsed */
int serFrdUsed(void);
/*** Endheader */

_rs232_debug
int serFrdUsed(void)
{
	return serXrdUsed(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFwrUsed                   <RS232.LIB>

SYNTAX:		   int serFwrUsed(void);

DESCRIPTION:   Returns the number of characters in the F output buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	the number of characters currently in the F output buffer

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrUsed
END DESCRIPTION **********************************************************/

/*** Beginheader serFwrUsed */
int serFwrUsed(void);
/*** Endheader */

_rs232_debug
int serFwrUsed(void)
{
	return serXwrUsed(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFrdFlush                  <RS232.LIB>

SYNTAX:		   void serFrdFlush(void);

DESCRIPTION:   Flushes the serial port F input buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXrdFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serFrdFlush */
void serFrdFlush(void);
/*** Endheader */

_rs232_debug
void serFrdFlush(void)
{
	serXrdFlush(SER_PORT_F);
}

/* START FUNCTION DESCRIPTION ********************************************
serFwrFlush                  <RS232.LIB>

SYNTAX:		   void serFwrFlush(void);

DESCRIPTION:   Flushes (i.e., does not transmit) the serial port F transmit
					buffer.
               This function is non-reentrant.

PARAMETER1:    None

RETURN VALUE:	None

NOTE:				This function has been generalized for all serial ports.
   				For complete information, see serXwrFlush
END DESCRIPTION **********************************************************/

/*** Beginheader serFwrFlush */
void serFwrFlush(void);
/*** Endheader */

_rs232_debug
void serFwrFlush(void)
{
	serXwrFlush(SER_PORT_F);
}

//************************************************************************
//************************* Parity Check *********************************
//************************************************************************

/*** BeginHeader ser_paritytable */
extern const char ser_paritytable[];
/*** EndHeader */
// The parity table contains a value of 0x80 if there are an even number of
// bits for the given byte index.
// This is the correct mask for setting 8th bit for odd parity with 7-bit data
const char ser_paritytable[] = {
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,
        0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80
};

/*** BeginHeader ser_genparitytable */
void ser_genparitytable(void);
/*** EndHeader */
// Used to generate the code above for the definition of ser_paritytable[].
// Not used in production code -- only run if you need to regenerate the
// ser_paritytable[] declaration.
void ser_genparitytable(void)
{
   auto int i;
   auto int j;
   auto int count;

	printf( "const char ser_paritytable[] = {\n\t");
   for (i = 0; i < 256; i++)
   {
   	if (i)
   	{
			printf( ",%s", (i & 0x07) ? " " : "\n\t");
   	}

      count = 0;
      for (j = 0; j < 8; j++)
      {
         if (i & (1 << j)) count++;
      }
      printf( "0x%02x", (count % 2) ? 0 : 0x80);
   }
   printf( "\n};\n");
}

/*** BeginHeader ser8_getparity */
__root int ser8_getparity(int HL);		//asm call, don't use in C
/*** EndHeader */
/*
	ser8_getparity() -- deprecated on Rabbit 4000 and later
*/

#asm __root
; returns parity bit for an 8bit data byte (9bit byte)
; assumes byte is in L, parity flag is in H - 0 for odd, 1 for even
; returns parity bit in hl
; trashes A register
ser8_getparity::
	push	ix

	; load byte from parity table into A, adjusting for even/odd parity
	ld		ix, ser_paritytable
	ld		a, L
	xor	h
	ld		a, (ix+a)

	; HL = (A == 0x80) ? 1 : 0
	cp		0x80
	flag	eq, hl

	pop	ix
	ret
#endasm


/*** BeginHeader ser7_setparity */
__root int ser7_setparity(int HL);		//asm call, don't use in C
/*** EndHeader */
#asm __root
; sets the parity bit for a 7bit character
; assumes character in L, parity flag in H - 0 for odd, 1 for even
; returns parity fixed byte in L
; trashes A register
ser7_setparity::
	push	ix
	res	7, L		; strip high bit from l

	; load byte from parity table into A, adjusting for even/odd parity
	ld 	ix, ser_paritytable
	ld		a, L
	xor	h
	ld		a, (ix+a)

	; OR the byte into the mask and then store back in L
	or		L
	ld		L, a
	pop	ix
	ret
#endasm

/*** BeginHeader ser7_checkparity */
__root int ser7_checkparity(int HL);		//asm call, don't use in C
/*** EndHeader */
#asm __root
;checks if the parity for a byte with 7 data bits is correct
;L contains the byte to check, H holds the parity type flag -
;0 for odd, 1 for even
;returns true on hl if parity is correct
; trashes A register
; (note that this is the opposite return value of ser8_getparity)
ser7_checkparity::
	push	ix

	; load byte from parity table into A, adjusting for even/odd parity
	ld		ix, ser_paritytable
	ld		a, L
	xor	h
	ld		a, (ix+a)

	; HL = (A != 0x80) ? 1 : 0
	cp		0x80
	flag	neq, hl

	pop	ix
	ret
#endasm

/*** Beginheader serSetParity */
char serSetParity(char tx_byte, char parity);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
serSetParity                  <RS232.LIB>

SYNTAX:		   char serSetParity(char tx_byte, char parity);

DESCRIPTION:   returns an 8bit version of the input byte with the high bit set
   				for correct parity

PARAMETER1:    tx_byte : the original 7bit character without a parity bit
PARAMETER2:    parity: This can be one of two character values
   						  'E' - even parity, returned character will have
   						   	even number of set bits
   						  'O' - odd parity, returned character will have
   						  		odd number of set bits

RETURN VALUE:	The tx_byte with its high bit set for correct parity

END DESCRIPTION **********************************************************/
_rs232_debug
char serSetParity(char tx_byte, char parity)
{
   tx_byte = tx_byte & 0x7f;
   if (parity == 'O')
   {
   	// table has masks for setting odd parity directly
   	return (tx_byte | ser_paritytable[tx_byte]);
   }
   else if (parity == 'E')
   {
   	// set bit, then clear if necessary
   	return (tx_byte | 0x80) & ~(ser_paritytable[tx_byte]);
   }
   else
   {
   	// bad parity type character, what do we do???
   	return 0;
   }
}

/*** Beginheader serCheckParity */
int serCheckParity(char rx_byte, char parity);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
serCheckParity                  <RS232.LIB>

SYNTAX:		   int serCheckParity(char rx_byte, char parity);

DESCRIPTION:   returns true if parity of rx_byte matches the parity type given
   				for the sake of speed, this function does not check for
   				invalid parity types

PARAMETER1:    rx_byte : character for which parity bit will be checked
PARAMETER2:    parity: This can be one of two character values
   						  'E' - even parity, returns true if even number of
   						   	set bits
   						  'O' - odd parity, returns true if odd number of
   						   	set bits

RETURN VALUE:	1 if parity is correct
   				0 if parity is not correct

END DESCRIPTION **********************************************************/
_rs232_debug
int serCheckParity(char rx_byte, char parity)
{
   if ( (rx_byte & 0x80) ^ (ser_paritytable[rx_byte & 0x7f]) )
   {
   	// high bit does not match parity table mask
   	return (parity == 'E');
   }
   else
   {
   	return (parity == 'O');
   }
}

/*** BeginHeader */
#endif
/*** EndHeader */



