/*** BeginHeader */
#ifndef __FAT16_LIB
#define __FAT16_LIB

#define FAT_VERSION 0x0402

/*** EndHeader */


/* START LIBRARY DESCRIPTION *********************************************
FAT16.LIB

COPYRIGHT - NCT AG (c) 2002 - 2003
COPYRIGHT - Digi International, Inc. (c) 2003 - 2010

Compact FAT Filesystem supporting FAT16

All basic operations are supported like

- partitioning a media which is mounted as a "device"
- formatting partitions or removeable media
- creating and deleting directories and subdirectories with "n" levels
- creating and deleting, reading writing and seeking in files
- reading directories (browse)

Note though that features can be compiled in or out - see the CONFIGURATION
section below.

Gotchas and general information:
- DON'T USE FUNCTIONS THAT START WITH AN UNDERSCORE UNLESS YOU ARE CODING FOR
  THIS LIBRARY AND OR YOU HAVE A DEEP UNDERSTANDING OF THE INNER DEPENDENCIES
  OF THE FUNCTIONS! Functions starting with an underline are internal functions
  and heavily rely on the context of the whole library. Violation of this rule
  is likely to result in a total data loss for the active partition(s) or the
  whole device..

- In order to understand the API and implementation properly some terms need
  to be defined more precisely.
  - We speak about a DRIVER as a software driver which works with the
  	 underlying hardware & media to create a storage system that can host
	 "n" DEVICES. Real world examples of media would be a Flash Memory
	 driver/interface, a SCSI driver/controller, an ATA/IDE bus
    driver/contoller, etc.
  - We speak about a DEVICE as a physical device or media hosting one to four
	 PARTITIONS. Note, some removeable devices may have no master boot record
	 and therefore no partition table, these are not currently supported in this
    library.  You may partition such removeable media and then it would be
    useable with this library.  A real world example of such media is a
    CompactFlash or SD card.
  - We speak about a PARTITION as a range of logical sectors on a device which
	 contains a file system. If this filesystem is a FAT-16 filesystem we can
	 operate on it. Real world examples of what we understand as a partition is
	 what's commonly known as the "drive C:" in a PC.

- The proper sequence of calls to start using FAT16.LIB is to first call all
  xxx_InitCtrl() functions of all drivers that are present in a system.
  Note, these functions are NOT part of FAT16.LIB, but must exist in low level
  driver modules used to interface the devices.  One such low level module
  is sflash.lib, which may serve as starting point for other implementations.
  One driver should be selected as the 'primary driver' and should
  be the first one initialized.  Then fat_Init may be used to easily
  enumerate and mount the specified partition on device 0, or fat_AutoMount may
  be used to enumerate and mount (by default) all FAT partitions on any FAT
  useable devices.

  In the case of sflash.lib, there is only one device and it is device 0, while
  nflash_fat.lib supports up to two devices, 0 and 1.  After a successful call
  to either fat_Init or fat_AutoMount, all other file and directory functions
  are useable on the mounted partition(s).  Your application may also mount
  additional partitions if desired, if they are available (as when new removable
  media is inserted or installed).

  To stop operating a filesystem fat_UnmountPartition() must be called. If a
  removeable device shall be taken out of the system, all partitions that are
  mounted must first be unmounted. fat_UnmountPartition() closes all files
  that are open so closing the files beforehand is optional. However the
  application almost certainly needs to know about the device removal. NOTE,
  removing a device with mounted partitions can lead to dataloss if write
  operations were made that have not been flushed to the media.

Limitations:

- While all 4 potentially present master partitions per device are seen (and
  respected), currently only the following partition types are supported:
      0x04 (fat16), 0x06 (fat16), 0x0e (fat16 lba)

- The partition limitation above DOES NOT include extended partitions.  There
  are no plans to offer extended partition support now or in the future.
  This does mean that a device is limited to 4 partitions or volumes.

- NOTE! The previously mentioned partition types are not binding. They only
  serve as an identifier to look at the BPB of the partition. In other words,
  in theory it could be that the type info in the MBR would suggest that the
  partition is of type FAT16 but in reality it would be a FAT12 partition etc.
  So, the TYPE of the filesystem is exclusively computed based on the number of
  clusters present on a volume and by nothing else. This is according to the
  FAT specification as written by Microsoft.

- No long file names, this is FAT, NOT VFAT!!! The long name part of
  entries found in directories is simply ignored. Files could be created
  with OS's operating with long names, but the non-DOS name parts are neither
  updated nor maintained in any ways. Deleting a file with long names results
  in dangling long name elements. This does not hurt software using this
  library, but no tests were made with regard to using such volumes with other
  operating systems. Attempts to create long file names with this library will
  fail.

- The FAT library strictly uses lba sector addresses internally. It's the IO
  modules responsibility to translate such addresses into proper cylinder/
  head/sector information if such a need arises.

- The library has only been tested on 512 byte sectors.

- Supports a maximum of 16 devices per driver.

- uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

History:
        SEE ReleaseNotes_FAT.txt

END DESCRIPTION **********************************************************/

/*** BeginHeader */

/*************************************************************************/
/* CONFIGURATION CONFIGURATION CONFIGURATION CONFIGURATION CONFIGURATION */
/*************************************************************************/

/* lines in this section are here to "configure" the library and therefore
	the memory footprint vs. functionalty. */

//#define FAT16_READONLY 		// disables write operations to all devices
#ifndef FAT16_READONLY
#define FAT_WRITEACCESS
#endif

//#define FAT_BLOCK 	         // sets library to 'blocking' mode
//#define FAT_DEBUG 				// outputs debug printf statements etc.

//#define FAT_USE_FORWARDSLASH  	// Sets forward slash instead of back slash
											//  as the path separator

#define FAT_MIN_CLUST_SIZE  4    // Sets minumum cluster size (in 512 byte
                                 //  sectors) for sector based FTL's
                                 //  Must be a power of 2

/***********************************************************************/
/* END OF CONFIGURATION - END OF CONFIGURATION - END OF CONFIGURATION  */
/***********************************************************************/

/*****************************************************************
 Convenience macros to use with API functions needing a fat_part
 argument. If only using one partition per device DEVICE_A is the
 soldered on  flash for the RCM3360 or RCM3365, and DEVICE_B is the Xd card.
 If using the RCM3370 or RCM3375 and one partition DEVICE_A is the Xd card.
******************************************************************/
#define DRIVE_A  fat_part_mounted[0]
#define DRIVE_B  fat_part_mounted[4]
/*****************************************************************
 If using more than one partition per device,
 use PARTITION_A - PARTITION_D for first device (soldered on NAND
 flash for the RCM3360 or RCM3365, XD card for the RCM3370 or RCM3375)
 Use PARTITION_E - PARTITION_H for the second device (XD card on the
 RCM3370 or RCM3375)
******************************************************************/
#define PARTITION_A  fat_part_mounted[0]
#define PARTITION_B  fat_part_mounted[1]
#define PARTITION_C  fat_part_mounted[2]
#define PARTITION_D  fat_part_mounted[3]
#define PARTITION_E  fat_part_mounted[4]
#define PARTITION_F  fat_part_mounted[5]
#define PARTITION_G  fat_part_mounted[6]
#define PARTITION_H  fat_part_mounted[7]

// Run time error number if mutex error with uC/OS-II
#ifndef ERR_FAT_MUTEX_ERROR
	#define  ERR_FAT_MUTEX_ERROR  (-EFATMUTEX)
#endif

#ifdef FAT_USE_UCOS_MUTEX
  #ifndef FAT_BLOCK
    #error "FAT must be used in blocking mode with uC/OS-II."
    #fatal "    You must #define FAT_BLOCK in your program."
  #endif
  #ifndef FAT_MUTEX_TIMEOUT_SEC
    #define FAT_MUTEX_TIMEOUT_SEC 5
  #endif
  // Number of OS ticks for time-out
  #define FAT_MUTEX_TIMEOUT (OS_TICKS_PER_SEC*FAT_MUTEX_TIMEOUT_SEC)
  extern void* fat_Mutex; // Will be used as OS_EVENT*
  void* fat_Mutex;        //   Use void* here so it doesn't
                          //   matter if OS_EVENT is defined yet
#endif

#ifdef FAT_BLOCK
	#define FAT_BLOCK_FLAGS		FTC_WAIT
#else
	#define FAT_BLOCK_FLAGS		0
#endif

#ifdef FAT_DEBUG
	#define _fat_debug __debug
#else
	#define _fat_debug __nodebug
#endif

#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_RAW 3

/* The file types as used within this library. */
#define FAT_FILE		0x55			/* this is an ordinary file */
#define FAT_DIR		0x56			/* this is a directory */
#define FAT_LABEL		0x57			/* this is a label. Only one permitted
												per partition, only in __root directory */

/* Internal FAT type definitions */
#define FAT_TYPE_MASK	0x000f		// Mask to evaluate partition type
#define FAT_TYPE_NO		0x0000		// Not a FAT partition - ignored by us
#define FAT_TYPE_12		0x0001		// This is a FAT12 type partition
#define FAT_TYPE_16		0x0002		// This is a FAT16 type partition
#define FAT_TYPE_32		0x0003		// This is a FAT32 type partition**
#define FAT_TYPE_VOL		0x0080		// Not a partition, but a FAT volume**
#define FAT_TYPE_MTD		0x8000		// Mounted partition
	// ** = These are for possible future support

// Mode flags for calling fat_Open...
#define FAT_OPEN			0x0000	/* Object must already exist */
   // do not use 0x0001 or 0x0002
#define FAT_CREATE		0x0100	/* Create object only if it does not exist */
#define FAT_MUST_CREATE	(0x0200|FAT_CREATE)	/* Create the object;
                                                  error if it already exists */
   // following bits set in file->flag field.
#define FAT_SEQUENTIAL	  0x04	// File in sequential access mode.  Changes
											// cache requests such that when the last byte
                              	// of a physical page is read/written, the
                              	// cache entry is set to LRU.
#define FAT_READONLY      0x08 	// File is opened in read-only mode.  Can make
                              // some optimizations in open processing.
#define FAT_MODEFLAGS (FAT_SEQUENTIAL|FAT_READONLY)

// Mode flags for fat_ReadDir
#define FAT_INC_LNAME   0x0040   // Return long name entries in the directory
#define FAT_INC_EMPTY	0x0080	// Return empty entries in the directory
#define FAT_INC_DEL		0x4000	// Return deleted entries in the directory
#define FAT_INC_ACTIVE	0x8000	// Return active entries in the directory
#define FAT_INC_ALL		0xC0FF	// Return ALL entries
#define FAT_INC_DEF		0x8031   // Default directory filter

#define FAT_FIL_RD_ONLY	0x0100   // Filter on read-only attribute
#define FAT_FIL_HIDDEN	0x0200   // Filter on hidden attribute
#define FAT_FIL_SYSTEM	0x0400   // Filter on system attribute
#define FAT_FIL_DIR		0x1000   // Filter on directory attribute
#define FAT_FIL_ARCHIVE	0x2000   // Filter on modified attribute

// Position codes for fat_Split and fat_Trunc
#define FAT_BRK_END		-1		// Break file at EOF position
#define FAT_BRK_POS		-2    // Break file at current position pointer

#ifndef FAT_MAX_PARTITIONS
 #define FAT_MAX_PARTITIONS  4  /* Allow all primary partitions if unstated */
#endif

/* Some fixed FAT constants */
#define FAT_DIRPS		16			/* number of directory entries per sector */
#define FAT_DIRSZ		32			/* size in bytes of a directory entry */
#define FAT_ROOTSZ	512		/* default max entries in root directory */
#define FAT_SECSIZE	512		/* size of a sector (Must be power of 2) */
#define SEC_32MB	 0x010000	/* Number of 512 byte sectors on 32MB device */
#define SEC_64MB	 0x020000	/* Number of 512 byte sectors on 64MB device */
#define SEC_128MB	 0x040000	/* Number of 512 byte sectors on 128MB device */
#define SEC_256MB	 0x080000	/* Number of 512 byte sectors on 256MB device */
#define SEC_512MB	 0x100000	/* Number of 512 byte sectors on 512MB device */
#define SEC_1GB	 0x200000	/* Number of 512 byte sectors on 1GB device */
#define SEC_2GB	 0x400000	/* Number of 512 byte sectors on 2GB device */
#define SEC_4GB	 0x800000	/* Number of 512 byte sectors on 4GB device */
#define SEC_8GB	0x1000000	/* Number of 512 byte sectors on 8GB device */

#define FAT_BADMARK  0xFFF7   /* Bad cluster marker for FAT table */
#define FAT_EOC      0xFFFF   /* End of chain marker for FAT table */

#ifndef EDRVBUSY              // For backwards compatibility with DC9.01
  #define  EDRVBUSY       309 // Driver level is busy, new write not started
#endif

/**
 * 	Which way does your slash character lean ?  Application can override.
 * 	NOTE: This affects directory separator.  Neither slash can be part of
 * 	a filename or label (see _fat_invalid_label_chars[] below).
 * 	(Use numbers rather than char constants works around DC8 compiler bug.)
 * 	If FAT_USE_FORWARDSLASH is not defined, then backslash is default.
 * 		FAT_SLASH_STR -- handy for compiler string concatenation.
 */
#ifdef FAT_USE_FORWARDSLASH
	#define FAT_SLASH_CH 	'/'
   #define FAT_SLASH_STR	"/"
   #define _FATX_OTHER_SLASH_CH (0134)		/* for error checking '\\' */
#else
	#define FAT_SLASH_CH 	'\134'
   #define FAT_SLASH_STR	"\134"
   #define _FATX_OTHER_SLASH_CH ('/') 		/* for error checking '/' */
#endif

#use "part.lib"           // MBR partition library

/* These are public global variables for primary driver and ftc part */
mbr_drvr *fat_sysdriver;
int fat_sysftc;

/* This structure describes a location as both a cluster with the offset
	into it and as an absolute sector with the offset into it. */
typedef struct
{
	unsigned long s_cluster;		/* starting cluster (for FAT) */
	unsigned long cluster;			/* temporary cluster */
	unsigned long offset;	 		/* offset within cluster */

	unsigned long sector;			/* sector of entry/file (for access speed) */
	unsigned int sofs;				/* sector offset */

	/* the following fields are used in two contexts. During opening the
		file, they serve as an identifier of a potential first unused slot in
		the directory. Once the file is open they point to the directory entry
		of the file so that the directory can be easily updated (size wise) if
		the file is closed. */
	unsigned long u_cluster;	 /* cluster holder during allocation,
                                   also seek offset byte count for fat_Seek() */
	unsigned long u_sector;		 /* sector of first unused entry / dir */
	unsigned int u_sofs;			 /* sector offset of above */
   unsigned int u_flags;		 /* Flags as follows: */
#define FAT_USOFS_DELETED	0x8000	// u_* points to deleted directory entry
	int	nav_offset;				 // Offset into the pathname string of the
   									 // directory component being examined by
                               // _fat_navigate et al.
   int	nav_state;				 // 0: initial; 1: reading dirent;
                               // 2: fat_Status() read; 3,4 used by fat_checkdir;
   									 //  5 used by _fat_scan (along with 0/1);
                               // Also uses FAT_FILESTATE_CRn states for
                               // _fat_create
   int	nav_sec;						// Sector counter for nonblocking mode
   char	dname[12];					// Name as stored in directory entry
} fat_location;

/* Information for working on a file. Every open file has a copy of this. */
typedef struct _FATfile
{
	struct _fat_part *part;		/* partition on which this file resides */
	int type;						/* type of file see FAT_FILE etc. */
	char flag;						/* flag: see below */
		#define FAT_ACCESSED	0x01	/* this file was accessed - set the time
														at close */
		#define FAT_MODIFIED	0x02	/* this file was modified - set the time
														and date at close */
      // NOTE: other flags correspond to flag setting on fat_Open call
      //       (FAT_SEQUENTIAL etc.)
	struct {
   	// This sub-structure must be the same as fat_dirent, except without the
      // 11-byte name field.  This is a cache of the marker value (dirent_mark).
      // There is no marker for the root directory, however the fileSize field
      // is set to the root dir length.  The fileSize field is always written
      // back as zero for directory entries (other than the root dir!).
	   char     attr;          // Attributes
	   char     resv;    // Reserved for Win NT
	   char     crtTimeTenth;  // Create time 'tenths' + LSB of seconds ( 0-19 )
	   word     crtTime;       // Create time
	   word     crtDate;       // Creation date
	   word     lstAccDate;    // Last access date (no time!)
	   word     fstClustHi;    // Hi word of first cluster
	   word     wrtTime;       // Last write time
	   word     wrtDate;       // Last write date
	   word     fstClustLo;    // Lo word of first cluster
	   unsigned long fileSize; // EOF position.
   } de;

	fat_location loc;				/* location info */

	unsigned long pos;			/* position pointer offset in bytes from start */
   int dirent_mark;           /* Rollback marker for file size */

	struct _FATfile *next;		/* linked list of open files per part */
	int state;						/* File-level operation state. This has two parts:
   									   MSB contains 'classification' of the operation
                                      in progress;
                                 LSB contains the state of that operation. */
   	// Classification...
   	#define FAT_OP_OPEN		0x0100
      #define FAT_OP_CLOSE		0x0400
      #define FAT_OP_SPLIT		0x0500
      #define FAT_OP_TRUNC		0x0600
      #define FAT_OP_DELETE	0x0700
      #define FAT_OP_SYNC		0x0800
   	#define FAT_OP_CREATE	0x0900
   	#define FAT_OP_SEEK		0x0A00
   	#define FAT_OP_WRITE		0x0B00

      // This is a special code for when the file struct is not initialized
      // or closed.
   	#define FAT_FILESTATE_NOTOPEN 	0		// Null state: not yet open

      // Detailed states for each classification...
   	#define FAT_FILESTATE_INIT 		(1|FAT_OP_OPEN)
      #define FAT_FILESTATE_NAV			(2|FAT_OP_OPEN)
      #define FAT_FILESTATE_GETPATH		(3|FAT_OP_OPEN)
		#define FAT_FILESTATE_EXTDIR		(4|FAT_OP_OPEN)
      #define FAT_FILESTATE_CREATE		(5|FAT_OP_OPEN)
      #define FAT_FILESTATE_FOUND		(6|FAT_OP_OPEN)
      #define FAT_FILESTATE_DIRLEN		(7|FAT_OP_OPEN)
      #define FAT_FILESTATE_IDLE			(8|FAT_OP_OPEN)	// Open, and idle

      #define FAT_FILESTATE_CLOSE		(1|FAT_OP_CLOSE)

      #define FAT_FILESTATE_SP_END			(0|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_TRANS		(1|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_VERIFY		(2|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_UPD_FILE  	(3|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_MARK1		(4|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_MARK2		(5|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_MARK3		(6|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_MARK4		(7|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_EXP_DIR		(8|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_ADD_DIR		(9|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_CLR_DIR		(10|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_SAV_NAME  	(11|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_SAV_DIR		(12|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SP_GET_MRKR  	(13|FAT_OP_SPLIT)
      #define FAT_FILESTATE_SPLIT_ERR		(14|FAT_OP_SPLIT)

      #define FAT_FILESTATE_TR_NEXT		(1|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TR_START	(2|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TR_MARK		(4|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TR_MARK1	(5|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TR_MARK2	(6|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TR_MARK3	(7|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TR_FREE 	(8|FAT_OP_TRUNC)
      #define FAT_FILESTATE_TRUNC_ERR	(9|FAT_OP_TRUNC)

      #define FAT_FILESTATE_SYNC			(1|FAT_OP_SYNC)

      #define FAT_FILESTATE_SEEK			(1|FAT_OP_SEEK)
      #define FAT_FILESTATE_SEEK1		(2|FAT_OP_SEEK)

      #define FAT_FILESTATE_WRITE		(1|FAT_OP_WRITE)

      // These values actually used in loc->nav_state
      // (while filestate contains FAT_FILESTATE_CREATE)
      #define FAT_FILESTATE_CR_INIT		FAT_OP_CREATE
      #define FAT_FILESTATE_CR_NEW		(1|FAT_OP_CREATE)
      #define FAT_FILESTATE_CR_CLEAR	(2|FAT_OP_CREATE)
      #define FAT_FILESTATE_CR_START	(3|FAT_OP_CREATE)
      #define FAT_FILESTATE_CR_DENTRY	(4|FAT_OP_CREATE)
      #define FAT_FILESTATE_CR_UPDATE	(5|FAT_OP_CREATE)
      #define FAT_FILESTATE_CR_ALLOC	(6|FAT_OP_CREATE)
      #define FAT_FILESTATE_ERR			(7|FAT_OP_CREATE)

} FATfile;

/* Structure holding general & FAT specific information about a partition */
typedef struct _fat_part
{
   /* FAT specific information of the partition */
	unsigned int sec_clust;			/* number of sectors per cluster */
	unsigned int fat_cnt;			/* number of fat's */
   unsigned int fat_len;         /* size of one fat table in bytes/2 */
	unsigned int root_cnt;			/* number of entries in root directory */
	unsigned int res_sec;			/* number of reserved sectors */
	unsigned int byte_sec;			/* bytes per sector */
	unsigned long sec_fat;			/* number of sectors per FAT */
	unsigned long serialnumber;	/* set when formatted */

   /* Counters/stats about the partition */
	unsigned long totcluster;		/* the total number of clusters */
	unsigned long badcluster;		/* the number of bad clusters */
	unsigned long freecluster;		/* the number of free clusters */
	unsigned long nextcluster;		/* for circular allocation of new clusters */

	/* The following entries are calculated to speed up processing */
	unsigned long fatstart;			/* starting sector of first FAT */
	unsigned long rootstart;		/* starting sector of root directory */
	unsigned long datastart;		/* starting sector of data area */
	unsigned long clustlen;			/* sec_clust * byte_sec */

	int type;							/* Type of partition (FAT_TYPE_..) */
   int ftc_prt;						/* Journal number registered with FTC */
   int pnum;							/* Partition number (in MBR) */

   int opstate;						// Operation state (Idle, Allocate, Delete)
		#define FAT_PART_IDLE     0      // Idle state (Allocate or deletion only)
		#define FAT_PART_SUBSTATE 0x0FFF // Mask for bits used as sub-state value
      #define FAT_PART_MOUNT    0x1000 // Flag to show mount in progress
      #define FAT_PART_UNMNT    0x2000 // Flag to show unmount in progress
		#define FAT_PART_ALLOC    0x4000 // Flag to show allocation in progress
		#define FAT_PART_DEL      0x8000 // Flag to show deletion in progress
   int opcount;						// Operational counter
	unsigned int  clust1;			// begining cluster values during allocation
	unsigned int  clust2;			// read buffer for clusters during allocation
   void *active;						// Pointer to active operation structure
	unsigned int  linkclust;		// Cluster to link new block to

	mbr_part *mpart;					/* mbr partition record for this partition */
	mbr_dev *dev;						/* physical device partition belongs to */
	FATfile *first;					/* linked list of files */
}  fat_part;

// BPB data section, at the begining of each partition.  62 bytes.
typedef struct
{
	char		jmpBoot[3];		// Jump instuction to Boot Code
	char		OEMname[8];		// OS Name string
   word		byte_sec;		// Bytes per sector
   char		sec_clust;		// Sectors per cluster
   word		res_sec;			// Reserved sector count (FAT12/16=1 FAT32=32)
   char		fat_cnt;			// Number of FAT tables
   word		root_cnt;		// Number of Entries in Root Directory
   word		sec_cnt16;		// Total Number of Sectors (if 0, look to sec_cnt32)
   char		media;			// Media type (0xF8 = fixed, 0xF0 = removable)
   word		sec_fat;			// Sectors per FAT table (if 0, look to sec_fat32)
   word		sec_track;		// Sectors per track for INT13 (Not used here)
   word		heads;			// Number of heads for INT13 (Not used here)
   unsigned long hid_sec;	// Count of hidden sectors for INT13 (Not used here)
   unsigned long sec_cnt32;  // Total Number of Sectors (if 0, see sec_cnt16)
   char		drv_num;			// Drive number for INT13 (0x80 = hard drive)
   char		reserved;		// Reserved for use by WIN-NT
   char		boot_sig;		// Extended boot signature (set to 0x29)
   unsigned long vol_ID;   // Volume serial number
	char		vol_label[11];	// Volume label
	char		fs_type[8];		// File system type "FAT12   " or "FAT16   "
} _fat_bpb;

// Directory entry mapping, as it appears on disk.  32 bytes.
typedef struct
{
	char		name[11];		// Short name (blank padded 8+3)
	char		attr;				// Attributes:
#define FATATTR_READ_ONLY	0x01
#define FATATTR_HIDDEN		0x02
#define FATATTR_SYSTEM		0x04
#define FATATTR_VOLUME_ID	0x08
#define FATATTR_DIRECTORY	0x10
#define FATATTR_ARCHIVE		0x20
#define FATATTR_LONG_NAME	0x0F
   char		resv;		// Reserved for Win NT
   char		crtTimeTenth;	// Create time 'tenths' + LSB of seconds hence 0-19
   word		crtTime;			// Create time
   word		crtDate;			// Creation date
   word		lstAccDate;		// Last access date (no time!)
   word		fstClustHi;		// Hi word of first cluster
   word		wrtTime;			// Last write time
   word		wrtDate;			// Last write date
   word		fstClustLo;		// Lo word of first cluster
   unsigned long fileSize;	// EOF position
} fat_dirent;

#define _fat_cUint2Ulong(buf, L) (*(unsigned long *)(L) = *(word *)(buf))
#define _fat_cUlong2Ulong(buf,L) (*(unsigned long *)(L)=*(unsigned long *)(buf))
#define _fat_cUint2Uint(buf, u) (*(word *)(u) = *(word *)(buf))
#define _fat_Uint2Ulongc(buf, i) (*(unsigned long *)(buf) = (word)(i))
#define _fat_Ulong2Ulongc(buf, L) (*(unsigned long *)(buf) = (unsigned long)(L))
#define _fat_Uint2Uintc(buf, i) (*(word *)(buf) = (word)(i))

#use "fat_config.lib"		// FAT (driver and devices) configuration library
#use "fatftc.lib"				// Write-thru cache library

// If Serial Boot Flash of 1MB and no SD card, must define MAX_FIRMWARE_BINSIZE
#ifdef __AUTO_FIRMWARE_BINSIZE
   #if (_SERIAL_BOOT_FLASH_ && ORG_FLASH_SIZE == 0x100000)
      #ifndef FAT_SD_DEVICE
		   #fatal "MAX_FIRMWARE_BINSIZE must be defined to allow space for FAT."
      #endif
	#endif
#endif

extern FATfile _temp_file;	// Temp file for fat_Create()/fat_CreateDir()

extern const __far char mbr_start[];

/*** EndHeader */

#ifndef MBR_START_DEFINED
/* The MBR that we use to partition the device. */
const __far char mbr_start[] {
	"\xFA\x33\xC0\x8E\xD0\xBC\x00\x7C\x8B\xF4\x50\x07\x50\x1F\xFB\xFC" \
	"\xBF\x00\x06\xB9\x00\x01\xF2\xA5\xEA\x1D\x06\x00\x00\xBE\xBE\x07" \
	"\xB3\x04\x80\x3C\x80\x74\x0E\x80\x3C\x00\x75\x1C\x83\xC6\x10\xFE" \
	"\xCB\x75\xEF\xCD\x18\x8B\x14\x8B\x4C\x02\x8B\xEE\x83\xC6\x10\xFE" \
	"\xCB\x74\x1A\x80\x3C\x00\x74\xF4\xBE\x8B\x06\xAC\x3C\x00\x74\x0B" \
	"\x56\xBB\x07\x00\xB4\x0E\xCD\x10\x5E\xEB\xF0\xEB\xFE\xBF\x05\x00" \
	"\xBB\x00\x7C\xB8\x01\x02\x57\xCD\x13\x5F\x73\x0C\x33\xC0\xCD\x13" \
	"\x4F\x75\xED\xBE\xA3\x06\xEB\xD3\xBE\xC2\x06\xBF\xFE\x7D\x81\x3D" \
	"\x55\xAA\x75\xC7\x8B\xF5\xEA\x00\x7C\x00\x00\x49\x6E\x76\x61\x6C" \
	"\x69\x64\x20\x70\x61\x72\x74\x69\x74\x69\x6F\x6E\x20\x74\x61\x62" \
	"\x6C\x65\x00\x45\x72\x72\x6F\x72\x20\x6C\x6F\x61\x64\x69\x6E\x67" \
	"\x20\x6F\x70\x65\x72\x61\x74\x69\x6E\x67\x20\x73\x79\x73\x74\x65" \
	"\x6D\x00\x4D\x69\x73\x73\x69\x6E\x67\x20\x6F\x70\x65\x72\x61\x74" \
	"\x69\x6E\x67\x20\x73\x79\x73\x74\x65\x6D\x00\x00\x00\x00\x00\x00"
};
#define MBR_START_DEFINED
#endif


/****************************************************************************/
/* Some internal helper functions beyond this point.                        */
/****************************************************************************/


/*** BeginHeader _fat_DumpBuf */
void _fat_DumpBuf( __far char * );
/*** EndHeader */

__debug void _fat_DumpBuf( __far char * sbuf )
{
#ifdef FAT_DEBUG
	auto int	i;
   auto char buf[17];
   auto __far char *ptr;

	for( ptr = sbuf, buf[16] = 0; ptr < sbuf + 512; )
	{
		printf( "%05X:  ", ptr - sbuf );
		for( i = 0; i < 16; i++ ) {
			buf[i] = isprint( *ptr ) ? *ptr : ' ';
         printf( "%02X ", *ptr++ );
		}
		printf("%s\n", buf);
	}
#endif
   return;
}


/*** BeginHeader _fat_Clust2Dir */
int _fat_Clust2Dir( unsigned char *, unsigned long );
/*** EndHeader */

_fat_debug int _fat_Clust2Dir( unsigned char *buf, unsigned long c )
{
	*(word *)(buf + offsetof(fat_dirent, fstClustHi)) = ((word *)&c)[1];
	*(word *)(buf + offsetof(fat_dirent, fstClustLo)) = *(word *)&c;
}


/*** BeginHeader _fat_Dir2Clust */
void _fat_Dir2Clust( unsigned char *, unsigned long * );
/*** EndHeader */
_fat_debug void _fat_Dir2Clust( unsigned char *buf, unsigned long *c )
{
	((word *)c)[1] = *(word *)(buf + offsetof(fat_dirent, fstClustHi));
	*(word *)c = *(word *)(buf + offsetof(fat_dirent, fstClustLo));
}

/*** BeginHeader _fat_xDir2Clust */
void _fat_xDir2Clust( long, unsigned long * );
/*** EndHeader */
_fat_debug void _fat_xDir2Clust( long buf, unsigned long *c )
{
	// Same as _fat_Dir2Clust, except dir entry is far (xmem)
	((word *)c)[1] = *((word __far *)(buf + offsetof(fat_dirent, fstClustHi)));
	*(word *)c = *((word __far *)(buf + offsetof(fat_dirent, fstClustLo)));
}

/*** BeginHeader _fat_table_update */
long _fat_table_update(fat_part * , unsigned long, int * );
/*** EndHeader */
/************************************************************************
_fat_table_update

SYNTAX: long _fat_table_update(fat_part *part, unsigned long clust,
													int *state)

DESCRIPTION: Dual purpose function based on calling value of state.
				 If state points to a variable with 0 value, this function
             only calculates the sector and offset to the FAT table
             entry for the given clust value.  Returns the sector and
             puts the offset in state.
             If state points to a variable with non-zero value, this
             function updates the FAT table entry referenced by clust
             with the link contained in part->clust1.  Returns 0
             on success, -EBUSY or error codes from read/write calls.
             Destroys contents of part->clust1 & part->linkclust.

PARAMETER1:  part - valid partition pointer

PARAMETER2:  clust - cluster value

PARAMETER3:  state - pointer to state variable, should be 0 for calc only,
							or non-zero value with lowest two bits being 0 on
                     the initial call (a multiple of 4).  The state variable
                     should be static if using non-blocking mode as it will
                     be used to track progress through this function.  The
                     calling function should set aside all 4 states that the
                     function can use.  These will be the range of the original
                     state value thru the original value + 3.  State value
                     will be unknown on exit.

RETURN VALUE:	0, -EBUSY or read/write error code if in update mode
					sector location of desired cluster entry in the FAT table

END DESCRIPTION **********************************************************/

_fat_debug long _fat_table_update(fat_part *part, unsigned long clust,
													int *state)
{
	int rc;
	unsigned ofs, i, s;
   unsigned long sec;

   ofs = (unsigned)clust << 1;
   s = part->byte_sec;
   ofs &= s - 1;               // Calc offset of requested cluster entry
   i = 8;
   if (s > 512) {
      for (s >>= 9; !(s & 1) && (i < 14); s >>= 1, i++);
   }
  	sec = (clust >> i) + part->fatstart;  // Calc sector of cluster entry
   if (!(*state)) {
   	*state = (int)ofs;    // Simply return sec and offset if *state = 0
      return (long)sec;
   }

   // *state not zero, update FAT table entry with link in part->clust1
   if ( ( rc = fatftc_write( part->ftc_prt, sec, ofs, 2,
               paddr(&part->clust1), FAT_BLOCK_FLAGS ) ) != 2 ) {
      return rc;
   }
   return 0;
}

/*** BeginHeader _fat_xfind_free */
unsigned int _fat_xfind_free(long , unsigned );
/*** EndHeader */
/************************************************************************
_fat_xfind_free

SYNTAX: unsigned int _fat_xfind_free(long src, unsigned len)

DESCRIPTION: Return the offset in bytes till the first available cluster
             is found starting with the xmem cluster entry pointed to by
             src.  Search length is set by len.

PARAMETER1:  src is an xmem (linear) address of the starting cluster entry
             to begin the search from

PARAMETER2:  len is the maximum number of bytes to search (will be
             truncated to an even value)

RETURN VALUE:	Offset from starting search cluster to the first free
               cluster.  Offset to entry just past the search window
               if not found.

END DESCRIPTION **********************************************************/

#asm __nodebug
_fat_xfind_free::
		ld		hl, (SP+2+4)		; HL = len
		or		a                 ; clear the Carry flag
		rr		hl						; HL = loop count (Carry was clear from above)
		test	hl						; check for nonzero loop count
		jr		z, .done				; exit if loop count == 0 (i.e. len <= 1)

		ld		bc, hl				; BC = loop count
		clr	hl
		ld		de, hl				; DE = initial free cluster index (i.e. zero)
		ld		px, (SP+2+0)		; PX = src (starting cluster physical address)
.loop:
		ld		hl, (px+0)			; HL = cluster entry
		test	hl						; update Zero flag (free == 0)
		jr		z, .found			; report index if a free cluster is found

		inc	de						; increment the free clusters index
		ld		px, px+2				; point to the next cluster entry
		dwjnz	.loop

.found:
		ld		hl, de				; HL = free cluster index vs. past clusters index
		add	hl, hl				; HL = free cluster offset vs. past search window
.done:
		ret
#endasm


/*** BeginHeader _fat_xnull_len */
unsigned int _fat_xnull_len(long , unsigned );
/*** EndHeader */
/************************************************************************
_fat_xnull_len

SYNTAX: unsigned int _fat_xnull_len(long src, word len)

DESCRIPTION: Return the length (in bytes) of contiguous free cluster
             entries found starting with the xmem byte pointed to by src.
             Search length is set by len.

PARAMETER1:  src - xmem (linear) address of the first cluster entry
             to start searching from.

PARAMETER2:  len is the maximum number of bytes to search (will be
             truncated to an even value)

RETURN VALUE:	length of contiguous free cluster entries in bytes

*************************************************************************/

#asm __nodebug
_fat_xnull_len::
		ld		hl, (SP+2+4)		; HL = len
		or		a                 ; clear the Carry flag
		rr		hl						; HL = loop count (Carry was clear from above)
		test	hl						; check for nonzero loop count
		jr		z, .done				; exit if loop count == 0 (i.e. len <= 1)

		ld		bc, hl				; BC = loop count
		clr	hl
		ld		de, hl				; DE = initial free cluster count (i.e. zero)
		ld		px, (SP+2+0)		; PX = src (starting cluster physical address)
.loop:
		ld		hl, (px+0)			; HL = cluster entry
		test	hl						; update Zero flag (free == 0)
		jr		nz, .found			; report count if a used cluster is found

		inc	de						; increment the contiguous free clusters count
		ld		px, px+2				; point to the next cluster entry
		dwjnz	.loop

.found:
		ld		hl, de				; HL = contiguous free clusters count
		add	hl, hl				; HL = contiguous free cluster entries byte length
.done:
		ret
#endasm

/*** BeginHeader _fat_xcount_free */
unsigned int _fat_xcount_free(long , unsigned );
/*** EndHeader */
/************************************************************************
_fat_xcount_free

SYNTAX: unsigned int _fat_xcount_free(long src, unsigned len)

DESCRIPTION: Return the total number of free cluster entries found within
				 the search area starting at the xmem byte pointed to by src.
             Search length is set by len.

PARAMETER1:  src - xmem (linear) address of the first cluster entry
             to start searching from.

PARAMETER2:  len is the maximum number of bytes to search (will be
             truncated to an even value)

RETURN VALUE:	count of free cluster entries found in search range

*************************************************************************/

#asm __nodebug
_fat_xcount_free::
		ld		hl, (SP+2+4)		; HL = len
		or		a                 ; clear the Carry flag
		rr		hl						; HL = loop count (Carry was clear from above)
		test	hl						; check for nonzero loop count
		jr		z, .done				; exit if loop count == 0 (i.e. len <= 1)

		ld		bc, hl				; BC = loop count
		clr	hl
		ld		de, hl				; DE = initial free cluster count (i.e. zero)
		ld		px, (SP+2+0)		; PX = src (starting cluster physical address)
.loop:
		ld		hl, (px+0)			; HL = cluster entry
		test	hl						; update Zero flag (free == 0)
		jr		nz, .skip			; skip over (i.e. don't count) used clusters

		inc	de						; increment the free clusters count
.skip:
		ld		px, px+2				; point to the next cluster entry
		dwjnz	.loop

		ld		hl, de				; HL = final free clusters count
.done:
		ret
#endasm


/*** BeginHeader _fat_new_clust */
int _fat_new_clust( fat_part *, unsigned long, unsigned long *, int );
/*** EndHeader */
      						// FAT16 New Cluster States
#define FAT_NC_READ_NB		FAT_PART_ALLOC+1	// Read next FAT sector from device
#define FAT_NC_NEW_BLOCK	FAT_PART_ALLOC+2	// Scan for new available block
#define FAT_NC_READ_XB		FAT_PART_ALLOC+3	// Read next FAT sector from device
#define FAT_NC_NEXT_BLOCK	FAT_PART_ALLOC+4	// Scan for next available block
#define FAT_NC_READ_L		FAT_PART_ALLOC+5	// Read link entry
#define FAT_NC_LINK			FAT_PART_ALLOC+6	// Link new cluster to existing chain
#define FAT_NC_ERROR			FAT_PART_ALLOC+7 // Error occured, rollback transaction

_fat_debug int _fat_new_clust( fat_part *part, unsigned long clust,
											unsigned long *n_clust, int count )
{
#ifndef FAT16_READONLY
// Fixed variable locations - do not move or rearrange!
   auto int y;        			// Temp storage
	auto unsigned x;           // Temp storage
   auto long cl;              // Cluster link temp storage
	auto unsigned myclust;     // Cluster value for current position
   auto int z;
	auto int rc;               // Return codes and temp storage
// End of fixed variable locations
   auto int allocated;			// Counts number of clusters allocated so far
	auto int ofs;         		// Offset in current sector
   auto unsigned fat_sector;  // Sector within the FAT partition
	auto unsigned long sector; // Absolute sector on the device
   auto int fat_cntr;			// Counts FAT sectors
   auto int fat_end_offset;	// Offset to end of FAT in last sector
   auto long sbuf;            // Sector buffer pointer
   auto union {
      __far unsigned * ptr;     // Pointer to cluster entry in FAT table
      long l;
   } entry;

	if (clust == 1)
   	return -EINVAL;

#ifndef FAT_BLOCK
  	if (part->opstate & FAT_PART_ALLOC)
   {
		if (part->active != (void *)n_clust) {	// Verify it's the same caller
      	return -EBUSY;                		// If not, he's got to wait
      }
   }
   else {
	  	if (part->opstate & FAT_PART_DEL) {	// See if deletion in progress
   		return -EBUSY;                // If so, can't start allocation
      }
      else {
   	   part->active = (void *)n_clust;   // Save pointer as caller reference
#endif
	      part->opstate = FAT_PART_ALLOC;    	 // Idle, start new allocation
		   part->clust1 = (unsigned)part->nextcluster; // Set starting cluster
         if (count) {                  // If allocating, start a transaction
			   if ((rc = fatrj_transtart(part->ftc_prt)) < 0) {
            	if (rc != -ETRANSOPEN) {
            		part->opstate = FAT_PART_IDLE; // Can't get a transaction
	               return rc;           	  // System fault
   	         }
			   }
		   }
#ifndef FAT_BLOCK
      }
   }
#endif

#ifdef FAT_VERBOSE
	printf( "FAT: _fat_new_clust() entry %ld\r\n", MS_TIMER );
#endif

	fat_cntr = (int)part->sec_fat + 1;		// Add one for pre-decrement
	// Compute ending offset of FAT table
   fat_end_offset = (part->fat_len << 1) % part->byte_sec;
   fat_end_offset = (fat_end_offset ? fat_end_offset : part->byte_sec);
#ifdef FAT_BLOCK
	if ( !count )
#else
	if ( !count && (part->opstate == FAT_PART_ALLOC))
#endif
   {
		part->freecluster = 0L;		// Count cycle requested, clear counts
		part->totcluster = part->fat_len - 2;  // Set total clusters in data area
      part->nextcluster = 2L;                // Set next cluster to allocate
      if (part->badcluster == 0xFFFFFFFFL) {
       	part->badcluster = 0;
      }
      myclust = 2;
      fat_sector = 0;
      ofs = 4;
		part->opstate = FAT_NC_READ_NB;
	}
   else
   {
		/* Start search from last used cluster.  Check for wrapping. */
      myclust = part->clust1;
      if ( myclust >= part->fat_len || myclust < 2 ) {
      	myclust = 2;
         fat_sector = 0;
	      ofs = 4;
      }
      else {	// Use sector as temporary long storage during calculation
      	sector = (unsigned long)myclust <<  1;
		   fat_sector = (unsigned)(sector / part->byte_sec);
   	   ofs = (int)(sector & (part->byte_sec - 1));
      }
#ifndef FAT_BLOCK
      if ( part->opstate == FAT_PART_ALLOC ) {
#endif
	      fat_cntr++;			// Do first inspected FAT sector twice.
			part->opstate = (clust ? FAT_NC_READ_XB : FAT_NC_READ_NB);
         part->linkclust = (unsigned)clust;
         *n_clust = 0L;
#ifndef FAT_BLOCK
      }
      else {
         fat_cntr = part->opcount;  // Restore previous count
      }
#endif
   }

   y = 0;
	allocated = 0;
   sector = fat_sector + part->fatstart;
	while ( part->opstate )
	{
    switch ( part->opstate )
    {
      case FAT_NC_READ_NB:
      case FAT_NC_READ_XB:
      	if (!( --fat_cntr ))	// See if whole FAT has been scanned
         {
				part->opstate = FAT_PART_IDLE;		// Set idle state
            if (count) {
	            part->nextcluster = myclust;
               part->freecluster -= allocated;
               if (!allocated) {
               	allocated = -ENOSPC;
               }
            }
            else {
            	allocated = 0;
            }
            break;
         }
		   if (( rc = fatftc_read( part->ftc_prt, sector, &sbuf,
         									FAT_BLOCK_FLAGS )) < 0 )
	      {
#ifndef FAT_BLOCK
      		if (rc == -EBUSY)	{
               if (allocated) {
               	rc = allocated;
                  part->freecluster -= allocated;
                  part->nextcluster = myclust + 1;
                  part->opstate = FAT_PART_IDLE;
               }
               else {
	           		// Busy, save myclust and fat_cntr
			         part->clust1 = myclust;
      	         part->opcount = ++fat_cntr;
               }
#ifdef FAT_VERBOSE
               printf( "FAT: _fat_new_clust() exit %ld\r\n", MS_TIMER );
#endif
					return rc;
      	   }
#endif
				part->opstate = FAT_NC_ERROR;		// Set error state
				break;
	      }
         part->opstate++;
         break;

      case FAT_NC_NEW_BLOCK:
      case FAT_NC_NEXT_BLOCK:
        	if (ofs >= part->byte_sec) {
           	sector++;
            fat_sector++;
  	      	ofs -= part->byte_sec;
            part->opstate--;
     	      break;
        	}
			// Set rc to 1 if last sector of FAT table
		   rc = (fat_sector == (unsigned)(part->sec_fat - 1) ? 1 : 0 );
         if	((rc && (ofs >= fat_end_offset)) || (fat_sector >= part->sec_fat))
         {
           	sector = part->fatstart;
            fat_sector = 0;
  	      	ofs = 4;
            myclust = 2;
            part->opstate--;
     	      break;
         }
         if (!count) {
            if (fat_sector) {
               part->freecluster += _fat_xcount_free(sbuf,
                                       (rc ? fat_end_offset : part->byte_sec));
            }
            else {   // First sector of FAT always has an offset of 4
               part->freecluster += _fat_xcount_free(sbuf + 4,
                                                   part->byte_sec - 4);
            }
            ofs = part->byte_sec;
            break;
         }
         // Find next free cluster
         y = _fat_xfind_free(sbuf + ofs, part->byte_sec - ofs);
         ofs += y;
         myclust += y >> 1;
         if	((rc && (ofs >= fat_end_offset)) || (ofs >= part->byte_sec)) {
            break;
         }

         // Found free cluster, start assigning to cluster chain
         y = _fat_xnull_len(sbuf + ofs, part->byte_sec - ofs) >> 1;
         if (y > (count - allocated)) {
            y = count - allocated;
         }
         part->clust1 = myclust;		// Save first open cluster and offset
         x = ofs;

         // See if adding to existing chain
         if (part->opstate == FAT_NC_NEXT_BLOCK) {
            myclust = part->linkclust;			// Get link cluster
            ofs = 0;
            sector = _fat_table_update(part, myclust, (int *)&ofs);
	         part->opstate = FAT_NC_LINK;	// Link chain to this cluster
           	part->clust2 = *((int __far *)(sbuf + ofs));
            break;
         }

         // Get remaining space in the rollback journal into z
         if (!fatrj_status(part->ftc_prt, (word *)&z)) {
          	rc = -EFAULT;						// Must have a transaction open
				part->opstate = FAT_NC_ERROR;		// Set error state
				break;
         }
         // Allow for possible checkpoint entry and see if block too large
         if (z < (((sizeof(RJHeader) + FAT_MAXCHK) * 2) + 10)) {
            y = z = 0;         // Journal already too full, close it out
         }
         else {
            z -= (((sizeof(RJHeader) + FAT_MAXCHK) * 2) + 8);
            if (y > (z >> 1)) {
               y = z >> 1;     // Trim to remaining journal space
               z = 0;          //  and show journal entry has no more room
            }
            else {
               z -= y << 1;    // Calculate remaining journal space
            }
         }

         if (y) {
	         // Store pre-image of clusters to be allocated in rollback journal
	         if ((rc = _fatrj_store_preimage(part->ftc_prt, sector, sbuf, ofs,
	                                                 y << 1, RJT_PREIMAGE)) < 0)
	         {
	            part->opstate = FAT_NC_ERROR;    // Set error state
	            break;
	         }
            fatftc_makedirty(sbuf);					// Mark sector buffer dirty
            allocated += y;							// Adjust allocated value
            if (!(*n_clust)) { *n_clust = part->clust1; }

            // Extend cluster chain through available block of free clusters
            for (entry.l = sbuf + ofs, ofs += (y << 1); --y; entry.ptr++) {
               *entry.ptr = ++myclust;
            }
            *entry.ptr = 0xFFFF;

            if (count == allocated) {
            	part->nextcluster = myclust + 1;
               part->freecluster -= count;
               part->opstate = FAT_PART_IDLE;
               break;
            }
            part->linkclust = myclust++; 			// Save link cluster
         }

         // See if we've exhausted the rollback journal freespace
         if (z <= 1) {
            rc = FAT_PART_ALLOC;
            z = 0x5A5A;
            cl = part->linkclust;
            y = count - allocated;
            x = part->pnum;
            rc = fatrj_setchk(part->ftc_prt, &rc);
            if (!rc) {
               rc = fatrj_tranend(part->ftc_prt, 0);
            }
            if (!rc) {
               rc = fatrj_transtart(part->ftc_prt);
            }
            if (rc) {
               part->opstate = FAT_NC_ERROR; // Set error state
               break;
            }
         }
         // Rollback OK, Set to link to next block
         part->opstate = FAT_NC_NEXT_BLOCK;
         part->clust2 = *((int __far *)(sbuf + ofs));
         break;

      case FAT_NC_LINK:		// Create link to new cluster
			if ( ( rc = fatftc_write( part->ftc_prt, sector, ofs, 2,
			         		paddr(&part->clust1), FAT_BLOCK_FLAGS ) ) != 2 )
         {
#ifndef FAT_BLOCK
   	   	if (rc == -EBUSY) {
            	// Busy, set allocation state and clust as ID
	     	   	part->opcount = fat_cntr;
               return -EBUSY;
	         }
#endif
				part->opstate = FAT_NC_ERROR;		// Set error state
            break;
         }

         myclust = part->clust1;
         ofs = 0;
         sector = _fat_table_update(part, myclust, (int *)&ofs);
         fat_cntr++;
         part->opstate = FAT_NC_READ_NB;
         break;

      default:
      	rc = -EFAULT;      // Set fault code and drop into error handler

      case FAT_NC_ERROR:
     		if (count) {
            if (fatrj_rollback(part->ftc_prt, FAT_BLOCK_FLAGS) == -EBUSY) {
            	return -EBUSY;
            }
         }
      	part->opstate = FAT_PART_IDLE;
         allocated = rc;             // Put error code in allocated for exit
      	break;
	 }
	}

#ifdef FAT_VERBOSE
	printf( "FAT: _fat_new_clust() exit %ld\r\n", MS_TIMER );
#endif

   part->active = NULL;
   rc = z = 0;                       // Clear power loss recovery check point
   fatrj_setchk(part->ftc_prt, &rc);
  	return allocated;
#else
	return -EPERM;
#endif
}


/*** BeginHeader _fat_next_clust */
int _fat_next_clust( fat_part *, unsigned long *, word );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Returns the cluster number of the next cluster in the linked list
   contained in the FAT.

   RETURNS:		0    on success
   			-ENODATA if cluster is not in use.
            -EFAULT if cluster is marked bad.
				 -EEOF  if last cluster in the chain.
   		   or any error possible from a call to fatftc_read
*************************************************************************/

_fat_debug int _fat_next_clust(fat_part *part, unsigned long *clust, word block)
{
	auto int rc;
	auto unsigned int x;
	auto long sbuf;

#GLOBAL_INIT{ fat_sysdriver = NULL; }
#GLOBAL_INIT{ fat_sysftc = -1; }

   if (part->type == FAT_TYPE_12) {
		printf("FAT12 not supported\n");
		return -ENOSYS;
   }

	// Test for root directory (treated as one large cluster - always EOF)
   if (!(*clust)) {
   	return -EEOF;
   }

	// Compute sector and offset of FAT entry for this cluster
	sbuf = (*clust / (FAT_SECSIZE / 2)) + part->fatstart;
	x = ((unsigned int)*clust & ((FAT_SECSIZE / 2) - 1)) << 1;

	/* read the FAT sector we need */
   if (( rc = fatftc_read( part->ftc_prt, sbuf, &sbuf, block )) < 0 ) {
		return rc;
   }

	/* get the word at location x */
	x = *((int __far *)( sbuf + x ));

	/* this is either the end of the file or an invalid state */
   if ( x == 0 ) {
#ifdef FAT_VERBOSE
     printf("FAT: _fat_next_clust (ENODATA) clust = %ld, x = %d, sbuf = %lx\n",
						      						*clust, x, sbuf);
#endif
		return -ENODATA;
   }
	if( x >= 0xfff7 ) {
		return (x == 0xfff7 ? -EFAULT : -EEOF);
   }

	*clust = (unsigned long)x;

	return 0;
}


/*** BeginHeader _fat_free_clust */
int _fat_free_clust( fat_part *, unsigned long );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
   This function frees a cluster chain starting with the given cluster.

   RETURNS:		0    on success
   			-EFAULT if cluster is not in use.
   		   or any error possible from a call to fatftc_read or
               fatftc_write

*************************************************************************/

      						// FAT Free Cluster States
#define FAT_FC_CALC	FAT_PART_DEL+1	// Calculate new sector & offset values
#define FAT_FC_READ	FAT_PART_DEL+2	// Read next FAT sector from device
#define FAT_FC_READ2	FAT_PART_DEL+3	// Read spanned sector from device
#define FAT_FC_GET	FAT_PART_DEL+4	// Get next link from the chain
#define FAT_FC_FREE	FAT_PART_DEL+5	// Free next link from the chain
#define FAT_FC_ERR	FAT_PART_DEL+6	// Error handling, rollback the transaction

_fat_debug int _fat_free_clust( fat_part *part, unsigned long clust )
{
#ifndef FAT16_READONLY
	auto unsigned myclust, inuse;
   auto unsigned x;
   auto int y;
	auto unsigned long sector;
	auto int ofs;
   // The following five variables should not change order or type!!!
   auto int pnum;
   auto long sbuf;
   auto unsigned newclust;
   auto int z;
	auto int rc;

	myclust = (unsigned)clust;

#ifndef FAT_BLOCK
  	if (part->opstate & (FAT_PART_DEL))
   {
		if ((unsigned)clust == part->clust2 || part->opstate == FAT_PART_DEL) {
        	y = part->opstate;
      	myclust = (y == FAT_PART_DEL ? (unsigned)clust : part->clust1);
         x = part->linkclust;
         part->opstate = FAT_FC_CALC;
   	}
      else {
      	return -EBUSY;
      }
   }
   else
	   if (part->opstate & (FAT_PART_ALLOC)) {
   		return -EBUSY;
      }
      else {
      	part->opstate = FAT_FC_CALC;
         y = 0;
		   if ((rc = fatrj_transtart(part->ftc_prt)) < 0)
		   {
         	part->opstate = FAT_PART_IDLE;
            return rc;
		   }
      }
#else
	part->opstate = FAT_FC_CALC;
   y = 0;
#endif

#ifdef FAT_VERBOSE
	printf( "FAT: _fat_free_clust() entry %ld\r\n", MS_TIMER );
#endif

   inuse = (part->type == FAT_TYPE_12 ? 0x0FF7 : 0xFFF7);
	while( (myclust < inuse) && myclust )
	{
    switch (part->opstate)
    {
    	case FAT_FC_CALC:
      	// Calculate new sector & offset values from myclust
         ofs = 0;
         sector = _fat_table_update(part, myclust, (int *)&ofs);
         if (y == FAT_FC_FREE)
         {
            y = part->opcount;
            if (!y) {
               y++;
               sector++;
               ofs = 0;
            }
         }
         else {
            part->opstate++;
         }

    	case FAT_FC_READ:
    	case FAT_FC_READ2:
			/* Read the FAT sector in question */
		   if (( rc = fatftc_read( part->ftc_prt, sector, &sbuf,
      									FAT_BLOCK_FLAGS )) < 0 )
      	{
#ifndef FAT_BLOCK
      		part->clust1 = myclust; 			     // Save next cluster and
	  	   	part->clust2 = (unsigned)clust;       // save calling cluster
            part->linkclust = x;
	      	if (rc == -EBUSY) {
            	return -EBUSY;
            }
#endif
		  		part->opstate = FAT_FC_ERR;
				break;
   	   }

    	case FAT_FC_GET:
			// Get the next link in the chain
         newclust = *((int __far *)( sbuf + ofs ));
         y = 2;
         part->opstate = FAT_FC_FREE;
         x = 0;
         if (newclust < 2)
         {
            rc = z = 0;
            part->opstate = FAT_PART_IDLE;
            fatrj_setchk(part->ftc_prt, &rc);
            return -EFAULT;   // Broken or invalid chain, report fault
         }

		case FAT_FC_FREE:
			/* Mark the entry as free or bad */
			if ( ( rc = fatftc_write( part->ftc_prt, sector, ofs, y, paddrSS(&x),
        								FAT_BLOCK_FLAGS ) ) != y )
      	{
#ifndef FAT_BLOCK
      		part->clust1 = myclust; 		  // Save next cluster and
  	   		part->clust2 = (unsigned)clust; // save calling cluster
            part->linkclust = x;            // and write value and size/state
            part->opcount = 2;
	      	if (rc == -EBUSY) {
            	return -EBUSY;
            }
#endif
		  		part->opstate = FAT_FC_ERR;
				break;
   	   }

         // See if rollback journal is full
	      if (fatrj_status(part->ftc_prt, (word *)&rc))
   	   {
      		if (rc < ((sizeof(RJEntry) + 21)) * 3)
         	{
            	rc = FAT_PART_DEL;
	            z = 0x5A5A;
               pnum = part->pnum;
   	         rc = fatrj_setchk(part->ftc_prt, &rc);
               if (!rc) {
	            	rc = fatrj_tranend(part->ftc_prt, 0);
               }
      	      if (!rc) {
               	rc = fatrj_transtart(part->ftc_prt);
               }
         	   if (rc) {
               	part->opstate = FAT_FC_ERR;
               }
	         }
   	   }
         if (newclust < inuse) {
           	ofs += ((newclust - myclust) * 2);
           	if (ofs >= part->byte_sec || ofs < 0) {
         		part->opstate = FAT_FC_CALC;
            }
            else {
  	         	part->opstate = FAT_FC_GET;
            }
         }
        	myclust = newclust;
         part->freecluster++; 	// Adjust free space on partition
         break;

		case FAT_FC_ERR:
         if (rc = fatrj_rollback(part->ftc_prt, FAT_BLOCK_FLAGS))
         {
#ifndef FAT_BLOCK
	      	if (rc == -EBUSY) {
            	return -EBUSY;
            }
#endif
         	return rc;
         }
         else {
         	rc = -EIO;
         }
			rc = z = 0;
		   part->opstate = FAT_PART_IDLE;
			fatrj_setchk(part->ftc_prt, &rc);
         return -EIO;

      default:
    }
	}

#ifdef FAT_VERBOSE
	printf( "FAT: _fat_free_clust() exit %ld\r\n", MS_TIMER );
#endif
	rc = z = 0;
   part->opstate = FAT_PART_IDLE;
	return fatrj_setchk(part->ftc_prt, &rc);
#else
	return -EPERM;
#endif
}

/*** BeginHeader _fat_chkpoint */
int _fat_chkpoint(word dev, word prt, mbr_dev * fdev, __far word * chkdat);
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Called by the FTC layer if an long allocate or delete transaction is
   interrupted due to power loss, reset or system crash. Will complete
   the partially done transaction if a recovery state is detected.

RETURNS:		0
*************************************************************************/
_fat_debug int _fat_chkpoint(word dev, word prt, mbr_dev * fdev,
                               __far word * chkdat)
{
	auto int rc, count;
	auto word state;
   auto unsigned long clust;
   auto unsigned long nclust;
   auto fat_part part;

   // Format of checkpoint data (chkdat)
   //  word state;      // State of the checkpoint transaction
   //  word signature;  // Checkpoint signature (0x5A5A if valid)
   //  word clust1;     // Allocation = Next cluster available on the device
                        // Deletion = Root of chain being deleted.
   //  word clust2;     // Current last cluster of chain (allocation)
   //  word resvd;      // Reserved
   //  word part_num;   // Partition number on device
   //  word allocate;   // Number of clusters to allocate to chain
   if (state = *chkdat)
   {
      // Check for valid state, signature & part_num
      if (state < 0x2000 || *(chkdat + 1) != 0x5A5A || *(chkdat + 5) > 3) {
      	return 0;
      }

      fdev->ftc_dev = dev;
      while ((rc = _fat_EnumPartition( fdev, *(chkdat + 5), &part)) == -EBUSY);
		if (!rc) {
	      if (state == FAT_PART_ALLOC) {     // Interrupted allocation??
         	part.nextcluster = *(chkdat + 2);
            clust = *((__far unsigned long *)(chkdat + 3));
            count = *(chkdat + 6);
            while (count) {
            	while ((rc = _fat_new_clust( &part, clust, &nclust, count ))
               										== -EBUSY);
              	count = (rc < 0 ? 0 : count - rc);
               clust = part.nextcluster - 1;
            }
      	}
	      else if (state == FAT_PART_DEL) {  // Interrupted deletion??
         	clust = *(chkdat + 2);
         	while ((rc = _fat_free_clust( &part, clust )) == -EBUSY);
         }
         clust = 0;
         fatrj_setchk(part.ftc_prt, &clust);
      }
		fdev->fs_part[*(chkdat + 5)] = NULL;
   }
   return 0;
}


/*** BeginHeader _fat_clust2sec */
int _fat_clust2sec( fat_part *, unsigned long, unsigned long * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	This function translates a cluster into a sector address.  Pass in
   a valid partition pointer (part) and cluster value (clust).  The
   calculated sector value is placed in sector.

   RETURNS:		0 on success
   				-EEOF if clust is not within the given partition
*************************************************************************/

_fat_debug int _fat_clust2sec( fat_part *part, unsigned long clust,
											unsigned long *sector )
{
	if( clust == (unsigned int) 0 ) {
		*sector = part->rootstart;
   }
	else {
		*sector = (( clust - 2 ) * part->sec_clust ) + part->datastart;

		/* let's check wether the resulting sector address is within the
			partition boundaries or not. */
		if ((*sector) >= (part->mpart->startsector +	part->mpart->partsecsize)) {
			return -EEOF;
      }
	}

	return 0;
}


/*** BeginHeader _fat_checkdir */
int _fat_checkdir( fat_part *, fat_location * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
   This function is used to check whether a directory is empty or not.
   It's used by fat_Delete() and reads along the whole directory
   chain to check whether there are entries or not.

   RETURNS:		0 on success
   			  -ENOTEMPTY if file/directory entry is found
              -EBUSY if the device is busy. (if NON-BLOCKING)
   	other errors from calling fatftc_read & _fat_next_cluster
*************************************************************************/
_fat_debug int _fat_checkdir( fat_part *part, fat_location *loc )
{
	auto int i;
	auto int rc;
   auto long sbuf;

	if (loc->s_cluster == 0) {
		return -ENOTEMPTY;		// Can't delete the root directory
   }

   rc = 0;
#ifndef FAT_BLOCK
   switch (loc->nav_state) {
   default:
 	  loc->nav_state = 3;
#endif
	loc->cluster = loc->s_cluster;
	loc->offset = 0L;
	_fat_clust2sec( part, loc->cluster, &loc->sector );


#ifndef FAT_BLOCK
	case 3:
#endif
	   for(;; loc->sector++, loc->offset += part->byte_sec )
	   {
	      if( loc->offset == part->clustlen ) {
	         /* get the next cluster */
	         if( rc = _fat_next_clust( part, &loc->cluster, FAT_BLOCK_FLAGS )) {
	            if (rc == -EEOF) { // End of directory found
	               return 0;       // And no entries found!!
               }
	            break;
	         }
	         _fat_clust2sec( part, loc->cluster, &loc->sector );
	         loc->offset = (unsigned long) 0;
	      }

#ifdef FAT_BLOCK
	      if (( rc = fatftc_read( part->ftc_prt, loc->sector, &sbuf,
	                                 FAT_BLOCK_FLAGS | FTC_MAKE_LRU )) < 0 ) {
	         return rc;
         }
#else
			loc->nav_state = 4;
         // fall through
	   case 4:
	      if (( rc = fatftc_read( part->ftc_prt, loc->sector, &sbuf,
                                    FAT_BLOCK_FLAGS | FTC_MAKE_LRU )) < 0) {
         	break;
         }
#endif

	      for( i = 0; i < part->byte_sec; i += FAT_DIRSZ ) {
	         rc = (int)(*((char __far *)(sbuf + i)));
	         if( rc && rc != '.' && rc != 0xe5 ) {
	            return -ENOTEMPTY;
            }
            if (!rc) {
            	// Got to end of entries ever used
               return 0;
            }
	      }
	      loc->nav_state = 3;
	   }	// outer for
#ifndef FAT_BLOCK
	}	// switch
#endif
	return rc;
}


/*** BeginHeader _fat_first_deleted */
void _fat_first_deleted( fat_location * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
 This function marks u_sector and u_sofs with the current location if it's
 not yet marked.  A deleted entry bit is set in u_sofs.
*************************************************************************/

_fat_debug void _fat_first_deleted( fat_location *loc )
{
	if( loc->u_sector == (unsigned long) 0 ) {
		loc->u_sector = loc->sector;
		loc->u_sofs = loc->sofs;
      loc->u_flags |= FAT_USOFS_DELETED;
	}
	return;
}


/*** BeginHeader _fat_first_unused */
void _fat_first_unused( fat_location * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
 This function marks u_sector and u_sofs with the current location if it's
 not yet marked with an unused entry.  Will replace a first deleted entry.
*************************************************************************/

_fat_debug void _fat_first_unused( fat_location *loc )
{
	if( !loc->u_sector || (loc->u_flags & FAT_USOFS_DELETED) ) {
		loc->u_sector = loc->sector;
		loc->u_sofs = loc->sofs;
      loc->u_flags &= ~FAT_USOFS_DELETED;
	}
	return;
}


/*** BeginHeader _fat_getname */
int _fat_getname( const char *, char * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
 This function fills buf with a normalized filename "NAME    EXT" where
 all letters are capitalized, name portion is blank filled if less than 8
 characters. and ext is blank filled if less than 3 characters.  This is
 the standard format of names stored in directory entries.

 buf must point to an area of exactly 12 chars (8+3+null terminator).

 The name is not allowed to contain any spaces or control chars, or any
 of a specified set of illegal chars.  An initial 0xE5 in the name is
 translated to 0x05 when stored in buf (as per FAT specification).

 A path separator character in the name (/ or \) causes early termination
 of scanning i.e. this function can be used to extract successively the
 elements of a path string.

   RETURNS:		0 if no valid characters found or badly formed name.
             number of characters parsed from fname string on success -
               in this case fname+<retval> will point to a null or a
               path separator character.
*************************************************************************/

_fat_debug int _fat_getname( const char *fname, char *buf )
{
	auto char build[12];
	auto const char * p;
   auto word extlen, i, c, plen;

	// clear out return buffer (should be blank if any errors)
	strcpy(buf, "           ");	// 11 blanks plus null

   // Name cannot start with dot (unless just . or ..)
	if (fname[0] == '.') {
		plen = fname[1] == '.' ? 2 : 1;
		if (fname[plen] && fname[plen] != FAT_SLASH_CH) {
	      // character after "." or ".." must be null or FAT_SLASH_CH
			return 0;
		}
		memcpy(buf, "..", plen);
		return plen;
	}

	// set up buffer to build normalized name
	strcpy(build, "           ");	// 11 blanks plus null

   extlen = -1;

   // Make temp copy of name, and uppercase it, and check for illegal chars
   for (plen = 0, p = fname; *p && *p != FAT_SLASH_CH && plen < 13; plen++)
   {
   	c = toupper(*p++);

		if ((c <= ' ') || strchr("\"*+,/:;<=>?[\\]|", c)) {
			// if (control-character or space || some other invalid character)
      	return 0;
      }

      if (c == '.') {					// we've found the extension
      	if (extlen != -1)	{		// error, filename can't have two extensions
				return 0;
      	}
			extlen = 0;
      }
      else if (extlen != -1)		// we're parsing the extension now
      {
         if (extlen == 3) {			// error, extension is already 3 characters
            return 0;
         }
         build[8+extlen++] = c;
      }
      else	{							// we're parsing the base filename
         if (plen == 8)	{			// error, base filename is already 8 characters
            return 0;
         }
         build[plen] = c;
      }
   }

   if (!plen || !extlen) {			// error, zero-byte base filename or extension
   	return 0;
	}

	// If first character is 0xE5 (marker for a deleted file), substitute
	// 0x05 instead (per FAT standard).
   if (build[0] == 0xE5) {
   	build[0] = 0x05;
	}

   memcpy(buf, build, 12);
   return plen;
}


/*** BeginHeader _fat_navigate */
int _fat_navigate(fat_part *, const char *, const char **, int, fat_location *);
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Scans the directory tree of the partition for "name" of type "type".
   String name should contain an absolute path and file/directory name.
   On success, loc will contain location data for the desired entry.
   Structure 'loc' must be maintained between calls if an -EBUSY code
   is returned as progress information is kept there.

   On first call (to navigate from the root directory) loc should be
   set to zeros.

   In the case of ENOENT and ENFILE, which indicate that a new entry
   would need to be created, then *newpart will be set to point to the
   trailing part of the given path name which needs to be created,
   i.e. was not found.
   This may or may not contain a path separator.  If it does, then
   this would imply that subdirectory(s) would need to be created to
   contain the actual object.  This is not directly supported by
   the _fat_create() function.

   loc->dname will be set to contain the
   blank-padded (i.e. directory format) version of the first pathname
   component of *newpath, if *newpath is not a zero-length string.

   RETURNS:	0 on success.  loc->u_sector/u_sofs points to the
              containing directory entry; loc->s_cluster is the
              first cluster of the object.  s_cluster, u_sector
              and u_sofs will all be zero if the root directory
              is specified.
   			-ENOENT if the file/directory does not exist.
              loc->u_sector/loc->u_offs indicates a free directory
              entry which may be used to create an entry for this
              object should that be required.
            -EPERM if the file/directory does not exist and the
              parent directory it would be added to is read only
            -EROOTFULL if the entry doesn't exist, and it must be
              placed in the root directory if it was created, but
              the root directory is full.
            -ENFILE if the entry doesn't exist, and the directory in
              which it would be created has no free entries, but the
              directory may be expanded because it is not the root
              directory. loc->cluster contains the last allocated
              cluster of the directory (thus _fat_new_clust() can
              be called with this as the "prev cluster" parameter).
              loc->u_sector/u_sofs is set to zero.
            -EPATHSTR if fname is not a valid path/name string or
            				if label type and path is not the root, or
                        if name is '/' or empty and type is not
                        FAT_DIR.
   			-EBUSY if required to call again with same parameters.
     Note: -EBUSY will not occur if the loc struct points to auto
     storage.  In this case, the function is forced to be blocking,
     and the MAKE_LRU flag will be set to ensure that there is always
     a flushable, clean, cache entry for the next directory in
     sequence.  Of course, if there are to be no write delays at
     all, then the caller will need to manually read in the root
     directory's first sector, and make it the LRU.
*************************************************************************/


_fat_debug int _fat_navigate( fat_part *part, const char *name,
                          const char ** newpart, int type, fat_location *loc )
{
	auto int i, inroot, block;
	auto int rc, readonly;
   auto const char *ptr;
   auto long sbuf;

   block =(word)loc >= (word)STACKORG ? FTC_WAIT | FTC_MAKE_LRU: FAT_BLOCK_FLAGS;

   inroot = !loc->s_cluster;
   if (inroot && !loc->nav_state) {
   	// First-time condition
   	loc->nav_offset = 0;	// Offset of directory path component in name
      loc->nav_state = 2;	// Something not zero and not 1.
   }
   ptr = name + loc->nav_offset;

   // eliminate leading backslash if present
   if (*ptr == FAT_SLASH_CH) { ++ptr; }

   if (!*ptr && inroot) {
   	// Trying to open the root directory.
      if (type != FAT_DIR) {
      	return -EPATHSTR;		// No can do if not looking for directory
      }
		loc->u_sector = 0;
      loc->u_sofs = 0;
      loc->u_flags = 0;
      *newpart = ptr;			// Will point to emptry string.
      return 0;
   }

	/* navigate to the directory in question */
	for(rc = -EPATHSTR, readonly = 0; *ptr; )
	{
   	// Set to the trailing pathname component(s) which we are looking for.
   	*newpart = ptr;

#ifndef FAT_BLOCK
   	if (loc->nav_state == 1) {
      	//_fat_getname( ptr, loc->dname );
      	goto _navstate_1;
      }
#endif

		if ( i = _fat_getname( ptr, loc->dname ) )
      {
         ptr += i;
      	if (*ptr == FAT_SLASH_CH)
         {
         	// The component must be a directory name, since slash follows
            if (type == FAT_LABEL) {
            	return -EPATHSTR;		// Label MUST reside in root
            }

         	if ((rc = _fat_scan( part, loc->dname, FAT_DIR, loc, block)) < 0)
            {
#ifndef FAT_BLOCK
            	if (rc == -EBUSY) {
               	return rc;
               }
               else
#endif
	            	goto _handle_noent;
            }
            readonly = rc;  // Save read only state of the directory
            ptr++;	// Skip the slash
         }
         else
         {
         	// We have reached the last pathname component provided.
         	if ((rc = _fat_scan( part, loc->dname, type, loc, block)) < 0)
            {
#ifndef FAT_BLOCK
            	if (rc == -EBUSY) {
               	return rc;
               }
               else
#endif
	            	goto _handle_noent;
            }
            readonly = rc;  // Save read only state of search entry
         }
      }
      else {
      	return -EPATHSTR;
      }

      loc->nav_state = 1;

_navstate_1:

		/* if we are here, loc denotes the directory entry which points to the
			directory we shall change to. We thus do the change here. */
      loc->u_sector = 0;	// Found this entry, reset for next path component.
      inroot = 0;				// No longer in root directory.
      // Get directory sector location from cache...
      if ((rc = fatftc_read( part->ftc_prt, loc->sector, &sbuf, block)) < 0) {
         return rc;
      }
      loc->nav_state = 2;
      loc->nav_offset = ptr - name;

		_fat_xDir2Clust(sbuf + loc->sofs, &loc->s_cluster);
		loc->cluster = loc->s_cluster;
      loc->offset = 0UL;
	}

   if (rc < 0)
   	return rc;

   // If we exited the loop, then the name completely matched.  Make
   // loc->u_sector/u_sofs point to the directory entry which contains
   // this object.
   loc->u_sector = loc->sector;
   loc->u_sofs = loc->sofs;

  	return readonly;  // Return read only flag for file or directory just found

_handle_noent:
	if (rc != -ENOENT) {
   	return rc;
   }
   // Return proper error for specific file/directory not found condition
  	return readonly ? -EPERM : loc->u_sector ? -ENOENT :
                                                 inroot ? -EROOTFULL : -ENFILE;
}



/*** BeginHeader _fat_scan */
int _fat_scan( fat_part *, const char *, int, fat_location *, word );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Scan the directory starting at loc->cluster (offset 0) for an entry
   named 'fname' of type 'type'.
   On success, 'loc' will indicate the desired entry:
     loc->cluster = cluster of directory which contains entry.
     loc->offset = offset to actual dir entry
     loc->sector/sofs = sector and offset which contains entry

   If loc->u_sector is zero on entry, then loc->u_sector/u_sofs will be
   set to the first unused entry in the directory encountered, if any.
   If the entry was not found, but there were no free entries, then
   loc->cluster will indicate the last cluster of the directory.

   RETURNS:	 0 or 1 on success (1 indicates entry found is read only)
   		  -ECORRUPT if cluster/offset in 'loc' are invalid for this partition
   		  -ENOENT if file/directory entry is not found
   		  -ETYPE if entry does not match 'type'
   		   or any error possible from a call to fatftc_read
*************************************************************************/

_fat_debug int _fat_scan( fat_part *part, const char *fname, int type,
										fat_location *loc, word block )
{
	auto int j;
	auto int k;
	auto int rc;
   auto long sbuf;

   if (loc->nav_state == 2) {
   	// Starting new scan
   	loc->nav_sec = 0;
      loc->nav_state = 5;
   }

	for( ;; )
	{
      if (loc->nav_state == 5) {
	      /* translate the cluster to a sector address */
	      if ( _fat_clust2sec( part, loc->cluster, &loc->sector ) ) {
	         return -ECORRUPT; // this would be fatal and should never happen!
	      }

	      /* set k to the number of sectors in a cluster or the number
	         of sectors in the root directory (if scanning root) */
	      k = (loc->cluster ? part->sec_clust : ( part->root_cnt / FAT_DIRPS ));
	      loc->sector += loc->nav_sec;
	      for(; loc->nav_sec < k; ++loc->nav_sec, ++loc->sector )
	      {
	         if((rc = fatftc_read(part->ftc_prt, loc->sector, &sbuf, block)) < 0)
            {
	            return rc;
	         }

	         for(loc->sofs=0; loc->sofs < part->byte_sec; loc->sofs += FAT_DIRSZ)
	         {
               // Get first character of name (shows unused or deleted status)
	            rc = (int)(*((unsigned char __far *)(sbuf + loc->sofs)));
	            if( rc == 0 ) {
	               _fat_first_unused( loc );
	               loc->nav_sec = 0;
	               return -ENOENT;   // This is the end of the current directory
	            }
	            if( rc == 0x00e5 ) {
	               _fat_first_deleted( loc );
	               continue;         /* this is a deleted entry */
	            }

               // Check file attributes for current directory entry
	            rc = *((int __far *)(sbuf + loc->sofs + 11));
	            if( ( rc & FATATTR_LONG_NAME ) == FATATTR_LONG_NAME ) {
	               continue;         /* we ingore long filename entries */
	            }

               // Compare fname with name portion of current directory entry
	            if( ! strncmp( (char __far *)(sbuf + loc->sofs), fname, 11 ) )
	            {
	               /* MATCH FOUND! */
	               loc->offset =(((unsigned long)loc->nav_sec) << 9) + loc->sofs;
	               loc->nav_sec = 0;
	               switch( type )
	               {
	                  case FAT_FILE:
	                     /* Searching for a file, entry MUST be a file */
	                     return ( rc & (FATATTR_DIRECTORY|FATATTR_VOLUME_ID) )
	                                 ? -ETYPE : rc & FATATTR_READ_ONLY;
	                  case FAT_DIR:
	                     /* Searching for directory, entry MUST be a directory */
	                     return ( rc & FATATTR_DIRECTORY ) ?
                                       rc & FATATTR_READ_ONLY : -ETYPE;
	                  case FAT_LABEL:
	                     /* if searching for the label, entry MUST be a label */
	                     return ( rc & FATATTR_VOLUME_ID ) ? 0 : -ETYPE;
	               }
	            }
	         }
	      }

	      loc->nav_sec = 0;
	      loc->nav_state = 6;
      }
	   /* retrive the next cluster. Note, cluster '0' (the root directory) will
			always result in an end of cluster condition due to the F8FF pattern
			found at the cluster '0' spot. */
		if( (rc = _fat_next_clust( part, &loc->cluster, block )) < 0 ) {
      	if (rc == -EBUSY) {
         	return rc;
         }
         loc->sofs = 0;
			break;
      }

      loc->nav_state = 5;
	}

	return -ENOENT;								/* the not found exit point */
}


/*** BeginHeader _fat_tm2timestamp */
void _fat_tm2timestamp( unsigned int *, unsigned int *, char * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
 This function converts the current system time into a FAT timestamp.
*************************************************************************/

_fat_debug void _fat_tm2timestamp( unsigned int *dat,
														unsigned int *tim, char *tenths )
{
	auto struct tm t;

	tm_rd( &t );

	/* This field is actually tenths of a second and we
      only have time in seconds */
	if( tenths != NULL ) {
		*tenths = (( t.tm_sec & 1 ) ? 10 : 0 );
   }
	if( tim != NULL ) {
		/* calculate the FAT time value */
		*tim = ( ((unsigned)(t.tm_sec) >> 1 ) | ((unsigned)(t.tm_min) << 5 )
					| ((unsigned)(t.tm_hour) << 11 ) );
	}

	if( dat != NULL ) {
		/* calculate the FAT date */
		*dat = ( (unsigned)(t.tm_mday) | ((unsigned)tm_mon2month(t.tm_mon) << 5 )
               | (((unsigned)(t.tm_year) - 80)<< 9 ) );
		/* tm_year is 1900 based whereas the directory date is 1980 based */
	}
	return;
}

/*** BeginHeader _fat_timestamp2tm */
void _fat_timestamp2tm( struct tm *, unsigned int, unsigned int, char );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
 This function converts a FAT timestamp into a system time structure.
 Does not set tm_wday value in the tm structure.
*************************************************************************/

_fat_debug void _fat_timestamp2tm( struct tm *t, unsigned int dat,
														unsigned int tim, char tenths )
{
	if( t != NULL )
	{
		/* calculate the tm time fields */
		t->tm_sec = (tim & 0x001F) << 1;
		if( tenths >= 10 )   // Truncate tenths of a second
			t->tm_sec++;
      t->tm_min = (tim & 0x07E0) >> 5;
		t->tm_hour = tim >> 11;

		/* calculate the tm date fields */
		t->tm_mday = dat & 0x001F;
      t->tm_mon = month2tm_mon((dat & 0x01E0) >> 5);
      t->tm_year = (dat >> 9) + 80;
		/* tm_year is 1900 based whereas the directory date is 1980 based */
	}
	return;
}


/*** BeginHeader _fat_create */
int _fat_create( fat_part *, int, fat_location *, long *);
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	This function creates a directory entry where "loc" points
	to (loc->u_sector/u_sofs). Internal states are kept in loc->nav_state
   and this must be set to FAT_FILESTATE_CR_INIT before calling
   fat_create for the first time.  The following actions are performed:

   NOTE: caller needs to open/close transaction.  This will journal up to
   40 bytes in up to 5 entries, but usually 36 bytes in 3 entries.  If it
   is a new directory being created, some additional sectors will be set
   to zeros but this does not need to be journalled.

   _fat_new_clust() is called for anything but a volume label.
   Worst case is if we need to allocate new cluster at end of current
   directory (for the new entry) plus the usual new cluster for the first
   cluster of the object we are creating.

	- the directory was scanned before we got called. That is u_sector will
	  point to the first usable slot which we are going to use. In case it
     is still zero, then we allocate a new cluster. In case it fails we
     return -ENOSPC to inform the caller.  Otherwise, we use this newly
     allocated space as the slot found.  NOTE: it is the caller's
     responsibility to ensure we are not going to try to expand the root
     directory - this is usually detected by _fat_navigate(), which returns
     -EROOTFULL if this situation arises.
	- if this is not going to be a label, we allocate a new cluster. If this
	  fails, we return the error -ENOSPC. If this works, or if we are about
	  to create a label entry, we create the entry and let it point towards
	  the just allocated cluster.
	- We then update the sector holding the entry.
	- If this is going to be a directory, we create the . and .. entries in
	  it and initialize all the other space of this newly allocated cluster
	  to all zeroes.  (Preallocation is forced to be 1 cluster for dirs).
	- We return to the caller reporting sucess:
       loc->s_cluster is first cluster of new object
       loc->sector/sofs indicates parent dir slot

   The prealloc parameter contains a byte count of the amount of space
   to pre-allocate for the new object.  This is rounded up to the next
   positive whole number of clusters.  On entry, *prealloc is set to the
   desired byte count.  On return, is is set to the number of bytes
   actually allocated.  In the case of error or running out of space on
   the partition, this may be set less than the requested amount (or
   even zero on complete failure).

   RETURNS:		0 on success
   			-ENOSYS if FAT partition support is not available
            -ENOSPC if space is not available.  Note that insufficient
              space _beyond_ the first necessary cluster does not
              return an error (but can be detected because *prealloc is
              less than the requested amount on return).
            Other -value if error.

*************************************************************************/

_fat_debug int _fat_create( fat_part *part, int type,
											 fat_location *loc, long * prealloc)
{
#ifndef FAT16_READONLY
	static fat_dirent dent[2];
	auto unsigned int i;
	auto char msec;
	auto unsigned int tim;
	auto unsigned int dat;
	auto int rc;
	//auto unsigned long cluster;
   auto unsigned long sector;
   auto long sbuf;
   auto long alloc;

   if (loc->nav_state == FAT_FILESTATE_CR_INIT) {
   	// First-time condition.  If no loc->u_sector then extend directory.
      loc->nav_state = loc->u_sector ? FAT_FILESTATE_CR_START
      														: FAT_FILESTATE_CR_NEW;
   }

   switch (loc->nav_state) {

   default:
   	return -EFSTATE;

   case FAT_FILESTATE_CR_NEW:
		// We need a new directory cluster to extend directory
      // loc->cluster contains the last directory cluster scanned.
      // Add another cluster to this chain.
      loc->sector = loc->cluster;
		if ((rc = _fat_new_clust( part, loc->cluster, &loc->cluster, 1 )) < 0 ) {
			return rc;			/* device is probably full */
      }

		_fat_clust2sec( part, loc->cluster, &loc->u_sector );
      loc->u_sofs = 0;
      loc->u_flags = 0;
		loc->sector = loc->u_sector;
		loc->sofs = 0;
      loc->nav_sec = part->sec_clust - 1;
      loc->nav_state = FAT_FILESTATE_CR_CLEAR;
      // Fall through to next state

   case FAT_FILESTATE_CR_CLEAR:
		/* Clear the just allocated cluster to all zeroes */
      for (; loc->nav_sec >= 0; --loc->nav_sec) {
	      if (( rc = fatftc_write( part->ftc_prt, loc->sector+loc->nav_sec, 0,
                 FAT_SECSIZE, 0, FAT_BLOCK_FLAGS | FTC_MEMSET | FTC_NO_PREIMAGE
                        | (loc->nav_sec ? FTC_MAKE_LRU : 0)) ) < 0 ) {
	         return rc;
         }
		}
      loc->nav_state = FAT_FILESTATE_CR_START;
      // Fall through to next state

        // Directory has room or new cluster added, ready to create new file.
   case FAT_FILESTATE_CR_START:

	if( type != FAT_LABEL )
	{
   	// Allocate the first cluster for either file or directory being created
      if( (rc = _fat_new_clust( part, 0uL, &loc->cluster, 1 )) < 0 )
      {
      	if (rc != -EBUSY) {
         	*prealloc = 0;
         }
         return rc;   // Error state not needed, fat_new_clust does rollback
      }

	   // Work out preallocation amount
   	loc->nav_offset = 1;		// Default to 1 cluster
	   // Note: we only pre-allocate more than one cluster for a file.
      //       Directories get 1 cluster. This is assumed by dir init code!
	   if (type == FAT_FILE && *prealloc > part->clustlen)
   	{
     		alloc = ((*prealloc + part->clustlen - 1) & ~(part->clustlen - 1))
         				/ part->clustlen;
         if (alloc > part->freecluster) {
            alloc = part->freecluster;
         }
         // Limit allocation to maximum positive integer
         loc->nav_offset = (alloc > 0x7FFF ? 0x7FFF : (int)alloc);
	   }

		/* if we are here, loc->u_sector and loc->u_sofs definitely point to the
			directory entry we are about to create. However, with the exception of
			the "label" we now must allocate at least 1 cluster for the contents
	      of the object we intend to create first because if this fails we
   	   return failure and that's it. If it suceeds, then we can create the
      	directory entry and all is well. */
      loc->nav_sec = ( type == FAT_DIR ? part->sec_clust-1 : 1);
	   loc->nav_state = FAT_FILESTATE_CR_DENTRY;

	      // Create the directory entry for the new file/directory
	case FAT_FILESTATE_CR_DENTRY:
     	// If new sub-directory, clear to zeroes and add . and .. entries.
		if( type == FAT_DIR )
		{
	      /* calculate the starting sector of the new sub-directory */
	      _fat_clust2sec( part, loc->cluster, &sector );

	      // Zero out all sectors in the new cluster (no journalling required,
	      // since previous data is unimportant).
	      // Do backward to ensure cache hit for final . and .. write.
	      for (; loc->nav_sec >= 0; --loc->nav_sec) {
	         if ((rc = fatftc_write( part->ftc_prt, sector+loc->nav_sec, 0,
            					FAT_SECSIZE, 0L, FAT_BLOCK_FLAGS | FTC_MEMSET |
                            									FTC_NO_PREIMAGE) ) < 0)
            {
		      	if (rc == -EBUSY)
				      return rc;
	         	loc->nav_sec = rc;
			      loc->nav_state = FAT_FILESTATE_ERR;
               *prealloc = 0;
	            goto _fatfc_err;
            }
	      }
         loc->nav_sec = 1;
			_fat_tm2timestamp( &dat, &tim, &msec );

	      /* create '.' entry */
	      memset(dent[0].name, ' ', 11);
	      dent[0].name[0] = '.';
	      dent[0].attr = FATATTR_DIRECTORY;   /* the attribute byte */
	      dent[0].resv = 0;

	      /* the creation time etc. */
	      dent[0].crtTimeTenth = msec;        /* the so-called milli seconds */
	      dent[0].crtTime = dent[0].wrtTime = tim;  /* the creation time and */
	      dent[0].crtDate = dent[0].lstAccDate = dent[0].wrtDate = dat; // date
	      dent[0].fileSize = 0;

	      /* the dot entry points to itself */
	      _fat_clust2sec( part, loc->cluster, &sector );
	      _fat_Clust2Dir((char *)dent, loc->cluster );

	      memcpy(dent+1, dent, sizeof(dent[0])); // .. is basically like .

	      /* create '..' entry */
	      dent[1].name[1] = '.';
	      /* while the dot dot entry points to the parent directory */
	      _fat_Clust2Dir((char *)(dent+1), loc->s_cluster );
	      // Write both entries in one fell swoop.
	      // Again, pre-image is unimportant since entire op gets rolled back.
	      // Cannot get -EBUSY, because must be in cache from the above
	      if ((rc = fatftc_write( part->ftc_prt, sector, 0, sizeof(dent),
                               paddr(&dent), FTC_WAIT | FTC_NO_PREIMAGE)) < 0)
         {
         	loc->nav_sec = rc;
		      loc->nav_state = FAT_FILESTATE_ERR;
            *prealloc = 0;
            goto _fatfc_err;
         }
		}
		// Remember starting cluster
      loc->s_cluster = loc->cluster;
	}
	else {
		loc->s_cluster = (unsigned long) 0;	// For label entry
   }

   /* From here we can definitely create the parent directory entry,
	      loc->dname has the name */
   _fat_tm2timestamp( &dat, &tim, &msec );

   memcpy(dent[0].name, loc->dname, 11 );

   /* the file attribute (type of file) */
   dent[0].attr = "\x00\x10\x08"[ type - FAT_FILE ];
   dent[0].resv = 0;

   /* the creation time etc. */
   dent[0].crtTimeTenth = msec;           /* the so-called milli seconds */
   dent[0].crtTime = dent[0].wrtTime = tim;  /* the creation time */
   dent[0].crtDate = dent[0].lstAccDate = dent[0].wrtDate = dat;  /* and date */
   dent[0].fileSize = 0;

   _fat_Clust2Dir((char *)dent, loc->s_cluster );    /* the starting cluster */
   loc->nav_state = FAT_FILESTATE_CR_UPDATE;
   // Fall through to next state

	case FAT_FILESTATE_CR_UPDATE:
	   /* now update the directory entry on device */
	   rc = fatftc_write(part->ftc_prt, loc->u_sector, loc->u_sofs,
	                        sizeof(dent[0]), paddr(&dent), FAT_BLOCK_FLAGS);
	   if (rc < 0) {
      	if (rc == -EBUSY) {
		      return rc;
         }
	      loc->nav_state = FAT_FILESTATE_ERR;
         *prealloc = 0;
	      break;
      }
      else
         loc->nav_state = FAT_FILESTATE_CR_ALLOC;

	case FAT_FILESTATE_CR_ALLOC:
      // Allocate additional clusters to new file if requested.
      // loc->nav_sec starts at 1 for the first cluster already allocated.
      // loc->nav_offset contains the allocation amount in clusters.
      // Allocation will always be 1 for a new directory, skipping the while.
   	while (loc->nav_sec < loc->nav_offset) {
      	// A single call to _fat_new_clust can allocate more than 1 cluster
	      if( (rc = _fat_new_clust( part, loc->cluster, &loc->cluster,
	         				loc->nav_offset - loc->nav_sec )) < 0 )
         {
         	if (rc == -ENOSPC) {
               *prealloc = loc->nav_sec * part->clustlen;
               break;
            }
            *prealloc = 0;
	         return rc;   // Error state not needed, fat_new_clust does rollback
         }
         // Set loc->cluster to last cluster in new extended chain
         loc->cluster = (unsigned long)part->linkclust;
         loc->nav_sec += rc;  // Move count forward by number of clusters added
#ifndef FAT_BLOCK
			return -EBUSY;
#endif
      }
      // Setup file/directory position pointer to start of file
      loc->cluster = loc->s_cluster;
      loc->offset = 0;
      return loc->nav_sec;

	case FAT_FILESTATE_ERR:
    _fatfc_err:
      if (!(rc = fatrj_rollback(part->ftc_prt, 0))) {
         loc->nav_state = 0;
         rc = loc->nav_sec;
      }
     	return rc;

   } //switch

   loc->sector = loc->u_sector;
   loc->sofs = loc->u_sofs;

   return 0;
#else
	return -EPERM;
#endif
}


/*** BeginHeader _fat_PartCalc */
int _fat_PartCalc( fat_part * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	This function is calculating redundant partition data which is used
	to increase performance. Important note about "fatlen", this is the
   ACTUAL length of one FAT table in bytes.  This may not completely fill
   the number of sectors allocated to each FAT table.  It also does a
   sanity check of BPB data used to fill the partition structure.

   RETURNS:		0 on success
   			-ENOSYS if FAT partition support is not available
            -EUNFORMAT if partition data from BPB is invalid
*************************************************************************/

_fat_debug int _fat_PartCalc( fat_part *part )
{
	auto unsigned long c;
	auto int rc;

   if (!part->byte_sec || !part->sec_clust || !part->fat_cnt || !part->sec_fat
         || !part->root_cnt || !part->dev->byte_page)
   {
      return -EUNFORMAT;
   }

	/* FAT starts after the boot and hidden sectors. */
	part->fatstart = part->mpart->startsector + (unsigned long)part->res_sec;

	/* Root directory starts right after the last FAT sector. */
	part->rootstart = part->fatstart +
                               ((unsigned long)part->fat_cnt * part->sec_fat);

	/* Calculate the length of the root directory */
	part->datastart = ((unsigned long)(( part->root_cnt * FAT_DIRSZ ) +
      		part->dev->byte_page - 1) / part->byte_sec ) + part->rootstart;

	/* the length of a cluster */
	part->clustlen = (unsigned long)part->sec_clust * part->byte_sec;

	c = ((part->mpart->startsector + part->mpart->partsecsize - part->datastart)
   		 		/ part->sec_clust ) + 2;
	rc = 0;
   if( c < 65527 ) {
		part->type |= FAT_TYPE_16;		/* Volume is FAT16 */
		part->fat_len = (unsigned)c;
	}
	else {
		part->type |= FAT_TYPE_32;		/* Volume is FAT32 */
		part->fat_len = (unsigned)c << 1;
		rc = -ENOSYS;						/* FAT32 is not supported at this time */
	}

	return rc;
}

/*** BeginHeader _fat_chs2LBA */
void _fat_chs2LBA( mbr_dev *, unsigned int,
									unsigned int, unsigned int, unsigned long* );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Returns calcluated LBA from cylinder, head and sector values.
*************************************************************************/
_fat_debug void _fat_chs2LBA( mbr_dev *dev, unsigned int c,
								unsigned int h, unsigned int s, unsigned long *lba )
{
	*lba = ((unsigned long) c * (dev->heads * dev->sec_track)) +
				(h * dev->sec_track) +  s - 1;
}

/*** BeginHeader _fat_CheckPart */
int _fat_CheckPart( fat_part * );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Checks that a partition structure has valid information and is linked
	 to an active device.  Returns partition number on connected device if
    successful, otherwise a negative filesystem error code.

RETURNS:	     Partition number on device if Success
				  -EIO for device link or structure is not valid or active.
              -EINVAL if the Partition has missing or invalid information.
              -EBADPART if the partition is not a FAT partition.
              -EBUSY if the device is busy. (if NON-BLOCKING)
*************************************************************************/
_fat_debug int _fat_CheckPart( fat_part *part )
{
	auto unsigned int c;
	auto unsigned int s;
	auto int rc;
   auto _fat_bpb __far *sbpb;

   /* See if partition and device pointers are useable */
   if ((part == NULL) || (part->ftc_prt < 0)) {
   	return -EINVAL;	// Bad or unregistered partition pointer
   }
   if ((part->dev == NULL) || (part->dev->ftc_dev < 0)) {
   	return -EIO;      // Bad or unregistered device pointer
   }
  	if (fat_IsFatMBREntry(part->mpart->parttype) == 0) {
     	return -EBADPART;
   }

   // Read BPB from start sector of the partition
   if (( rc = fatftc_read( part->ftc_prt, part->mpart->startsector,
                      (long *)&sbpb, FAT_BLOCK_FLAGS | FTC_MAKE_LRU )) < 0 ) {
      return rc;
   }

   // Test calculated values stored in partition structure
   if ( ( part->byte_sec  != sbpb->byte_sec) ||
        ( part->sec_clust != sbpb->sec_clust)||
        ( part->res_sec   != sbpb->res_sec)  ||
        ( part->fat_cnt   != sbpb->fat_cnt)  ||
        ( part->root_cnt  != sbpb->root_cnt) ||
		  ( part->sec_fat   != sbpb->sec_fat)  ||
		  ( part->serialnumber != sbpb->vol_ID)) {
      return -EINVAL;
   }

	if ((part->fatstart != (part->mpart->startsector + part->res_sec))
    || (part->rootstart != (part->fatstart + (part->fat_cnt * part->sec_fat)))
    || (part->datastart != ((unsigned long)(( part->root_cnt * FAT_DIRSZ ) +
    ( part->byte_sec - 1 )) / (unsigned long)part->byte_sec) + part->rootstart)
    || (part->clustlen != ((unsigned long)part->sec_clust * part->byte_sec))) {
    	return -EINVAL;
    }


	c = (unsigned)((part->mpart->startsector + part->mpart->partsecsize -
   					part->datastart) / part->sec_clust) + 2;

   if (part->fat_len != c) {
   	return -EINVAL;
   }

	return 0;
}


/*** BeginHeader _fat_isopen */
int _fat_isopen( fat_part *part, fat_location *loc );
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	Scans file chain on part to see if file at location 'loc' is open.

RETURNS:		1 if file/directory at loc is open.
            0 if file/directory at loc is not open.
*************************************************************************/
_fat_debug int _fat_isopen( fat_part *part, fat_location *loc )
{
	auto FATfile *fptr;

   for (fptr = part->first; fptr; fptr = fptr->next) {
   	if (fptr->loc.s_cluster == loc->s_cluster) {
      	return 1;
      }
   }
   return 0;
}


/*** BeginHeader fat_IsFatMBREntry */
int fat_IsFatMBREntry( unsigned char parttype );
/*** EndHeader */

const char FAT_codes[7] = {0x01, 0x04, 0x06, 0x0b, 0x0c, 0x0e, 0};

/********************** >> INTERNAL FUNCTION << *************************
	This function defines which partition types we recognize.

RETURNS:		1 if parttype is a FAT partition type code.
            0 if parttype is not a FAT partition type code.
*************************************************************************/
_fat_debug int fat_IsFatMBREntry( unsigned char parttype )
{
   if (!parttype || parttype & 0xe0) {
   	return 0;
   }

	return ( strchr(FAT_codes, (parttype & 0x0f)) ? 1 : 0);
}


/*** BeginHeader _fat_unmountdevparts */
void _fat_unmountdevparts(fat_part **prtMountList, int devnum);
/*** EndHeader */


/********************** >> INTERNAL FUNCTION << *************************
	This function unmounts a device's mounted partitions.

RETURNS: Nothing.
*************************************************************************/
_fat_debug void _fat_unmountdevparts(fat_part **prtMountList, int devnum)
{
	auto int i, rc;

	for (i = devnum*FAT_MAX_PARTITIONS; i < (devnum+1)*FAT_MAX_PARTITIONS; ++i) {
		if (prtMountList[i]) {
#ifdef FAT_VERBOSE
			printf("_fat_unmountdevparts:  unmounting partition %d...\n", i);
#endif
			while ((rc = _fat_UnmountPartition(prtMountList[i])) == -EBUSY);
#ifdef FAT_VERBOSE
			printf("_fat_unmountdevparts:  ...rc=%d\n", rc);
#endif
			prtMountList[i] = NULL;
		}
	}
}


/*** BeginHeader _fat_clear_mbr */
int _fat_clear_mbr(mbr_dev *dev);
#ifdef FAT_USE_UCOS_MUTEX
int __fat_clear_mbr(mbr_dev *dev);
#endif
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************

/* START_FUNCTION DESCRIPTION ********************************************
_fat_clear_mbr                <FAT16.LIB>

SYNTAX:			int _fat_clear_mbr(mbr_dev *dev)

DESCRIPTION:  This function drops any cache entries related to the given
              device and performs a direct clear of the mbr area and
              any bpb areas of partitions currently defined in the mbr.
              The device must be formatted after this function is run to
              setup new usable partitions.  This will invalidate any
              partition structures related to this device so all partitions
              must be unmounted before calling this function.  Partitions
              must be rebuilt after using this function.  This will also
              render any non-FAT partitions on the device inaccessable.

              USE WITH CAUTION!!! Only use for full re-format of a device.
              This does not affect any other devices within the system.

              This is a blocking function.

PARAMETER 1: 	Pointer to enumerated mbr_dev device structure for device

RETURN VALUE: 	0 on success
					-EIO on device IO error.
               -EINVAL if dev is not an enumerated device
               -EPERM if dev has any mounted partitions

SEE ALSO: 		fat_EnumDevice, fat_FormatDevice, fat_FormatPartition
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int _fat_clear_mbr( mbr_dev *dev)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = __fat_clear_mbr( dev );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int __fat_clear_mbr( mbr_dev *dev)
#else
_fat_debug int _fat_clear_mbr( mbr_dev *dev)
#endif
{
   auto int i, rc;
   auto char __far *buf;

   if (!dev || !dev->driver || !dev->seccount || dev->ftc_dev < 0
        || !dev->byte_sec ) {
   	return -EINVAL;
   }

   for (i = 4; i--; ) {
      if (dev->fs_part[i]) {
         return -EPERM;    // Mounted partition found, abort mbr clear
      }
   }

   // Drop all cache entries, markers and transactions from the device
   rc = fatftc_flushdev(dev->ftc_dev, FTC_NOWRITE);
   if (rc < 0) {
      return rc;
   }

   // Get memory for sector/spare buffers
   buf = (__far char *)xalloc(dev->byte_sec + 16);
   _f_memset(buf, 255, dev->byte_sec + 16);
   for (i = 4; i--; ) {
      if (dev->part[i].partsecsize) {  // Does this partition exist?
	      // Clear BPB sector of partition directly (bypass cache)
         do {
            dev->driver->xxx_InformStatus(dev, 0);
	         rc = dev->driver->xxx_WriteSector(dev->part[i].startsector, buf,
                                               buf+512, dev, 0);
         } while (rc == -EDRVBUSY);
         while (rc == -EBUSY) {    // Wait for write to complete
            rc = dev->driver->xxx_InformStatus(dev, 0);
         }
         if (rc) {
            xrelease((long)buf, dev->byte_sec + 16);   // Release buffers
            return rc;                                 // and return error
         }
      }
   }

   // Clear MBR sector on device directly (bypass cache)
   do {
      dev->driver->xxx_InformStatus(dev, 0);
      rc = dev->driver->xxx_WriteSector(0L, buf, buf+512, dev, 0);
   } while (rc == -EDRVBUSY);
   while (rc == -EBUSY) {    // Wait for write to complete
      rc = dev->driver->xxx_InformStatus(dev, 0);
   }
   xrelease((long)buf, dev->byte_sec + 16);   // Release sector/spare buffers

   // Clear the partition table within the MBR data structure
   memset(dev->part, 0, sizeof(mbr_part)*4);

   return rc;
}


/*** BeginHeader _fat_automount */
int _fat_automount(word, word, const _fat_driver_descr *,
                    const _fat_device_descr *, mbr_drvr *, mbr_dev *,
                     fat_part *, fat_part **, word);
/*** EndHeader */

/********************** >> INTERNAL FUNCTION << *************************
	This function actually does the work of auto mounting all available
	devices' FAT partition(s).

RETURNS:		0 if completely successful,
            negative FAT error code if partly successful or unsuccessful
*************************************************************************/

/* START_FUNCTION DESCRIPTION ********************************************
_fat_automount                <FAT16.LIB>

SYNTAX:			int _fat_automount(word nDrvs, word nDevs,
					                   const _fat_driver_descr *drvConfig,
					                   const _fat_device_descr *devConfig,
					                   mbr_drvr *drvTable, mbr_dev *devTable,
					                   fat_part *prtTable, fat_part **prtMountList,
					                   word flags);

DESCRIPTION:	Initializes the drivers in the drivers configuration list
					and enumerates the devices in the devices configuration
					list, then mounts partitions on all devices according to
					the device's configuration flags.  This function makes
					initializing multiple devices using the FAT library as easy
					as possible.  The first driver in the configuration list
					becomes the primary driver in the system, if one is not
					already set up.

               After this function successfully returns, the application
               can start calling directory and file functions for the
               mounted device partitions.

               If devices and/or partitions are not already formatted,
               this function can optionally format them according to the
               the device's configuration flags.

               This function may be called multiple times, but will not
               attempt to (re)mount device partitions that it has already
               mounted.

               Once a device partition has been mounted by this function,
               unmounts and remounts must be handled by the application.


PARAMETER 1: 	Number of drivers to initialize in drivers configuration
					list.

PARAMETER 2: 	Number of devices to enumerate in devices configuration
					list.

PARAMETER 3: 	Pointer to drivers configuration list.

PARAMETER 4:	Pointer to devices configuration list.

PARAMETER 5:	Pointer to devices' partition mounted map.

PARAMETER 6: 	Pointer to array of driver structures to fill in.

PARAMETER 7: 	Pointer to array of device structures to fill in.

PARAMETER 8: 	Pointer to array of FAT partition structures to fill in.

PARAMETER 9:   Run-time device configuration flags to allow overriding the
               default device configuration flags.  If not overriding the
               default configuration flags, specify FDDF_USE_DEFAULT.  To
               override the default flags, specify the ORed combination of
               one or more of the following:
                 FDDF_MOUNT_PART_0       //mount device(s)' partition 0
                 FDDF_MOUNT_PART_1
                 FDDF_MOUNT_PART_2
                 FDDF_MOUNT_PART_3
                 FDDF_MOUNT_PART_ALL     //mount all partitions
                 FDDF_MOUNT_DEV_0        //apply to specified device(s)
                 FDDF_MOUNT_DEV_1
                 FDDF_MOUNT_DEV_2
                 FDDF_MOUNT_DEV_3
                 FDDF_MOUNT_DEV_ALL      //mount all available devices
                 FDDF_NO_RECOVERY        //use norecovery if first fails
                 FDDF_COND_DEV_FORMAT    //format device if unformatted
                 FDDF_COND_PART_FORMAT   //format partition if unformatted
                 FDDF_UNCOND_DEV_FORMAT  //format device unconditionally
                 FDDF_UNCOND_PART_FORMAT //format partition unconditional
               Note: the FDDF_MOUNT_PART_* flags apply equally to all
               FDDF_MOUNT_DEV_* devices which are specified.  If this is a
               problem, call this function multiple times with a single
               DEV flag bit each time.
               Note: formatting the device creates a single FAT partition
               covering the entire device.  It is recommended that you
               always set the *_PART_FORMAT flag bit if you set the
               corresponding *_DEV_FORMAT flag bit.

RETURN VALUE: 	0 on success
					-EIO on device IO error.
               -EINVAL if pnum, driver, device or part are invalid
               -EUNFORMAT if device is not formatted
               -EBADPART if partition is not a valid FAT partition
					-ENOPART if no partitions exist on the device
               -EBUSY if the device is busy.  (Only if non-blocking)
               -ENODEV  failed to mount removable device because it wasn't
                        found. Other error conditions will override this
                        return value.

SEE ALSO: 		fat_EnumDevice, fat_EnumPartition, fat_MountPartition
*************************************************************************/
_fat_debug
int _fat_automount(word nDrvs, word nDevs, const _fat_driver_descr *drvConfig,
                    const _fat_device_descr *devConfig, mbr_drvr *drvTable,
                     mbr_dev *devTable, fat_part *prtTable,
                      fat_part **prtMountList, word flags)
{
	auto char *usesignature;
	auto int i, j, mounts, rc, save_rc;
	auto word useflags, *wptr;
	auto const _fat_driver_descr *drvdesc;
	auto const _fat_device_descr *devdesc;
	auto fat_part *temppart, **temppartlist;
   auto mbr_dev *dev;
   auto  mbr_drvr *driver;
   auto long ladrDev,serial;
   auto char  newVolume;
   static char devVolLabel[12];
   static int deviceEnum[6];
	auto FTCDevInfo di;

   usesignature = NULL;
   drvdesc = NULL;
   devdesc = NULL;
   temppart = NULL;
   temppartlist = NULL;

   memset(deviceEnum,0,sizeof(deviceEnum));

	// basic sanity check, do we have all of the information we need?
	if (!nDrvs || !nDevs || !drvConfig || !devConfig || !drvTable ||
        !devTable || !prtTable || !prtMountList || (flags>FDDF_USE_DEFAULT) ||
         !(flags & (FDDF_MOUNT_PART_ALL|FDDF_USE_DEFAULT)) ||
          !(flags & (FDDF_MOUNT_DEV_ALL|FDDF_USE_DEFAULT)) )
	{
		return -EINVAL;
	}

   // If unconditional, don't need conditional
   if((flags&FDDF_COND_DEV_FORMAT) && (flags&FDDF_UNCOND_DEV_FORMAT)){
       flags &= ~FDDF_COND_DEV_FORMAT;
   }
   if(flags&FDDF_UNCOND_DEV_FORMAT) {
       flags |= FDDF_UNCOND_PART_FORMAT;
   }
   if((flags&FDDF_COND_PART_FORMAT) && (flags&FDDF_UNCOND_PART_FORMAT)){
       flags &= ~FDDF_COND_PART_FORMAT;
   }

	save_rc = rc = 0;
	// All drivers must be initialized and all devices enumerated before any
	//  partition access is done, in order to ensure that dirty FTC buffers can
	//  be flushed.  Otherwise, could deadlock on partition enum/mount if all FTC
	//  buffers are dirty but one is required for rollback on a different device!
	for (i = 0; i < nDrvs; ++i) {
      driver = drvTable + i;
		drvdesc = drvConfig + i;

		if (*((int *)(driver)) == 0) {    // See if not initialized
			if (rc = drvdesc->InitDriver(driver, NULL)) {
#ifdef FAT_VERBOSE
				printf("_fat_automount:  InitDriver(%d) fatal error %d.\n", i, rc);
#endif
				// driver init error is serious, return result code immediately
            // unless there are multiple drivers and this is a no medium error
            // or driver has already been initialized
            if (!(rc == -ENOMEDIUM && nDrvs > 1) && rc != -EEXIST) {
   				return (rc == -1 ? -EIO : rc);
            }
			}
		}
		for (j = 0; j < nDevs; ++j) {
         dev = devTable + j;
			devdesc = devConfig + j;
   		useflags = (flags == FDDF_USE_DEFAULT) ? devdesc->flags : flags;
         if (useflags & (FDDF_MOUNT_DEV_0 << j)) {
            if (_fat_driver_table[0].type[j]) {
               if (fat_part_mounted[j * 4]) {
                  rc = _fat_UnmountDevice(dev);
	               //*** Use low level API to re-initialize after dev unmount
	               rc = driver->xxx_EnumDevice(driver, dev, devdesc->deviceID,0);
#ifdef FAT_VERBOSE
                  printf("Automount Unmounting Device: %d, rc = %d \n", j, rc);
#endif
               }
            }
         }
#ifdef FAT_NAND_DEVICE_USED  // NAND specific initialization check
#ifdef FAT_ALLOW_HOTSWAP  // #define'd in fat_config.lib
#ifndef FAT_NOHOTSWAP     // #define'able by user
         // A NULL default volume label indicates that this is a removable
         // device. _fat_driver_table[0].type[j] == 0 means that the driver
         // initialization for this device wasn't complete the last time
         // through automount.
         if(strlen(devdesc->sig)==0&&_fat_driver_table[0].type[j]==0 &&
           devdesc->sig && !strcmp(_fatConfig[j].type, "NF"))
         {
            // This is to allow autotmount to succeed to mount a removable XD
            // card after automount was already called with no XD present. This
            // is needed because the call to Init driver above does some device
            // level initialization. In the case of a single device (e.g. the
            // RCM3370), we shouldn't be in this code block and don't need to
            // be because of the way nf_InitDriver works.
            if(!nf_initDevice(&(_nf_defaultDevList[j]), 1)) {

#ifdef FAT_HOTSWAP_VERBOSE
                printf("initializing previously absent removable dev.\n");
#endif
                // Successfully initialized this NAND flash device handle
                _fat_driver_table[0].type[j] = MBRTYPE_FLASH |
#ifndef __FATFTL_LIB       // FTL layer hides bad block markers from FAT
                                             MBRTYPE_MARKERS |
#endif
                                              MBRTYPE_REMOVE ;

               // Link soldered flash device handle to this one
               // this one's next pointer is already zeroed out.
               if(&(_nf_defaultDevList[0]))
               {
                   _nf_defaultDevList[0].next = &(_nf_defaultDevList[j]);
               }
            }
         }
#endif    // ifndef FAT_NOHOTSWAP
#endif    // ifdef FAT_ALLOW_HOTSWAP
#endif    // ifdef FAT_NAND_DEVICE_USED

			if (!(useflags & (FDDF_MOUNT_DEV_0 << j)) ||
			    (devdesc->InitDriver != drvdesc->InitDriver))
			{
				// Do not want to act on this device or device doesn't belong to
				//  current driver, so skip it
				continue;
			}

		   if (useflags & FDDF_UNCOND_DEV_FORMAT)
         {
				// conditional format, first unmount all partitions on this device
				_fat_unmountdevparts(prtMountList, j);

#ifdef FAT_VERBOSE
				printf("2 _fat_automount:  fat_FormatDevice(%d)...\n", j);
#endif
				// format device with a single maximal partition
				rc = _fat_FormatDevice(dev, 6);
				rc = (rc == -EEXIST) ? 0 : rc;	// ignore existing device error
   			if (rc && !save_rc) {
	   			save_rc = rc;
		   	}
			}

         newVolume = 0;
         memset(devVolLabel,0,12);

#ifdef FAT_REMOVABLE      // #define'd in fat_config.lib

         // If const label is set to a NULL string, this is a removable device
         //  Use the volume serial number to create label, and see if it's the
         //  same as the last one that was mounted.
         if (devdesc->sig == NULL || strlen(devdesc->sig) == 0) {
            //*** Use low level API to initialize
            rc = driver->xxx_EnumDevice(driver, dev, devdesc->deviceID, 0);

            if (rc) {  // unformatted device should return error
#ifdef FAT_VERBOSE
               printf("1 _fat_automount: fat_EnumDevice returned %d.\n", rc);
#endif
               if(rc != -EUNFORMAT) {
                  nDevs--;
                  continue;
               }
            }
            // Mark device as removable
            _fat_driver_table[i].type[dev->dev_num] |= MBRTYPE_REMOVE ;

            //*** Read first sector from device
            ladrDev = xalloc(1024);
            //*** Set offset if not NAND flash ***
            while((driver->xxx_ReadSector(0L, ladrDev,
                                           (__far char *)NULL, dev)) == -EBUSY);
			   if (strcmp(_fatConfig[i].type, "NF")) {
               while((driver->xxx_ReadSector(1L, ladrDev+512,
                                           (__far char *)NULL, dev)) == -EBUSY);
            }
            // Read the volume serial number
            _f_memcpy((void __far *)&serial,(void __far *)(ladrDev + 0x227), 4);
#ifdef FAT_VERBOSE
            printf("1 _fat_automount: read vol label %s.\n",devVolLabel);
#endif

            //*** See if dev. has Master Boot Record (MBR)
            if(rc || xgetint(ladrDev + 0x1FE) != 0xAA55 ||
                  (useflags & FDDF_UNCOND_PART_FORMAT)  ||
                  (useflags & FDDF_UNCOND_DEV_FORMAT))
            {
               //*** No MBR, Create unique Volume Serial Number
            	wptr = (word *)(&serial);
      			_fat_tm2timestamp( wptr + 1, wptr, NULL);
               //*** Create volume label from Volume Serial Number
               sprintf(devVolLabel, "%0lx", serial);

                newVolume = 1;
#ifdef FAT_VERBOSE
               printf("_fat_automount: creating vol. label %s\n", devVolLabel);
#endif
            }
            else {
               //*** Create volume label from the volume serial number
               sprintf(devVolLabel, "%08lx", serial);
               //*** Compare volume label from device to cache
               if(memcmp((char __far *)devVolLabel,_ftc.dv[j].di->devsig,8)){
                  newVolume = 1;
#ifdef FAT_VERBOSE
                  printf(
                    "_fat_automount: found new volume label(N = %s, O = %s)\n",
                    devVolLabel, _ftc.dv[j].di->devsig);
#endif
               }
               else {
#ifdef FAT_VERBOSE
                  printf(
                   "fat_automount: cached vol. matches dev. %s\n",devVolLabel);
#endif
               }
            }
            xrelease( ladrDev, 1024);  // Free xmem

            if(newVolume &&
                !(useflags & (FDDF_UNCOND_DEV_FORMAT | FDDF_UNCOND_PART_FORMAT)))
            {
                _f_memcpy((void __far *)&di, _ftc.dv[j].di, sizeof(di));
                // Unregister existing volume
                rc = fatftc_regdev(NULL,di.devsig,1,NULL);
#ifdef FAT_VERBOSE
                printf("1 _fat_automount: fatftc_regdev returned %d, \n", rc);
#endif
                // Flush cache without writes
                rc = fatftc_flushdev(j, FTC_PURGE | FTC_NOWRITE);
#ifdef FAT_VERBOSE
                printf(
                 "_fat_automount: fatftc_flushdev (NO WRITE) returned %d.\n",rc
                );
#endif
                // Make sure device is unregistered and no recovery is attempted
                _ftc.dv[j].flags &= ~FTCDR_REGISTERED;
                dev->ftc_dev = -1;
                useflags = FDDF_NO_RECOVERY | useflags;
            }
            _ftc.dv[j].flags |= FTCDR_REASSIGN;  // make reassignable
        }
#endif      // end of ifdef FAT_REMOVABLE

        newVolume = 0;
        devVolLabel[8] = 0;

        // ********************************************************************
        // Soldered-on device driver is intialized with const hardcoded label.
        // XD card driver is initialized with const NULL and created or read
        // above.
        // ********************************************************************
        usesignature = (devdesc->sig && strlen(devdesc->sig)) ?
                             devdesc->sig : devVolLabel;
        rc = _fat_EnumDevice(driver, dev, devdesc->deviceID,
                   usesignature, useflags & FDDF_NO_RECOVERY);
#ifdef FAT_VERBOSE
         if (!rc) {
            printf("_fat_automount:  _fat_EnumDevice(%d,%d,%s) error %d.\n",
                   i, j, usesignature, rc);
         }
#endif
			// ignore existing device or (probable removed device) I/O errors
#ifdef FAT_REMOVABLE          // Removeable device may need to be re-registered
			if (rc == -EEXIST) { // with the cache layer
            if (dev->ftc_dev < 0) {
	            // Register the device with the cache layer
	            dev->ftc_dev = fat_removableDev = fatftc_regdev(dev,
                                                      usesignature, 1, NULL);
            }
            rc = 0;
         }
         else rc = (rc == -EIO) ? 0 : rc;
#else
			rc = ((rc == -EEXIST) || (rc == -EIO)) ? 0 : rc;
#endif
			if ((rc && (useflags & FDDF_COND_DEV_FORMAT)) )
         {
				// conditional format, first flush cache without writes
            rc = fatftc_flushdev(j, FTC_PURGE | FTC_NOWRITE);
#ifdef FAT_VERBOSE
            printf(
               "_fat_automount: fatftc_flushdev (NO WRITE) returned %d.\n",rc
            );
#endif
				// then unmount all partitions on this device
				_fat_unmountdevparts(prtMountList, j);
#ifdef FAT_VERBOSE
				printf("2 _fat_automount:  fat_FormatDevice(%d)...\n", j);
#endif
				// format device with a single maximal partition
				rc = _fat_FormatDevice(dev, 6);
				rc = (rc == -EEXIST) ? 0 : rc;	// ignore existing device error
			}
			if (rc) {
				if (!save_rc) {
					save_rc = rc;
				}
			}
         else {
            rc = _fat_EnumDevice(driver, dev, devdesc->deviceID,
                             usesignature, FDDF_NO_RECOVERY & useflags);
#ifdef FAT_VERBOSE
            if (rc) {
               printf("2 _fat_automount:  _fat_EnumDevice(%d,%d,%s) error %d.\n",
                      i, j, usesignature, rc);
            }
#endif
            // ignore existing device or (probable removed device) I/O errors
            rc = ((rc == -EEXIST) || (rc == -EIO)) ? 0 : rc;
            if (rc && !save_rc) {
               save_rc = rc;
            }
			}
#ifdef FAT_VERBOSE
			if (!rc) {
				printf("_fat_automount:  enumerated driver %d's device %d (%d).\n",
				       i, devdesc->deviceID, j);
			}
#endif
		}	// end for j
	}	// end for i

	mounts = 0;
	// Now step through the devices to mount all of the partitions found.
	for (i = 0; i < nDevs; ++i) {
      dev = devTable + i;
		devdesc = devConfig + i;
		useflags = (flags == FDDF_USE_DEFAULT) ? devdesc->flags : flags;
		if (!(useflags & (FDDF_MOUNT_DEV_0 << i))) {
			// do not want to act on this device, so skip it
			continue;
		}
		for (j = 0; j < FAT_MAX_PARTITIONS; ++j) {
			if (!(useflags & (FDDF_MOUNT_PART_0 << j))) {
				// do not want to act on this partition, so skip it
				continue;
			}
			temppart = prtTable + i * FAT_MAX_PARTITIONS + j;
			temppartlist = prtMountList + i * FAT_MAX_PARTITIONS + j;
#ifdef FAT_VERBOSE
				printf("_fat_automount:  temppart is %04X, temppartlist is %04X.\n",
				       temppart, temppartlist);
#endif
			if (useflags & FDDF_UNCOND_PART_FORMAT) {
				// unconditional format, first unmount this partition
#ifdef FAT_VERBOSE
				printf("1 _fat_automount:  unmounting partition %d...\n", j);
#endif
				while ((rc = _fat_UnmountPartition(*temppartlist)) == -EBUSY);
#ifdef FAT_VERBOSE
				printf("1 _fat_automount:  ...rc=%d\n", rc);
#endif
				*temppartlist = NULL;
#ifdef FAT_VERBOSE
				printf("1 _fat_automount:  fat_FormatPartition(%d,%d)...\n", i, j);
#endif
				while ((rc = _fat_FormatPartition(dev, temppart, j, FAT_TYPE_16,
                               usesignature, NULL)) == -EBUSY);
#ifdef FAT_VERBOSE
				printf("1 _fat_automount:  ...rc=%d.\n", rc);
#endif

            if (rc == -ENOPART && !j) {
#ifdef FAT_VERBOSE
					printf("1 _fat_automount:  fat_FormatDevice(%d, 3)...\n", i);
#endif
					while ((rc = _fat_FormatDevice(dev, 3)) == -EBUSY);
               if (!rc) {
                  save_rc = 0;
                  if (dev->ftc_dev < 0) {
                     usesignature = strlen(devdesc->sig) ? devdesc->sig
                                                            : devVolLabel;
                     rc = _fat_EnumDevice(driver, dev, devdesc->deviceID,
                             usesignature, useflags & FDDF_NO_RECOVERY);
                  }
               }
#ifdef FAT_VERBOSE
					printf("1 _fat_automount:  ...rc=%d.\n", rc);
#endif
            }

				// save error result if one hasn't already been saved before
            //  unless a no partition error and other partition(s) mounted
				if (rc && !save_rc && (rc != -ENOPART || !mounts)) {
				   save_rc = rc;
				}
			}
			if (*temppartlist && temppart->dev->fs_part[temppart->pnum] == temppart)
         {
				// don't do anything more if partition is currently mounted OK
				continue;
			}
			// FIX THIS - Currently blocking to avoid registration error
			while((rc = _fat_EnumPartition(dev, j, temppart)) == -EBUSY);
#ifdef FAT_VERBOSE
			if (rc) {
				printf("1 _fat_automount:  fat_EnumPartition(%d,%d) error %d.\n",
				       i, j, rc);
			}
#endif
			rc = (rc == -EEXIST) ? 0 : rc;	// ignore existing partition error
			if(rc == -EUNFORMAT &&
              (useflags&(FDDF_COND_PART_FORMAT || FDDF_UNCOND_PART_FORMAT)))
         {
				// conditional or unconditional format of partition
#ifdef FAT_VERBOSE
				printf("2 _fat_automount:  fat_FormatPartition(%d,%d)...\n", i, j);
#endif
				while ((rc = _fat_FormatPartition(dev, temppart, j, FAT_TYPE_16,
                               usesignature, NULL)) == -EBUSY);
#ifdef FAT_VERBOSE
				printf("2 _fat_automount:  ...rc=%d.\n", rc);
#endif
			}
			if (rc) {
				// save error result if more serious or none saved
				if ((rc != -ENOPART || !mounts)&&(!save_rc || save_rc == -ENOPART))
            {
               save_rc = rc;
            }
				// don't attempt anything more if partition is not enumerated and is
				//  not reformatted
				continue;
			}
			// FIX THIS - Currently blocking to avoid registration error
			while((rc = _fat_EnumPartition(dev, j, temppart)) == -EBUSY);
#ifdef FAT_VERBOSE
			if (rc) {
				printf("2 _fat_automount:  fat_EnumPartition(%d,%d) error %d.\n",
				       i, j, rc);
			}
#endif
			rc = (rc == -EEXIST) ? 0 : rc;	// ignore existing partition error
			if (!rc) {
				// FIX THIS - Currently blocking to avoid registration error
				while ((rc = _fat_MountPartition(temppart)) == -EBUSY);
#ifdef FAT_VERBOSE
				printf("_fat_automount:  fat_MountPartition(%d,%d) rc=%d.\n",
				       i, j, rc);
#endif
			}
			if (rc) {
            _fat_UnmountPartition(temppart); // In case Mount fails
 				// save error result if one hasn't already been saved before
				if (!save_rc) {
					save_rc = rc;
				}
			} else {
				// mark this device's partition as mounted by assigning the
				//  partition structure's address into the mounted list
				*temppartlist = temppart;
				++mounts;	// one more successful partition mount
            if (save_rc == -ENOPART) {
               save_rc = 0;   // Drop no partition error if at least one mounts
            }
#ifdef FAT_VERBOSE
				printf("_fat_automount:  mounted device %d (%d) partition %d.\n",
				       devdesc->deviceID, i, j);
#endif
			}
		}	// end for j
	}	// end for i

	if (mounts && !fat_sysdriver) {
		// if not already set, make the initial driver table entry the default
		fat_sysdriver = drvTable;
	}

	// return zero or first encountered serious (but non-fatal) error code,
	//  even when successful
	return save_rc;
}	/* end _fat_automount() */


/***************************************************************************/
/* User level functions below this point.  -  DO NOT USE ABOVE FUNCTIONS!! */
/*                                                                         */
/***************************************************************************/


/*** BeginHeader fat_EnumDevice, _fat_EnumDevice */
int fat_EnumDevice( mbr_drvr *, mbr_dev *, int, char *, int );
#ifndef FAT_USE_UCOS_MUTEX
#define  _fat_EnumDevice fat_EnumDevice
#else
int _fat_EnumDevice( mbr_drvr *, mbr_dev *, int, char *, int );
#endif
extern int fat_removableDev;
extern int fat_solderedDev;

/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_EnumDevice                        <FAT16.LIB>

SYNTAX:       fat_EnumDevice(mbr_drvr *driver, mbr_dev *dev, int devnum
											char *sig, int norecovery );

DESCRIPTION:  This function is called to learn about devices present on
              the driver passed in.  The device will be added to the
              linked list of enumerated devices.  Partition pointers will
              be set to NULL indicating they have not been enumerated yet.
              Partition entries must be enumerated separately.  The
              signature string is an identifier given to the write-thru
              cache and MUST remain consistent between resets so the
              device can be associated properly with any battery-backed
              cache entries remaining in memory.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5
         seconds and can be changed by #define'ing a different value for
         FAT_MUTEX_TIMEOUT_SEC.
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   driver - Pointer to a driver structure (setup during
                      init of storage device driver.)

PARAMETER2:   dev - Pointer to a device structure to be filled in.

PARAMETER3:   devnum - Physical device number of device on the driver.

PARAMETER4:   sig - Pointer to a unique signature string. **NOTE - this
							value MUST remain the same between resets.

PARAMETER 5:  Boolean flag - Set True to ignore power recovery data.
										True is considered any value except zero.

RETURNS:	     0 for Success
				  -EIO for Error trying to read the device or structure.
              -EINVAL if devnum invalid or does not exist.
              -ENOMEM if memory for page buffer/RJ is not available.
              -EUNFORMAT if the device is accessible, but not formatted.
              			You can use it provided it is formatted/partitioned
                     by either this library or another system.
              -EBADPART if the partition table on the device is invalid
              -ENOPART if the device does not have any FAT partitions.
                     This code is superceded by any other error detected.
				  -EEXIST if the device has already been enumerated.
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_AutoMount, fat_Init, fat_EnumPartition

*************************************************************************/

// Global device IDs for use with fatftc_flushdev, etc.
int fat_removableDev;
int fat_solderedDev;

#ifdef FAT_USE_UCOS_MUTEX
_fat_debug
int fat_EnumDevice( mbr_drvr *driver, mbr_dev *dev, int devnum,
												char *sig, int norecovery )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_EnumDevice(driver, dev, devnum, sig, norecovery );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug
int _fat_EnumDevice( mbr_drvr *driver, mbr_dev *dev, int devnum,
												char *sig, int norecovery )
#else

_fat_debug
int fat_EnumDevice( mbr_drvr *driver, mbr_dev *dev, int devnum,
												char *sig, int norecovery )
#endif

{
   static __far char *xptr;
	auto char dsig[16];
	auto int rc;
   auto mbr_dev *ptr;
   auto char temp[0xE0];

#GLOBAL_INIT{
   fat_removableDev = -2;
   fat_solderedDev = -2;
   xptr = 0L;
}

   if (!driver)
   	return -EIO;

   if (driver->ndev)
   {
		// Scan enumerated devices to see if this device already exists
   	ptr = driver->dlist;
      while (1) {
   		if (ptr->dev_num == devnum) {
  	   	   return -EEXIST;		// Device already enumerated
         }
        	if (ptr->next) {     // See if chain continues
            ptr = ptr->next;  // Move to next device in chain
         }
         else {
            break;            // Exit with pointer to end of linked list
         }
      }
   	if (driver->ndev	>= driver->maxdev) {
	   	return -EDQUOT;
      }
   }

   if (xptr) {
      rc = 0;     // Read returned busy, no need to re-enumerate
   }
   else {
	   memset(dev, 0, sizeof(mbr_dev));
   	rc = driver->xxx_EnumDevice(driver, dev, devnum, 0);
   }

   if (!rc || rc == -EEXIST)
   {
      if (!xptr) {
         if (xavail(NULL) < dev->byte_sec) {
         	return -ENOMEM;
         }
         xptr = (__far char *)xalloc(dev->byte_sec);
      }

      // Read first sector from device
      while ((rc = driver->xxx_ReadSector(0L, xptr,
                                           (__far char *)NULL, dev)) == -EBUSY);

      // See if device has a Master Boot Record (MBR)

      // If NAND flash driver, verify that MBR was created by this libray -
      //     xD factory formatted MBRs aren't valid with this FAT.
      if (rc || (!strcmp(_fatConfig[dev->dev_num].type, "NF") &&
            memcmp(mbr_start, xptr, 0xE0)) || (xgetint(xptr+510) != 0xAA55))
      {
#ifdef FAT_VERBOSE
 			 printf("_fat_EnumDevice: Invalid MBR found\n");
#endif
         // No MBR at all or read error
         xrelease( (long)xptr, dev->byte_sec);
         xptr = 0L;
         dev->ftc_dev = -1;        // Disconnect from cache

         if (rc) {
            for (ptr = driver->dlist; ptr && ptr != dev; ptr = ptr->next);
            ptr = NULL;   // On error, disconnect device from active list
            return rc;
         }
         else {
            return -EUNFORMAT;
         }
      }
#ifdef FAT_VERBOSE
  	   printf("_fat_EnumDevice: Valid MBR found\n");
#endif

		// Copy MBR partition table to device structure
      for (rc = 4; rc--; _f_memcpy((void __far *)&(dev->part[rc]),
                                     xptr + (16 * rc) + 0x1BE , 16));

      xrelease( (long)xptr, dev->byte_sec);
      xptr = 0L;

	   // Copy signature string and pad with spaces
   	rc = strlen(sig);
	   if (rc > 16) rc = 16;
   	strncpy(dsig, sig, rc);
	   if (rc < 16) memset(dsig + rc, 0x20, 16 - rc);

      // Register the device with the Cache
     	rc = fatftc_regdev(dev, dsig, norecovery, _fat_chkpoint);
      if(dev->driver->type[dev->dev_num] & MBRTYPE_REMOVE) {
         fat_removableDev = rc;
      }
      else {
         fat_solderedDev = rc;
      }
      if (rc < 0)
      {
         if (rc != -EEXIST) {    // Device not registered with cache
	      	dev->ftc_dev = -1;
            if ((rc != -ENOMEM) && (rc != -EINVAL)) {
            	rc = -EIO;
            }
         }
      }
      else {
		   if (driver->ndev) {
   			ptr->next = dev;
         }
		   else {
   			driver->dlist = dev;
         }
      	dev->ftc_dev = rc;
         driver->ndev++;
         rc = 0;
      }
   }
   return rc;
}

/*** BeginHeader fat_FormatDevice, _fat_FormatDevice */
int fat_FormatDevice( mbr_dev *, int );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_FormatDevice fat_FormatDevice
#else
int _fat_FormatDevice( mbr_dev *, int );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_FormatDevice                        <FAT16.LIB>

SYNTAX:       fat_FormatDevice(mbr_dev *dev, int mode)

DESCRIPTION:  This function is called to format a device.  The device will
				  have a DOS master boot record written to it.  If the device
              was previously formatted, existing partitions will be left
              alone. The formatted device will be registered with the
              write-thru cache for use with the FAT library.  The one
              partition mode will instruct the function to create a
              partition table with one partition using the entire device.
              This mode only works if the device is currently unformatted
              or has no partitions.

              NOTE: When used with the FTL layer (NAND Flash) this function
                    will block for the low level format and registration
                    required for a device format even in non-blocking mode.

 uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5
         seconds and can be changed by #define'ing a different value for
         FAT_MUTEX_TIMEOUT_SEC.
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   dev - Pointer to data structure for the device to format.

PARAMETER2:   mode -  0 = normal (use part table in device)
							 1 = one partition using the entire device
                      		(Errors if partitions in device structure)
                      3 = force one partition using the entire device
                      		(Overwrites values in device structure)
                      6 = same as mode 1

RETURNS:	     0 for Success
				  -EIO for Error trying to read the device or structure.
              -EINVAL if invalid mode or partitions exist in mode 1.
              -ENOMEM if memory for page buffer/RJ is not available.
              -EPERM if the device has mounted partition(s)
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_AutoMount, fat_Init, fat_EnumDevice,
               fat_PartitionDevice, fat_FormatPartition

*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_FormatDevice( mbr_dev *dev, int mode )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_FormatDevice( dev, mode );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_FormatDevice( mbr_dev *dev, int mode )
#else
_fat_debug int fat_FormatDevice( mbr_dev *dev, int mode )
#endif
{
	auto int rc, type, retcode;
   auto long sc;
#ifdef __FATFTL_LIB
   auto int saved_rc;
   auto __far _FTL_Device *ftl_dev;
   auto char __far *pbuf;
#endif

   if (!dev || !dev->driver || ((unsigned)dev->driver) == 0xFFFF) {
   	return -EIO;
   }

#ifdef __FATFTL_LIB
   // Special case for full FTL layer format with partition overwrite
   if (dev->ftl_dev_idx >= 0 && dev->ftl_dev_idx < FTL_MAXDEV) {
      if (!mode) {   // Save partition table for mode 0
         pbuf = (char __far *)xalloc(sizeof(mbr_part) * 4);
         _f_memcpy(pbuf, (char __far *)dev->part, sizeof(mbr_part) * 4);
      }
      else {
         if (mode != 3) {
	         for (rc = 4; rc--; ) {
	            if (dev->part[rc].partsecsize) {
	               return -EINVAL;
	            }
	         }
         }
      }
      ftl_dev = &(ftl.dev[dev->ftl_dev_idx]);
      ftl_dev->state = FTLS_UNMOUNT;
      rc = ftl_InformStatus(dev, FTLS_FORMAT);    // Erase entire device
      if (!rc) {
         rc = ftl_InformStatus(dev, FTLS_FORMAT);
      }
      if (!rc) {
         // Re-enumerate with FTL layer as FTL device info is now invalid
         do {
            rc = ftl_EnumDevice(dev->driver, dev, dev->dev_num);
         } while (rc == -EBUSY);
         if (!rc && !mode) {  // Restore partition table for mode 0
	         _f_memcpy((char __far *)dev->part, pbuf, sizeof(mbr_part) * 4);
	         xrelease((long)pbuf, sizeof(mbr_part) * 4);
         }
      }
      else {
         if (!mode) {
	         xrelease((long)pbuf, sizeof(mbr_part) * 4);
         }
         return rc;
      }
   }
#endif

   if (mode == 1 || mode == 3 || mode == 6)
   {
   	if (mode & 0x02 && mode != 6) {
	      for (rc = 4; --rc; ) {
      		type = dev->part[rc].parttype;
            memset(&dev->part[rc], 0, sizeof(dev->part[rc]));
	         if (retcode = mbr_CreatePartition(dev, rc, type)) {
            	if (retcode != -EUNFORMAT) {
	            	return retcode;
               }
               else {
               	break;
               }
            }
   	   }
      }
      else {
	      for (rc = 4; rc--; ) {
     			if (dev->part[rc].partsecsize) {
  	      		return -EINVAL;
            }
	     	}
      }
  		type = dev->part[0].parttype;
  		memset(dev->part, 0, sizeof(mbr_part) * 4);
      dev->part[0].starthead = 0xFE;
      dev->part[0].endhead = 0xFE;
      if (dev->driver->type[dev->dev_num] & MBRTYPE_SECTOR_FTL) {
	      dev->part[0].startsector = 1;
      }
      else {
	      dev->part[0].startsector = dev->byte_page / dev->byte_sec;
      }
      // Sectors in entire device (less first cluster for MBR)
#ifdef __FATFTL_LIB
      if (dev->ftl_dev_idx >= 0) {   // Special case for FTL layer format
         dev->part[0].partsecsize = (ftl.dev[dev->ftl_dev_idx].locate_size *
                 (unsigned long)(dev->byte_page / dev->byte_sec)) -
                    dev->part[0].startsector;
      }
      else
#endif
      {
         dev->part[0].partsecsize = dev->seccount - dev->part[0].startsector;
      }
      dev->part[0].parttype = 6;    // Always force to FAT16

      if ((mode == 3) && (retcode != -EUNFORMAT)) {
         rc = mbr_CreatePartition(dev, 0, type);
         if (rc) {
         	return rc;
         }
      }
   }
   else {
   	if (mode) { return -EINVAL; }
   }

   rc = mbr_FormatDevice(dev);

   if (rc == -EEXIST) {
      rc = 0;
   }
	return rc;
}


/*** BeginHeader fat_EnumPartition, _fat_EnumPartition */
int fat_EnumPartition( mbr_dev *, int, fat_part * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_EnumPartition  fat_EnumPartition
#else
int _fat_EnumPartition( mbr_dev *, int, fat_part * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_EnumPartition                        <FAT16.LIB>

SYNTAX:       fat_EnumPartition( mbr_dev *dev, int pnum,
												fat_part *part );

DESCRIPTION:  This function is called to enumerate a partition on the
              given device.  The partition information will be put into
              the FAT partition structure pointed to by part.  The
              partition pointer will be linked to the device structure,
              registered with the write-thru cache and will then be
              active.  The partition must be of a valid FAT type.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5
         seconds and can be changed by #define'ing a different value for
         FAT_MUTEX_TIMEOUT_SEC.
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   dev - Pointer to a MBR device structure

PARAMETER2:   pnum - Partition number to link and enumerate

PARAMETER3:   part - Pointer to a FAT partition structure to be filled in

RETURNS:	     0 for Success
				  -EIO for Error in reading the device or structures.
              -EINVAL if the Partition Number is invalid.
              -EUNFORMAT if the device is accessible, but not formatted.
              -EBADPART if the partition is not a valid FAT partition.
              -ENOPART if the partition does not exist.
              -ENOSYS if the partition is not a supported FAT format.
				  -EEXIST if the partition is already enumerated elsewhere.
              -EUNFLUSHABLE if no flushable sectors in write-thru cache
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_EnumDevice, fat_FormatPartition, fat_MountPartition

*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_EnumPartition( mbr_dev *dev, int pnum, fat_part *part)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_EnumPartition( dev, pnum, part);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_EnumPartition( mbr_dev *dev, int pnum, fat_part *part)
#else
_fat_debug int fat_EnumPartition( mbr_dev *dev, int pnum, fat_part *part)
#endif

{
   auto int rc;
   auto union {
     long l;
     __far _fat_bpb *ptr;
   } buf;

   /* See if device pointer is useable */
   if (dev == NULL || part == NULL) {
#ifdef FAT_VERBOSE
		printf("fat_EnumPartition:  Device or Partition Pointer Invalid.\n");
#endif
   	return -EIO;      // Bad device or part pointer
   }

	/* never more than four partitions */
	if ( pnum < 0 || pnum > 3 ) {
#ifdef FAT_VERBOSE
		printf("fat_EnumPartition:  Partition %d is Invalid.\n", pnum);
#endif
		return -EINVAL;
   }

   memset(part, 0, sizeof(fat_part));
   if ( fat_IsFatMBREntry(dev->part[pnum].parttype) == 0 ) {
#ifdef FAT_VERBOSE
		printf("fat_EnumPartition:  Partition %d is not a FAT Partition.\n", pnum);
#endif
     	return (dev->part[pnum].parttype ? -EBADPART : -ENOPART);
   }

   // Don't recognize FAT12 partition if FAT12 is not supported
   if (dev->part[pnum].parttype == 1) {
      return -ENOSYS;
   }

   if (dev->fs_part[pnum])
   {
   	if (dev->fs_part[pnum] != part) {
#ifdef FAT_VERBOSE
   		printf("fat_EnumPartition:  Partition %d: fs_part already in use.\n",
                   pnum);
#endif
	   	return -EEXIST;
      }
   }
   else
   part->ftc_prt = -1;
   part->pnum = pnum;
   part->dev = dev;
   part->mpart = &(dev->part[pnum]);

   if (( rc = fatrj_regpartition( dev->ftc_dev, pnum )) < 0) {
  		return rc;
   }
   part->ftc_prt = rc;
   if ( fat_sysftc < 0 ) {
      fat_sysftc = rc;
   }
#ifdef FAT_VERBOSE
	printf("fat_EnumPartition:  Partition %d using Cache pointer %d.\n",
                   part->pnum, part->ftc_prt);
#endif

   if (part->mpart->partsecsize)
   {
	   if (part->mpart->starthead != 0xFE && dev->heads > part->mpart->starthead)
   	{
      	part->mpart->startsector = (long)(part->mpart->startseccyl >> 6) *
      		(dev->sec_track * dev->heads) + (part->mpart->starthead *
         		dev->sec_track) + (part->mpart->startseccyl & 0x3F) - 1;
	   }
   }
   else {
#ifdef FAT_VERBOSE
	printf("fat_EnumPartition:  Partition %d no sector size given.\n", pnum);
#endif
   	return -EBADPART;
   }

   if (( rc = fatftc_read( part->ftc_prt, part->mpart->startsector, &buf.l,
   								 FAT_BLOCK_FLAGS | FTC_MAKE_LRU )) < 0 )
   {
#ifndef FAT_BLOCK
  		if (rc == -EUNFLUSHABLE) {	// Bill: I'm not sure about this
     		rc = -EBUSY;
      }
#endif
  		return rc;
   }

   rc = xgetint(buf.l + 510);
   if (rc == 0xAA55)
   {
		part->byte_sec = buf.ptr->byte_sec;
     	part->sec_clust = buf.ptr->sec_clust;
		part->res_sec =  buf.ptr->res_sec;
	   part->fat_cnt = buf.ptr->fat_cnt & 0xFF;
   	part->root_cnt = buf.ptr->root_cnt;
		part->sec_fat = buf.ptr->sec_fat;
		part->serialnumber =	buf.ptr->vol_ID;

      if ((rc = _fat_PartCalc( part )) < 0) {
#ifdef FAT_VERBOSE
   	   printf("fat_EnumPartition:  Partition %d, Error %d on fat_PartCalc.\n",
                   pnum, rc);
#endif
      	return rc;
      }

      // Setup Partition control stucture locations
      part->fatstart = part->mpart->startsector +  part->res_sec;
      part->rootstart = part->fatstart + (part->sec_fat * part->fat_cnt);
      part->datastart = part->rootstart + (part->root_cnt / 16);
		part->fat_len = (unsigned)((part->mpart->startsector +
      		part->mpart->partsecsize -	part->datastart) / part->sec_clust) + 2;

   	/* Setup Counters/stats about the partition */
      part->totcluster = part->fat_len - 2;
		part->badcluster = 0xFFFFFFFF;	// Invalid, will trigger recount

		part->dev = dev;			/* physical device partition belongs to */

		// Set default FAT type
		part->type = FAT_TYPE_16;

      part->clustlen = part->sec_clust * part->byte_sec;
      dev->fs_part[pnum] = part;
   }
   else
   {
#ifdef FAT_VERBOSE
   	printf("fat_EnumPartition:  Partition %d has invalid BPB.\n", pnum);
#endif
   	return -EUNFORMAT;
   }

#ifdef FAT_VERBOSE
 	printf("fat_EnumPartition:  Success, partition %d enumerated.\n", pnum);
#endif
	return 0;
}


/*** BeginHeader fat_MountPartition, _fat_MountPartition */
int fat_MountPartition( fat_part * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_MountPartition  fat_MountPartition
#else
int _fat_MountPartition( fat_part * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_MountPartition                        <FAT16.LIB>

SYNTAX:       fat_MountPartition( fat_part *part );

DESCRIPTION:  Marks the enumerated partition as mounted on both the
				  FAT and MBR level.  The partition MUST be previously
              enumerated with fat_EnumPartition.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5
         seconds and can be changed by #define'ing a different value for
         FAT_MUTEX_TIMEOUT_SEC.
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - Pointer to a FAT partition structure to mount

RETURNS:	     0 for Success
              -EINVAL if Device or Partition structure or pnum is invalid.
              -EBADPART if Partition is not a FAT partition.
              -EBADBLOCK if Partition has a bad block which is in use.
              -ENOPART if Partition does not exist on the device.
              -EPERM if the partition has not been enumerated.
              -EACCESS if partition linked to other fat_part struct
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_EnumPartition, fat_UnmountPartition

*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_MountPartition( fat_part *part )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_MountPartition( part );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_MountPartition( fat_part *part )
#else
_fat_debug
int fat_MountPartition( fat_part *part )
#endif

{
	auto int i, rc;
   auto unsigned long x;

   /* See if partition pointer is useable */
   if ( part == NULL ) {
#ifdef FAT_VERBOSE
		printf("fat_MountPartition:  Partition Pointer Invalid.\n");
#endif
   	return -EINVAL;      // Bad partition pointer
   }

   if ( fat_IsFatMBREntry(part->mpart->parttype) == 0 ) {
#ifdef FAT_VERBOSE
		printf("fat_MountPartition:  Partition %d is not a FAT Partition.\n",
                   part->pnum);
#endif
   	return -EBADPART;
   }

   if (part->mpart->parttype == FAT_TYPE_12) {
#ifdef FAT_VERBOSE
		printf("fat_MountPartition: Partition %d is a FAT-12 Partition.\n",
                   part->pnum);
      printf("                    FAT-12 partitions are not supported.\n");
#endif
   	return -ENOSYS;
   }

	if ( part->dev == NULL || part->dev->driver == NULL ||
   		( part->dev->driver->ndev == 0 )) {
#ifdef FAT_VERBOSE
		printf("fat_MountPartition:  Partition %d has bad device/driver links.\n",
                   part->pnum);
#endif
		return -EPERM;			// Partition missing info, needs enumeration
   }

   if (part->pnum < 0 || part->pnum > 3) {
#ifdef FAT_VERBOSE
		printf("fat_MountPartition:  Invalid Partition Number %d.\n", part->pnum);
#endif
   	return -EPERM;       // Device not linked to this partition
   }

   if ((fat_part *)part->dev->fs_part[part->pnum] != part)
   {
   	if (part->dev->fs_part[part->pnum])
      {
#ifdef FAT_VERBOSE
   		printf("fat_MountPartition:  Partition %d: fs_part already in use.\n",
                   part->pnum);
#endif
      	part->dev = NULL; 		// Invalidate this partition structure
         part->ftc_prt = -1;     // Another copy is linked to this partition
         return -EACCES;
      }
      part->dev->fs_part[part->pnum] = (void *)part;
      part->opstate = FAT_PART_IDLE;
   }

   if ( part->mpart->status & MBRP_MOUNTED ) {
#ifdef FAT_VERBOSE
   		printf("fat_MountPartition:  Partition %d already mounted. (OK)\n",
                   part->pnum);
#endif
   	return 0;	// Partition is already mounted, return success
   }

   if ( part->first ) { // File already linked with unmounted partition,
#ifdef FAT_VERBOSE
   		printf("fat_MountPartition:  Partition %d: File already linked.\n",
                   part->pnum);
#endif
   	return -EPERM;		// This is not allowed.
   }

   if ( part->ftc_prt < 0)
   {
#ifdef FAT_VERBOSE
 		printf("fat_MountPartition:  Partition %d needs Cache pointer.\n",
                   part->pnum);
#endif
   	// Register the partition with the cache system
	   if (( part->ftc_prt = fatrj_regpartition( part->dev->ftc_dev, i )) < 0) {
			return part->ftc_prt;
      }
      part->opstate = FAT_PART_IDLE;
   }
#ifdef FAT_VERBOSE
	printf("fat_MountPartition:  Partition %d using Cache pointer %d.\n",
                   part->pnum, part->ftc_prt);
#endif

   if ( part->badcluster == 0xFFFFFFFF || part->opstate)
   {
   	switch (part->opstate)
      {
      	case FAT_PART_IDLE:
         	if (part->dev->driver->type[part->dev->dev_num] & MBRTYPE_MARKERS)
            {
            	part->opcount = 2;
               part->clust2 = (unsigned int)(part->datastart /part->sec_clust);
               part->badcluster = 0L;
            	part->opstate = FAT_PART_MOUNT;
            }
            else {
            	part->opstate = FAT_PART_MOUNT + 8;
            	goto _fat_count_clusters;
            }

      	case FAT_PART_MOUNT:
		     	for ( ; (unsigned int)part->opcount < part->fat_len;
            										part->opcount++, part->clust2++ )
            {
              	if ((rc = part->dev->driver->xxx_ReadSector(
                    (unsigned long)part->clust2, (__far char *)NULL,
                      (__far char *)NULL, part->dev)) < 0)
               {
                  if (rc != -EBADBLOCK) {
	                  return rc;
                  }
                  part->opstate = FAT_PART_MOUNT + 1;
	               part->badcluster++;
#ifdef FAT_VERBOSE
                 	printf("fat_MountPartition:  Partition %d: Bad Block %d.\n",
                   part->pnum, part->clust2);
#endif
               }
               else {
                  continue;
               }

         case FAT_PART_MOUNT + 1:
         	  x = part->opcount;
              rc = _fat_next_clust( part, &x, FAT_BLOCK_FLAGS );
              if (rc == -EFAULT) {
         		  continue;        // Block already marked bad in FAT
              }
		     	  if (rc == -ENODATA) {
                 part->opstate = FAT_PART_MOUNT + 4;
              }
              else {
		           return (rc == -EBUSY ? -EBUSY : -EBADBLOCK);
              }

         case FAT_PART_MOUNT + 4:      // Bad Block found, go mark in FAT
         case FAT_PART_MOUNT + 5:
         case FAT_PART_MOUNT + 6:
         case FAT_PART_MOUNT + 7:
         		part->clust1 = FAT_BADMARK;
               if ((rc = (int)_fat_table_update(part,
                       (unsigned long)part->opcount, &part->opstate)) < 0) {
						return rc;
               }
               part->opstate = FAT_PART_MOUNT + 4;
            }
            part->opstate = FAT_PART_MOUNT + 8;

         default:
      _fat_count_clusters:
	    		// Count free clusters on the partition
   			if ((rc = _fat_new_clust( part, 0, &x, 0 )) < 0) {
      			return rc;
            }
            part->opstate = FAT_PART_IDLE;
	         break;
      }
   }

#ifdef FAT_VERBOSE
	printf("fat_MountPartition:  Partition %d mounted at FAT level.\n",
                   part->pnum);
#endif
   // Mount partition at MBR level
	return mbr_MountPartition( part->dev, part->pnum );
}

/*** BeginHeader fat_UnmountPartition, _fat_UnmountPartition */
int fat_UnmountPartition( fat_part * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_UnmountPartition  fat_UnmountPartition
#else
int _fat_UnmountPartition( fat_part * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_UnmountPartition                        <FAT16.LIB>

SYNTAX:       fat_UnmountPartition( fat_part *part );

DESCRIPTION:  Marks the enumerated partition as unmounted on both the
				  FAT and MBR level.  The partition MUST be previously
              enumerated with fat_EnumPartition.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - Pointer to a FAT partition structure to unmount

RETURNS:	     0 for Success
              -EINVAL if Device or Partition structure or pnum is invalid.
              -EBADPART if Partition is not a FAT partition.
              -ENOPART if Partition does not exist on the device.
              -EPERM if the partition has not been enumerated.
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_EnumPartition, fat_MountPartition
*************************************************************************/

#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_UnmountPartition( fat_part *part )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_UnmountPartition( part );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_UnmountPartition( fat_part *part )
#else
_fat_debug
int fat_UnmountPartition( fat_part *part )
#endif
{
	auto int rc, rc2;
   auto long sbuf;
#ifdef PC_COMPATIBLE
   auto char buf[64];
#endif

   rc2 = 0;
	if (!part)
   	return -EINVAL;

#ifdef PC_COMPATIBLE
   if (!part->opstate)
   {
#endif
	   if ((rc = _fat_SyncPartition( part )) < 0) {
         if (rc != -EROFS) {
      		return rc;
         }
         rc2 = rc;
      }
#ifdef PC_COMPATIBLE
      part->opstate = FAT_PART_UNMNT;
      part->opcount = 0;
   }
   else {
   	if (part->opstate >= FAT_PART_ALLOC) {
      	return -EBUSY;
      }
   }

   while (1) {
    switch (part->opstate)
    {
   	case FAT_PART_UNMNT:
#endif
			/* close all potentially left open files */
		  	while ( part->first )
		   {
				if ((rc = _fat_Close( part->first )) < 0)
            {
   	      	if (rc != -EBUSY) {
	  	         	part->opstate = FAT_PART_IDLE;
               }
		        	return rc;
            }
		   }
#ifdef PC_COMPATIBLE
         part->opstate = FAT_PART_UNMNT + 1;   // Set to next state and drop in

   	case FAT_PART_UNMNT + 1:
      	// Check for end condition
         if (part->opcount >= part->sec_fat)
         {  // Secondary table updated, flush changes to device and exit
            rc = fatftc_flushdev(part->dev->ftc_dev,FAT_BLOCK_FLAGS);
         	if (rc != -EBUSY)
  	         	part->opstate = FAT_PART_IDLE;
            if (rc) {
	           	return rc;    // Error in flushing - Abort unmount
            }
#endif
				part->dev->fs_part[part->pnum] = NULL;	//Mark unmounted @ FAT level
				rc = mbr_UnmountPartition( part->dev, part->pnum);
            return (rc ? rc : rc2);
#ifdef PC_COMPATIBLE
         }
	      // Read sector from FAT table 1
		   if ((rc = fatftc_read( part->ftc_prt, part->fatstart+part->opcount,
   	     							 (long *)&part->clust1, FAT_BLOCK_FLAGS )) < 0 )
         {
         	if (rc != -EBUSY) {
            	part->opstate = FAT_PART_IDLE;	// Error in reading - Abort unmount
            }
				return rc;
         }
       	part->opstate = FAT_PART_UNMNT + 2;   // Set to next state and drop in

   	case FAT_PART_UNMNT + 2:
   	   // Read sector from FAT table 2 and compare
		   if ((rc = fatftc_read( part->ftc_prt,
         							  part->fatstart + part->opcount + part->sec_fat,
   	     							  &sbuf, FAT_BLOCK_FLAGS )) < 0 )
         {
         	if (rc != -EBUSY) {
            	part->opstate = FAT_PART_IDLE;
            }
				return rc;
         }
         // Compare FAT 1 sectors to those in FAT 2
         if (memcmp((char __far *)sbuf,
                        (char __far *)(*((long *)&part->clust1)), 512)) {
	       	part->opstate = FAT_PART_UNMNT + 3;  // Set to next state & drop in
         }
         else {
	       	part->opstate = FAT_PART_UNMNT + 1; // Sector match, no write needed
            part->opcount++;  					   // Move to next FAT sector
            break;
         }

   	case FAT_PART_UNMNT + 3:
      	// Write changed sector to FAT table 2
		   if ((rc = fatftc_write( part->ftc_prt,
         							  part->fatstart + part->opcount + part->sec_fat,
   	     							  0, 512, (*((long *)&part->clust1)),
                                FAT_BLOCK_FLAGS )) < 0 )
         {
         	if (rc != -EBUSY) {
            	part->opstate = FAT_PART_IDLE;
            }
				return rc;
         }
         part->opcount++;  					// Move pointer to next FAT sector
       	part->opstate = FAT_PART_UNMNT + 1;	// Go read next FAT sector
         break;

      default:
      	return -EIO;
    }  // end of switch
   }   // end of while(1)
#endif
}

/*** BeginHeader fat_UnmountDevice, _fat_UnmountDevice */
int fat_UnmountDevice( mbr_dev * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_UnmountDevice  fat_UnmountDevice
#else
int _fat_UnmountDevice( mbr_dev * );
#endif

/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_UnmountDevice                              <FAT16.LIB>

SYNTAX:       fat_UnmountDevice( mbr_dev * dev );

DESCRIPTION:  Unmounts all FAT partitions on the given device and
				  unregisters the device from the cache system.  This
              commits all cache entries to the device and prepares
              the device for power down or removal.  The device
              structure given must have been enumerated with
              fat_EnumDevice.

    uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   dev - Pointer to a FAT device structure to unmount

RETURNS:	     0 for Success
              -EINVAL if Device structure is invalid.
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_EnumDevice, fat_AutoMount, fat_UnmountPartition
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_UnmountDevice( mbr_dev *dev )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_UnmountDevice(dev );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_UnmountDevice( mbr_dev *dev )
#else
_fat_debug int fat_UnmountDevice( mbr_dev *dev )
#endif
{
	auto int rc, i;
   auto fat_part *part;
   auto mbr_dev *dptr;

	if (!dev || !dev->driver) {
   	return -EINVAL;
   }

   // Return success if device is not currently mounted
   if (dev->ftc_dev < 0) {
      return 0;
   }

   // Unmount any active FAT partitions
   for (i = FAT_MAX_PARTITIONS; i--; ) {
      if (dev->fs_part[i]) {
         part = (fat_part *)dev->fs_part[i];
         // Verify that this is a FAT partition
         if (part->mpart == &(dev->part[i])) {
            rc = _fat_UnmountPartition(part);
            if (rc < 0) {
               return rc;
            }
            else {
               // Need to zero-out the fat_part_mounted partition
               //  pointer table entry in case we remount the device.
               fat_part_mounted[part->dev->dev_num * FAT_MAX_PARTITIONS
                                                         + part->pnum] = NULL;
            }
         }
      }
   }

   // Unregister the device with the Write-Thru Cache
   rc = fatftc_flushdev(dev->ftc_dev, FAT_BLOCK_FLAGS | FTC_PURGE);
   if (rc < 0) { return rc; }

   if (dev->driver->dlist) {
      // See if this device is first device in driver's linked list
      if (dev == (mbr_dev *)dev->driver->dlist) {
         dev->driver->dlist = dev->next;  // If so, remove it
      }
      else {
         // Search for this device in the driver's linked list
         for (dptr = (mbr_dev *)dev->driver->dlist;
              dptr->next && (dptr->next != (void *)dev);
              dptr = (mbr_dev *)dptr->next);
         // If found, remove from linked list
         if (dptr->next) { dptr->next = dev->next; }
      }
      // Lower number of registered devices within driver structure
      dev->driver->ndev--;
   }

   // Inform driver layer that device has been unmounted
   dev->driver->xxx_InformStatus(dev, 1);

   // Clear device structure and mark as unregistered with FTC
   memset(dev, 0, sizeof(mbr_dev));

   dev->ftc_dev = -1;
   return 0;
}


/*** BeginHeader fat_AutoMount */
int fat_AutoMount(word);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fat_AutoMount                 <FAT16.LIB>

SYNTAX:			int fat_AutoMount(word flags);

DESCRIPTION:	Initializes the drivers in FAT_CONFIG.LIB's default drivers
               configuration list and enumerates the devices in the
               default devices configuration list, then mounts partitions
               on enumerated devices according to the device's default
               configuration flags, unless overridden by the specified run
               time configuration flags.  Despite its lengthy description,
               this function makes initializing multiple devices using the
               FAT library as easy as possible.  The first driver in the
               configuration list becomes the primary driver in the
               system, if one is not already set up.

               After this function successfully returns, the application
               can start calling directory and file functions for the
               devices' mounted partitions.

               If devices and/or partitions are not already formatted,
               this function can optionally format them according to the
               the device's configuration or run time override flags.

               This function may be called multiple times, but will not
               attempt to (re)mount device partitions that it has already
               mounted.

               Once a device partition has been mounted by this function,
               unmounts and remounts must be handled by the application.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER 1:   Run-time device configuration flags to allow overriding the
               default device configuration flags.  If not overriding the
               default configuration flags, specify FDDF_USE_DEFAULT.  To
               override the default flags, specify the ORed combination of
               one or more of the following:
                 FDDF_MOUNT_PART_0       //mount device(s)' partition 0
                 FDDF_MOUNT_PART_1
                 FDDF_MOUNT_PART_2
                 FDDF_MOUNT_PART_3
                 FDDF_MOUNT_PART_ALL     //mount all partitions
                 FDDF_MOUNT_DEV_0        //apply to specified device(s)
                 FDDF_MOUNT_DEV_1
                 FDDF_MOUNT_DEV_2
                 FDDF_MOUNT_DEV_3
                 FDDF_MOUNT_DEV_ALL      //mount all available devices
                 FDDF_NO_RECOVERY        //use norecovery if first fails
                 FDDF_COND_DEV_FORMAT    //format device if unformatted
                 FDDF_COND_PART_FORMAT   //format partition if unformatted
                 FDDF_UNCOND_DEV_FORMAT  //format device unconditionally
                 FDDF_UNCOND_PART_FORMAT //format partition unconditional
               Note: the FDDF_MOUNT_PART_* flags apply equally to all
               FDDF_MOUNT_DEV_* devices which are specified.  If this is a
               problem, call this function multiple times with a single
               DEV flag bit each time.
               Note: formatting the device creates a single FAT partition
               covering the entire device.  It is recommended that you
               always set the *_PART_FORMAT flag bit if you set the
               corresponding *_DEV_FORMAT flag bit.

RETURN VALUE: 	0 on success
					-EIO on device IO error.
               -EINVAL if prtTable is invalid
               -EUNFORMAT if device is not formatted
               -EBADPART if partition is not a valid FAT partition
					-ENOPART if no partitions exist on the device
               -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_EnumDevice, fat_EnumPartition, fat_MountPartition
*************************************************************************/
_fat_debug
int fat_AutoMount(word flags)
{
   auto int rc;

#ifdef FAT_USE_UCOS_MUTEX
    // Wait for semaphore
    _fat_ucos_mutex_pend();
#endif

	rc = _fat_automount(num_fat_drivers, num_fat_devices, _fatConfig,
	                      _fatDevConfig, _fat_driver_table, _fat_device_table,
	                      _fat_part_table, fat_part_mounted, flags);

#ifdef FAT_USE_UCOS_MUTEX
    // Signal semaphore
    _fat_ucos_mutex_post();
#endif
   return rc;
}


/*** BeginHeader fat_Init, _fat_Init */
int fat_Init( int, mbr_drvr *, mbr_dev *, fat_part *, int );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Init  fat_Init
#else
int _fat_Init( int, mbr_drvr *, mbr_dev *, fat_part *, int );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fat_Init                              <FAT16.LIB>

SYNTAX:			fat_Init( int pnum, mbr_drvr *driver, mbr_dev *dev
									, fat_part *part, int norecovery )

DESCRIPTION:   Replaced by more powerful fat_AutoMount function.

					Initializes the default driver (in MBR_DRIVER_INIT),
					enumerates device 0, then enumerates and mounts the
               specified partition. This function makes initializing the
               FAT library as easy as possible. This function will ONLY
               work with device 0 of the default driver.  This
               driver becomes the primary driver in the system.

               After this function successfully returns, the application
               can start calling directory and file functions.

               The desired partition must already be formatted.  If the
               partition mount fails, you can call again with a different
               partition number (parameter #1).  The device will not be
               initialized a second time.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER 1: 	Partition number to mount, from 0 to 3 .

PARAMETER 2: 	Pointer to driver structure to fill in.

PARAMETER 3: 	Pointer to device structure to fill in.

PARAMETER 4: 	Pointer to partition structure to fill in.

PARAMETER 5: 	Boolean flag - Set True to ignore power recovery data.
										True is considered any value except zero.

GLOBALS: 		MBR_DRIVER_INIT has the default contoller init function

RETURN VALUE: 	0 on success
					-EIO on device IO error.
               -EINVAL if pnum, driver, device or part are invalid
               -EUNFORMAT if device is not formatted
               -EBADPART if partition is not a valid FAT partition
					-ENOPART if no partitions exist on the device
               -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_AutoMount, fat_EnumDevice, fat_EnumPartition,
               fat_MountPartition
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Init( int pnum, mbr_drvr *root_driver, mbr_dev *dev
									, fat_part *part, int norecovery )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Init(pnum, root_driver, dev, part, norecovery );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Init( int pnum, mbr_drvr *root_driver, mbr_dev *dev
									, fat_part *part, int norecovery )
#else
_fat_debug int fat_Init( int pnum, mbr_drvr *root_driver, mbr_dev *dev
									, fat_part *part, int norecovery )
#endif

{
	auto int rc;
   auto mbr_dev *dptr;


	if ( !root_driver || !dev || !part ) {
   	return -EINVAL;
   }

   if ( !fat_sysdriver ) {
      MBR_DRIVER_INIT;
      fat_sysdriver = root_driver;
   }

   dptr = NULL;
   if ( root_driver->ndev )
   {
   	/* If driver has enumerated device, then device must be an
      	 enumerated device on the driver */
      for (dptr = root_driver->dlist; dptr; dptr=dptr->next)
      {
      	if (dptr->driver != root_driver)
         {
            if (fat_sysdriver == root_driver) {
            	MBR_DRIVER_INIT;
               dptr == NULL;
               break;
            }
            else {
            	return -EINVAL;
            }
         }
         if (dev == dptr) {
         	break;
         }
      }

      if (!dptr) {
      	return -EINVAL;
      }
   }

	if (dptr != dev)
   {
	   dev->ftc_dev = -1;
      dev->ftl_dev_idx = -1;
      memset(part, 0, sizeof(part));
		/*  Enumerate device 0. */
		if ((rc = _fat_EnumDevice( root_driver , dev, 0, MBR_SIG, norecovery))) {
			return rc;
      }
	}

   if ( dev->fs_part[pnum] != (mbr_part *)part )
   {
   	if (dev->fs_part[pnum]) {
      	return -EINVAL;
      }
      // FIX THIS - Currently blocking to avoid registration error
		while ((rc = _fat_EnumPartition( dev, pnum, part )) == -EBUSY);
		if ( rc != 0 ) {
      	return rc;
      }
   }
   else {
   	if (part->dev != dev) {
      	return -EBADPART;			// Not a FAT partition
      }
   }

   // FIX THIS - Currently blocking to avoid registration error
	while ((rc = _fat_MountPartition( part )) == -EBUSY);
   return ( rc );
}   /* end fat_Init() */


/*** BeginHeader fat_PartitionDevice, _fat_PartitionDevice */
int fat_PartitionDevice( mbr_dev *, int );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_PartitionDevice  fat_PartitionDevice
#else
int _fat_PartitionDevice( mbr_dev *, int );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fat_PartitionDevice                           <FAT16.LIB>

SYNTAX:		 fat_PartitionDevice( mbr_dev *dev, int pnum )

DESCRIPTION: ATTENTION!!!! This function modifies the MBR (partitions
				 the device), possibly destroying access to information on
             the device. The partition information contained in the device
             structure MUST be meaningfull and the sizes and start positions
             must make sense (no overlapping, etc.)  The partition selected
             by pnum MUST be a FAT partition (to create non-FAT partitions,
             see mbr_CreatePartition). If the device structure is not valid
             for the device, an -EINVAL error is returned. The device being
             partitioned must have been formatted and enumerated beforehand.

             This function will only allow changes to one partition at a
             time, and this partition must either not exist or be of a
             FAT type. You may not modify an existing non-FAT partition
             using this function (see mbr_CreatePartition). The validity of
             the new partition will be verified before any changes are done
             to the device. All other partition information in the device
             structure (for those partitions that are not being modified)
             MUST MATCH the values currently existing on the MBR. The type
             given for the new partition must either be zero (if deleting
             the partition) or a FAT type.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER 1: 	Pointer to device structure of device to be partitioned.

PARAMETER 2: 	Partition number of partition being modified.


RETURN VALUE: 	0 on success
					-EIO on device IO error.
               -EINVAL if pnum or device structure are invalid
               -EUNFORMAT if device is not formatted
               -EBADPART if partition is non-FAT partition
               -EPERM if partition is mounted
               -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_FormatDevice, fat_EnumDevice, fat_FormatPartition
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_PartitionDevice( mbr_dev *dev, int pnum )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_PartitionDevice( dev, pnum );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_PartitionDevice( mbr_dev *dev, int pnum )
#else
_fat_debug int fat_PartitionDevice( mbr_dev *dev, int pnum )
#endif

{
	auto int rc;
   auto long sbuf;

   if ((!dev) || (!(dev->driver)) || (fat_sysftc < 0)) {
   	return -EIO;
   }
   if ((pnum < 0) || (pnum > 3) ||
   	 !( fat_IsFatMBREntry(dev->part[pnum].parttype))) {
   	return -EINVAL;
   }
   if (dev->part[pnum].status & MBRP_MOUNTED) {
   	return -EPERM;
   }

   if ((rc = fatftc_read(fat_sysftc, 0, &sbuf, FAT_BLOCK_FLAGS)) < 0) {
		return rc;
   }

   rc = xgetint(sbuf + 510);
   if (rc != 0xAA55) {
      return -EUNFORMAT;
   }

   sbuf += 0x1BE;
	rc =  xgetint( sbuf + (pnum * 16) + offsetof(mbr_part, parttype)) & 0x00FF;
   if ( rc && !(fat_IsFatMBREntry( rc ))) {
   	return -EBADPART;
   }

	for( rc = 4; rc--;  ) {
   	if (rc != pnum) {
	   	if (memcmp( (char __far *)(sbuf + (rc * 16)),
                         (char __far *)&dev->part[rc], 16)) {
         	return -EINVAL;
         }
      }
	}

   /* Validate partition table in device structure */
	if (( rc = mbr_ValidatePartitions( dev )) < 0) {
      return -EINVAL;
   }

   rc = fatftc_write( fat_sysftc, 0, 0x1BE + (pnum * 16), 16,
					  	 	paddr(&dev->part[pnum]), FAT_BLOCK_FLAGS );
	if (rc == 16) {
   	rc = 0;
   }

	return rc;
}



/*** BeginHeader fat_FormatPartition, _fat_FormatPartition */
int fat_FormatPartition( mbr_dev *, fat_part *, int, int, char *, int (*)());
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_FormatPartition  fat_FormatPartition
#else
int _fat_FormatPartition( mbr_dev *, fat_part *, int, int, char *, int (*)());
#endif
/*** EndHeader */

/* The MS-DOS 5.0 Partition boot sector. */
__xdata FAT_bootsec {
	"\xEB\x3C\x90\x4D\x53\x44\x4F\x53\x35\x2E\x30\x00\x02\x02\x01\x00" \
	"\x02\x00\x02\x00\x00\xF8\x00\x00\x20\x00\x10\x00\x20\x00\x00\x00" \
	"\x00\x00\x00\x00\x80\x00\x29\x12\x34\x56\x78\x20\x20\x20\x20\x20" \
	"\x20\x20\x20\x20\x20\x20\x46\x41\x54\x31\x36\x20\x20\x20\xFA\x33" \
	"\xC0\x8E\xD0\xBC\x00\x7C\x16\x07\xBB\x78\x00\x36\xC5\x37\x1E\x56" \
	"\x16\x53\xBF\x3E\x7C\xB9\x0B\x00\xFC\xF3\xA4\x06\x1F\xC6\x45\xFE" \
	"\x0F\x8B\x0E\x18\x7C\x88\x4D\xF9\x89\x47\x02\xC7\x07\x3E\x7C\xFB" \
	"\xCD\x13\x72\x79\x33\xC0\x39\x06\x13\x7C\x74\x08\x8B\x0E\x13\x7C" \
	"\x89\x0E\x20\x7C\xA0\x10\x7C\xF7\x26\x16\x7C\x03\x06\x1C\x7C\x13" \
	"\x16\x1E\x7C\x03\x06\x0E\x7C\x83\xD2\x00\xA3\x50\x7C\x89\x16\x52" \
	"\x7C\xA3\x49\x7C\x89\x16\x4B\x7C\xB8\x20\x00\xF7\x26\x11\x7C\x8B" \
	"\x1E\x0B\x7C\x03\xC3\x48\xF7\xF3\x01\x06\x49\x7C\x83\x16\x4B\x7C" \
	"\x00\xBB\x00\x05\x8B\x16\x52\x7C\xA1\x50\x7C\xE8\x92\x00\x72\x1D" \
	"\xB0\x01\xE8\xAC\x00\x72\x16\x8B\xFB\xB9\x0B\x00\xBE\xE6\x7D\xF3" \
	"\xA6\x75\x0A\x8D\x7F\x20\xB9\x0B\x00\xF3\xA6\x74\x18\xBE\x9E\x7D" \
	"\xE8\x5F\x00\x33\xC0\xCD\x16\x5E\x1F\x8F\x04\x8F\x44\x02\xCD\x19" \
	"\x58\x58\x58\xEB\xE8\x8B\x47\x1A\x48\x48\x8A\x1E\x0D\x7C\x32\xFF" \
	"\xF7\xE3\x03\x06\x49\x7C\x13\x16\x4B\x7C\xBB\x00\x07\xB9\x03\x00" \
	"\x50\x52\x51\xE8\x3A\x00\x72\xD8\xB0\x01\xE8\x54\x00\x59\x5A\x58" \
	"\x72\xBB\x05\x01\x00\x83\xD2\x00\x03\x1E\x0B\x7C\xE2\xE2\x8A\x2E" \
	"\x15\x7C\x8A\x16\x24\x7C\x8B\x1E\x49\x7C\xA1\x4B\x7C\xEA\x00\x00" \
	"\x70\x00\xAC\x0A\xC0\x74\x29\xB4\x0E\xBB\x07\x00\xCD\x10\xEB\xF2" \
	"\x3B\x16\x18\x7C\x73\x19\xF7\x36\x18\x7C\xFE\xC2\x88\x16\x4F\x7C" \
	"\x33\xD2\xF7\x36\x1A\x7C\x88\x16\x25\x7C\xA3\x4D\x7C\xF8\xC3\xF9" \
	"\xC3\xB4\x02\x8B\x16\x4D\x7C\xB1\x06\xD2\xE6\x0A\x36\x4F\x7C\x8B" \
	"\xCA\x86\xE9\x8A\x16\x24\x7C\x8A\x36\x25\x7C\xCD\x13\xC3\x0D\x0A" \
	"\x4E\x6F\x6E\x2D\x53\x79\x73\x74\x65\x6D\x20\x64\x69\x73\x6B\x20" \
	"\x6F\x72\x20\x64\x69\x73\x6B\x20\x65\x72\x72\x6F\x72\x0D\x0A\x52" \
	"\x65\x70\x6C\x61\x63\x65\x20\x61\x6E\x64\x20\x70\x72\x65\x73\x73" \
	"\x20\x61\x6E\x79\x20\x6B\x65\x79\x20\x77\x68\x65\x6E\x20\x72\x65" \
	"\x61\x64\x79\x0D\x0A\x00\x49\x4F\x20\x20\x20\x20\x20\x20\x53\x59" \
	"\x53\x4D\x53\x44\x4F\x53\x20\x20\x20\x53\x59\x53\x00\x00\x00\x00"
};


/* START FUNCTION DESCRIPTION *******************************************
fat_FormatPartition                   <FAT16.LIB>

SYNTAX:  fat_FormatPartition( mbr_dev *dev,	fat_part *part, int pnum,
										int type, char *label, int (*usr)() )

DESCRIPTION:
	Format partition number pnun acording to type. The partition table
   information in device must be valid. This is always the case if the
   device was enumerated which is a requirement to call this function.
   The type must be a valid FAT type. Also note that after the partition
   is formatted it is NOT mounted, but is linked to the device as the
   current partition filesystem.  If -EBUSY is returned, the partition
   structure must not be disturbed until a subsequent call returns
   something other than -EBUSY. Many newer PC technologies (i.e.
   CompactFlash card readers hooked up to USB etc.) have a restriction
   in that only the first partition of a device is recognized. This is
   because such devices usually reserve a drive letter in advance and
   are not prepared to dynamically assign more drive letters to
   partitions added on the fly. This of course is only of concern if
   the media that is processed by this code should later on be read in
   a PC....

 uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   dev - Pointer to a device structure containing partitions

PARAMETER2:   part  - Pointer to a FAT partition structure to be linked
							 NOTE: opstate MUST be set to zero before first call
                            if library is used in Non-Blocking mode.

PARAMETER3:   pnum  - Partition number on device (0 thru 3)

PARAMETER4:   type  - Partition type

PARAMETER5:   label - Partition label string

PARAMETER6:   usr   - Pointer to a user function

RETURNS:	     0 for Success
				  -EIO for Error in reading the device or structures.
              -EINVAL if the Partition Number is invalid.
              -EPERM if write access is not allowed
              -EUNFORMAT if the device is accessible, but not formatted.
              -EBADPART if the partition is not a valid FAT partition.
				  -EACCES if the partition is mounted or linked to a filesystem
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO: 		fat_AutoMount, fat_Init, fat_FormatDevice, fat_EnumDevice,
					fat_PartitionDevice, fat_EnumPartition
*************************************************************************/

#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_FormatPartition( mbr_dev *dev, fat_part *part, int pnum,
												   int type, char *label, int (*usr)() )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_FormatPartition(dev,part,pnum,type,label,usr);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_FormatPartition( mbr_dev *dev, fat_part *part, int pnum,
												   int type, char *label, int (*usr)() )
#else
_fat_debug int fat_FormatPartition( mbr_dev *dev, fat_part *part, int pnum,
												   int type, char *label, int (*usr)() )
#endif
{
#ifndef FAT16_READONLY
	auto int i;
	auto int rc;
   auto long x, y;
   auto word *wptr, b, s;
	auto _fat_bpb bpb_dat;
   auto char sig[17];

   if ( !dev || !part ) {
   	return -EIO;
   }

#ifdef FAT_BLOCK
   // See if partition is mounted or device has a filesystem link for it
   if ((dev->part[pnum].status & MBRP_MOUNTED) || dev->fs_part[pnum]) {
   	return -EACCES;
   }
   part->opstate = 0;
#else
   // See if partition is mounted or device has a filesystem link for it
   if ((dev->part[pnum].status & MBRP_MOUNTED) ||
              (dev->fs_part[pnum] && !part->opstate)) {
   	return -EACCES;
   }
#endif
   if (!part->opstate && (part->dev != dev || part->pnum != pnum ||
          part->type != type)) {
      part->ftc_prt = -1;  // Uninitialized partition, show no cache connection
   }
   switch (part->opstate)
   {
		case 0:	// Initialize FAT partition structure on first call
			if (part->ftc_prt >= 0) {
		   	fatrj_tranend( part->ftc_prt, 0);
		   }
         part->opstate++;

	   case 1:	// Make sure partition is enumerated and of 'FAT type'
   		rc = _fat_EnumPartition( dev, pnum, part );
         if ( rc && rc != -EUNFORMAT ) {
   			return rc;
         }
	      if ((fat_IsFatMBREntry(dev->part[pnum].parttype) == 0) ||
         		(part->mpart->partsecsize == 0)) {
   	   	return -EBADPART;
         }
         part->opstate = 2;

      case 2:
			if ((rc = fatftc_flushdev( dev->ftc_dev, FAT_BLOCK_FLAGS)) < 0) {
				return rc;
         }
         //Set sectors per cluster & FAT type based on type & size of partition
         part->type = FAT_TYPE_16;
         part->byte_sec = dev->byte_sec;
	      if (dev->driver->type[dev->dev_num] & MBRTYPE_FLASH) {
            // If sector addressable device, use smallest cluster size possible
	         if (dev->driver->type[dev->dev_num] & MBRTYPE_SECTOR_FTL) {
	            s = (word)((dev->seccount + 0x0FFFFL) / 0x10000L);
					for (b = FAT_MIN_CLUST_SIZE; s > b; b <<= 1);
	            part->sec_clust = b;
	         }
	         else {
	            part->sec_clust = dev->byte_page / dev->byte_sec;
	         }
            while (part->mpart->partsecsize > (((long)part->sec_clust) << 16))
            {
               part->sec_clust <<= 1;
            }
         }
      	else {
				// calculate the megabyte size of the partition
		  		x = part->mpart->partsecsize;
            if ( x < SEC_512MB ) {
              	part->sec_clust = (x < SEC_128MB ? 4 : 8);
            }
				else {
               x >>= 16;
            }
			}

         for (i = 0; i < num_fat_drivers &&
                dev->driver != &(_fat_driver_table[i]); i++);
         if (i >= num_fat_drivers) { return -EIO; }
         //Set part->res_sec based on whether SD card or other device
         part->res_sec = (strcmp(_fatConfig[i].type, "SD") ? 1 : 4);

		   // calculate available clusters for data and FAT
			x = (part->mpart->partsecsize - (FAT_ROOTSZ / FAT_DIRPS)) /
				 					  		  part->sec_clust;

			// now calculate the size of the FAT
         i = ((int)(x / (FAT_SECSIZE / 4)) / part->sec_clust) - 1;
         part->sec_fat = (int)((x - i +(FAT_SECSIZE / 2)) / (FAT_SECSIZE/2));

         part->root_cnt = FAT_ROOTSZ;
         x = part->sec_fat << 1;
         if (!(dev->driver->type[dev->dev_num] & MBRTYPE_SECTOR_FTL)) {
            // Cluster align the end of the root directory if no FTL
            i = (int)((x + part->mpart->startsector + part->res_sec) &
                        (part->sec_clust - 1));
            if (i) part->root_cnt += (part->sec_clust - i) * FAT_DIRPS;
         }

         // Handle special case where FAT tables may be one sector too large
         // First calculate the free sectors after FAT/Reserve/Root usage
         y = part->mpart->partsecsize - (x + (part->mpart->startsector %
            part->sec_clust) + part->res_sec + (part->root_cnt / FAT_DIRPS));
         y = (y / part->sec_clust) + 2;  // Convert to FAT entries needed
         // See if entries would fit if FAT tables were reduced by 1 sector
         if (y <= ((long)(part->sec_fat - 1) << 8)) {
            // If so, reduce size of FAT tables by one and add to Root dir.
            part->sec_fat--;
            x -= 2;
            part->root_cnt += 32;
         }

         // Use cluster length storage as counter for clearing FAT tables
			part->clustlen = x + (part->root_cnt / FAT_DIRPS) + part->res_sec;
      	part->opstate++;

		case 3:	// Clear FAT tables and Root directory
         while (rc = fatftc_write(part->ftc_prt,
                        part->mpart->startsector + part->clustlen, 0, 512,0,
                            FAT_BLOCK_FLAGS | FTC_MEMSET | FTC_NO_PREIMAGE))
			{
  	      	if (rc != 512) {
   	         return rc;
            }
            // See if first sector of either FAT copy
				if (part->clustlen == (part->sec_fat + part->res_sec) ||
            								part->clustlen == part->res_sec)
           	{
           		x = (dev->driver->type[dev->dev_num] & MBRTYPE_REMOVE) ?
                      0xFFFFFFF0 : 0xFFFFFFF8;
               // Re-write first four bytes of FAT table
               rc = fatftc_write(part->ftc_prt,
                       part->mpart->startsector + part->clustlen, 0, 4,
                          paddrSS(&x), FAT_BLOCK_FLAGS | FTC_NO_PREIMAGE);
					if (rc != 4) {
                 	return rc;
               }
     	      }
        	   if (!(--part->clustlen)) {
              	break;
            }
         }
			part->clustlen = (unsigned long)part->sec_clust * part->byte_sec;
        	part->opstate++;

	   case 4:	// Write BPB boot code template to device
   		if ((rc = fatftc_write(part->ftc_prt, part->mpart->startsector, 62, 450,
             (FAT_bootsec + 62), FAT_BLOCK_FLAGS | FTC_NO_PREIMAGE)) != 450) {
            return rc;
         }
        	part->opstate++;

      case 5:   // Calculate and write BPB data section to device
      	// Initialize structure with boot sector template
      	_f_memcpy((char __far *)&bpb_dat, (void __far *)FAT_bootsec,
                        sizeof(bpb_dat));

         // Set total sectors in the partition
			if (part->mpart->partsecsize & 0xFFFF0000) {
      		bpb_dat.sec_cnt32 = part->mpart->partsecsize;
         }
         else {
      		bpb_dat.sec_cnt16 = (word)(part->mpart->partsecsize);
         }

			//bpb_dat.byte_sec = 512;
         bpb_dat.sec_clust = (char)part->sec_clust;

         bpb_dat.res_sec = part->res_sec;  // reserved sectors set earlier
         bpb_dat.fat_cnt = 2;              // fat copies (always 2)

         // Get sectors per FAT calculated earlier
         bpb_dat.sec_fat = (word)part->sec_fat;

         // Get entries in root directory calculated earlier
         bpb_dat.root_cnt = (word)part->root_cnt;

			// Get track size and number of heads from the device description
			bpb_dat.sec_track = dev->sec_track;
			bpb_dat.heads = dev->heads;

			// Set Volume Serial Number
      	wptr = (word *)(&bpb_dat.vol_ID);
			_fat_tm2timestamp( wptr + 1, wptr, NULL);

         // See if this is a primary partition on a removable device
         if ((pnum == 0) && (dev->driver->type[dev->dev_num] & MBRTYPE_REMOVE))
         {
           sprintf(sig, "%08lx        ", *((long *)wptr));
           //*** Write new volume serial number to cache layer
           root2xmem((long)_ftc.dv[dev->ftc_dev].di->devsig, sig, 16);
         }

         // Set Volume Label
     	   // Copy label to vol_label and pad with spaces
         if (label) {
	         i = strlen(label);
         	strncpy(bpb_dat.vol_label, label, 11);
            if(i<11)bpb_dat.vol_label[i]=0x20;
         }
         else {
            bpb_dat.vol_label[0] = 0x20;
         }

   		if ((rc = fatftc_write(part->ftc_prt, part->mpart->startsector, 0, 62,
		   		paddrSS(&bpb_dat), FAT_BLOCK_FLAGS | FTC_NO_PREIMAGE)) != 62) {
            return rc;
         }
        	part->opstate++;

		case 6:	// Write BPB signature to last two bytes of BPB
      	i = 0xAA55;
   		if ((rc = fatftc_write(part->ftc_prt, part->mpart->startsector, 510,
			   		2, paddrSS(&i), FAT_BLOCK_FLAGS | FTC_NO_PREIMAGE)) != 2) {
            return rc;
         }
         part->opstate++;

      case 7:
         // See if partition type matches with partition table on the MBR
         i = (part->type == 2 ? 6 : part->type);   // Convert to MBR type codes
         if (i != dev->part[pnum].parttype) {
            // Modify type value within the partition table on the MBR
      		if ((rc = fatftc_write(part->ftc_prt, 0, 0x1C2 + (pnum << 4),
                       1, paddrSS(&i), FAT_BLOCK_FLAGS | FTC_NO_PREIMAGE)) != 1)
            {
               return rc;
            }
            dev->part[pnum].parttype = i;
         }
         part->opstate++;

      case 8:
        	rc = _fat_EnumPartition( dev, pnum, part );
		   if (rc) {
   			return rc;
         }
         part->opstate = 512;

      case 512:
		 	// make sure our cached numbers are right.
      	rc = _fat_CheckPart( part );
         if (rc) {
         	return rc;
         }
         break;

		default:
      	return -EINVAL;
	}

   part->opstate = 0;
	return 0;
#else
	return -EPERM;
#endif
}

/*** BeginHeader fat_SyncPartition, _fat_SyncPartition */
int fat_SyncPartition(fat_part *part);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_SyncPartition  fat_SyncPartition
#else
int _fat_SyncPartition(fat_part *part);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_SyncPartition                   <FAT16.LIB>

SYNTAX:       fat_SyncPartition(fat_part *part)

DESCRIPTION:
   Flushes all cached writes to the specified partition to the actual
   device.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition to be syncronized

RETURNS:	     0 for Success
              -EINVAL - invalid partition handle
              -EBUSY if the device is busy.  (Only if non-blocking).
                Call this function again to complete the sync.
              Any other negative value: I/O error when updating the
                device.

SEE ALSO:     fat_Close, fat_SyncFile, fat_UnmountPartition
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_SyncPartition(fat_part *part)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_SyncPartition(part);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_SyncPartition(fat_part *part)
#else
_fat_debug int fat_SyncPartition(fat_part *part)
#endif
{
   auto int rc;

   /* See if partition pointer is useable */
   if ( part == NULL ) {
   	return -EINVAL;      // Bad partition pointer
   }
	if ( part->dev == NULL || part->dev->driver == NULL ||
   		( part->dev->driver->ndev == 0 )) {
		return -ENOPART;	   // Partition missing vital info, needs enumeration
   }
   if ( fat_IsFatMBREntry(part->mpart->parttype) == 0 ) {
   	return -EBADPART;
   }
  	if ((fat_part *)part->dev->fs_part[part->pnum] != part) {
   	return -EPERM;       // Device not linked to this partition
   }
	return fatftc_flushdev(part->dev->ftc_dev, FAT_BLOCK_FLAGS);
}

/*** BeginHeader fat_GetName, _fat_GetName */
int fat_GetName( fat_dirent *, char *, word );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_GetName  fat_GetName
#else
int _fat_GetName( fat_dirent *, char *, word );
#endif
#define FAT_LOWERCASE 0x0001
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_GetName                   <FAT16.LIB>

SYNTAX:      int fat_GetName(fat_dirent * entry, char * buf, word flags)

DESCRIPTION:
   This function translates the file or directory name in the fat_dirent
   structure into a printable name.  FAT file names are stored in a
   strict fixed-field format in the fat_dirent structure (returned from
   fat_Status(), for example).  This format is not always suitable for
   printing, so this function should be used to convert the name to
   a printable null-terminated string.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   entry - Pointer to a directory entry as obtained by
              fat_Status().

PARAMETER2:   buf - pointer to char array which will be filled in.
              This array must be at least 13 characters long.

PARAMETER3:   Options:
                0: standard format e.g. AUTOEXEC.BAT or XYZ.GIF
                FAT_LOWERCASE: standard format, but make lower case.

RETURNS:             0 for Success
              -EINVAL - invalid (NULL) parameter(s).

SEE ALSO:     fat_ReadDir, fat_Status
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_GetName(fat_dirent * entry, char * buf, word flags)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_GetName(entry, buf, flags);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_GetName(fat_dirent * entry, char * buf, word flags)
#else
_fat_debug int fat_GetName(fat_dirent * entry, char * buf, word flags)
#endif

{
	auto char * p;
	auto word i;

	if (!entry || !buf) {
		return -EINVAL;
   }

   for (p = entry->name, i = 9; --i && !isspace(*p); ++p)
   {
		*buf++ = ((*p == 0x05) ? 0xE5 : ((flags & FAT_LOWERCASE) ?
      					tolower(*p) : *p));
   }

   if (!isspace(entry->name[8])) {
		*buf++ = '.';
		for (p = entry->name+8, i = 4; --i && !isspace(*p); ++p)
			*buf++ = ((flags & FAT_LOWERCASE) ? tolower(*p) : *p);
   }
	*buf = 0;
	return 0;
}

/*** BeginHeader fat_GetPartition */
int fat_GetPartition (fat_part **part, const char **file, const char *fullpath);
/*** EndHeader */
/* START FUNCTION DESCRIPTION *******************************************
fat_GetPartition										                   <FAT16.LIB>

SYNTAX:      int fat_GetPartition (fat_part **part, const char **file,
                                      const char *fullpath)

DESCRIPTION:
	Split a full pathname (e.g., "a:/filename.txt") into a paritition and
	filename.

	Examples (with FAT_USE_FORWARDSLASH defined):
		a:/filename.txt	-> partition A, /filename.txt
		/b/filename.txt	-> partition B, /filename.txt
		C:filename.txt		-> partition C, /filename.txt

	Examples (without FAT_USE_FORWARDSLASH defined):
		a:\filename.txt	-> partition A, \filename.txt
		\b\filename.txt	-> partition B, \filename.txt
		C:filename.txt		-> partition C, \filename.txt

PARAMETER1:   part - Memory location to store a pointer to the fat partition
					(drive letter).

PARAMETER2:   file - Memory location to store a pointer into fullpath
					(parameter 3) where the filename begins.

PARAMETER3:   fullpath - Pathname to parse.

RETURNS:             0 for Success
              -EINVAL - unable to parse <fullpath>
*************************************************************************/
_fat_debug
int fat_GetPartition (fat_part **part, const char **file, const char *fullpath)
{
	int p, i;
	const char *f;
   char buffer[12];

	*file = NULL;
	// check for null pathname
   p = fullpath[0];
	if (! p) {
		return -EINVAL;
	}
	else if (p == FAT_SLASH_CH)
	{
		// Using unix-style pathname  (/a/filename.txt)
		p = fullpath[1];
		f = &fullpath[2];
	}
	else if (fullpath[1] == ':')
	{
		// X:/filename.ext convention, fall through to code below
		f = &fullpath[2];
	}
	else {
		// Not a recognized pathname.  If <fullpath> is just a bare 8.3 filename,
		// allow it and assume parition A.

      // Invalid file if _fat_getname() throws an error, or filename doesn't
      // end with a null byte.
	   i = _fat_getname (fullpath, buffer);
	   if (!i || fullpath[i]) {
	   	return -EINVAL;
	   }

      // fullpath is a valid 8.3 filename
      *part = fat_part_mounted[0];
      *file = fullpath;
      return 0;
	}

   if (p >= 'a' && p <= 'h') {
      *part = fat_part_mounted[p - 'a'];
   }
   else if (p >= 'A' && p <= 'H') {
      *part = fat_part_mounted[p - 'A'];
   }
   else {
      // invalid partition letter
      return -EINVAL;
   }

   *file = f;
   return 0;
}

/*** BeginHeader fat_Status, _fat_Status */
int fat_Status( fat_part *, const char *, fat_dirent *);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Status  fat_Status
#else
int _fat_Status( fat_part *, const char *, fat_dirent *);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Status                   <FAT16.LIB>

SYNTAX:       int fat_Status( fat_part *part, const char *name,
							fat_dirent * entry)

DESCRIPTION:
	Scans for the specified entry and fills in entry structure if found
   without opening the directory or entry.

     uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition being used

PARAMETER2:   name - full path name of the entry to be found

PARAMETER3:   entry - pointer to a directory entry structure to fill in

RETURNS:	     0 for Success
				  -EIO - on device I/O error
              -EINVAL - if part, name or entry are invalid.
              -ENOENT - file/directory/label could not be found
              -EBUSY if the device is busy.  (Only if non-blocking).
                Call again without changing any parameters to continue.

SEE ALSO:     fat_ReadDir
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Status( fat_part *part, const char *name, fat_dirent * entry)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Status( part, name, entry);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Status( fat_part *part, const char *name, fat_dirent * entry)
#else
_fat_debug int fat_Status( fat_part *part, const char *name, fat_dirent * entry)
#endif

{
	auto fat_location loc;
   auto const char * newpath;	// Trailing part of path which we need to create
   auto int rc;
   auto long sbuf;

   // Check that partition is properly mounted and entry pointer exists
   if (!part || !entry || part->dev->fs_part[part->pnum] != part ||
       !(part->mpart->status & MBRP_MOUNTED)) {
		return -EINVAL;
   }
   memset(&loc, 0, sizeof(loc));
#ifndef FAT_BLOCK
	// Stage the root dir into cache.  This may miss, so we can return
   // -EBUSY just for this.
   rc = fatftc_read( part->ftc_prt, part->rootstart, &sbuf, FTC_MAKE_LRU );
   if (rc < 0) {
   	return rc;
   }
#endif
   // loc is an auto, so _fat_navigate will block.  Since we read in the
   // root dir sector above, it will get an initial cache hit for the
   // first level (root), then may have read misses only, but no need to flush
   // dirty sectors (since FTC_MAKE_LRU is set).  Sooooo... we are blocking
   // but will only wait for reads (which are fast) not writes.
   // If we didn't do this slight hack, then caller would have to pass a
   // static loc struct (and initialize it) so that navigate could be truly
   // non-blocking.
  	rc = _fat_navigate( part, name, &newpath, FAT_FILE, &loc );
   if (rc < 0 && rc != -ETYPE) {
   	return rc;
   }

   // Cache hit is guaranteed
   rc = fatftc_read( part->ftc_prt, loc.sector, &sbuf, FTC_WAIT|FTC_MAKE_LRU);
   if (rc >= 512) {
      _f_memcpy((void __far *)entry,(void __far *)(sbuf + loc.sofs), FAT_DIRSZ);
      loc.nav_state = 0;
   	return 0;
   }
   return rc;
}

/*** BeginHeader fat_Open, _fat_Open  */
int fat_Open( fat_part *, const char *, int, int, FATfile *, long *);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Open fat_Open
#else
int  _fat_Open( fat_part *, const char *, int, int, FATfile *, long *);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Open                   <FAT16.LIB>

SYNTAX:       int fat_Open( fat_part *part, const char *name, int type,
								  int ff, FATfile *file, long * prealloc)

DESCRIPTION:
	Open a file or directory, optionally creating it if it does not
   already exist. If the function returns -EBUSY, it should be called
   repeatedly with the same arguments until it returns something other
   than -EBUSY.  Parent directory must already exist.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition being used

PARAMETER2:   name - full path name of the file to be opened/created

PARAMETER3:   type - must be FAT_FILE or FAT_DIR depending on what is to
						be opened/created.

PARAMETER4:   ff - flags: must be one of
						FAT_OPEN (0) - Object must already exist
                  FAT_CREATE   - Object is created only if it does not
                    already exist
                  FAT_MUST_CREATE - Object is created, and it must not
                    already exist.
                  FAT_READONLY - No write operations (this flag is
                    mutually exclusive with any of the CREATE flags).
                  FAT_SEQUENTIAL - Optimize for sequential reads
                    and/or writes.  This setting can be changed while
                    the file is open by using the fat_fcntl()
                    function.

PARAMETER5:   file - pointer to an empty FATfile struct that will act as
						a handle for the newly opened file.
                  Note: if using non-blocking style, you must memset this
                  struct to zero before calling the first time.  Keep
                  calling until something other than -EBUSY is returned,
                  but do not change anything in *file (or any of the
                  other parameters) while doing so.

PARAMETER6:   prealloc - an initial byte count if the object needs to be
                  created.  This number is rounded up to the nearest
                  whole number of clusters greater than or equal to 1.
                  This parameter is only used if one of the *_CREATE
                  flags is set, and the object does not already exist.
                  On return, *prealloc is updated to the actual number
                  of bytes allocated. May be NULL in which case 1 cluster
                  is allocated if successful.

RETURNS:	     . 0 for Success
              . -EINVAL - invalid argument.  Missing pointer or trying to
                          create vol. label, or conflicting flags.
              . -ENOENT - file/directory could not be found
              . -ENOSPC - no space on partition to create file/directory
              . -EPERM - trying to create a file/directory on a read-only
		              		partition
              . -EPATHSTR - Invalid path string for file/directory
              . -EEXIST - object existed when FAT_MUST_CREATE flag set.
              . -EMFILE - too many open files.  If you get this code,
                you can increase the FAT_MAXMARKERS definition in
                the BIOS.
              . -EFSTATE - file structure not in valid state.  Usually
              means it was not zeroed before calling this function for the
              first time (for that file struct).  It can also occur if the
              same file struct is used when it already has an open file.
              The file must be closed before re-using the file structure.
              . Other negative values indicate I/O error etc.

              Non-blocking mode only:
              . -EBUSY - the device is busy.

SEE ALSO:     fat_ReadDir, fat_Status, fat_Close
*************************************************************************/

#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Open( fat_part *part, const char *name, int type,
									int ff, FATfile *file, long *prealloc )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Open(part, name, type, ff, file, prealloc);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Open( fat_part *part, const char *name, int type,
									int ff, FATfile *file, long *prealloc )
#else
_fat_debug int fat_Open( fat_part *part, const char *name, int type,
									int ff, FATfile *file, long *prealloc )
#endif

{
   auto int rc;
   auto fat_location * loc;
   auto long sbuf;
   auto unsigned long clust, free;
   auto const char * newpath;	// Trailing part of path which we need to create

   if (!part || !file || type == FAT_LABEL ||
           ((ff & FAT_READONLY) && (ff & FAT_MUST_CREATE))) {
   	return -EINVAL;     // Doesn't handle labels or conflicting flags
   }
   if (!name) {
      return -EPATHSTR;
   }
#ifdef FAT16_READONLY
	if(ff & FAT_CREATE) {
		return -EPERM;
   }
#endif
   // Check partition is properly mounted
   if (part->dev->fs_part[part->pnum] != part ||
       !(part->mpart->status & MBRP_MOUNTED)) {
		return -EINVAL;
   }
   if (part->mpart->status & MBRP_READONLY) {
      if (ff & FAT_CREATE) {
         return -EPERM;    // Can't use Create flag on read only partition
      }
      ff |= FAT_READONLY;  // Force read only flag
   }
   if (file->state == FAT_FILESTATE_IDLE) {
      return -EFSTATE;    // File structure is already in use
   }

#ifndef FAT_BLOCK
	if(!file->state)	// FAT_FILESTATE_NOTOPEN
   {
#endif
   // If the create flag is set, then open a transaction NOW to interlock
   // with other opens which may need to occur.  If it turns out that we don't
   // actually need to create, the transaction is closed (no harm done).
   if (ff & FAT_CREATE) {
      if (part->opstate != FAT_PART_IDLE) {
         return -EBUSY;
      }
      rc = fatrj_transtart(part->ftc_prt);
      free = part->freecluster;
#ifndef FAT_BLOCK
      if (rc == -ETRANSOPEN) {
         return -EBUSY;
      }
#endif
      if (rc < 0) {
         return rc;
      }
      part->opstate = 1;
   }
   memset(file, 0, sizeof(*file));
   file->state = FAT_FILESTATE_INIT;
#ifndef FAT_BLOCK
	}
#endif

	loc = &file->loc;

   // Loop until busy, error, or all done
	for (;;) switch (file->state)
   {
   default:
   	return -EFSTATE;
   case FAT_FILESTATE_INIT:
      file->state = FAT_FILESTATE_NAV;
   case FAT_FILESTATE_NAV:
		// Navigate to the directory in question.
      file->flag = (char)(ff & FAT_MODEFLAGS);	// Set initial fcntl/mode flags
   	rc = _fat_navigate( part, name, &newpath, type, loc );
	#ifndef FAT_BLOCK
		if(rc == -EBUSY) {
   		return rc;
      }
	#endif
   	if (ff & FAT_CREATE) {
	      part->opstate = FAT_PART_IDLE;
      }
		switch( rc )
		{
         case 1:
            file->flag |= FAT_READONLY;   // File/Dir found was read only
         case 0:
         	// The file was found; navigate set u_sector/u_sofs to point to the
            // containing directory entry.  s_cluster is the 1st cluster of the
            // file itself.
            if (ff & FAT_CREATE) {
            	// Already exists, no allocation transaction required
	            fatrj_tranend(part->ftc_prt, 0);
	            if (ff & (FAT_MUST_CREATE & ~FAT_CREATE)) {
			         file->state = FAT_FILESTATE_NOTOPEN;
	               return -EEXIST;
	            }
            }
      		file->state = FAT_FILESTATE_FOUND;
      		break;
         case -EROOTFULL:
         	// Would need to extend root directory, which ain't allowed.
         	rc = ff & FAT_CREATE ? -EROOTFULL : -ENOENT;
            goto _fat_closetran;
         case -ENFILE:
         	// Not found, and need to extend a non-root directory.
            rc = -ENOENT;
			case -ENOENT:
				if (ff & FAT_CREATE) {
            	// Only allowed to create one new level, thus if 'not found'
               // part of path contains a path separator, this is a no-no.
            	if (!strchr(newpath, FAT_SLASH_CH)) {
	               // loc->u_sector/u_sofs contains free slot in directory.  If
	               // no free slot, loc->cluster is the last cluster of the
	               // directory, which will be extended by _fat_create().
	               file->state = FAT_FILESTATE_CREATE;
	               loc->nav_state = FAT_FILESTATE_CR_INIT; // to initialize
      				part->opstate = 1;                  	 //  _fat_create
	               break;
               }
            }
            // fall thru
			default:
         _fat_closetran:
	         file->state = FAT_FILESTATE_NOTOPEN;
            if (ff & FAT_CREATE) {
	            fatrj_tranend(part->ftc_prt, 0);
            }
				return rc;		/* something is wrong with the file */
		}
      break;

   case FAT_FILESTATE_CREATE:
      // loc->u_sector/u_sofs contains free slot in directory, or if u_sector
      // is zero then loc->cluster points to the last cluster of the containing
      // directory which we are going to extend to contain a new entry (the
      // latter case obtains if -ENFILE was returned by _fat_navigate() above).
      // A transaction is already open.
      if (prealloc == NULL) {
        sbuf = 1;     // Use sbuf if prealloc pointer is NULL
        prealloc = &sbuf;
      }
   	rc = _fat_create(part, type, loc, prealloc);
 	#ifndef FAT_BLOCK
      if (rc == -EBUSY) {
      	return rc;
      }
   #endif
   	if (rc < 0) {
         file->state = FAT_FILESTATE_NOTOPEN;
         part->freecluster = free;
         fatrj_rollback(part->ftc_prt, FTC_WAIT);
      	return rc; //some other type of error
      }
      else {
         // Save the number of allocated bytes in prealloc
         *prealloc = part->clustlen * rc;
      }
      file->state = FAT_FILESTATE_FOUND;
      // Fall through...

   //actually open it
   case FAT_FILESTATE_FOUND:
      file->part = part;
		file->type = type;	// File or directory.  Cannot subsequently write to
      							// a directory, but can read it like an ordinary
                           // file (you get the raw data i.e. 32-byte entries).

	   _fat_clust2sec(part, loc->cluster = loc->s_cluster, &loc->sector );

      // Set size marker pointer to -1 (Not registered)
      file->dirent_mark = -1;


	   /* Take over the length of the file. Note that directories have a length
	      of '0'. They "end" at the end of the cluster chain or with the first
         entry that starts with a '\0' byte whichever comes first.  Thus, for
         directories we initially calculate the length based strictly on the
         number of clusters assigned to that directory.  If the directory is
         later extended, this will not be reflected in the open "file"
         descriptor. */
      if (loc->u_sector) {
      	// This read is guaranteed cache hit
	      if ((rc = fatftc_read(part->ftc_prt, loc->u_sector, &sbuf,
         								FTC_WAIT)) < 0) {
	         file->state = FAT_FILESTATE_NOTOPEN;
	         if (ff & FAT_CREATE) {
	            part->freecluster = free;
	            fatrj_rollback(part->ftc_prt, FTC_WAIT);
	         }
	         return rc;
         }

         sbuf += loc->u_sofs;
	      _fat_xDir2Clust(sbuf, &loc->s_cluster );
         loc->sofs = 0;
         // The following call is guaranteed not to block, because
         // we just read in the appropriate sector above.  For directories,
         // we don't register the length field since this should never be
         // set to anything other than 0 on the disk.
         rc = fatrj_regmarker(part->dev->ftc_dev, loc->u_sector,
               loc->u_sofs + offsetof(fat_dirent, attr),
               sizeof(fat_dirent) - offsetof(fat_dirent, attr) -
                 (type == FAT_DIR ? sizeof(long) : 0),
               FTC_WAIT);
         if (rc < 0) {
	         file->state = FAT_FILESTATE_NOTOPEN;
	         if (ff & FAT_CREATE) {
	            part->freecluster = free;
	            fatrj_rollback(part->ftc_prt, FTC_WAIT);
	         }
            return -EMFILE;   // Too many open files (no marker)
         }
         file->dirent_mark = rc;
	      // Commit the directory entry object creation transaction
	      fatrj_tranend(part->ftc_prt, 0);

         // Read initial marker contents from cache into file struct.
         // In particular, the attr and fileSize fields.
         fatrj_getmarker(rc, &file->de);

	      if (type != FAT_FILE) {
         	// For directories, we override the fileSize field (which is
            // always zero in the on-disk dirent) to be the actual
            // directory length.
	         loc->u_cluster = loc->s_cluster;
            file->de.fileSize = 0;	// This should be done already, but j.i.c.
	         // Scan the directory cluster chain, updating total length.
	         do {
	            file->de.fileSize += part->clustlen;
	            rc = _fat_next_clust(part, &loc->u_cluster, FAT_BLOCK_FLAGS);
               if (rc == -EBUSY) {
               	file->state = FAT_FILESTATE_DIRLEN;
               	return rc;
               }
	         } while (!rc);
	      }
      }
      else {
      	// Opening the root directory.  Nothing points to it.
         // Leave loc->s_cluster zero, then fat_Read will not use cluster
         // chaining; instead, it will read sequentially up to file->de.fileSize
         // bytes.
         file->de.fileSize = part->root_cnt * sizeof(fat_dirent);
      }
	_fat_file_opened:
      file->state = FAT_FILESTATE_IDLE;	// Open but inactive

		/* add to linked list of open files in partition struct */
		file->next = part->first;
		part->first = file;

      return 0;	// All done

   case FAT_FILESTATE_DIRLEN:
   	// This state only occurs when opening a non-root directory
      do {
         rc = _fat_next_clust(part, &loc->u_cluster, FAT_BLOCK_FLAGS);
         if (rc == -EBUSY) {
            return rc;
         }
         if (!rc) {
         	file->de.fileSize += part->clustlen;
         }
      } while (!rc);
      goto _fat_file_opened;

	}	// for (;;) switch

   // Should never get here
	return -EFSTATE;
}


/*** BeginHeader fat_CreateDir, fat_CreateFile,
                         _fat_CreateDir, _fat_CreateFile */
// These are together, because they both make use of a static variable
int fat_CreateDir(fat_part * part, const char * dirname);
int fat_CreateFile(fat_part * part, const char * filename, long alloc_size,
								FATfile * file);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_CreateDir  fat_CreateDir
#define _fat_CreateFile  fat_CreateFile
#else
int _fat_CreateDir(fat_part * part, const char * dirname);
int _fat_CreateFile(fat_part * part, const char * filename, long alloc_size,
								FATfile * file);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_CreateDir                   <FAT16.LIB>

SYNTAX:  int fat_CreateDir(fat_part * part, const char * dirname)

DESCRIPTION:
	Creates a directory if it does not already exist. Parent directory
   must already exist.

   In non-blocking mode, only one file or directory can be created
   at any one time, since a single static FATfile is used for
   temporary storage.  Each time you call this function, pass the
   same dirname pointer (not just the same string contents).

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition being used

PARAMETER2:   dirname - full path name of the directory to be created

RETURNS:	     0 for Success
              -EINVAL - invalid argument.  Trying to create vol. label
              -ENOENT - parent directory does not exist
              -EPERM - trying to create a directory on a read-only
		              		partition
              -EBUSY if the device is busy.  (Only if non-blocking)
              -EFSTATE if non-blocking, but a previous sequence of calls
                to this function (or fat_CreateFile) has not completed
                and you are trying to create a different file or
                directory.  You must complete the sequence of calls
                for each file or directory i.e. keep calling until
                something other than -EBUSY is returned.

              Other negative values possible from fat_Open/fat_Close call

SEE ALSO:     fat_ReadDir, fat_Status, fat_Open, fat_CreateFile
*************************************************************************/

FATfile _temp_file;	// Temp file for fat_CreateFile()/fat_CreateDir()
#ifndef FAT_BLOCK
const char * _temp_file_name;   // Remembers dirname/filename pointer.
#endif

#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_CreateDir(fat_part * part, const char * dirname)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_CreateDir(part, dirname);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_CreateDir(fat_part * part, const char * dirname)
#else
_fat_debug int fat_CreateDir(fat_part * part, const char * dirname)
#endif

{
	auto long alloc;
   auto int rc;
#ifndef FAT_BLOCK
   #GLOBAL_INIT { memset(&_temp_file, 0, sizeof(_temp_file)); }
#endif

#ifndef FAT_BLOCK
   if (_temp_file.state && dirname != _temp_file_name) {
   	return -EBUSY;
   }
	_temp_file_name = dirname;
   switch (_temp_file.state) {
     default:		// File start open or opening
#endif
     alloc = 0;	// Default to minimum allocation amount
	  rc = _fat_Open(part, dirname, FAT_DIR, FAT_CREATE, &_temp_file, &alloc);
     if (rc) {
#ifdef FAT_BLOCK
       _temp_file.state = 0;
#else
       if (rc != -EBUSY) { _temp_file.state = 0; }
#endif
     }
     else {
#ifndef FAT_BLOCK
	  case FAT_FILESTATE_IDLE:		// File state is open or closing
	  case FAT_FILESTATE_CLOSE:
#endif
   	  rc = _fat_Close(&_temp_file);
     }
#ifndef FAT_BLOCK
	} //switch
#endif
   return rc;
}


/* START FUNCTION DESCRIPTION *******************************************
fat_CreateFile                   <FAT16.LIB>

SYNTAX:  int fat_CreateFile(fat_part * part, const char * filename,
                                long alloc_size, FATfile * file)

DESCRIPTION:
	Creates a file if it does not already exist. Parent directory must
   already exist.

   If `file` is NULL:
	   In non-blocking mode, only one file or directory can be created
	   at any one time, since a single static FATfile is used for
	   temporary storage.  Each time you call this function, pass the
      same dirname pointer (not just the same string contents).

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition being used

PARAMETER2:   filename - full path name of the file to be created

PARAMETER3:   alloc_size - initial number of bytes to pre-allocate.
                 Note that at least one cluster will be allocated.  If
                 there is not enough space for the requested allocation
                 amount (beyond the first cluster) then the file will be
                 allocated with whatever space is available on the
                 partition, but no error code will be returned.  If
                 not even the first cluster is allocated then there
                 will be an error return code (-ENOSPC).
                 This initial allocation amount is rounded up to the
                 next whole number of clusters.

PARAMETER4:   file: if not NULL, the created file is opened and accessible
                using this handle.  If NULL, the file is closed after
                it is created.

RETURNS:	     0 for Success
              -EINVAL - invalid argument.  Trying to create vol. label
              -ENOENT - parent directory does not exist
              -EPERM - trying to create a file on a read-only partition
              -EBUSY if the device is busy.  (Only if non-blocking)
              -EFSTATE if non-blocking, but a previous sequence of calls
                to this function (or fat_CreateDir) has not completed
                and you are trying to create a different file or
                directory.  You must complete the sequence of calls
                for each file or directory i.e. keep calling until
                something other than -EBUSY is returned.  This code
                is only returned if you pass a NULL file pointer, or
                if the file pointer is not NULL and the referenced file
                is already open.
              -EPATHSTR	- Bad file/dir path string. Valid filenames are
                          limited to the 8.3 format.

              Other negative values indicate I/O error etc.

SEE ALSO:     fat_Open, fat_ReadDir, fat_Write, fat_CreateDir
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_CreateFile(fat_part * part, const char * filename,
                              long alloc_size, FATfile * file)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_CreateFile(part,  filename, alloc_size, file);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_CreateFile(fat_part * part, const char * filename,
                              long alloc_size, FATfile * file)
#else
_fat_debug int fat_CreateFile(fat_part * part, const char * filename,
                              long alloc_size, FATfile * file)
#endif

{
	auto int dummy;
   auto int rc;

   if (!file) {
   	dummy = 1;
      file = &_temp_file;
   }
   else {
   	dummy = 0;
   }
#ifndef FAT_BLOCK
   if (dummy) {
   	if (file->state && filename != _temp_file_name) {
   		return -EFSTATE;
      }
		_temp_file_name = filename;
   }
   switch (file->state) {
   default:		// File start open or opening
#endif
	rc = _fat_Open(part, filename, FAT_FILE, FAT_CREATE, file, &alloc_size);
   if (rc) {
#ifdef FAT_BLOCK
     file->state = 0;
#else
     if (rc != -EBUSY) { file->state = 0; }
#endif
   }
   else {
#ifndef FAT_BLOCK
	case FAT_FILESTATE_IDLE:		// File state is open or closing
	case FAT_FILESTATE_CLOSE:
#endif
   	if (dummy) { rc = _fat_Close(file); }
	}
#ifndef FAT_BLOCK
	} //switch
#endif
   return rc;
}

/*** BeginHeader fat_OpenDir, _fat_OpenDir */
int fat_OpenDir(fat_part * part, const char * dirname, FATfile * dir);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_OpenDir  fat_OpenDir
#else
int _fat_OpenDir(fat_part * part, const char * dirname, FATfile * dir);
#endif

/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_OpenDir                   <FAT16.LIB>

SYNTAX:  int fat_OpenDir(fat_part * part, const char * dirname, FATfile * dir)

DESCRIPTION:
	Opens a directory for use, filling in FATfile handle.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition being used

PARAMETER2:   dirname - full path name of the directory to be created

PARAMETER3:   dir - handle to the directory requested

RETURNS:	     0 for Success
              -EINVAL - invalid argument.
              -ENOENT - directory does not exist
              -EBUSY if the device is busy.  (Only if non-blocking)
              Other negative values possible from fat_Open call

SEE ALSO:     fat_ReadDir, fat_Status, fat_Open, fat_Close
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_OpenDir(fat_part * part, const char * dirname, FATfile * dir)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_OpenDir( part, dirname,  dir);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_OpenDir(fat_part * part, const char * dirname, FATfile *dir)
#else
_fat_debug int fat_OpenDir(fat_part * part, const char * dirname, FATfile * dir)
#endif

{
	auto long alloc;
   auto int rc;

   alloc = 0;	// Default to minimum allocation amount
	rc = _fat_Open(part, dirname, FAT_DIR, 0, dir, &alloc);
   return rc;
}

/*** BeginHeader fat_ReadDir, _fat_ReadDir */
int fat_ReadDir(FATfile * dir, fat_dirent * entry, int mode);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_ReadDir  fat_ReadDir
#else
int _fat_ReadDir(FATfile * dir, fat_dirent * entry, int mode);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_ReadDir                   <FAT16.LIB>

SYNTAX:  int fat_ReadDir(FATfile * dir, fat_dirent * entry, int mode)

DESCRIPTION:
	Reads the next directory entry of desired type from the given
   directory, filling in the entry structure.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   dir - handle for the directory being read

PARAMETER2:   entry - handle to the entry structure to fill in

PARAMETER3:   mode - 0 = next active file or directory entry including
							read only (no hidden, sys, label, deleted or empty)

                   - nonzero sets selection on following attributes:
                     FATATTR_RD_ONLY   - include read-only entries
							FATATTR_HIDDEN    - include hidden entries
							FATATTR_SYSTEM    - include system entries
							FATATTR_DIRECTORY - include directory entries
							FATATTR_ARCHIVE   - include modified entries

							FAT_FIL_RD_ONLY   - filter on read-only attribute
							FAT_FIL_HIDDEN    - filter on hidden attribute
							FAT_FIL_SYSTEM    - filter on system attribute
							FAT_FIL_DIRECTORY - filter on directory attribute
							FAT_FIL_ARCHIVE   - filter on modified attribute

               These 'INC' flags default to FAT_INC_ACTIVE if none set
							FAT_INC_DEL       - include deleted entries
							FAT_INC_EMPTY     - include empty entries
                     FAT_INC_LNAME     - include long name entries
                     FAT_INC_ACTIVE    - include active entries

               Pre-defined filters to make it easier to create your own
                     FAT_INC_ALL       - returns ALL entries of ANY type
                     FAT_INC_DEF       - default (files & dirs including
                     							read-only and archive)

               NOTE: Active files included by default unless any of
                     FAT_INC_DEL, FAT_INC_EMPTY, or FAT_INC_LNAME
                     are set. Include flags become desired filter value
                     if associated filter flags are set.

			 Examples of some filter behaviour:
  		mode = FAT_INC_DEF | FAT_FIL_HIDDEN | FATATTR_HIDDEN
			 would return next hidden entry (file or directory)
  		mode = FAT_INC_DEF | FAT_FIL_HIDDEN | FAT_FIL_DIR | FATATTR_HIDDEN
			 would return next hidden directory (not hidden file)
  		mode = FAT_INC_DEF | FAT_FIL_HIDDEN | FAT_FIL_DIR | FATATTR_HIDDEN
      			 & ~FATATTR_DIRECTORY
			 would return next hidden file (not hidden directory)
      mode = FAT_INC_ALL & ~FAT_INC_EMPTY
          would return next non-empty entry of any type

RETURNS:	     0 for Success
              -EINVAL - invalid argument
              -ENOENT - directory does not exist
              -EEOF - no more entries in the directory
              -EFAULT - directory chain has link error
              Other negative values possible from fat_Open call
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO:     fat_OpenDir, fat_Status
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_ReadDir(FATfile * dir, fat_dirent * entry, int mode)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_ReadDir( dir, entry, mode);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_ReadDir(FATfile * dir, fat_dirent * entry, int mode)
#else
_fat_debug int fat_ReadDir(FATfile * dir, fat_dirent * entry, int mode)
#endif

{
	auto int mask, nam, att;
   auto int rc;

   if (!dir || !entry || dir->type != FAT_DIR) {
   	return -EINVAL;
   }
	if (dir->pos >= dir->de.fileSize) {
   	return -EEOF;
   }

	if (!mode) {
   	mode = FAT_INC_DEF;		// Set default include of
      mask = 0x0E;
   }
   else {
      // Turn on FAT_INC_ACTIVE if other name based includes are off
      if (!(mode & (FAT_INC_EMPTY | FAT_INC_DEL | FAT_INC_LNAME))) {
      	mode |= FAT_INC_ACTIVE;
      }
      // Set attribute mask based on includes and filters
      mask = ((mode >> 8) | (~mode)) & 0x3F;
   }

   rc = _fat_Read(dir, (char *)entry, FAT_DIRSZ);
#ifndef FAT_BLOCK
   if (!rc) {
      // if 0 bytes read in non-blocking mode then the device was busy
      rc = -EBUSY;
   }
#endif
   while (rc == FAT_DIRSZ)
   {
      nam = entry->name[0];			// First character of name
      att = entry->attr;     		// File attributes
      if (nam) {
         if (nam != 0xE5 && ((att & 0x0F) == 0x0F)) {
	         if (mode & FAT_INC_LNAME) {
         	   return 0;
	         }
         }
         else if ((mode & (nam == 0xE5 ? FAT_INC_DEL : FAT_INC_ACTIVE)) &&
         	  (!((att ^ mode) & mask))) {
            return 0;
         }
      }
      else {
         if (mode & FAT_INC_EMPTY) {
            return 0;
         }
      }
   	rc = _fat_Read(dir, (char *)entry, FAT_DIRSZ);
#ifndef FAT_BLOCK
      if (!rc) {
         // if 0 bytes read in non-blocking mode then the device was busy
         rc = -EBUSY;
      }
#endif
   }
   return rc;
}

/*** BeginHeader fat_SyncFile,  _fat_SyncFile */
int fat_SyncFile( FATfile * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_SyncFile  fat_SyncFile
#else
int _fat_SyncFile( FATfile * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_SyncFile                   <FAT16.LIB>

SYNTAX:       fat_SyncFile(FATfile *file)

DESCRIPTION:
   Updates directory entry for the given file, commiting cached size,
   dates and attribute fields to the actual directory.  Same affect as
   closing and re-opening the file.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for the open file

RETURNS:	     0 for Success
              -EINVAL - invalid file handle
              -EPERM - this operation is not permitted on the root
                directory.
              -EBUSY if the device is busy.  (Only if non-blocking).
                Call this function again to complete the sync.
              -EFSTATE - file not open or in an invalid state
              Any other negative value: I/O error when updating the
                directory entry.

SEE ALSO:     fat_Close, fat_Open, fat_OpenDir
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_SyncFile(FATfile *file)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_SyncFile(file);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_SyncFile(FATfile *file)
#else
_fat_debug int fat_SyncFile(FATfile *file)
#endif
{
   auto int rc;
   auto word tstime;
   auto word tsdate;
	auto fat_part *part;

   switch (file->state) {
   default:
   	return -EFSTATE;
   case FAT_FILESTATE_IDLE:
	   part = file->part;
	   _fat_tm2timestamp( &tsdate, &tstime, (char *)&rc );
	   if (file->dirent_mark < 0) {
	      return -EPERM;
      }

	   // Not root directory itself.  Must have open marker.  Write back the marker.
	   if (file->flag & FAT_MODIFIED) {
	      // Update date and time of write
	      file->de.wrtTime = tstime;
	      file->de.wrtDate = tsdate;
	      file->de.attr |= FATATTR_ARCHIVE;
	   }
	   file->de.lstAccDate = tsdate;

	   fatrj_setmarker(file->dirent_mark, &file->de);

	   file->state = FAT_FILESTATE_SYNC;
      // fall thru...
   case FAT_FILESTATE_SYNC:
   	// Write marker value back to disk.  We could unreg/re-reg the marker, but
      // this may cause race conditions if app tries to open more files before
      // re-calling. Instead, just write the marker value.

      // Note: for now, don't actually write to disk.  This has following
      //   implications:
      // 1. Saves wear on flash sector.
      // 2. This function cannot return -EBUSY
      // 3. Other readers of the directory entry will not "see" the updated
      //    values until the file is closed.
      //
	   file->state = FAT_FILESTATE_IDLE;
   	break;
   }
   return 0;
}


/*** BeginHeader fat_Close, _fat_Close */
int fat_Close( FATfile * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Close  fat_Close
#else
int _fat_Close( FATfile * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Close                   <FAT16.LIB>

SYNTAX:       fat_Close(FATfile *file)

DESCRIPTION:
   Closes a currently open file.  You SHOULD check the return code,
   since an I/O needs to be performed when closing a file, to update
   the file's EOF offset (length), last access date, attributes and
   last write date (if modified) in the directory entry.  This is
   particularly critical when using non-blocking mode.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for the open file

RETURNS:	     0 for Success
              -EINVAL - invalid file handle
              -EBUSY if the device is busy.  (Only if non-blocking).
                Call this function again to complete the close.
              Any other negative value: I/O error when updating the
                directory entry.  In this case, the file is forced
                closed, but its recorded length may not be valid.

SEE ALSO:     fat_Open, fat_OpenDir
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Close( FATfile *file )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Close( file );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Close( FATfile *file )
#else
_fat_debug int fat_Close( FATfile *file )
#endif

{
	auto FATfile *p;
	auto FATfile *q;
   auto int rc;
   auto word tstamp[2];
   auto fat_part * part;

   if (!file || !(part = file->part)) {
   	return -EINVAL;
   }

   // See if file actually exists in linked list for this partition.
	for (p = part->first, q = NULL; p; q = p, p = p->next) {
		if (p == file) {
      	break;
      }
   }
   if (!p) {
   	return -EINVAL;
   }

   switch (file->state) {
   default: return -EFSTATE;
	case FAT_FILESTATE_IDLE:
	   // Update directory entry if this is a file.
	   if (file->dirent_mark >= 0) {
	      if (part->opstate != FAT_PART_IDLE && part->opstate != FAT_PART_UNMNT)
         {
	         return -EBUSY;
         }
         if (part->opstate == FAT_PART_IDLE) {
		      part->opstate = 1;
         }
	      _fat_SyncFile(file);
         file->state = FAT_FILESTATE_CLOSE;
         // fall thru...
	   }
	   else {
	      rc = 0;  // Closing the root directory.  No I/O to do.
         break;
      }
   case FAT_FILESTATE_CLOSE:
      rc = fatrj_unregmarker(file->dirent_mark, FAT_BLOCK_FLAGS);
      if (rc == -EBUSY) {
         return rc;
      }
      if (part->opstate == 1) {
	      part->opstate = FAT_PART_IDLE;
      }
   	break;
   }

	// take the file out of the linked list of open files of this partition
   if (q) {
      q->next = file->next;
   }
   else {
      file->part->first = file->next;
   }

	memset( file, 0, sizeof(*file) );

	return rc;
}


/*** BeginHeader fat_Delete, _fat_Delete */
int fat_Delete( fat_part *, int, const char * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Delete  fat_Delete
#else
int _fat_Delete( fat_part *, int, const char * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Delete                   		<FAT16.LIB>

SYNTAX:       fat_Delete( fat_part *part, int type, const char *name )

DESCRIPTION:
   This function deletes the specified file or directory on specified
   partition. The type must match or the deletion will not occur. This
   function inserts a deletion code into the directory entry and marks
   the sectors as available in the FAT table but does not actually
	destroy the data contained in the sectors.  A directory must be
   empty to be deleted.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle for the partition being used

PARAMETER2:   type - must be FAT_FILE or FAT_DIR depending on what is to
						be deleted

PARAMETER3:   name - full path name of the file/directory to be deleted

RETURNS:	     0 for Success
              -EIO on device IO error
				  -EINVAL if part, type, or name contain invalid values
              -EPATHSTR if name is not a valid path/name string or
				  -EPERM if the file is open, write protected, hidden
              			or system
              -ENOTEMPTY if the directory is not empty
				  -ENOENT if file/directory does not exist
              -EBUSY if the device is busy.  (Only if non-blocking)
              -EPSTATE if the partition is busy i.e. there is an
                allocation in progress.  (Only if non-blocking)

SEE ALSO:     fat_Open, fat_DirOpen, fat_Split, fat_Truncate, fat_Close
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Delete( fat_part *part, int type, const char *name )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Delete( part, type, name );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Delete( fat_part *part, int type, const char *name )
#else
_fat_debug int fat_Delete( fat_part *part, int type, const char *name )
#endif

{
#ifndef FAT16_READONLY
	static fat_location loc;
	auto const char * newpath;
	auto int rc;
   auto long sbuf;

   // Check type and that partition is properly mounted
	if (( type != FAT_FILE && type != FAT_DIR ) || part == NULL ||
   			part->dev->fs_part[part->pnum] != part ||
			       !(part->mpart->status & MBRP_MOUNTED)) {
		return -EINVAL;
   }

   if (!name) {
      return -EPATHSTR;   // Must give name string to delete
   }

   if (part->opstate == FAT_PART_IDLE) {
      if (rc = fatrj_transtart(part->ftc_prt)) {
         if (rc == -ETRANSOPEN) {
            // Somebody got in with (probably) file create.  Let it complete.
            rc = -EBUSY;
         }
         return rc;
      }
		/* initialize the location structure */
		memset( &loc, 0, sizeof( loc ) );
      part->opstate = FAT_PART_DEL+101;
   }
   else if (part->opstate & FAT_PART_DEL && part->opstate < (FAT_PART_DEL|100)) {
   	if (loc.s_cluster != part->clust2) {
      	return -EBUSY;
      }
   }
   else if (!(part->opstate & FAT_PART_DEL)) {
   	return -EBUSY;
   }


   switch (part->opstate & 0xFF)
   {
   	case 101:
			/* navigate to the object in question */
			if ((rc = _fat_navigate( part, name, &newpath, type, &loc )) < 0) {
         	if (rc == -EROOTFULL || rc == -ENFILE) {
            	rc = -ENOENT;
            }
				break;
         }
         if (*newpath == '.') {		// Relative references not allowed
         	rc = -EPATHSTR;
            break;
         }
         if (rc) {
            rc = -EPERM;      // File/Dir is read only - can't delete
            break;
         }
			// Entry was found and was proper type
         part->opstate++;

      case 102:
      	// Read entry and check for attributes which would block delete
         // This is guaranteed cache hit.
         rc = fatftc_read(part->ftc_prt, loc.u_sector, &sbuf, FTC_WAIT);
	      if (rc < 0) {
				break;
         }
			if (rc = xgetint(sbuf + loc.u_sofs + 11) & 0x1F) {
            if (type == FAT_FILE || (rc & 0x0F)) {
	         	rc = -EPERM;
					break;
            }
         }
         part->opstate++;

      case 103:
      	if (type == FAT_DIR) {
				// If directory found, is it empty?
   	      if ( rc = _fat_checkdir( part, &loc )) {
            	if (rc != -EBUSY) {
		         	rc = -ENOTEMPTY;
               }
					break;
         	}
	         // Directory is empty, OK to delete
         }
      	// Final check, is it in use
         if (rc = _fat_isopen( part, &loc )) {
         	rc = -EPERM;
				break;
         }
         part->opstate++;

      case 104:
      	// Ready to delete, mark the entry
	      if ((rc = fatftc_write(part->ftc_prt, loc.u_sector, loc.u_sofs,
							        	1, 0x0E5L, FTC_MEMSET | FAT_BLOCK_FLAGS)) < 0) {
         	break;
         }
         part->opstate = FAT_PART_DEL;

      default:
      	// Substates for _fat_free_clust
      	if (!(rc = _fat_free_clust(part, loc.s_cluster)) || rc == -EBUSY) {
            break;
         }

         // Fall thru if error
      _fd_rollback:
      	// Don't break from this one.  Block until rollback complete.  This
         // should never have anything to write back (unless I/O error), so
         // will not block.
      	fatrj_rollback(part->ftc_prt, FTC_WAIT);
        	part->opstate = FAT_PART_IDLE;
         return rc;
	}

   if (rc == -EBUSY) {
   	return rc;
   }
   if (rc < 0) {
      goto _fd_rollback;
   }
   else {
      fatrj_tranend(part->ftc_prt, 0);
		part->opstate = FAT_PART_IDLE;
   }
	return rc;
#else
	return -EPERM;
#endif
}


/*** BeginHeader fat_Split, _fat_Split */
int fat_Split( FATfile *, long, const char * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Split  fat_Split
#else
int _fat_Split( FATfile *, long, const char * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Split                   		<FAT16.LIB>

SYNTAX:       fat_Split( FATfile * file, long where, const char * newfile)

DESCRIPTION:
   This function splits the allocated clusters assigned to the file
   specified by the file handle 'file'. The split keeps data up to
   the byte position given by 'where' and any remaining allocated
   clusters beyond this point are assigned to a new file named by the
   string 'newfile'. As the name implies, this is a newly created file
   and must not already exist. If successful, the original file is closed
   and the file handle is returned pointing to a new open empty file named
   by 'newfile'. This new file contains no data, but is already allocated
   the remaining cluster chain that was freed by the split. The file
   handle given must point to a file of FAT_FILE type.  This function can
   only be used to split one file at a time, even across multiple
   partitions. Additional requests will be held off with EBUSY returns
   until the active split completes. On error, 'file' may or may not be
   left open, check 'file->loc.s_cluster' to verify. If s_cluster is 0,
   the file has been closed and the handle 'file' is free to be re-used.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle to the open file to be split

PARAMETER2:   where - absolute byte to split the file if >= 0
							 if FAT_BRK_END then split at EOF
                      if FAT_BRK_POS then split at current file position
              NOTE: If absolute byte is beyond EOF, file is split at EOF

PARAMETER3:   newfile - absolute path & name for file to be created.

RETURNS:	     0 for Success
              -EIO on device IO error
				  -EINVAL if 'file' has invalid references
				  -ENOENT if 'file' does not exist
              -ETYPE if 'file' is not FAT_FILE type
              -EBUSY if the system is busy.
              -EFSTATE if file in inappropriate state (non-blocking)
     ***** Original file unchanged and left open on the errors below *****
              -EPATHSTR if 'newfile' is not a valid path/name string
              -EEOF if no clusters available after the split point to
                     give to 'newfile'.
				  -EPERM if 'file' is in use, write protected, hidden, or
              			system file.
              -EEXIST if 'newfile' already exists.

SEE ALSO:     fat_Open, fat_DirOpen, fat_Delete, fat_Truncate, fat_Close
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Split( FATfile * file, long where, const char * newfile)
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Split( file, where,  newfile);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Split( FATfile * file, long where, const char * newfile)
#else
_fat_debug int fat_Split( FATfile * file, long where, const char * newfile)
#endif

{
#ifndef FAT16_READONLY
	static fat_location sp_loc;
   auto FATfile *p, *q;
	auto const char * newpath;
	auto int i, rc;
   auto long sbuf;
   auto unsigned sec, ofs;

#GLOBAL_INIT{ sp_loc.sector = 0; }

   // Check for valid file pointer
	if (!file) {
		return -EINVAL;
   }
   if (!newfile || !(*newfile)) {
      return -EPATHSTR;
   }
   if (file->type != FAT_FILE) {
   	return -ETYPE;
   }
   if (file->de.attr & (FATATTR_READ_ONLY | FATATTR_SYSTEM | FATATTR_HIDDEN)) {
   	return -EPERM;
   }

   switch (file->state)
   {
      case FAT_FILESTATE_IDLE:
      	if (sp_loc.sector) {		// See if fat_Split already in use
         	return -EBUSY;
         }
         sp_loc.sector = 1;     // This will block other split calls
      	// Check for EOF code or 'where' beyond EOF
         if (where == FAT_BRK_POS) {
  	      	where = file->pos;
         }
         else {
	         if (where == FAT_BRK_END || where > file->de.fileSize) {
	            where = file->de.fileSize;
            }
            else if (where < 0) {
               where = 0;
            }
	         // Position to end of current file (in use portion)
	         if (rc = _fat_Seek(file, where, SEEK_SET )) {
	            return rc;
            }
         }
         file->state = FAT_FILESTATE_SP_END;

      case FAT_FILESTATE_SP_END:  // Find end of file, check for extra clusters
         *((unsigned long *)&file->loc.nav_offset) = file->loc.cluster;
         if ((rc = _fat_next_clust(file->part, &file->loc.cluster,
         			 	FAT_BLOCK_FLAGS)) == -EBUSY ) {
         	return rc;
         }
         if (rc < 0)
         {              // File access error or -EEOF (No extra clusters)
	         file->loc.cluster = *((unsigned long *)&file->loc.nav_offset);
	         file->state = FAT_FILESTATE_IDLE;
            file->loc.nav_state = 0;  	// Clear states
	         sp_loc.sector = 0;     		// Release lock
         	return rc;
         }
         sp_loc.nav_state = 0;  	  // Initialize navigation state
		   memset(&sp_loc, 0, 12);   // Zero locations for _fat_Navigate
         sp_loc.u_sector = 0;      // while leaving sector field at 1
         file->state = FAT_FILESTATE_SP_TRANS;

   	case FAT_FILESTATE_SP_TRANS: // Start file split by opening transaction
      	// Open a new rollback transaction
         if (rc = fatrj_transtart(file->part->ftc_prt))
         {
         	if (rc == -ETRANSOPEN) {
            	rc = -EBUSY;
            }
            else {
		         sp_loc.sector = 0;     		// Release lock
            }
				return rc;
         }
         file->state = FAT_FILESTATE_SP_VERIFY;

      case FAT_FILESTATE_SP_VERIFY:	  // Verify newfile path and if file exists
      	if ((rc = _fat_navigate( file->part, newfile, &newpath, FAT_FILE,
         						&sp_loc )) < 0)
         {
				// See if not found error (Need to create file)
   	      if ( rc == -ENOENT || rc == -ENFILE )
      	   {
					if ( i = _fat_getname( newpath, sp_loc.dname ) )
               {
               	// Make sure we made it through all directories
			      	if (*(newpath + i) == FAT_SLASH_CH) {
                  	rc = -EPATHSTR;
                     break;
                  }
                  // Newfile is indeed a new file, set next state based
                  //  on if we need another directory cluster to add newfile
                  file->state = (rc == -ENFILE ? FAT_FILESTATE_SP_EXP_DIR :
                  										   FAT_FILESTATE_SP_UPD_FILE );
			         // Save new write date & time to file since it will be closed
						_fat_tm2timestamp( &file->de.wrtDate, &file->de.wrtTime,
                  		(char *)&i );
			         // Save new accessed date to file since it will be closed
         			file->de.lstAccDate = file->de.crtDate;
			      	// Save new length of file if necessary
         			file->de.fileSize = where;
			      	// Set archive flag of file if necessary
         			if (!(file->de.attr & FATATTR_ARCHIVE)) {
         				file->de.attr |= FATATTR_ARCHIVE;
			            file->flag &= ~FAT_MODIFIED;
         			}
			         if (rc = fatrj_setmarker(file->dirent_mark, &file->de)) {
                     break;
                  }
               }
               else {
               	rc = -EPATHSTR;
                  break;
               }
         	}
            else {
            	break;
            }
         }
         else {
	         rc = -EEXIST;	// Newfile exists, cannot split to an existing file
   	      break;
         }

      case FAT_FILESTATE_SP_UPD_FILE: // Update file entry in directory
      case FAT_FILESTATE_SP_EXP_DIR:  // Update file, directory needs expansion
         // Write directory entry changes to file, consider it closed now
	      if (rc = fatrj_unregmarker(file->dirent_mark, FAT_BLOCK_FLAGS)) {
            break;
         }
         if (++file->state == FAT_FILESTATE_SP_ADD_DIR)
         {

   	case FAT_FILESTATE_SP_ADD_DIR:
				// Directory needs additional cluster to create newfile
      		if ((rc = _fat_new_clust( file->part, sp_loc.cluster,
         					&sp_loc.u_cluster, 1)) < 0 )
            {
           		break;
            }
				if ( _fat_clust2sec( file->part, sp_loc.u_cluster,
         						&sp_loc.u_sector ) )
	         {
					rc = -EINVAL;	// this would be fatal and should never happen!
            	break;
				}
	         file->state = FAT_FILESTATE_SP_CLR_DIR;

   	case FAT_FILESTATE_SP_CLR_DIR:
				// Clear the just allocated cluster to all zeroes
		      if (( rc = fatftc_write( file->part->ftc_prt, sp_loc.u_sector,
                    0, FAT_SECSIZE, 0, FAT_BLOCK_FLAGS | FTC_MEMSET |
                                         FTC_NO_PREIMAGE ) ) < 0 )
            {
	   	      break;
            }
         }
      	// Setup directory entry for newfile
         sp_loc.s_cluster = sp_loc.cluster = file->loc.cluster;
         _fat_clust2sec(file->part, sp_loc.cluster, &sp_loc.sector);
         sp_loc.sofs = 0;
         file->de.attr = FATATTR_ARCHIVE;
         file->de.resv = 0;
      	file->de.crtDate = file->de.wrtDate;
         file->de.crtTime = file->de.wrtTime;
         file->de.crtTimeTenth = *((char *)&i);
         file->de.fileSize = 0;
         _fat_Clust2Dir(((char *)&file->de) - 11, sp_loc.s_cluster);
         file->part->clust1 = 0xFFFF;
         file->state = FAT_FILESTATE_SP_MARK1;

      case FAT_FILESTATE_SP_MARK1:   // Lowest 2 bits used by _fat_table_update
      case FAT_FILESTATE_SP_MARK2:   // to track progress on busy condition.
      case FAT_FILESTATE_SP_MARK3:   // This requires four MARK states
      case FAT_FILESTATE_SP_MARK4:   // First state MUST have low 2 bits clear
      	// Mark file's current cluster as last in chain
      	if ((rc = (int)_fat_table_update(file->part,
         		*((unsigned long *)&file->loc.nav_offset), &file->state)) < 0)
         {
  	         break;
         }
         memcpy(&file->loc, &sp_loc, sizeof(sp_loc));
         file->state = FAT_FILESTATE_SP_SAV_NAME;

      case FAT_FILESTATE_SP_SAV_NAME:
      	// Save filename in directory entry for newfile
	      if ((rc = fatftc_write(file->part->ftc_prt, file->loc.u_sector,
         		file->loc.u_sofs,11,paddr(file->loc.dname),FAT_BLOCK_FLAGS))< 0)
         {
  	         break;
         }
         file->state = FAT_FILESTATE_SP_SAV_DIR;

      case FAT_FILESTATE_SP_SAV_DIR:
      	// Save rest of directory entry for newfile
	      if ((rc = fatftc_write(file->part->ftc_prt, file->loc.u_sector,
	        		file->loc.u_sofs + 11, 21,paddr(&file->de),FAT_BLOCK_FLAGS))< 0)
         {
  	         break;
         }
         file->state = FAT_FILESTATE_SP_GET_MRKR;

      case FAT_FILESTATE_SP_GET_MRKR:
      	// Get marker for directory entry size/date fields
         rc = fatrj_regmarker(file->part->dev->ftc_dev, file->loc.u_sector,
               file->loc.u_sofs + offsetof(fat_dirent, attr),
               sizeof(fat_dirent)-offsetof(fat_dirent, attr), FAT_BLOCK_FLAGS);
         if (rc < 0) {
            rc = -EMFILE;	// Too many open files (no marker)
            break;
         }
         // Save marker handle in directory entry and end transaction
         file->dirent_mark = rc;
         fatrj_tranend(file->part->ftc_prt, 0);
         // Save filesize and position to sp_loc before copying
         sp_loc.offset = file->de.fileSize = file->pos = 0L;
         // Setup file as handle to newfile with data from sp_loc
      	memcpy(&file->loc, &sp_loc, sizeof(sp_loc));
         file->de.attr = FATATTR_ARCHIVE;
         file->state = FAT_FILESTATE_IDLE;
         // Clear sp_loc.sector to make available for next split
		   sp_loc.sector = 0;
			rc = 0;
         break;

      case FAT_FILESTATE_SPLIT_ERR:
      	rc = sp_loc.sofs;   // Get error code from sofs
      	break;

   	default:
      	return -EFSTATE;
	}

   // Anything but 0 or -EBUSY means we encountered a problem
   if (rc && (rc != -EBUSY)) {
   	// Do we have a marker handle?
   	if (file->dirent_mark >= 0) {
      	// If so, release it and show no marker associated with file
      	i = fatrj_unregmarker(file->dirent_mark, FAT_BLOCK_FLAGS);
         file->dirent_mark = -1;
         // If problem releasing marker, just exit here
	      if (i) {
         	// reset filestate and show sp_loc struct is available again
            file->state = FAT_FILESTATE_IDLE;
       	   sp_loc.sector = 0;
   	      return rc;
         }
      }
      // Rollback the transaction we opened at the start of the split
      i = fatrj_rollback(file->part->ftc_prt, FAT_BLOCK_FLAGS);
      if (i == -EBUSY) {
         sp_loc.sofs = rc;   // Save error code in sofs
         return -EBUSY;
      }
	   // See if file exists in linked list for this partition.
		for(p = file->part->first, q = NULL; p; q = p, p = p->next) {
			if (p == file) {
				// Remove file from linked list of open files of this partition
			   if (q) {
   	   		q->next = file->next;
            }
			   else {
      			file->part->first = file->next;
            }
            // And clear file structure
				memset( file, 0, sizeof(*file) );
            break;
	      }
      }
     	// reset filestate and show sp_loc struct is available again
      file->state = FAT_FILESTATE_IDLE;
	   sp_loc.sector = 0;
   }
	return rc;
#else
	return -EPERM;
#endif
}


/*** BeginHeader fat_Truncate, _fat_Truncate */
int fat_Truncate( FATfile *, long );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Truncate  fat_Truncate
#else
int _fat_Truncate( FATfile *, long );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Truncate                   		<FAT16.LIB>

SYNTAX:       fat_Truncate( FATfile * file, long where )

DESCRIPTION:
   This function truncates the file at byte position 'where' and
   frees any left over allocated clusters.  File must be of FAT_FILE
   type.

PARAMETER1:   file - handle to the open file to be truncated

PARAMETER2:   where - absolute byte to truncate the file if >= 0
							 if FAT_BRK_END then truncate at EOF (free clusters only)
                      if FAT_BRK_POS then truncate at current file position
              NOTE: If absolute byte is beyond EOF, file truncated at EOF

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

RETURNS:	     0 for Success
              -EIO on device IO error
				  -EINVAL if 'file' has invalid references
				  -EPERM if either file is in use, write protected, hidden,
              			  or system.
				  -ENOENT if 'file' does not exist
              -ETYPE if 'file' is not FAT_FILE type
              -EBUSY if the system is busy.
              -EFSTATE if file in inappropriate state (non-blocking)

SEE ALSO:     fat_Open, fat_DirOpen, fat_Delete, fat_Split
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Truncate( FATfile * file, long where )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Truncate( file, where );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Truncate( FATfile * file, long where )
#else
_fat_debug int fat_Truncate( FATfile * file, long where )
#endif

{
#ifndef FAT16_READONLY
	auto int i, rc;
   auto long sbuf;

   // Check for valid file pointer
	if (!file) {
		return -EINVAL;
   }
   if (file->type != FAT_FILE) {
   	return -ETYPE;
   }
   if (file->de.attr & (FATATTR_READ_ONLY | FATATTR_SYSTEM | FATATTR_HIDDEN)) {
   	return -EPERM;
   }

#ifndef FAT_BLOCK
   // See if partition is active with allocation or other deletion
   if (file->part->opstate) {
   	if (!(file->part->opstate & FAT_PART_DEL) || file->part->active != file)
      	return -EBUSY;	// If not this operation, return busy
   }
   else {
   	file->part->opstate = FAT_PART_DEL;  	// Set deletion flag and
   	file->part->active = file;					//  save pointer to current file
   }
#endif

   switch (file->state)
   {
      case FAT_FILESTATE_IDLE:     // Start here from idle
		case FAT_FILESTATE_SEEK:     // Seek states to accomodate fat_Seek call
		case FAT_FILESTATE_SEEK1:
      	// Check for EOF code or 'where' beyond EOF
         if (where == FAT_BRK_POS) {
  	      	where = file->pos;
         }
         else {
	         if (where == FAT_BRK_END || where > file->de.fileSize) {
	            where = file->de.fileSize;
            }
            else if (where < 0) {
               where = 0;
            }
	         // Position to end of current file (in use portion)
	         if (rc = _fat_Seek(file, where, SEEK_SET )) {
	            return rc;
            }
         }
         file->state = FAT_FILESTATE_TR_NEXT;

      case FAT_FILESTATE_TR_NEXT:
         // Ready for release of allocated but unused clusters if any exist.
			// Put last used cluster in loc.u_cluster for fat_next_clust call.
         file->loc.u_cluster = file->loc.cluster;
			if (rc = _fat_next_clust( file->part, &file->loc.u_cluster,
                                                            FAT_BLOCK_FLAGS ))
         {
           	if (rc == -EEOF) {	// Additional clusters to free?
            	if (where < file->de.fileSize) { // No, check for change in size
			        	file->de.attr |= FATATTR_ARCHIVE;
		   			file->flag |= FAT_MODIFIED;
			         file->de.fileSize = where;
         			rc = fatrj_setmarker(file->dirent_mark, &file->de);
               }
               else {
						rc = 0;
               }
               file->part->opstate = FAT_PART_IDLE;
            }
	        	break;
         }
         // First unused but allocated cluster pointed to by loc.u_cluster
         file->state = FAT_FILESTATE_TR_START;

      case FAT_FILESTATE_TR_START:
      	// Ready to delete, start a roll-back transaction
         if (rc = fatrj_transtart(file->part->ftc_prt)) {
         	if (rc == -ETRANSOPEN) { rc = -EBUSY; }
				break;
         }
         file->state = FAT_FILESTATE_TR_MARK;

      case FAT_FILESTATE_TR_MARK:  // Lowest 2 bits used by _fat_table_update
      case FAT_FILESTATE_TR_MARK1: // to track progress on busy condition.
      case FAT_FILESTATE_TR_MARK2: // This requires four MARK states
      case FAT_FILESTATE_TR_MARK3: // First state MUST have low 2 bits clear
      	// Mark new end of cluster chain
         file->part->clust1 = 0xFFFF;
	      if ((rc = (int)_fat_table_update(file->part, file->loc.cluster,
            		&file->state)) < 0)
         {
#ifndef FAT_BLOCK
         	if (rc != -EBUSY)
#endif
	            fatrj_rollback(file->part->ftc_prt, FTC_WAIT);
  	         break;
         }
         file->state = FAT_FILESTATE_TR_FREE;

      case FAT_FILESTATE_TR_FREE:
      	// Free pre-allocated clusters
      	if (rc = _fat_free_clust(file->part, file->loc.u_cluster))
         {
#ifndef FAT_BLOCK
         	if (rc != -EBUSY)
#endif
					file->state = FAT_FILESTATE_TRUNC_ERR;
  	         break;
         }
         fatrj_tranend(file->part->ftc_prt, 0);
			// Set archive flag of file
        	file->de.attr |= FATATTR_ARCHIVE;
		   file->flag |= FAT_MODIFIED;
         file->de.fileSize = where;
         rc = fatrj_setmarker(file->dirent_mark, &file->de);
         break;

      case FAT_FILESTATE_TRUNC_ERR:
      	rc = (int)file->loc.u_sofs;
         break;

   	default:
      	return -EPERM;
	}

	if ( file->state == FAT_FILESTATE_TRUNC_ERR ) {
  	   if (fatrj_rollback(file->part->ftc_prt, FAT_BLOCK_FLAGS) == -EBUSY) {
	   	file->loc.u_sofs = (unsigned)rc;
      	return -EBUSY;
      }
   }

	if (rc != -EBUSY) {
   	file->loc.cluster = file->loc.s_cluster;
		_fat_clust2sec( file->part, file->loc.cluster, &file->loc.sector );
      file->loc.offset = file->pos = 0;
      file->loc.sofs = 0;
   	file->state = FAT_FILESTATE_IDLE;
   }
	return rc;
#else
	return -EPERM;
#endif
}

/*** BeginHeader fat_Read, fat_xRead, _fat_Read, _fat_xRead */
int fat_Read( FATfile *, char *, int );
int fat_xRead( FATfile *, char __far *, int );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Read  fat_Read
#define _fat_xRead  fat_xRead
#else
int _fat_Read( FATfile *, char *, int );
int _fat_xRead( FATfile *, char __far *, int );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Read                   		<FAT16.LIB>

SYNTAX:       fat_Read( FATfile* file, char *buf, int len )

DESCRIPTION:
   This function reads len characters from the specified file and places
   the characters into string 'buf'. Returns the number of characters
   actually read on success. Characters will be read beginning at the
   current position of the file and the position pointer will be left
   pointing to the next byte to be read. File position can be set by the
   fat_Seek function. If the file contains less the len characters from
   the current position to the EOF, then the transfer will stop at the
   EOF. If already at the EOF, -EEOF is returned. The len parameter must
   be positive, limiting reads to 32767 bytes per call.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for the file being read

PARAMETER2:   buf - pointer to buffer where data is to be placed.
					May be NULL in order to discard data

PARAMETER3:   len - length of data to be read.  If this is zero,
                then the return code will be '1' if not at EOF,
                or '0' if at EOF.

RETURNS:	     Number of bytes read on Success.  May be less than
                the requested amount in non-blocking mode, or
                if EOF was encountered.
              -EEOF stating position for read was at (or beyond)
                end-of-file.
              -EIO on device IO error
				  -EINVAL if file, buf, or len contain invalid values
				  -EPERM if the file is locked
				  -ENOENT if file/directory does not exist
              -EFSTATE if file in inappropriate state (non-blocking)

SEE ALSO:     fat_Open, fat_xRead, fat_Write, fat_xWrite, fat_Seek
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX  // Mutex wrapper
_fat_debug int fat_Read( FATfile* file, char *buf, int len )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_xRead(file, (char __far *) paddr(buf), len);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Read( FATfile* file, char *buf, int len )
#else
_fat_debug int fat_Read( FATfile* file, char *buf, int len )
#endif
{
	return _fat_xRead(file, (char __far *) paddr(buf), len);
}

/* START FUNCTION DESCRIPTION *******************************************
fat_xRead                   		<FAT16.LIB>

SYNTAX:       fat_xRead( FATfile* file, char far *buf, int len )

DESCRIPTION:
   This function reads len characters from the specified file and places
   the characters into string buf. Returns the number of characters
   actually read on success. Characters will be read beginning at the
   current position of the file and the position pointer will be left
   pointing to the next byte to be read. File position can be set by the
   fat_Seek function. If the file contains less the len characters from
   the current position to the EOF, then the transfer will stop at the
   EOF. If already at the EOF, -EEOF is returned. The len parameter must
   be positive, limiting reads to 32767 bytes per call.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for the file being read

PARAMETER2:   buf - pointer to buffer where data is to be placed.
					May be NULL in order to discard data

PARAMETER3:   len - length of data to be read.  If this is zero,
                then the return code will be '1' if not at EOF,
                or '0' if at EOF.

RETURNS:	     Number of bytes read on Success.  May be less than
                the requested amount in non-blocking mode, or
                if EOF was encountered.
              -EEOF stating position for read was at (or beyond)
                end-of-file.
              -EIO on device IO error
				  -EINVAL if file, buf, or len contain invalid values
				  -EPERM if the file is locked
				  -ENOENT if file/directory does not exist
              -EFSTATE if file in inappropriate state (non-blocking)

SEE ALSO:     fat_Open, fat_Read, fat_Write, fat_xWrite, fat_Seek
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX  // Mutex wrapper
_fat_debug int fat_xRead( FATfile* file, char __far *buf, int len )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_xRead(file, buf, len);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_xRead( FATfile* file, char __far *buf, int len )
#else
_fat_debug int fat_xRead( FATfile* file, char __far *buf, int len )
#endif
{
	auto int rd, ltr;
	auto int rc;
   auto long sbuf;
	auto fat_part *part;
   auto int isroot;
   auto word seq;
   auto int before_eof;

	if(file==NULL || len < 0 || file->type != FAT_FILE && file->type != FAT_DIR)
   {
		return -EINVAL;
   }

   if (file->state != FAT_FILESTATE_IDLE) {
   	return -EFSTATE;
   }

   isroot = !file->loc.s_cluster;

   before_eof = file->pos < file->de.fileSize;
   if (!len) {
   	return before_eof;
   }
   if (!before_eof) {
   	return -EEOF;
   }

   if (file->pos >= 7680) {
      rc = 0;
   }

	// retrieve a pointer to the partition
	part = (fat_part *) file->part;

	file->flag |= FAT_ACCESSED;

#ifdef FAT_VERBOSE
	printf( "FAT: FAT_Read() -> entry %ld\r\n", MS_TIMER );
#endif

	// file->loc.sector/soffs contains current sector number and offset,
   //   corresponding to file->pos.
   // loc.cluster/offset contains corresponding cluster number and offset.
   rd = 0;			// Total amount read
	while (len) {
   	// Are we at end of current cluster?
      if (isroot) {
      	// Root directory is treated as one big cluster.
      	if (file->loc.offset >= file->de.fileSize) {
         	return rd;
         }
      }
      else if (file->loc.offset >= part->clustlen) {
			/* If we are at a cluster boundary, there are two possible cases:
				- We are beyond or at EOF and thus have reached EOF
				- We are before EOF and thus must address the next cluster */
			if( file->pos < file->de.fileSize ) {
				/* before EOF */
#ifdef FAT_VERBOSE
				printf( "FAT: FAT_Read() -> _fat_next_clust() %ld\r\n", MS_TIMER );
#endif
				/* get the next cluster */
				if (rc = _fat_next_clust(part, &file->loc.cluster, FAT_BLOCK_FLAGS))
            {
					return (rc == -EBUSY ? rd : rc);	/* io error or busy */
            }
			}
			else {
         	return rd;		// At EOF
         }

			_fat_clust2sec( part, file->loc.cluster, &file->loc.sector );
			file->loc.offset = 0L;
      }

   	ltr = part->byte_sec - file->loc.sofs;		// Max length to read
      if (file->pos + ltr > file->de.fileSize) {
      	ltr = (int)(file->de.fileSize - file->pos);
      }
      if (ltr > len) {
      	ltr = len;
      }
      if (!ltr) {
      	break;		// Can only happen if at EOF
      }

	   // If sequential mode, set MAKE_LRU flag if reading last byte of drive
      // page size
	   seq = file->flag & FAT_SEQUENTIAL &&
	         !((file->loc.sector << 9) + file->loc.sofs + ltr &
               part->dev->byte_page - 1u) ?
	            FAT_BLOCK_FLAGS | FTC_MAKE_LRU :
	            FAT_BLOCK_FLAGS;

      rc = fatftc_read(part->ftc_prt, file->loc.sector, &sbuf, seq);

      if (rc < 0) {
      	return (rc == -EBUSY ? rd : rc);
      }
		if (buf) {
      	_f_memcpy(buf, (char __far *) (sbuf + file->loc.sofs), ltr);
	      buf += ltr;
      }
		file->pos += ltr;
      file->loc.sofs += ltr;
      file->loc.offset += ltr;
      len -= ltr;
      rd += ltr;
      if (file->loc.sofs >= part->byte_sec) {
      	// Reached end of current sector
      	++file->loc.sector;
         file->loc.sofs = 0;
      }
   }

#ifdef FAT_VERBOSE
	printf( "FAT: FAT_Read() -> exit %ld\r\n", MS_TIMER );
#endif

	return rd;
}

/*** BeginHeader fat_Write, fat_xWrite, _fat_Write, _fat_xWrite */
int fat_Write( FATfile *, char *, int );
int fat_xWrite( FATfile *, long, int );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Write  fat_Write
#define _fat_xWrite  fat_xWrite
#else
int _fat_Write( FATfile *, char *, int );
int _fat_xWrite( FATfile *, long, int );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Write                          		<FAT16.LIB>

SYNTAX:       fat_Write( FATfile* file, char *buf, int len )

DESCRIPTION:
	This function will write character into the file specified by the
   file pointer beginning at the current position in the file. Characters
   will be copied from the string pointed to by buf. The len variable
   controls how many characters will be written. This can be more than
   one sector in length and the write function will allocate additional
   sectors if needed. Data will be written into the file starting at the
   current file position regardless of existing data. Overwriting at
   specific points in the file can be accomplished by calling the
	fat_Seek function before calling fat_Write.

   In non-blocking mode, there is a subtle difference between a return
   code of '0' and '-EBUSY'.  In the 0 case, it is permissible to
   abandon the write operation and perform some other operation
   on this (or another) file.  In the -EBUSY case, you will not be
   able to perform any other write operations on this file's partition
   (including create or delete) until the write to this file is
   complete i.e. returns something other than -EBUSY.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for the open file being written

PARAMETER2:   buf - pointer to buffer where data to write is located

PARAMETER3:   len - length of data to write

RETURNS:	     Number of bytes written on Success (may be less than len,
              or zero if non-blocking mode)
              -EIO on device IO error
				  -EINVAL if file, buf, or len contain invalid values
				  -ENOENT if file/directory does not exist
              -ENOSPC if no space left on device to complete the write
              -EFAULT if problem in file (broken cluster chain, etc.)
				  -EPERM if the file is locked or write protected
              -EFSTATE if file in inappropriate state (non-blocking)
              -EBUSY if file needs to be extended (writing beyond
                current EOF position).  In this case, you must call
                back with the same parameters until something other
                than -EBUSY is returned.

SEE ALSO:     fat_Open, fat_Read, fat_xRead, fat_xWrite, fat_Seek
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Write( FATfile* file, char *buf, int len )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Write( file, buf, len );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Write( FATfile* file, char *buf, int len )
#else
_fat_debug int fat_Write( FATfile* file, char *buf, int len )
#endif

{
	return _fat_xWrite(file, buf ? paddr(buf) : 0L, len);
}

/* START FUNCTION DESCRIPTION *******************************************
fat_xWrite                         		<FAT16.LIB>

SYNTAX:       fat_xWrite( FATfile* file, long xbuf, int len )

DESCRIPTION:
	This function will write character into the file specified by the
   file pointer beginning at the current position in the file. Characters
   will be copied from the string pointed to by buf. The len variable
   controls how many characters will be written. This can be more than
   one sector in length and the write function will allocate additional
   sectors if needed. Data will be written into the file starting at the
   current file position regardless of existing data. Overwriting at
   specific points in the file can be accomplished by calling the
	fat_Seek function before calling fat_Write.

   In non-blocking mode, there is a subtle difference between a return
   code of '0' and '-EBUSY'.  In the 0 case, it is permissible to
   abandon the write operation and perform some other operation
   on this (or another) file.  In the -EBUSY case, you will not be
   able to perform any other write operations on this file's partition
   (including create or delete) until the write to this file is
   complete i.e. returns something other than -EBUSY.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for the open file being written

PARAMETER2:   xbuf - xmem address of buffer to be written

PARAMETER3:   len - length of data to write

RETURNS:	     Number of bytes written on Success (may be less than len,
              or zero if non-blocking mode)
              -EIO on device IO error
				  -EINVAL if file, buf, or len contain invalid values
				  -ENOENT if file/directory does not exist
              -ENOSPC if no space left on device to complete the write
              -EFAULT if problem in file (broken cluster chain, etc.)
				  -EPERM if the file is locked or write protected
              -EFSTATE if file in inappropriate state (non-blocking)
              -EBUSY if file needs to be extended (writing beyond
                current EOF position).  In this case, you must call
                back with the same parameters until something other
                than -EBUSY is returned.

SEE ALSO:     fat_Open, fat_Read, fat_xRead, fat_Write, fat_Seek
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_xWrite( FATfile* file, long buf, int len )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_xWrite( file, buf, len );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_xWrite( FATfile* file, long buf, int len )
#else
_fat_debug int fat_xWrite( FATfile* file, long buf, int len )
#endif

{
#ifndef FAT16_READONLY
	auto int ltw;
	auto int wrote;
	auto int rc;
   auto long link, plink;
	auto fat_part *part;

	if( file == NULL || file->type != FAT_FILE || len < 0
			  		|| !file->loc.s_cluster || !buf) {
		return -EINVAL;
   }

   if (file->flag & FAT_READONLY) {
   	return -EPERM;
   }

	// retrive a pointer to the partition
	part = file->part;

   if (len) {
   	file->flag |= FAT_MODIFIED;
   }
   else {
   	return 0;
   }

#ifdef FAT_VERBOSE
	printf( "FAT: FAT_Write() -> entry %ld\r\n", MS_TIMER );
#endif

#ifndef FAT_BLOCK
	if (file->state == FAT_FILESTATE_WRITE) {
   	wrote = file->loc.u_sofs;
      len -= wrote;
      buf += wrote;
      file->state = FAT_FILESTATE_IDLE;
      goto _newclust;
   }
   if (file->state != FAT_FILESTATE_IDLE) {
   	return -EFSTATE;
   }
#endif


	// file->loc.sector/sofs contains current sector number and offset,
   // 	corresponding to file->pos.
   // loc.cluster/offset contains corresponding cluster number and offset.
   wrote = 0;
	while (len) {
   	// Are we at end of current cluster?
      if (file->loc.offset >= part->clustlen) {
			/* At the cluster boundary, try to get the next cluster from chain */
#ifdef FAT_VERBOSE
				printf( "FAT: FAT_Write() -> _fat_next_clust() %ld\r\n", MS_TIMER );
#endif
         rc = _fat_next_clust(part, &file->loc.cluster, FAT_BLOCK_FLAGS);
        	if (rc) {
	         if (rc == -EEOF) {
#ifdef FAT_VERBOSE
		printf( "FAT: FAT_Write() -> _fat_new_cluster() %ld\r\n", MS_TIMER );
#endif
					/* allocate a new cluster */
				_newclust:
					rc = _fat_new_clust(part,file->loc.cluster,&file->loc.cluster,1);
#ifndef FAT_BLOCK
					if (rc == -EBUSY) {
               	// Indicate trying for new cluster
                  file->state = FAT_FILESTATE_WRITE;
                  file->loc.u_sofs = wrote;	// Remember how much we wrote
               	return rc;
               }
#endif
               // newclust opened a transaction for us
               fatrj_tranend(part->ftc_prt, 0);
               // Return if new_clust detected an error
               if (rc < 0) return rc;
				}
            else if (rc == -EBUSY) {
            	return wrote;
            }
   	      else {	// See if pre-allocated space
              	return -EFAULT;	/* Error - broken chain */
            }
         }
			_fat_clust2sec( part, file->loc.cluster, &file->loc.sector );
			file->loc.offset = 0L;
      }

   	ltw = part->byte_sec - file->loc.sofs;		// Max length to write
      if (ltw > len) {
      	ltw = len;
      }
      rc = fatftc_write(part->ftc_prt, file->loc.sector, file->loc.sofs, ltw,
      							buf, FAT_BLOCK_FLAGS);
      if (rc < 0) {
      	return rc == -EBUSY ? wrote : rc;
      }

		file->pos += rc;
      file->loc.sofs += rc;
      file->loc.offset += rc;
      len -= rc;
      wrote += rc;
      buf += rc;
      if (file->loc.sofs >= part->byte_sec) {
      	// Reached end of current sector
      	++file->loc.sector;
         file->loc.sofs = 0;
      }

   }

   // See if file length has changed
	if( file->pos > file->de.fileSize ) {
		file->de.fileSize = file->pos;
      if (fatrj_setmarker(file->dirent_mark, &file->de) < 0) {
   	   return -EFAULT;
      }
   }

#ifdef FAT_VERBOSE
	printf( "FAT: FAT_Write() -> exit %ld\r\n", MS_TIMER );
#endif

	return wrote;
#else
	return -EPERM;
#endif
}

/*** BeginHeader fat_Seek, _fat_Seek */
int fat_Seek(FATfile *, long, int);
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Seek  fat_Seek
#else
int _fat_Seek(FATfile *, long, int);
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Seek                   		<FAT16.LIB>

SYNTAX:       fat_Seek( FATfile* file, long pos, int whence )

DESCRIPTION:
	Positions the internal file position pointer. Seek will allocate
   clusters to the file if necessary, but will not move the position
   pointer beyond the original end of file unless doing a SEEK_RAW.
   In all other cases extending the pointer past the original end of
   file will preallocate the space that would be needed to position the
   pointer as requested, but the pointer will be left at the original
   end of file and the file length will not be changed.  If this occurs,
   an EOF error will be returned to indicate the space was allocated but
   the pointer was left at EOF.

PARAMETER1:   file - handle for the open file

PARAMETER2:   pos - position value in number of bytes (may be negative)

PARAMETER3:   whence: SEEK_SET - pos is absolute byte position to seek
											(where 0 is the first byte of the file)
							 SEEK_END - seek to 'pos' bytes from end of file*
                      SEEK_CUR - seek 'pos' bytes from current position*
                      SEEK_RAW - like SEEK_SET but will add on to the
                                 actual file length if set beyond end of
                                 file. Data added is NOT initialized.

              * Resultant values less than 0 will seek to start of file

     uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

RETURNS:	     0 for Success
              -EIO on device IO error
				  -EINVAL if file, buf, or len contain invalid values
				  -EPERM if the file is locked or write not permitted
				  -ENOENT if file/directory does not exist
              -EEOF if space allocated but pointer left at original EOF
              -ENOSPC if no space left on device to complete the seek
              -EBUSY if the device is busy.  (Only if non-blocking)
              -EFSTATE if file in inappropriate state (non-blocking)

SEE ALSO:     fat_Open, fat_Read, fat_Write, fat_xWrite
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Seek( FATfile* file, long pos, int whence )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Seek(  file, pos, whence );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Seek( FATfile* file, long pos, int whence )
#else
_fat_debug int fat_Seek( FATfile* file, long pos, int whence )
#endif

{
	auto int rc, bdry;
	auto fat_part *part;
   auto long cmask, delc, tweak;

	if( file == NULL || file->type != FAT_FILE ) {
		return -EINVAL;
   }

   // Adjust seek position according to whence parameter.  pos is set to
   //  absolute position.
   switch (whence) {
		case SEEK_SET:
		case SEEK_RAW:
      	break;
      case SEEK_END:
      	pos += file->de.fileSize;
         break;
      case SEEK_CUR:
      	pos += file->pos;
         break;
      default:
      	return -EINVAL;
   }
   if (pos < 0) {
   	pos = 0;		// No seek before start.
   }

	// retrieve a pointer to the partition
	part = (fat_part *) file->part;

	file->flag |= FAT_ACCESSED;

   if (file->state == FAT_FILESTATE_IDLE) {
   	// First time condition

	   if (!file->loc.s_cluster) {
	      // Special processing for root directory seeking.  There is no cluster
	      // chaining, so we treat the root dir as one giant cluster.
	      if (pos > file->de.fileSize) {
	         pos = file->de.fileSize;
         }
	      file->pos = pos;
	      file->loc.offset = pos;
	      _fat_clust2sec(part, 0, &file->loc.sector);
	      file->loc.sector += file->loc.offset >> 9;
	      file->loc.sofs = (word)(file->loc.offset & 0x1FF);
	      return 0;
	   }

   	file->state = FAT_FILESTATE_SEEK;
	   cmask = part->clustlen - 1;
	   bdry = !(pos & cmask);        // Set if moving to cluster boundary
	   cmask = ~cmask;


	   // Delta whole cluster byte count.  Negative if moving towards file start.
	   delc = (pos & cmask) - (file->pos & cmask);

	   if (delc < 0) {
	      // Move backward.  Since the cluster chain is singly linked, this is
	      // inefficient since we have to scan forward from the very start.
	      file->loc.cluster = file->loc.s_cluster;  // Start cluster of file.
         file->loc.offset = 0;                     // Start offset of file.
	      delc = pos & cmask;                       // Non-negative traverse count
	   }

	   // If we are going to move to a cluster boundary, reduce delc and
	   // increase the offset by clustlen to compensate.
	   if (delc && bdry) {
	      delc -= tweak = part->clustlen;
      }
	   else {
	      tweak = 0;
      }

      // If file offset was left at a cluster boundry, add in with delc
      file->loc.u_cluster = delc + (file->loc.offset & cmask);
      file->loc.u_sofs = (word)tweak;

   }
   else if ((file->state & 0xFF00) != FAT_OP_SEEK) {
   	return -EFSTATE;
   }

	switch (file->state) {
   default:
	   while (file->loc.u_cluster) {	// u_cluster contains byte count
	      rc = _fat_next_clust( part, &file->loc.cluster, FAT_BLOCK_FLAGS );
	      if( rc )
	      {
	#ifndef FAT16_READONLY
	         if( rc != -EEOF ) {
	            return rc;
            }
	         file->state = FAT_FILESTATE_SEEK1;
	         /* if we are here we allocate a new cluster. If this fails the drive
	            is full. */
	case FAT_FILESTATE_SEEK1:
	         if( ( rc = _fat_new_clust( part, file->loc.cluster,
	                                 &file->loc.cluster, 1 ) ) < 0 ) {
	            if (rc == -EBUSY)
	               fatrj_tranend(part->ftc_prt, 0);
	            return rc;
	         }
	         fatrj_tranend(part->ftc_prt, 0);
	         file->flag |= FAT_MODIFIED;
	         file->state = FAT_FILESTATE_SEEK;
	#else
	         return (rc == -EEOF ? -EPERM : rc);
	#endif
	      }
	      file->loc.u_cluster -= part->clustlen;
	   }
	}
	// At this point, pos is the absolute position and loc.cluster contains the
   // cluster containing this position.
	file->state = FAT_FILESTATE_IDLE;
   file->pos = pos;
   file->loc.offset = (pos & part->clustlen - 1) + file->loc.u_sofs;
	_fat_clust2sec( part, file->loc.cluster, &file->loc.sector );
   file->loc.sector += file->loc.offset >> 9;
   file->loc.sofs = (word)(file->loc.offset & 0x1FF);

	/* if we were seeking beyond EOF we must check the whence parameter to see
	   whether to adjust current position or length. */
	if( file->pos > file->de.fileSize ) {
   	if (whence == SEEK_RAW) {
			file->de.fileSize = file->pos; // Allow appending of uninitialized data
      }
      else {
      	file->pos = file->de.fileSize;
         return -EEOF;	// Return EOF to show pointer was pulled back to EOF
      }
   }
	return 0;
}


/*** BeginHeader fat_Tell, _fat_Tell */
int fat_Tell( FATfile *, unsigned long * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Tell  fat_Tell
#else
int _fat_Tell( FATfile *, unsigned long * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Tell                   <FAT16.LIB>

SYNTAX:       fat_Tell(FATfile *file, unsigned long *pos)

DESCRIPTION:
   This function gives the current position pointer for the file in
   bytes from the start in 'pos'. Zero indicates at the start.

    uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for an open file
PARAMETER1:   pos - pointer to long int to put the current file pointer
                    position in.

RETURNS:	     0 for Success
              -EINVAL - invalid open file handle
              -EIO - if position beyond EOF

SEE ALSO:     fat_Seek, fat_Read, fat_Write, fat_xWrite
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_Tell( FATfile *file, unsigned long *pos )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Tell( file, pos );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_Tell( FATfile *file, unsigned long *pos )
#else
_fat_debug int fat_Tell( FATfile *file, unsigned long *pos )
#endif
{
   if (!file || !file->part || !file->loc.s_cluster ||
   		!(file->type == FAT_FILE || file->type == FAT_DIR)) {
   	return -EINVAL;
   }

   if (file->pos > file->de.fileSize) {
	   return -EIO;
   }

   *pos = file->pos;
   return 0;
}



/*** BeginHeader fat_Free, _fat_Free */
unsigned int fat_Free( fat_part * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_Free  fat_Free
#else
unsigned int _fat_Free( fat_part * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_Free                            <FAT16.LIB>

SYNTAX:       fat_Free( fat_part *part )

DESCRIPTION:
   This function returns the number of free clusters on the partition.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   part - handle to the partition

RETURNS:	     Number of free clusters
				  Zero if part handle is bad or partition is not mounted.

SEE ALSO:     fat_EnumPartition, fat_MountPartition
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug unsigned int fat_Free( fat_part *part )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_Free( part );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug unsigned int _fat_Free( fat_part *part )
#else
_fat_debug unsigned int fat_Free( fat_part *part )
#endif

{
   if (!part || !(part->mpart->status & MBRP_MOUNTED)) {
   	return 0;
   }

   return (unsigned int)part->freecluster;
}

/*** BeginHeader fat_FileSize, _fat_FileSize */
int fat_FileSize( FATfile *, unsigned long * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_FileSize  fat_FileSize
#else
int _fat_FileSize( FATfile *, unsigned long * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_FileSize                   <FAT16.LIB>

SYNTAX:       fat_FileSize(FATfile *file, unsigned long *length)

DESCRIPTION:
   This function puts the current size of the file in bytes into
   'length'.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle for an open file

PARAMETER2:   length - pointer to unsigned long to receive length value

RETURNS:	     0 for Success
              -EINVAL - invalid open file handle

SEE ALSO:     fat_Open, fat_Seek
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_FileSize( FATfile *file, unsigned long *length )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_FileSize( file, length );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_FileSize( FATfile *file, unsigned long *length )
#else
_fat_debug int fat_FileSize( FATfile *file, unsigned long *length )
#endif

{
   if (!file || !file->part || !file->loc.s_cluster ||
   		!(file->type == FAT_FILE || file->type == FAT_DIR)) {
   	return -EINVAL;
   }

   *length = file->de.fileSize;
   return 0;
}

/*** BeginHeader fat_GetAttr, _fat_GetAttr */
int fat_GetAttr( FATfile *  );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_GetAttr  fat_GetAttr
#else
int _fat_GetAttr( FATfile *  );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_GetAttr                            <FAT16.LIB>

SYNTAX:       fat_GetAttr( FATfile *file )

DESCRIPTION:
   This function gets the given attributes to the file. Use defined
   attribute flags to check the value.

   uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle to the open file

RETURNS:      Attributes on Success
              -EINVAL - invalid open file handle

SEE ALSO:     fat_Open, fat_Status
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_GetAttr( FATfile *file )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_GetAttr( file );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_GetAttr( FATfile *file )
#else
_fat_debug int fat_GetAttr( FATfile *file )
#endif
{
   if (!file || !file->part || !file->loc.s_cluster ||
   		!(file->type == FAT_FILE || file->type == FAT_DIR)) {
   	return -EINVAL;
   }

   return file->de.attr & 0x3F;
}


/*** BeginHeader fat_SetAttr, _fat_SetAttr */
int fat_SetAttr( FATfile *, int );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_SetAttr  fat_SetAttr
#else
int _fat_SetAttr( FATfile *, int );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_SetAttr                            <FAT16.LIB>

SYNTAX:       fat_SetAttr( FATfile *file, int attr )

DESCRIPTION:
   This function sets the given attributes to the file. Use defined
   attribute flags to create the set value.

    uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   file - handle to the open file or directory

PARAMETER2:   attr - attributes to set in file
               (Note: Can't set volume label attribute with this function)

RETURNS:      0 for Success
              -EIO on device IO error
              -EINVAL - invalid open file handle
				  -EPERM if the file is locked or write not permitted
              -EBUSY if the device is busy.  (Only if non-blocking)

SEE ALSO:     fat_Open, fat_Status
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_SetAttr( FATfile *file, int attr )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_SetAttr( file, attr );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_SetAttr( FATfile *file, int attr )
#else
_fat_debug int fat_SetAttr( FATfile *file, int attr )
#endif
{
	auto int rc;

   if (!file || !file->part || !file->loc.s_cluster ||
   		!(file->type == FAT_FILE || file->type == FAT_DIR)) {
   	return -EINVAL;
   }

   rc = 0;
   if (file->flag & (FAT_MODIFIED | FAT_ACCESSED))
   {
   	file->de.attr |= FATATTR_ARCHIVE;  // Don't update attribute on sync
		rc = _fat_SyncFile( file );      // Sync to update dates and length
   }

   if (!rc)
   {
	   file->de.attr = (attr & 0x37);
      file->flag = 0;

		// Update file attributes
	   rc = fatftc_write(file->part->ftc_prt, file->loc.u_sector,
   	  		file->loc.u_sofs + 11, 1, paddr(&file->de.attr), FAT_BLOCK_FLAGS);
      if (rc == 1) {
         rc = 0;     // Successs, copy read only flag to file flag
         if (!(file->part->mpart->status & MBRP_READONLY)) {
            file->flag = (file->flag & ~FAT_READONLY) |
                                ((attr & FATATTR_READ_ONLY) << 3);
         }
      }
	}

   return rc;
}

/*** BeginHeader */
/* START FUNCTION DESCRIPTION *******************************************
fat_IsOpen                           <FAT16.LIB>

SYNTAX:       int fat_IsOpen( FATfile far *file)

DESCRIPTION:
   Returns non-zero if the FATfile passed is open and zero if closed.

   Currently implemented as a macro, but may be modified to be an actual
   function in a future release.

PARAMETER 1:  file - Pointer to a FATfile structure to check.

RETURNS:	     !0 if file is open
					0 if file is closed

SEE ALSO:     fat_ReadDir, fat_Status, fat_LastAccess, fat_LastWrite
*************************************************************************/
#define fat_IsOpen(file) ((file)->state)

/* START FUNCTION DESCRIPTION *******************************************
fat_IsClosed                         <FAT16.LIB>

SYNTAX:       int fat_IsClosed( FATfile far *file)

DESCRIPTION:
   Returns non-zero if the FATfile passed is closed and zero if open.

   Currently implemented as a macro, but may be modified to be an actual
   function in a future release.

PARAMETER 1:  file - Pointer to a FATfile structure to check.

RETURNS:	    !0 if file is closed
              0 if file is open

SEE ALSO:     fat_ReadDir, fat_Status, fat_LastAccess, fat_LastWrite
*************************************************************************/
#define fat_IsClosed(file) (!(file)->state)
/*** EndHeader */

/*** BeginHeader fat_CreateTime, _fat_CreateTime  */
int fat_CreateTime( fat_dirent *, struct tm * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_CreateTime  fat_CreateTime
#else
int _fat_CreateTime( fat_dirent *, struct tm * );
#endif

/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_CreateTime                   <FAT16.LIB>

SYNTAX:       fat_CreateTime( fat_dirent * entry, struct tm *t )

DESCRIPTION:
   This function puts the creation date & time of the entry given
   into the system time structure t.  Does not fill in the tm_wday
   field in the system time structure.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   entry - Pointer to a directory entry

PARAMETER2:   t - Pointer to a system time structure

RETURNS:	     0 for Success
              -EINVAL - invalid entry or time pointer

SEE ALSO:     fat_ReadDir, fat_Status, fat_LastAccess, fat_LastWrite
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_CreateTime( fat_dirent * entry, struct tm *t )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_CreateTime(entry, t);
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_CreateTime( fat_dirent * entry, struct tm *t )
#else
_fat_debug int fat_CreateTime( fat_dirent * entry, struct tm *t )
#endif

{
	if (!entry || !t) {
   	return -EINVAL;
   }

   _fat_timestamp2tm( t, entry->crtDate, entry->crtTime, entry->crtTimeTenth );
	return 0;
}


/*** BeginHeader fat_LastAccess, _fat_LastAccess */
int fat_LastAccess( fat_dirent *, struct tm * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_LastAccess  fat_LastAccess
#else
int _fat_LastAccess( fat_dirent *, struct tm * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_LastAccess                   <FAT16.LIB>

SYNTAX:       fat_LastAccess( fat_dirent * entry, struct tm *t )

DESCRIPTION:
   This function puts the last access date of the entry given into
   the system time structure t.  The time is always set to midnight.
   Does not fill in the tm_wday field in the system time structure.

uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   entry - Pointer to a directory entry

PARAMETER2:   t - Pointer to a system time structure

RETURNS:	     0 for Success
              -EINVAL - invalid entry or time pointer

SEE ALSO:     fat_ReadDir, fat_Status, fat_CreateTime, fat_LastWrite
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_LastAccess( fat_dirent * entry, struct tm *t )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_LastAccess( entry, t );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_LastAccess( fat_dirent * entry, struct tm *t )
#else
_fat_debug int fat_LastAccess( fat_dirent * entry, struct tm *t )
#endif

{
	if (!entry || !t) {
   	return -EINVAL;
   }

   _fat_timestamp2tm( t, entry->lstAccDate, 0, 0 );
	return 0;
}

/*** BeginHeader fat_LastWrite, _fat_LastWrite */
int fat_LastWrite( fat_dirent *, struct tm * );
#ifndef FAT_USE_UCOS_MUTEX
#define _fat_LastWrite  fat_LastWrite
#else
int _fat_LastWrite( fat_dirent *, struct tm * );
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION *******************************************
fat_LastWrite                   <FAT16.LIB>

SYNTAX:       fat_LastWrite( fat_dirent * entry, struct tm *t )

DESCRIPTION:
   This function puts the last write date & time of the entry given
   into the system time structure t.  Does not fill in the tm_wday
   field in the system time structure.

  uC/OS-II USERS:
       * The FAT API is not reentrant from multiple tasks. If you wish to
         use the FAT from multiple uC/COS tasks,  #define FAT_USE_UCOS_MUTEX.
       * Mutex timeouts or other mutex errors will cause a run-time
         error - ERR_FAT_MUTEX_ERROR. The default mutex timeout is 5 seconds
         and can be changed by #define'ing a different value
         for FAT_MUTEX_TIMEOUT_SEC
       * You MUST call fat_InitUCOSMutex after calling OSInit() and before
         calling FAT API functions
       * You must run the FAT in blocking mode (#define FAT_BLOCK)
       * You must not call low-level, non-API FAT or write-through cache
         functions. Only call FAT functions appended with 'fat_' and
         with public function descriptions.

PARAMETER1:   entry - Pointer to a directory entry

PARAMETER2:   t - Pointer to a system time structure

RETURNS:	     0 for Success
              -EINVAL - invalid entry or time pointer

SEE ALSO:     fat_ReadDir, fat_Status, fat_CreateTime, fat_LastAccess
*************************************************************************/
#ifdef FAT_USE_UCOS_MUTEX
_fat_debug int fat_LastWrite( fat_dirent * entry, struct tm *t )
{
    auto int rc;

    _fat_ucos_mutex_pend();  // Wait for semaphore
    rc = _fat_LastWrite( entry, t );
    _fat_ucos_mutex_post();  // Signal for semaphore
    return rc;
}

_fat_debug int _fat_LastWrite( fat_dirent * entry, struct tm *t )
#else
_fat_debug int fat_LastWrite( fat_dirent * entry, struct tm *t )
#endif

{
	if (!entry || !t) {
   	return -EINVAL;
   }

   _fat_timestamp2tm( t, entry->wrtDate, entry->wrtTime, 0 );
	return 0;
}

/*** BeginHeader fat_UnsupportedPartition */
int fat_UnsupportedPartition(int device);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fat_UnsupportedPartition           <FAT16.LIB>

SYNTAX:		 int fat_UnsupportedPartition(int device)

DESCRIPTION: Scans the given device for any unsupported FAT partitions
             and returns a type code for the first one found.
             The fat_AutoMount function should be run before calling.

PARAMETER1:   device - Device number of the FAT device to scan

RETURNS:	     0 if no unsupported FAT partitions were found.
              FAT_TYPE_12 - if a FAT12 partition was found.
              FAT_TYPE_16 - if a FAT16 partition was found while FAT16
                             support is disabled.
              FAT_TYPE_32 - if a FAT32 partition was found.
              -EINVAL     - invalid device number

SEE ALSO:     fat_AutoMount
*************************************************************************/
int fat_UnsupportedPartition(int device)
{
   auto int i, j;
   auto mbr_dev *dev;

   if (device >= num_fat_devices) {
      return -EINVAL;
   }

   for (i = 0; i < FAT_MAX_PARTITIONS; i++) {
      if (j = _fat_device_table[device].part[i].parttype) {
#ifndef FAT_FAT12
			if (j == 1) {
            return FAT_TYPE_12;
         }
#endif
#ifndef FAT_FAT16
			if (j == 4 || j == 6 || j == 14) {
            return FAT_TYPE_16;
         }
#endif
			if (j == 11 || j == 12) {
            return FAT_TYPE_32;
         }
      }
	}
   return 0;
}


/*** BeginHeader fat_InitUCOSMutex */
void fat_InitUCOSMutex(int mutexPriority);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fat_InitUCOSMutex             <FAT16.LIB>

SYNTAX:
   void fat_InitUCOSMutex(int mutexPriority);

DESCRIPTION:
   The FAT API is not reentrant from multiple tasks. If FAT is used in
   multiple uC/OS-II tasks, the following rules must be adhered to:

      1) #define FAT_USE_UCOS_MUTEX // before #use FAT16.LIB

      2) Call fat_InitUCOSMutex(mutexPriority) AFTER calling OSInit(), and
         BEFORE starting any tasks that use FAT. The mutexPriority
         parameter is a uC/OS-II task priority that MUST be higher than
         the priorities of all tasks that call FAT API functions.

      3) The application MUST NOT call low level (FAT or cache) functions
         while multi-tasking.

      4) The application is free to call regular FAT API functions BEFORE
         starting multitasking.

   A single mutex will ensure that only one FAT API runs at a time. Mutex
   timeouts or other errors will cause a run-time error,
      ERR_FAT_MUTEX_ERROR.

   uC/OS-II may raise the priority of tasks using mutexes to prevent
   priority inversion.

   The default mutex time-out in seconds is given by
      FAT_MUTEX_TIMEOUT_SEC
   which defaults to 5 seconds if not defined by the application before
   #use'ing the FAT library.

PARAMETER1:
   A uC/OS-II task priority that MUST be higher than the priorities of all
   tasks that call FAT API functions.

RETURN VALUE:
   None.
*************************************************************************/
_fat_debug
void  fat_InitUCOSMutex(int mutexPriority)
{
   auto char rc;

   fat_Mutex = OSMutexCreate(mutexPriority, &rc);

   if ((fat_Mutex == NULL) || (rc != OS_NO_ERR))
   {
      exception(ERR_FAT_MUTEX_ERROR);
      exit(ERR_FAT_MUTEX_ERROR);
   }
}

/*** BeginHeader _fat_ucos_mutex_pend, _fat_ucos_mutex_post */
void _fat_ucos_mutex_pend(void);
void _fat_ucos_mutex_post(void);
/*** EndHeader */

/**************************************************************
  These are the epilogue and prologue functions needed for
  all high-level FAT API functions when using uC/OS-II
**************************************************************/
_fat_debug
void _fat_ucos_mutex_pend(void)
{
   auto char rc;

   if (OSRunning)
   {
      // Wait for semaphore
      OSMutexPend((OS_EVENT*) fat_Mutex, FAT_MUTEX_TIMEOUT, &rc);
      if (rc != OS_NO_ERR)
      {
#ifdef FAT_VERBOSE
         printf("FAT: Mutex Pend error.\r\n");
#endif
         exception(ERR_FAT_MUTEX_ERROR);   // Mutex errors are fatal
         exit(ERR_FAT_MUTEX_ERROR);
      }
   }
}

_fat_debug
void _fat_ucos_mutex_post(void)
{
   if (OSRunning &&
       // Signal semaphore free
       OSMutexPost((OS_EVENT*) fat_Mutex) != OS_NO_ERR)
   {
#ifdef FAT_VERBOSE
      printf("FAT: Mutex Post error.\r\n");
#endif
      exception(ERR_FAT_MUTEX_ERROR);
      exit(ERR_FAT_MUTEX_ERROR);
   }
}

/*** BeginHeader */
#endif
/*** EndHeader */