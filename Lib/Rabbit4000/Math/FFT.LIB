/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *
FFT.LIB
DESCRIPTION: FFT routines
SUPPORT LIBRARIES: none
END DESCRIPTION **************************************************/

/*** BeginHeader fftcplx, fftcplxinv */

     void fftcplx   ( int *x, int n, int *blockexp );
     void fftcplxinv( int *x, int n, int *blockexp );

/*** EndHeader   fftcplx, fftcplxinv */

/* START FUNCTION DESCRIPTION *************************************
fftcplx         <FFT.LIB>

       SYNTAX:  void fftcplx( int *x, int N, int *blockexp )

  DESCRIPTION:  compute the complex DFT of the complex sequence
                in array x.

   PARAMETERS:         *x   pointer to complex sequence to be transformed
                        n   number of complex points, must be power of two
                *blockexp   pointer to integer block exponent

 RETURN VALUE:  complex DFT replaces complex sequence in array x.

                blockexp is increased by one each time array x is scaled
                to avoid arithmetic overflow.

    KEY WORDS:  DFT transform

END DESCRIPTION **************************************************/

__nodebug
void
fftcplx( int *x, int n, int *blockexp ) {

    fftcomplex( x, n, blockexp, 0 );    // 0 => forward DFT

}

/* START FUNCTION DESCRIPTION *************************************
fftcplxinv      <FFT.LIB>

       SYNTAX:  void fftcplxinv( int *x, int n, int *blockexp )

  DESCRIPTION:  Compute inverse DFT of complex spectrum in array x

   PARAMETERS:         *x   pointer to complex spectrum to be tranformed
                        n   number of complex points
                *blockexp   pointer to integer block exponent

 RETURN VALUE:  Complex sequence replaces the complex spectrum in array x.

                blockexp is incremented by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by log2(n) to reflect 1/n factor in the
                definition of the IDFT.


    KEY WORDS:  IDFT IFFT IFT transform

END DESCRIPTION **************************************************/

__nodebug
void
fftcplxinv( int *x, int n, int *blockexp ) {

    fftcomplex( x, n, blockexp, 1 );    // 1 => inverse FFT

}

// end of fftcplx, fftcplxinv

/*** BeginHeader fftreal, fftrealinv */

     void fftreal   ( int *x, int n, int *blockexp );
     void fftrealinv( int *x, int n, int *blockexp );

/*** EndHeader   fftreal, fftrealinv */

__root void unfold( int *x, int Npts, int *blockexp, int dir );

/* START FUNCTION DESCRIPTION *************************************
fftreal         <FFT.LIB>

       SYNTAX:  void fftreal( int *x, int n, int *blockexp )

  DESCRIPTION:  compute the positive-frequency complex DFT of the
                real sequence in array x.

   PARAMETERS:         *x   pointer to 2n-point real sequence
                        n   number of complex points in result,
                            must be power of two
                *blockexp   pointer to integer block exponent

 RETURN VALUE:  Complex spectrum replaces complex sequence in array x.

                blockexp is incremented by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by one (by function unfold) to account
                for not dividing by two when calculating even and
                odd parts.

    KEY WORDS:  DFT transform

END DESCRIPTION **************************************************/

__nodebug
void
fftreal( int *x, int n, int *blockexp ) {

    fftcomplex( x, n, blockexp, 0 );    // 0 => forward DFT
    unfold    ( x, n, blockexp, 0 );

}

/* START FUNCTION DESCRIPTION *************************************
fftrealinv      <FFT.LIB>

       SYNTAX:  void fftrealinv( int *x, int n, int *blockexp )

  DESCRIPTION:  Compute inverse DFT of positive-frequency complex
                spectrum in array x

   PARAMETERS:         *x   pointer to positive-frequency complex
                            spectrum to be tranformed
                        n   number of complex points
                *blockexp   pointer to integer block exponent

 RETURN VALUE:  2n-point real sequence replaces n-point complex spectrum
                in array x.

                blockexp is increased by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by one (by function unfold) to account
                for not dividing by two when calculating even and
                odd parts.  Finally, blockexp is diminished by log2(n)
                to reflect 1/n factor in the definition of the IDFT.

    KEY WORDS:  IDFT IFFT IFT transform

END DESCRIPTION **************************************************/

__nodebug
void
fftrealinv( int *x, int n, int *blockexp ) {

    unfold    ( x, n, blockexp, 1 );    // 1 => inverse DFT
    fftcomplex( x, n, blockexp, 1 );

}

/* START _FUNCTION DESCRIPTION *************************************
unfold          <FFT.LIB>

       SYNTAX:  void unfold( int *x, int Npts, int *blockexp, int dir )

  DESCRIPTION:  compute the complex DFT of the complex sequence
                in array x.

   PARAMETERS:         *x   pointer to complex sequence to be transformed
                     Npts   number of complex points, must be power of two
                *blockexp   pointer to integer block exponent
                      dir   integer flag, non-zero => inverse unfold

 RETURN VALUE:  complex DFT replaces complex sequence in array x.

                blockexp is incremented by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by one to account for not dividing by two
                when calculating even and odd parts.

    KEY WORDS:  DFT real transform

END DESCRIPTION **************************************************/

__nodebug
__root __nouseix
void
unfold( int *x, int Npts, int *blockexp, int dir ) {

// The input is an array x of Npts complex elements.  In the forward-transform
// direction array x contains the DFT of the complex sequence g(n) + jh(n)
// formed by contsructing from the 2*Npts real values x[n], n = 0, 1, ..., 2N - 1,
// the two sequences
//
//      g(n) = x[  2n  ], n = 0, 1, ..., Npts
//      h(n) = x[2n + 1], n = 0, 1, ..., Npts
//
// That is, the even-numbered elements constitute g(n), and the odd-numbered
// elements constitute h(n).
//
// In the reverse-transform direction, the array x contains the first Npts
// complex elements of a 2*Npts-element DFT of a 2*Npts real sequence.  In both
// cases the imaginary part of the zero-frequency term contains real part of
// the "fmax" term x[N].  (The imaginary part of the fmax term is
// always zero and need not be stored.)

// The numerical results in x contain an extra factor of two as a result of
// skipping a division by two when calculating even and odd parts.  blockexp is
// diminished by one to reflect the extra factor of two.

// Note that blockexp is always diminished by one to reflect not dividing by
// two when calculating even and odd parts.

    auto saveix;
    auto int ER, OI;
    auto int *cosptr, *sinptr, cursin, curcos, sinstep;

#define PIBY2BINDEX     2 * INTSPERQUAD
#define PIBINDEX        4 * INTSPERQUAD
// no parentheses lest assembler misinterpret them

#asm
; bookunfold

    ld (sp+@sp+saveix),ix       ; save ix

;   sinptr = sinetable;         ; int pointer to first entry (zero radians)

    ld hl,sinetable             ; address of sine(0)
    ld (sp+@sp+sinptr),hl       ; into working variable

;   cosptr = sinetable + INTSPERQUAD;
                                ; int pointer to last entry (pi/2)
                                ; know that cos(x) = sin(pi/2 - x)

    ld de,PIBY2BINDEX           ; address of sine[0] added to
    add hl,de                   ; byte count to pi/2
    ld (sp+@sp+cosptr),hl       ; equals address of cos(0)

;   sinstep = (PIBINDEX)/Npts;  ; step size in bytes to subsequent entries.
                                ; We process two complex elements at each step
                                ; (x[k] and x[N-k]).  To advance from one pair
                                ; to the next we step through the sine table
                                ; Npts/2 times from 0 to pi/2, and each step
                                ; will be (pi/2)/(Npts/2) or pi/Npts.  Since
                                ; sinestep cannot be smaller than two bytes,
                                ; Npts must be less than or equal to the
                                ; number of sine-table entries between zero
                                ; and pi.

    ld de,PIBINDEX          ; PIBINDEX is power of two
    ld hl,(sp+@sp+Npts)     ; Npts also power of two
    ex de,hl
    scf                     ; want carry set
    sbc hl,de               ; PIBINDEX - Npts positive means PIBINDEX >= 2*Npts
    jp p,.nptsokay
c   exception ( -ERR_RANGE );   // Npts too small
c	 exit( -ERR_RANGE );
.nptsokay:

    or a                    ; clear possible carry from sbc above
    ld hl,PIBINDEX          ; recover PIBINDEX
.unfloop:
    rr hl                   ; carry will remain zero here
    rr de                   ; and here
    jr nz,.unfloop           ; keep shifting until Npts divided down to 0

; At this point de has been shifted one time too many and de contains step/2.
; Undo the extra shift and save the result.

    add hl,hl               ; 2*(step/2) = step
    ld (sp+@sp+sinstep),hl

; Bear in mind that the input to the unfold function (in the forward case)
; contains the combined DFTs of the even components and of the odd components
; of the original sequence x[k], 0 <= k < 2N.

; First take care of two two special cases, the real part of the DFT output
; X[0] term (the dc value) and the real part of the DFT output X[N] term, the
; so-called "fmax" term.  The imaginary parts of both of these DFT outpus terms
; are zero because the imaginary part of the DFT of a real sequence is
; antisymmetric.  Since the imaginary part of the X[0] term is zero, the real
; non-zero real part of the X[N] term can be strore there (and is expected to
; be found there for an inverse unfold).

; For a forward unfold the X[0] and X[N] terms are calculated from the general
; expressions
;
;       Re{Out[ k ]} =  er - or*sin(pi*k/N) + ei*cos(pi*k/N)
;       Re{Out[N-k]} =  er + or*sin(pi*k/N) - ei*cos(pi*k/N)
;       Im{Out[ k ]} =  oi - ei*sin(pi*k/N) - or*cos(pi*k/N)
;       Im{Out[N-k]} = -oi - ei*sin(pi*k/N) - or*cos(pi*k/N)
;
;       when k = 0.  Since cos(0) = 1 and sin(0) = 0, we have
;
;       Re{Out[0]}   =  er + ei   Im{Out[0]} = 0
;       Re{Out[N]}   =  er - ei   Im{Out[N]} = 0
;
; Since
;       er = rx[0] + rx[N]
;       ei = ix[0] + ix[N]
;
; and since x[0] = x[N] by the periodicity of the DFT,
;
;       er = rx[0] + rx[0] = 2*rx[0]
;       ei = ix[0] + ix[0] = 2*ix[0]
;
; so that
;
;       Re{Out[0]} =  er + ei = 2*( rx[0] + ix[0] ), stored in rx[0]
;       Re{Out[N]} =  er - ei = 2*( rx[0] - ix[0] ), stored in ix[0]
;
; For an inverse unfold the two special cases are calculated from the general
; expressions
;
;       Re{Out[ k ]} =  er - or*sin(pi*k/N) - ei*cos(pi*k/N)
;       Re{Out[N-k]} =  er + or*sin(pi*k/N) + ei*cos(pi*k/N)
;       Im{Out[ k ]} =  oi - ei*sin(pi*k/N) + or*cos(pi*k/N)
;       Im{Out[N-k]} = -oi - ei*sin(pi*k/N) + or*cos(pi*k/N)
;
;       when k = 0, so that
;
;       Re{Out[0]} = er - ei     Im{Out[0]} =  oi + or
;       Re{Out[N]} = er + ei     Im{Out[N]} = -oi + or
;
; The imaginary parts of the n = 0 and n = N terms are identically zero since
; the input is assumed to be the DFT of a real sequence.
; Therefore ei = oi = 0, and
;
;       Re{Out[0]} = er          Im{Out[0]} = or
;       Re{Out[N]} = er          Im{Out[N]} = or
;
; Moreover, since the real part of the n = N term is assumed to be stored in
; the (otherwise zero) imaginary position of the n = 0 term, we have
;
;       Re{Out[0]} = er = rx[0] + rx[N] = rx[0] + ix[0], stored in rx[0]
;       Im{Out[0]} = or = rx[0] = rx[N] = rx[0] - ix[0], stored in ix[0]
;
; Except for a factor of two, these expressions for rx[0] and ix[0] are
; identical to those in the forward unfold case.

; N. B. The following code places the real part of the X[N] in the (otherwise
; zero) imaginary position of X[0] during a "forward" unfold and expects to
; find the real part of X[N] in the imaginary position of X[0] during an
; "inverse" unfold (a "fold"?).

    ld hl,(sp+@sp+dir)      ; get direction flag into reg a for ready access
    bool hl                 ; dir  = 0 > forward DFT
    ld a,l                  ; dir != 0 > inverse DFT

    ld iy,(sp+@sp+x)        ; iy has memory address of first complex element
    ld hl,(iy)              ; real part of the X[0] term
    ex de,hl
    ld hl,(iy + 2)          ; imaginary part of the X[0] term
    ld b,h
    ld c,l

;  ix[0] rx[0] ix[0]
;    -     -     -

    or a                    ; clear carry
    adc hl,de               ; rx[0] + ix[0]
    jp novf,.unfovf1
    call .fixovr
.unfovf1:
    or a                    ; clear carry and check direction flag
    jr nz,.unfovf2           ; nz means inverse unfold, skip the 2* factor
    adc hl,hl               ; 2*( rx[0] + ix[0] ) for forward unfold
    jp novf,.unfovf2
    call .fixovr
.unfovf2:
    ld (iy),hl              ; store in rx[0]

;  -  rx[0] ix[0]
;  -    -     -

    ex de,hl
    or a
    sbc hl,bc               ; rx[0] - ix[0]
    jp novf,.unfovf3
    call .fixovr
.unfovf3:
    or a                    ; clear carry and check direction flag
    jr nz,.unfovf4            ; nz means inverse unfold, skip 2* factor
    adc hl,hl               ; 2*( rx[0] - ix[0] ) for forward unfold
    jp novf,.unfovf4
    call .fixovr
.unfovf4:
    ld (iy + 2),hl          ; store in ix[0]

; Now unfold the remaining terms.  We need to set ix to the memory address of
; the last entry in the array.  The array has Npts complex elements, so the
; index of its last complex element is Npts - 1.  Since iy already contains the
; address of the first element in the array, the address last element is
; 4*(Npts - 1) bytes beyond iy.  Multiply (Npts - 1) by 4 and add to iy to get
; the address of the last element.

    ld hl,(sp+@sp+Npts)     ; Npts complex elements
    dec hl                  ; Npts - 1
    add hl,hl               ; 2*(Npts - 1)
    add hl,hl               ; 4*(Npts - 1)
    ex de,hl                ; free hl to load the address in iy
    ld hl,iy                ;
    add hl,de               ; hl gets iy + 4*(Npts - 1)
    ld ix,hl                ; which is the address of the last element

    ld de,4                 ; now bump iy to point to the
    add iy,de               ; second complex array element

; Start witht the following abbreviations.
;
;     o   kth complex element of the odd  part of the complex sequence x
;     e   kth complex element of the even part of the complex sequence x
;     r   twice the   real    part of a complex number
;     i   twice the imaginary part of a complex number
;
; so that the abbreviation "er" means twice the even part of the kth
; complex element of the real part of the sequence x.
;
; There is the question of how to handle a factor of two that arises from not
; dividing the sum and differences when calculating the even and odd parts.
;
; For (k = 1; k < N/2; k++) calculate in place pairs of complex output values
; from pairs of complex input values (shown initially for the forward direction.
;
;       Re{Out( k )} =  er + ei*cos(pi*k/N) - or*sin(pi*k/N)
;       Re{Out[N-K]} =  er - ei*cos(pi*k/N) + or*sin(pi*k/N)
;       Im{Out( k )} =  oi - ei*sin(pi*k/N) - or*cos(pi*k/N)
;       Im{Out[N-k]} = -oi - ei*sin(pi*k/N) - or*cos(pi*k/N)
;
; First calculate
;
;       rr = - or*sin(pi*k/N) (+,-) ei*cos(pi*k/N)
;       ii =   ei*sin(pi*k/N) (+,-) or*cos(pi*k/N)
;               where a forward DFT uses the first  sign of the sign pairs
;                and an inverse DFT uses the second sign of the sign pairs
;
; so that
;
;       Re{Out( k )} =  er + rr
;       Re{Out[N-K]} =  er - rr
;       Im{Out( k )} =  oi - ii
;       Im{Out[N-k]} = -oi - ii
;
; k = N/2 is treated as a special case since its angle is pi/2 and since k and
; N-k are the same point.

.UNFOLDLOOP:                 ; (v) top of the loop

; step sine and cosine

    ld hl,(sp+@sp+sinstep)
    ex de,hl
    ld hl,(sp+@sp+sinptr)
    add hl,de               ; next sine pointer
    ld (sp+@sp+sinptr),hl
    ld hl,(hl)              ; next sine value
    ld (sp+@sp+cursin),hl

    ld hl,(sp+@sp+cosptr)
    or a
    sbc hl,de               ; next cosine pointer
    ld (sp+@sp+cosptr),hl
    ld hl,(hl)              ; next cosine value
    ld (sp+@sp+curcos),hl

; sine and cosine done

; form  er = rx[k] + rx[N-k]        saved in temporary location ER
;       oi = ix[k] - ix[N-k]        saved in temporary location OI
;       or = rx[k] - rx[N-k]
;       ei = ix[k] + ix[N-k]

; calculate the even and odd parts of x[k] and x[N-k]
; first of the real parts

;       er = rx[k] + rx[N-k]
;       or = rx[k] - rx[N-k]

    ld hl,(iy)              ; rx[k]
    ld b,h                  ; bc gets rx[k]
    ld c,l
    ld hl,(ix)              ; rx[N-k]
    ld d,h
    ld e,l

;  rx[N-k] rx[N-k] rx[k]
;     -       -      -

    or a                    ; clear carry for adc
    adc hl,bc               ; calculate er

;  er  rx[N-k]  rx[k]
;   -     -       -

    jp novf,.unfovf5
    call .fixovr
.unfovf5:
    ld (sp+@sp+ER),hl       ; save er for later
    ld h,b
    ld l,c

;  rx[k] rx[N-k]  -
;    -      -     -

    or a
    sbc hl,de

;  or  -  -
;   -  -  -

    jp novf,.unfovf6
    call .fixovr
.unfovf6:
    ex de',hl               ; x in de'

;  -   -   -
;  -  or   -

; Now do the imaginary parts of X[k] and X[N-k]
;
;       oi = ix[k] - ix[N-k]
;       ei = ix[k] + ix[N-k]

    ld hl,(ix+2)            ; ix[N-k]
    ld b,h
    ld c,l
    ld hl,(iy+2)            ; ix[k]
    ld d,h
    ld e,l

;  ix[k] ix[k] ix[N-k]
;    -     or    -

    or a
    sbc hl,bc               ; calculate oi

;  oi ix[k] ix[N-k]
;   -   or     -

    jp novf,.unfovf7
    call .fixovr
.unfovf7:
    ld (sp+@sp+OI),hl      ; save oi for later
    ex de,hl

;  ix[k]  -  ix[N-k]
;    -   or     -

    or a
    adc hl,bc               ; ei

;  ei   -   -
;   -  or   -

    jp novf,.unfovf8
    call .fixovr
.unfovf8:
    ex de,hl               ; ei in de
    exx

;  -  or   -
;  -  ei   -

; complex multiply  (or + ei)*(cos + sin)

    ld hl,(sp+@sp+curcos)   ; get cosine
    ld b,h
    ld c,l
    ld bc',bc

;  -  or  cos
;  -  ei  cos

    mul                     ; hl:bc = de*bc
    rl b
    adc hl,hl

;  orcos  or   -
;    -    ei  cos

    exx

;    -    ei  cos
;  orcos  or   -

    mul
    rl b
    adc hl,hl

;  eicos  ei  -
;  orcos  or  -

    ld b,h
    ld c,l
    ld bc',bc

;    -    ei    -
;  orcos  or  eicos

    ld hl,(sp+@sp+cursin)       ; get sine
    ex de,hl
    ld b,h
    ld c,l

;   -   sin    ei
; orcos  or  eicos

    mul
    rl b
    adc hl,hl

;  iesin  sin    -
;  orcos   or  eicos

    ex de',hl
    ld b,h
    ld c,l

;    -     sin     or
;  orcos  eisin  eicos

    mul
    rl b
    adc hl,hl

;  orsin    -      -
;  orcos  eisin  eicos

; end of complex multiply

; Now form the rr and ii terms according to whether we're doing forward or
; inverse DFT
;
;   rr = - orsin (+,-) eicos    use positive for forward transform
;   ii =   eisin (+,-) orcos    use positive for forward transform

    bit 0,a                 ; if a(0) is 1, doing inverse transform
    jr nz,.invtran           ; (v)

; forward transform.  first form ii = orcos + eisin

    exx

;  orcos  eisin  eicos
;  orsin    -      -

    or a
    adc hl,de               ; ii = orcos + eisin
    jp novf,.unfovf9
    call .fixovr
.unfovf9:

;  ii    -  eicos
; orsin  -    -

; now form  rr = eicos - orsin

    ld de',bc
    exx
    ex de,hl

;  eicos  orsin  -
;   ii      -    -

    or a
    sbc hl,de               ; rr = eicos - orsin
    jp novf,.unfovf10
    call .fixovr
.unfovf10:

;  rr  -  -
;  ii  -  -

    jr .combine              ; (v)

.invtran:                    ; (^)

;   rr = - orsin (+,-) eicos    use negative for inverse transform
;   ii =   eisin (+,-) orcos    use negative for inverse transform

; inverse transform.  first form ii = eisin - orcos

;  orsin    -      -
;  orcos  eisin  eicos

    exx
    ex de,hl

;  eisin  orcos  eicos
;  orsin    -      -

    or a
    sbc hl,de               ; ii = eisin - orcos
    jp novf,.unfovf11
    call .fixovr
.unfovf11:

; now form rr = - orsin - eicos

;  ii     -   eicos
; orsin   -     -

    ld bc',bc
    exx
    ex de,hl

;   -  orsin  eicos
;  ii    -      -

    bool hl                 ; hl zero, carry zero
    ld l,h
    sbc hl,de               ; - orsin

    or a
    sbc hl,bc               ; rr = - orsin - eicos
    jp novf,.unfovf12
    call .fixovr
.unfovf12:

.combine:                    ; (^)

;  form fr[ k ] =   er + rr
;       fr[N-k] =   er - rr
;       fi[ k ] =   oi - ii
;       fi[N-k] = - oi - ii

;  rr  -  -
;  ii  -  -

    ld b,h                  ; rr to bc
    ld c,l
    ld hl,(sp+@sp+ER)       ; the saved er value
    ld d,h
    ld e,l

;  er  er  rr
;  ii   -   -

   or a
   adc hl,bc                ; er + rr
   jp novf,.unfovf13
   call .fixovr
.unfovf13:

   ld (iy),hl               ; rx[k] = er + rr
   ex de,hl

;  er  -  rr
;  ii  -   -

    or a
    sbc hl,bc               ; er - rr
    jp novf,.unfovf14
    call .fixovr
.unfovf14:
    ld (ix),hl              ; rx[N-k] = er - rr

    ex de,hl'               ; ii to de
    ld hl,(sp+@sp+OI)       ; the saved oi value
    ld b,h
    ld c,l

;  oi  ii  oi
;   -   -   -

    or a
    sbc hl,de               ; oi - ii
    jp novf,.unfovf15
    call .fixovr
.unfovf15:
    ld (iy+2),hl            ; ix[k] = oi - ii

;   -  ii  oi
;   -   -   -

    bool hl                 ; zero hl, zero carry
    ld l,h
    sbc hl,bc               ; - oi

; -oi  ii   -
;   -   -   -

    jp novf,.unfovf16
    call .fixovr
.unfovf16:
    or a
    sbc hl,de               ; - oi - ii
    jp novf,.unfovf17
    call .fixovr
.unfovf17:
    ld (ix+2),hl            ; ix[N-k] = - oi - ii

; all results put away
; step data pointers, done when iy==ix

    ld de,4
    add iy,de               ; iy points to next rx[k] value
    ld de,-4
    add ix,de               ; iy points to next rx[N-k] value

    ld hl,iy                ; compare iy, ix
    ex de,hl                ; iy in de
    ld hl,ix                ; ix in hl
    or a
    sbc hl,de               ; ix - iy ( ix <= iy )
    jp nz,.UNFOLDLOOP        ; (^) continue loop if they haven't met

; here to handle the very last point in the center of the array
; real = 2*real, imag = 2*imag

    ld hl,(iy)
    or a
    adc hl,hl               ; 2 * rx[N/2]
    jp novf,.unfovf18
    call .fixovr
.unfovf18:
    ld (iy),hl

    ld hl,(iy+2)
    or a
    adc hl,hl               ; 2 * ix[N/2]
    jp novf,.unfovf19
    call .fixovr
.unfovf19:
    ld (iy+2),hl            ; the last point

    ld ix,(sp+@sp+blockexp) ; blockexp is a pointer to int
    ld hl,(ix)              ; ix has address of int
    dec hl                  ; undo factor of two incurred by not including
                            ; division by two when computing even and odd
                            ; parts.
    ld (ix),hl
    jp .done


;-------------------------------------------------------------------------


; Overflow fixup function.  First fix hl, then divide by two the remaining five
; five 16-bit arithmetic registers and all data stored in array x.

; N.B.  This .fixovr also divides ER and OI by two

.fixovr:

    call fft_fixupregs  ; scale hl, hl', de, de', bc, bc'

    push af             ; af, hl, and ix used below
    push hl
    push ix

adj1: equ 2*(1 + 3)     ; adj1 accounts for pushing rtn add and pushing
                        ; af, hl, ix that have changed the value of sp
                        ; from before the call to .fixovr.

    ld hl,(sp+@sp+adj1+ER)    ; scale ER temporary value
    ld a,h                      ; sign bit into a(7)
    rla                         ; sign bit now in carry
    rr hl                       ; arithmetic right shift, lsb into carry
    jr nc,.ERdone                ; carry means lsb was 1
    set 0,l                     ; if lsb was 1 make new lsb 1
.ERdone:
    ld (sp+@sp+adj1+ER),hl

    ld hl,(sp+@sp+adj1+OI)      ; scale OI temporary value
    ld a,h
    rla
    rr hl
    jr nc,.OIdone
    set 0,l
.OIdone:
    ld (sp+@sp+adj1+OI),hl

; Now is a good time to bump blockexp to reflect right shift

    ld ix,(sp+@sp+adj1+blockexp)    ; blockexp is a pointer to int
    ld hl,(ix)                      ; hl has value of blockexp
    inc hl
    ld (ix),hl

; Save the remaining registers and call fft_blockshifter to scale the array

;   push af                         ; reminder - already pushed
;   push hl                         ; reminder - already pushed
;   push ix                         ; reminder - already pushed
    push iy
    push de
    push bc
    exx
      push hl                       ; save the alternate regs
      push de
      push bc
      push af
adj2: equ adj1 + 2*7                ; 7 more words were pushed

      ld hl,(sp+@sp+adj2+Npts)      ; number of complex points
      add hl,hl                     ; number of integers to shift
      push hl                       ; last arg pushed first
adj3: equ adj2 + 2

      ld hl,(sp+@sp+adj3+x)         ; pass array pointer
      push hl                       ; first arg pushed last

      call fft_blockshifter         ; no need to exchange register sets
      add sp,4                      ; dispose of args

      pop af                        ; restore alternate regs
      pop bc
      pop de
      pop hl
      exx                           ; restore normal registers
    pop bc
    pop de
    pop iy
    pop ix
    pop hl
    pop af

    ret                             ; end of .fixovr


.done:
    ld ix,(sp+@sp+saveix)
#endasm
}  // end of unfold

// end of fftreal, fftrealinv, unfold

/*** BeginHeader hanncplx, hannreal */

    void hanncplx( int *x, int n, int *blockexp );
    void hannreal( int *x, int n, int *blockexp );

/*** EndHeader   hanncplx, hannreal */

__root void fft_hann( int *x, int Npts, int *blockexp, int Real );

/* START FUNCTION DESCRIPTION *************************************
hanncplx     <FFT.LIB>

       SYNTAX:  void hanncplx( int *x, int n, int *blockexp )

  DESCRIPTION:  Convolve three-point Hann DFT with complex spectrum in
                array x

   PARAMETERS:         *x   pointer to complex spectrum
                        n   number of complex points
                *blockexp   pointer to integer block exponent

 RETURN VALUE:  Complex spectrum in array x is modified.

                blockexp is incremented by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by two to reflect 0.25 factor in Hann
                DFT definition.

    KEY WORDS:  DFT Hann window

END DESCRIPTION **************************************************/

__nodebug
void
hanncplx( int *x, int n, int *blockexp ) {

    fft_hann( x, n, blockexp, 0 );   // 0 => full spectrum

}

/* START FUNCTION DESCRIPTION *************************************
hannreal     <FFT.LIB>

       SYNTAX:  void hannreal( int *x, int n, int *blockexp )

  DESCRIPTION:  Convolve three-point Hann DFT with positive-frequency
                complex spectrum in array x

   PARAMETERS:         *x   pointer to positive-frequency complex spectrum
                        n   number of complex points
                *blockexp   pointer to integer block exponent

 RETURN VALUE:  Positive-frequency complex spectrum in array x is
                modified.

                blockexp is incremented by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by two to reflect 0.25 factor in Hann
                DFT definition.

    KEY WORDS:  DFT Hann window

END DESCRIPTION **************************************************/

__nodebug
void
hannreal( int *x, int n, int *blockexp ) {

    fft_hann( x, n, blockexp, 1 );   // 1 => positive-frequence spectrum

}

/* START _FUNCTION DESCRIPTION *************************************
fft_hann        <FFT.LIB>

       SYNTAX:  void fft_hann( int *x, int n, int *blockexp, int Real )

  DESCRIPTION:  Convolves the three-point frequency-domain Hann kernal
                with the complex array x.

   PARAMETERS:         *x   pointer to array of complex integer frequecies,
                            real parts in even-numbered elements
                        N   number of complex elements in x, must be >= 2,
                            i.e., sizeof(x)/sizeof(int) >= 4
                *blockexp   pointer to block exponent for complex x[Npts]
                     Real   non-zero implies x[Npts] contains the positive
                            frequencies of the transform of a real sequence
                            with Re x[fmax] stored in Im x[0].

 RETURN VALUE:  Complex spectrum in array x is modified.

                blockexp is incremented by one each time array x is
                scaled to avoid arithmetic overflow.  blockexp is
                diminished by two to reflect 0.25 factor in Hann
                DFT definition.

    KEY WORDS:  Hann window

END DESCRIPTION **************************************************/

__nodebug
__root __nouseix
void
fft_hann( int *x, int Npts, int *blockexp, int Real ) {



// Convolve the three-point frequency-domain Hann kernel with the
// array x.  If the array contains the complex coefficients of a
// "full-spectrum" DFT (i.e., the N-point DFT of an N-point sequence), the
// array is assumed to be periodic in N.  If the array contains the
// complex coefficents of a "half-spectrum" DFT (i.e., the N-point
// positive-frequency DFT of a 2N-point real sequence), the array is
// assumed to have the property x[k] = x*[-k] and to have the real
// part of the fmax term stored in the imaginary position of x[0].
//
//        x  array of complex points, real parts in even-numbered elements
//     Npts  number of complex elements in x, must be >= 2
// blockexp  pointer to block exponent.
//     Real  non-zero value indicates x[k] contains the
//           positive-frequency DFT of a real sequence
//
// Note that blockexp is always diminished by two to reflect 0.25 factor in
// Hann kernel definition.  blockexp may be incremented once or twice to avoid
// arithmetic overflow.


/*----------------------------------------------------------------------------


The x array is convolved with the three-point kernal 0.25*(1 + 2 + 1) so that each
element x[k] becomes


        x[k] = 0.25 * (x[k-2] + 2*x[k] + x[k+2])    (x[k] is complex)


The convolution is done in hloop as follows


__DC_hloop:
        Td = x[k + 2]
        Tb = Tc + Td          Tb = x[k] + x[k+2]
      x[k] = Ta + Tb        x[k] = (x[k-2] + x[k]) + (x[k] + x[k+2])


        Ta = Tb
        Tc = Td
         k = k + 2
        goto __DC_hloop


At the top of the loop Tc already contains x[k] and Ta contains the
sum of x[k] and x[k-2].  The loop sets Tb to the sum of x[k] and
x[k+2] and then sets x[k] to the sum of Ta and Tb.


First all the reals are calculated, then all the imaginaries are calculated.


The processor registers are seeded with the proper initial values depending
on whether the array is a full-spectrum DFT or a half-spectrum DFT.  The
loop terminates on the penultimate point so that the last point can
calculated using the proper (predetermined) x[k+2] value.


-------------------------------------------------------------------------------*/


    auto int savix, ctr, PreR, PreI, PostR, PostI, FmaxR, DoingRs;


    #define Complex     ( Real == 0 )


    if ( Npts < 2 )
    {
    	exception ( -ERR_RANGE );
	   exit( -ERR_RANGE );
	 }

    if ( Complex ) {             // "full-spectrum" DFT   x[k] periodic


        PreR  = x[2*Npts - 2];   // all by periodicity
        PostR = x[0];


        PreI  = x[2*Npts - 1];
        PostI = x[1];


    } // endof complex


    else  {  // real             // "half-spectrum" DFT   x[k] = x*[-k]


        PostR =   x[1];          // real part of "fmax"
        PreR  =   x[2];          // by antisymmetry


        PreI  = - x[3];          // by antisymmetry
        PostI =   0;             // by antisymmetry


        // Initially clear X[1], the imaginary part of the dc term so we can
        // use the loop machinery to handle to first term.  At the end of
        // the convolution we will replace the zero value (it will still be
        // zero) with the correct Re fmax value, which we might as well
        // calculate now.


         x[1] = 0;
        FmaxR = 2 * ( PostR + x[2*Npts - 2] );


    } // endof real


    DoingRs = 1;


#asm
    ld (sp+@sp+savix),ix        ; Dynamic C convention
    ld ix,(sp+@sp+x)            ; pointer to array of integers


    ld hl,(sp+@sp+PreR)


// Top of the main loop; executed once for reals, once for imaginaries


.seed_regs:                      ; (v)
    ex de,hl                    ; stash PreR or PreI in de for a moment
    ld hl,(ix)                  ; get first real or imaginary, which becomes
    ex de,hl                    ;   Tc in de
    or a                        ; clear carry for adc
    adc hl,de                   ; Ta has PrePreal or PreI + first real or imag
    jp novf,.hnovf1
    call .fixovr
.hnovf1:
    ld b,h                      ; Ta lives in bc
    ld c,l


// The index counter uses a' and a as the high and low bytes of a 16-bit
// counter.  At the bottom of the loop the low byte is decremented before it
// is tested for zero.  If it had initially been zero, the decrement will
// take it to 255, and 255 more iterations will follow, for a total of 256.
// Accommodate this behavior as follows.  If the low byte is initially zero
// and the high byte is NOT initially zero, decrement the high byte, thereby
// subtracting 256 from the counter and accounting for the 256 iterations.
// Note that since we know Npts is not less than 2, we need not test here
// for Npts - 1 equal zero.


// The loop counter must be initialized to Npts - 1, since the last point is
// handled explicitly.


    ld hl,(sp+@sp+Npts)         ; number of complex points
    dec hl                      ; want Npts - 1 to stop at penultimate point
    ld a,l                      ; low byte in a
    or a                        ; test low byte for zero
    jr nz,.h_ok                  ; a is nonzero, leave h alone
    dec h                       ; know that h must be nonzero, since hl >= 1
                                ;   and a == 0, so subtract 256 from the count
.h_ok:
    ex af,af'                   ; low byte in a'
    ld a,h                      ; high byte in a
    ex af,af'                   ; high byte in a', low byte in a

__DC_hloop:                          ; (v) main (inner) loop

;  -  Tc  Ta
;  -   -   -

    ld hl,(ix+4)                ; Td = x[k+2]
    ld d',h
    ld e',l

; Td  Tc  Ta
;  -  Td   -

    or a                        ; clear carry for adc
    adc hl,de                   ; Tb = Tc + Td
    jp novf,.hnovf2
    call .fixovr
.hnovf2:
    ld b',h                     ; save Tb
    ld c',l

; Tb   -  Ta
;  -  Td  Tb

    or a                        ; clear carry for adc
    adc hl,bc                   ; Ta + Tb
    jp novf,.hnovf3
    call .fixovr
.hnovf3:

; Ta+Tb  -   -
;   -   Td  Tb

    ld (ix),hl                  ; x[k] = x[k-2] +2x[k] + x[k+2]

    ld de,4                     ; point to real or imag part of next element
    add ix,de
    exx                         ; Ta = Tb, Tc = Td

    dec a                       ; loop counter low byte
    jr nz,__DC_hloop                 ; (^) more to do
    ex af,af'                   ; check high byte
    or a
    jr z,.hloopdone              ; done
    dec a
    ex af,af'
    jr __DC_hloop                    ; (^) back for more
.hloopdone:

    ld hl,(sp+@sp+DoingRs)      ; outer loop counter
    dec l
    ld (sp+@sp+DoingRs),hl
    jr nz,.doPostI               ; (v} zero means we just finished reals

.doPostR:                        ; () last real point has to be handled separately
    ld hl,(sp+@sp+PostR)        ; set Td to predetermined x[k+2]

; Td  Tc  Ta
;  -   -   -

    or a                        ; clear carry for adc
    adc hl,de                   ; Tb = Tc + Td
    jp novf,.hnovf4
    call .fixovr
.hnovf4:

; Tb   -  Ta
;  -   -   -

    or a                        ; clear carry for adc
    adc hl,bc                   ; Ta + Tb
    jp novf,.hnovf5
    call .fixovr
.hnovf5:

; Ta+Tb  -   -
;   -    -   -

    ld (ix),hl                  ; x[Npts-2] = xNpts-2] + 2x[Npts-2] + PostR
    ld ix,(sp+@sp+x)            ; back to array top
    inc ix                      ; point to first imaginary
    inc ix
    ld hl,(sp+@sp+PreI)         ; get first imaginary
    jr .seed_regs                ; (^) and go do the imaginaries

.doPostI:                        ; (^) last imag point has to be handled separately
    ld hl,(sp+@sp+PostI)        ; set Td to predetermined x[k+2]

; Td  Tc  Ta
;  -   -   -

    or a                        ; clear carry for adc
    adc hl,de                   ; Tb = Tc + Td
    jp novf,.hnovf6
    call .fixovr
.hnovf6:

; Tb   -  Ta
;  -   -   -

    or a                        ; clear carry for adc
    adc hl,bc                   ; Ta + Tb
    jp novf,.hnovf7
    call .fixovr
.hnovf7:


; Ta+Tb  -   -
;   -    -   -


    ld (ix),hl                  ; x[k] = x[k-2] + 2x[k] + PostI


; Done with convolution


; Diminish blockexp by two to reflect the 0.25 factor in front of the
; Hann kernel.


    ld ix,(sp+@sp+blockexp)     ; blockexp is a pointer to int
    ld hl,(ix)                  ; get value of blockexp
    dec hl                      ; diminish by two
    dec hl
    ld (ix),hl
    jp .done


; -------------------------------------------------------------------------


; Overflow fixup function.  First fix hl, then divide by two the remaining five
; five 16-bit arithmetic registers and all data stored in array x.


; N.B.  This .fixovr also divides by two the five temporaries
;       PreR, PreI, PostR, PostI, FmaxR


.fixovr:


    call fft_fixupregs          ; scale hl, hl', de, de', bc, bc'

    push af                     ; af, hl, and ix used below
    push hl
    push ix


adj1: equ 2*(1 + 3)             ; adj1 accounts for pushing rtn add and pushing
                                ; af, hl, ix that have changed the value of sp
                                ; from before the call to .fixovr.


    ld hl,(sp+@sp+adj1+PreR)    ; scale PreR temporary value
    ld a,h                      ; sign bit into a(7)
    rla                         ; sign bit now in carry
    rr hl                       ; arithmetic right shift, lsb into carry
    jr nc,.PreRDone              ; carry means lsb was 1
    set 0,l                     ; if lsb was 1 make new lsb 1
.PreRDone:
    ld (sp+@sp+adj1+PreR),hl


    ld hl,(sp+@sp+adj1+PreI)    ; scale PreI temporary value
    ld a,h
    rla
    rr hl
    jr nc,.PreIDone
    set 0,l
.PreIDone:
    ld (sp+@sp+adj1+PreI),hl


    ld hl,(sp+@sp+adj1+PostR)   ; scale PostR temporary value
    ld a,h
    rla
    rr hl
    jr nc,.PostRDone
    set 0,l
.PostRDone:
    ld (sp+@sp+adj1+PostR),hl


    ld hl,(sp+@sp+adj1+PostI)   ; scale PostI temporary value
    ld a,h
    rla
    rr hl
    jr nc,.PostIDone
    set 0,l
.PostIDone:
    ld (sp+@sp+adj1+PostI),hl


    ld hl,(sp+@sp+adj1+FmaxR)   ; scale FmaxR temporary value
    ld a,h
    rla
    rr hl
    jr nc,.FmaxRDone
    set 0,l
.FmaxRDone:
    ld (sp+@sp+adj1+FmaxR),hl


; Bump blockexp to reflect right shift divide by two


    ld ix,(sp+@sp+adj1+blockexp)    ; blockexp is a pointer to int
    ld hl,(ix)                      ; hl has value of blockexp
    inc hl
    ld (ix),hl


; Save the remaining registers and call fft_blockshifter to scale the array


;   push af                     ; reminder - already pushed
;   push hl                     ; reminder - already pushed
;   push ix                     ; reminder - already pushed
    push iy
    push de
    push bc
    exx
      push hl                   ; save the alternate regs
      push de
      push bc
      push af
adj2: equ adj1 + 2*7            ; 7 more words were pushed


      ld hl,(sp+@sp+adj2+Npts)  ; number of complex points
      add hl,hl                 ; number of integers to shift
      push hl                   ; last arg pushed first
adj3: equ adj2 + 2


      ld hl,(sp+@sp+adj3+x)     ; pass array pointer
      push hl                   ; first arg pushed last


      call fft_blockshifter     ; no need to exchange register sets
      add sp,4                  ; dispose of args


      pop af                    ; restore alternate regs
      pop bc
      pop de
      pop hl
      exx                       ; restore normal registers
    pop bc
    pop de
    pop iy
    pop ix
    pop hl
    pop af

    ret                         ; end of .fixovr


.done:
    ld ix,(sp+@sp+savix)        ; Dynamic C convention
#endasm

    if ( Real ) x[1] = FmaxR;
}  // end of fft_hann()

// end of hanncplx, hannreal, fft_hann

/*** BeginHeader fftcomplex */

     __root void fftcomplex( int *x, int n, int *blockexp, int dir );

/*** EndHeader   fftcomplex */

void fft_unscramble( int *x, int Npts );

/* START _FUNCTION DESCRIPTION *************************************
fftcomplex      <FFT.LIB>

       SYNTAX:  void fftcomplex( int *x, int n, int *blockexp, int dir)

  DESCRIPTION:  Computes DFT (IDFT) of complex sequence or spectrum
                stored in array x.

   PARAMETERS:         *x   pointer to complex array
                        n   number of complex points
                *blockexp   pointer to block exponent
                      dir   integer flag, non-zero => inverse FFT

 RETURN VALUE:  The computed complex spectrum (sequence) replaces the
                sequence (spectrum) in array x.

    KEY WORDS:  DFT IDFT IFT transform

END DESCRIPTION **************************************************/

__nodebug
__root __nouseix
void
fftcomplex( int *x, int Npts, int *blockexp, int dir ) {

/* Arguments

     x  Input and output (described for a FORWARD FFT)

        As input, array x contains either N complex numbers stored at
        ( x[0], x[1] ), ( [x[2], x[3] ), ..., ( x[2*N - 2], x[2*N - 1] )
        with reals in even locations, imaginaries at odd locations
        or it contains 2*N real numbers stored at x[0], x[1], .. x[2*N - 1].

        As output, array x contains the complex DFT spectrum of the input
        sequence.

        Data is stored as 16-bit two's-complement fractions where

               32767 represents + 1 - 2^-15
                   1 represents     + 2^-15
                  -1 represents     - 2^-15
               32768 represents - 1

  Npts  Number of complex entries in the data array.
        Npts must be a power of two.  Checked.

*blockexp During processing, numerical overflows are corrected by
          dividing all data by 2.  At completion blockexp contains
          the count of how many divisions by 2 were made.  For the
          inverse FFT blockexp is adjusted by log2 1/N, i.e.,

                    blockexp -= log2(Npts)

          to reflect the 1/N factor of the inverse transform definition.

   dir   0 => forward transform

            f[k] =  [sum over n] { x[n]*exp(-j*2*pi*k*n/N) }, j = sqrt(-1)

        !0 => inverse transform

            x[n] =  [sum over k] { f[k]*exp(+j*2*pi*n*k/N) } * 1/N

        If the input to the FFT is a discrete time sequence, then input
        index n is the discrete time variable, and output index k is the
        discrete frequency variable.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


//                              LOCAL VARIABLES

    auto int curangle;      // current twiddle-factor angle.
                            // a BYTE index into sine table.  always even.
                            // indexes sinetable to get sin(w), 0 <= w < pi/2.
                            // initialized to 0.

    auto int cosbindex;     // BYTE index into sine table of current cosine.
                            // initialized to PIBY2BINDEX (pi/2).

    auto int curanglestep;  // step in BYTES of curangle.
                            // doubles with each fold.

    auto int cursin,        // current sine and cosine values.
             curcos;        // scaled so that 32768 == 1.

    auto int bflywidth;     // number of BYTES from top leg of butterfly
                            // to bottom leg.  Always = 4 * Twiddlecount.
                            // (1024, 512, 256, ..., 4)

    auto int DFTcount;      // number of DFTs to be done in current fold
                            // (1, 2, ..., 256).
                            // *** was called innercount ***

    auto int DFTcountinit;  // special version of DFTcount for DFT counts 256
                            // and larger.

    auto int DFTcounter;    // down counter to cycle through DFTs at each fold.
                            // DFTcount, DFTcount - 1, ..., 1.
                            // *** was called innercounter ***

    auto int DFTstep;       // BYTE count to same-twiddle bfly in next DFT.
                            // always = 2*bflywidth = 8*Twiddlecount.
                            // ignored on first fold which has one butterfly.
                            // *** was called nextbflystep ***

    auto int Twiddlecount;  // number of butterflys in each DFT.
                            // equals bflywidth/4
                            // Twiddlecount * DFTcount = Npts/2
                            // Npts/2 = total number of butterflys/fold
                            // (256, 128, 64, ..., 1)
                            // *** was called outercount ***

    auto int Twiddlecounter;// down counter through cycle similar butterflies
                            // at each fold, i.e. butterflies in each DFT
                            // with same twiddle factor
                            // *** was called outerecounter ***

    auto int curtopbase;    // memory address into data array.
                            // points to top leg of first bfly in a DFT.
                            // Advances by 4 bytes for each new twiddle, i.e.
                            // for each DFTcount cycle.

    auto int curbottom;     // memory address into data array.
                            // points to bottom leg of each bfly.
                            // always equals curtopbase + bflywidth.

    auto int saveix;        // protect ix reg location - Dynamic C convention

    auto int log2Npts, m;   // log2Npts used to adjust blockexp by 1/N for
                            // inverse FFT



/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
// The number of complex points Npts must be a power of two and be equal to or
// greater the NPTSMIN and less than or equal to NPTSMAX.  NPTSMIN is determined
// by the fft_blockshifter function, which presently shifts four complex entries
// at a time.  NPTSMAX is determined by the number of sine-table entries as
// follows.  The first fold requires the largest set of twiddle factors, each of
// which comprises a distinct angle for which a sine and cosine must be
// obtained.  A sine table that has INTSPERQUAD entries from zero up to but not
// including pi/2 provides 2 * INTSPERQUAD sine and cosine values from zero to
// pi.  Therefore the number of first-fold twiddle factors must be less than or
// equal to 2 * INTSPERQUAD.  Since each twiddle factor is used to process two
// complex entries, NPTSMAX is 4 * INTSPERQUAD.

#define NPTSMAX         4 * INTSPERQUAD
#define NPTSMIN         4
#define LOG2NPTSMIN     2

// SINESIZE is four times the number of bytes of first-quadrant sine entries or
// eight times the number of first-quadrant entries and is always a power of
// two.  For a 256-entry-per-quadrant table, SINESIZE is 2048.  Since both
// SINESIZE and Npts must be powers of two, the division required to calculate
// curanglestep is accomplished by repeatedly dividing both numerator and
// denominator by 2 until the denominator becomes zero.  At that point the
// numerator will have been divided one time too many.

#define SINESIZE     8 * INTSPERQUAD

// The twiddle-factor angle is always zero at the beginning of each new fold.
// Insert the direction flag (DFT or IDFT) into the a register at this point,
// where it will be preserved at least until we complete the fold.  Thereby we
// avoid having to reinsert it for each new twiddle factor.
// Start twiddle-factor angle over at zero, butterfly to top of first DFT
// N.B.  The curbottom statements trashes the a register.
// c cosbindex    = PIBY2BINDEX;     ; initially points to pi/2
// c curtopbase   = (int) x;         ; byte index into data array, initially x[0]
// c curbottom    = curtopbase + bflywidth;

#define PIBY2BINDEX     2 * INTSPERQUAD

#asm

;                           INITIALIZE VARIABLES


; N.B.  No parentheses around 4 * INTSPERQUAD lest the assembler misinterpret
; them

    ld (sp+@sp+saveix),ix   ; save ix

; Check that Npts is an acceptable power of two.  Trial variable m is
; initialized to NPTSMIN.  If m doesn't equal Npts, it is doubled and compared
; again.  If no match is found before m exceeds NPTSMAX, the function takes an
; out-of-range error exit

; bookfft

    ld hl,(sp+@sp+Npts)     ; get Npts into bc
    ld b,h
    ld c,l
    ld de,NPTSMAX           ; NPTSMAX determined by size of sine table
    ld hl,NPTSMIN           ; initial value of trial variable m
    ld a,LOG2NPTSMIN        ; a will have log2 Npts when we finish

; hl    de      bc
;  m  NPTSMAX  Npts

.NptsLoop:                   ; (v)
    or a                    ; clear carry for sbc
    sbc hl,bc               ; m - Npts
    jr c,.NptsNextm          ; (v) c means m < Npts
    jr z,.NptsFound          ; (v) z means m = Npts
                            ; fall through if Npts is either too small
                            ; or not a power of two

c NptsError:  exception( -ERR_RANGE ); // (^)
c	 exit( -ERR_RANGE );

.NptsNextm:
    add hl,bc               ; recover m, faster than ld hl,( )
    add hl,hl               ; m *= 2
    inc a                   ; doubling m increases log2 m by one
    ex de,hl

; NPTSMAX  m  Npts
;    -     -    -

;   or a                    ; carry is already zero from add hl,hl
    sbc hl,de               ; compare NPTSMAX and  m, know carry is zero
    jr c,NptsError          ; (^) c means m > NPTSMAX
                            ; Npts is either too large or not a power of two

    add hl,de               ; recover NPTSMAX
    ex de,hl
    jr .NptsLoop             ; (^)

.NptsFound:                  ; Npts is an acceptable power of two.
    ld l,a                  ; hl is zero when we get here
    ld (sp+@sp+log2Npts),hl ; save order for use in inverse FFT 1/N factor

; the sample values given below are for a 512-point complex fft

;   DFTcount        = 1;            ; 1, 2, 4, 8, ..., 256

    ld hl,1
    ld (sp+@sp+DFTcount),hl

;   bflywidth       = 2 * Npts;     ; butterfly width in BYTEs
;                                   ; 1024, 512, 256, 128, ..., 4
    ld hl,(sp+@sp+Npts)
    add hl,hl
    ld (sp+@sp+bflywidth),hl        ; hl value reused below

;  curanglestep = - SINESIZE/Npts;  ; number of BYTEs to increment
;                                   ; sine table index at each fold
;                                   ; e.g. if 512 complex (256 bflies),
;                                   ; curanglestep steps by 4 bytes
;                                   ; over 0 - pi range
;                                   ; negative indicates first quadrant


; The test of Npts at the beginning of the function guarantees that
; curanglestep will be greater than or equal to 2 bytes.

    ld de,SINESIZE          ; SINESIZE is power of two
    rr hl                   ; get back Npts
.curangloop:                 ; carry is zero from add since Npts < 32768
    rr de                   ; carry is still zero since hl was even
    rr hl                   ; carry is still zero sine de was even
    jr nz,.curangloop        ; keep shifting until Npts is shifted down to 0

; The numerator in de has been shifted right one time too many.  Negate de to
; obtain the required first-quadrant minus-sign flag and then double de to
; undo the extra right shift.  Negating first saves an ex de,hl instruction.

    bool hl                 ; zero hl and carry for sbc
    ld h,l
    sbc hl,de               ; hl has new curanglestep/2
    add hl,hl               ; hl has new curanglestep
    ld (sp+@sp+curanglestep),hl

; - - - - - End of Variable Initialization - - - - - - - - - - - -

__DC_NEXTFOLD:

; The following DFTcounter initialization code assumes that DFTcount
; is a power of two.  The fast-decrement code at BFLYDONE treats an initial
; DFTcounter low byte value of zero as being 256; therefore initial values of
; DFTcounter greater than or equal to 256 are here diminished by 256.  N. B.:
; If the initial value of DFTcount is greater than 255 and *not* a power of
; two, the fast-decrement code will not count properly.

;   DFTcountinit = DFTcount < 256 ?  DFTcount : DFTcount - 256;

    ld hl,(sp+@sp+DFTcount)         ; subtract 256 from DFTcount and see if the
    dec h                           ;   value stays positive, in which case we
    jp p,.morethan255                ;   use the diminished value.  if the result
    inc h                           ;   goes negative, add back the 256
.morethan255:
    ld (sp+@sp+DFTcountinit),hl

;   Twiddlecounter = bflywidth/4;   // 256, 128, 64, ..., 1

    ld hl,(sp+@sp+bflywidth)        ; make Twiddlecouner = bflywidth/4
    or a                            ; clear carry for shift
    rr hl
    rr hl
    ld (sp+@sp+Twiddlecounter),hl

; N.B.  No parentheses for PIBY2BINDEX lest the assembler misinterpret them

    ld hl,PIBY2BINDEX           ; at each fold cosine starts out at pi/2
    ld (sp+@sp+cosbindex),hl

    ld hl,(sp+@sp+x)            ; butterflies start at top of array
    ld (sp+@sp+curtopbase),hl

    ex de,hl                    ; and curbottom is bflywidth bytes away
    ld hl,(sp+@sp+bflywidth)
    add hl,de
    ld (sp+@sp+curbottom),hl

    ld a,080h               ; a(7) == 1 => angle is zero
    ld hl,(sp+@sp+dir)      ; insert dir flag for forward or inverse
    bool hl                 ; insert flag in a(0), a(7), a(6) already set
    or a,l                  ; a(0): one => direct transform, zero => inverse

.NEXTTWIDDLE:                ; (v)

; set iy, ix pointers to upper and lower legs first butterfly in the first DFT

    ld iy,(sp+@sp+curtopbase)   ; top of butterfly
    ld ix,(sp+@sp+curbottom)    ; bottom of butterfly

; Reinitialize DFTcounter for next set of same-twiddle-factor butterflies

    ld hl,(sp+@sp+DFTcountinit) ; DFTcount possibly diminished by 256
    ex af,af'                   ; low byte kept in a' for speed
    ld a,l                      ; no need to clear DFTcountsp low byte
    ld (sp+@sp+DFTcounter),hl
    ex af,af'                   ; a' has lower 8 bits of inner loop counter;
                                ; upper 8 bits still in DFTcounter


;                               FFT BUTTERFLY
;
; ix points to bottom of butterfly
; iy points to top    of butterfly
;
; computes (x + jy) and (x - jy)*exp(-j*2*pi*k*n/N) for direct  FFT
; computes (x + jy) and (x - jy)*exp(+j*2*pi*k*n/N) for inverse FFT
;
; first compute and store the upper leg of the butterfly output
;
;           Real        (  iy  ) = x0 + x1
;           Imag        (iy + 2) = y0 + y1
;
; next compute the two differences
;
;           Real               x = x0 - x1
;           Imag               y = y0 - y1
;
; finally compute            for direct             for inverse
;
;           Real        (  ix  ) = a*x + b*y    (  ix  ) = a*x - b*y
;           Imag        (ix + 2) = a*y - b*x    (ix + 2) = a*y + b*x
;
; where a is cos( 2*pi*k*n/N ) and b is sin( 2*pi*k*n/N )
;
; check for overflow on any add where it is possible
; uses 2's complement 16-bit fractions arithmetic, with the
; binary point immediately following the sign bit.
;
; fixed register assignments in fold
;
;  a - a(0) == one => forward FFT, zero => inverse FFT
; iy - points to top    of butterfly
; ix - points to bottom of butterfly

.BUTTERFLY:                  ; (v) a has flags for zero, pi/2, and direction

; compute real sum and difference

    ld hl,(ix)              ; x1 to bc
    ld b,h
    ld c,l
    ld hl,(iy)              ; x0 to hl and de
    ld d,h
    ld e,l
    or a                    ; clear carry for adc
    adc hl,bc               ; hl has x0 + x1; keep x0 in de
    jp novf,.fovf1
    call .fixovr
.fovf1:
    ld (iy),hl              ; x0 + x1 to (iy), upper real leg
    ex de,hl                ; x0 copy to hl
    or a                    ; clear carry for sbc
    sbc hl,bc               ; x = x0 - x1
    jp novf,.fovf2
    call .fixovr
.fovf2:
    ex de',hl               ; x = x0 - x1 to de' (NR had: upper real )

; now compute imaginary sum and difference

    ld hl,(ix+2)            ; y1 to bc
    ld b,h                  ;
    ld c,l
    ld hl,(iy+2)            ; y0 to hl and de
    ld d,h                  ;
    ld e,l
    or a                    ; clear carry for adc
    adc hl,bc               ; hl has y0 + y1; keep y0 in de
    jp novf,.fovf3
    call .fixovr
.fovf3:
    ld (iy+2),hl            ; y0 + y1 to (iy + 2), upper imag leg
    ex de,hl                ; y0 to hl
    or a                    ; clear carry for sbc
    sbc hl,bc               ; y = y0 - y1
    jp novf,.fovf4
    call .fixovr
.fovf4:

;   Register Contents
;
;      hl de bc
;       y  -  -
;       -  x  -
;
; at this point we have x = x0 - x1 in de' and y = y0 - y1 in hl
; check for special cases: is angle zero or pi/2?
;      a(7) => zero
;      a(6) => pi/2
; note a(0) => inverse transform => use plus pi/2 angle

    or a                ; sets ovf if (a & 0xf0) != 0
    jp novf,.cplxmul     ; (v) bits 6 & 7 = zero => not a special case
    jp m,.putaway        ; (v) sign bit  => angle is zero; so twiddle = 1 + 0j

    bit 0,a             ; here if angle be pi/2; check inverse transform
    jr nz,.pluspi2       ; (v) bit 0 => inverse transform => use +pi/2

; forward transform; use angle -pi/2 => twiddle = 0 - i, cos = 0, sin = 1
; de' has x = x0 - x1; hl has y = y0 - y1
; exchange x and y; negate x

.minuspi2:               ; () want to get real in hl, imag in hl'
    ex de',hl           ; x in hl, y in de'
    ex de,hl            ; x in de for sbc below

; -  x  -
; -  y  -

    bool hl             ; zero hl and carry for sbc
    ld l,h
    sbc hl,de           ; hl gets -x, fixup if overflow
    jp novf,.fovf4a
    call .fixovr
.fovf4a:

; -x  -  -
;  -  y  -

    jr .putaway          ; (v) -x in hl, y in de'

; reverse transform; use angle +pi/2 => twiddle = 0 + i, cos = 0, sin = +1
; de' has x = x0 - x1; hl has y = y0 - y1
; negate y and exchange

.pluspi2:                ; (^)
    ex de,hl            ; y to de

;  -  y  -
;  -  x  -

    bool hl             ; zero hl and carry for sbc
    ld l,h
    sbc hl,de           ; hl gets -y
    jp novf,.fovf4b
    call .fixovr
.fovf4b:
    ex de',hl           ; de' gets -y, hl gets x

;  x  -  -
;  - -y  -

.putaway:                ; (^) put hl in imaginary, de' in real
    ld (ix+2),hl        ; imaginary
    ex de',hl
    ld (ix),hl          ; real
    jp .BFLYDONE         ; (v)

; now begin complex multiply; three things to keep in mind:
;
;  1.  mul:  hl:bc = de * bc
;
;  2.  since the numbers are treated as signed 16-bit fractions,
;      a multiplications results in a 30-bit fraction with two
;      sign bits.  After the multiplication we need to shift the
;      product left one position to realign the product.
;
;  3.  since we're keeping only signed 16-bit fractions, we need
;      retain only the upper half of a product, held by hl.

;  hl de bc
;   y  -  -
;   -  x  -

.cplxmul:
    ld b,h
    ld c,l              ; copy of y
    ld bc',bc           ; another copy

;  -  -  y
;  -  x  y

; sine at cursin, cosine at curcos
; in the register representations below, a is cosine, b is sine

    ld hl,(sp+@sp+curcos)   ; hl gets a, the cosine value
    ex de,hl                ; de gets a, hl gets

;  -  a  y
;  -  x  y

    mul                 ; hl gets upper 16 bits of a*y
    rl b                ; msb of bc into carry bit
    adc hl,hl           ; shift left w/ carry

; ay  a  -
;  -  x  y

    ex de',hl           ; move x to bc and hl'
    ld b,h
    ld c,l
    ld hl',bc

;  -  a  x
;  x ay  y

    mul                 ; hl gets upper 16 bits of a*x
    rl b                ; msb of bc into carry bit
    adc hl,hl           ; shift left w/ carry

; ax  -  -              ; done with cosine, discard a
;  x ay  y

    ex de,hl            ; move ax to hl', x to de
    ex de,hl'

;  -  x  -
; ax ay  y

    exx                 ; simulate ld bc,bc'
      ld bc',bc
      exx
    ld bc',de

;  -  -  y
; ax ay  x

    ld hl,(sp+@sp+cursin)   ; hl gets b, the sine value
    ex de,hl

;  -  b  y
; ax ay  x

    mul                 ; calculate b*y
    rl b                ; msb of bc into carry bit
    adc hl,hl           ; shift left w/ carry

; by  b  -
; ax ay  x

    ex de,hl'           ; move ax to de
    ex de,hl            ; move by to de

; ax by  -              ; representation duplicated twice below
;  b ay  x

    exx
    ld bc',de
    ex de,hl

;  -  b  x
; ax by ay

    mul                 ; calculate b*x
    rl b
    adc hl,hl

; bx  -  -
; ax by ay

    exx
    ld de',bc

; ax by  -              ; duplicated below
; bx ay  -

; paths for FFT and IFFT transform diverge here

    bit 0,a             ; has has direction flag
    jr z,.DODIRECT       ; (v)

; here to do inverse
                        ;   (  ix  ) = real = ax - by
                        ;   (ix + 2) = imag = ay + bx
; ax by  -
; bx ay  -

    or a                ; clear carry for sbc
    sbc hl,de           ; hl gets ax - by
    jp novf,.fovf5
    call .fixovr
.fovf5:

    ld (ix),hl          ; store IFFT real ax - by, discard b*y
    exx                 ; permanent exchange

; bx ay  -
;  -  -  -

    or a                ; clear carry for adc
    adc hl,de           ; ay + bx
    jp novf,.fovf5a
    call .fixovr
.fovf5a:
    ld (ix+2),hl        ; store IFFT imaginary ay + bx
    jr .BFLYDONE         ; (v) end of IFFT butterfly

; The four instructions above can be replaced by a jr to the jp novf,fovf5c
; instruction below.  Doing so saves eight bytes of code but no execution time
; and seems a little less tidy.

.DODIRECT:               ; (^) calculate
                        ; (  ix  ) = real = ax + by
                        ; (ix + 2) = imag = ay - bx
; ax by  -
; bx ay  -

    or a                ; clear carry for adc
    adc hl,de           ; ax + by
    jp novf,.fovf5b
    call .fixovr
.fovf5b:

    ld (ix),hl          ; store direct real ax + by; discard b*y
    exx                 ; permanent exchange
    ex de,hl            ; get bx and ay in position for subtract

; ay bx  -
;  -  -  -

    or a
    sbc hl,de           ; ay - bx
    jp novf,.fovf5c
    call .fixovr
.fovf5c:
    ld (ix+2),hl        ; store FFT direct imaginary ay - bx

.BFLYDONE:               ; (^)

// - - - - - end of single butterfly operation - - - - - - - - - - - - - -

; step ix and iy to same-twiddle bfly in next DFT

    ld hl,(sp+@sp+DFTstep)
    ex de,hl            ; put step value in de for add ix, add iy
    add ix,de
    add iy,de

; Decrement DFTcounter.  This decrement is in the innermost loop and has been
; made as fast as possible.  The lower byte of the DFTcounter is kept in the a'
; register for fast access.  If after being decremented the low byte is
; non-zero, go do more same-twiddle-factor butterflies.  If the low byte is
; zero, check if the high byte is zero.  If the high byte is not zero,
; decrement it and go do more same-twiddle-factor butterflies.  If the high
; byte is zero, there are no more same-twiddle-factor butterflies to do, go
; calculate new twiddle factor.

    ex af,af'           ; get low byte of DFTcounter from a'
    dec a               ; a counts down
    jr z,.checkhighbyte  ; a reached zero, check high byte
.restore_af:             ; (^)
    ex af,af'           ; replace low byte count and direction flag
    jp .BUTTERFLY        ; (^) go do more same-twiddle-factor butterflies

.checkhighbyte:
    ld hl,(sp+@sp+DFTcounter)
    cp a,h              ; see if high byte is zero (a already zero)
                        ; cp instruction preserves zero in a
    jr z,.twiddledone    ; a and h both zero => we're done with this twiddle
    dec h               ; decrement non-zero h
    ld (sp+@sp+DFTcounter),hl ; put back decremented DFTcounter
    jr .restore_af       ; (^) go to more same-twiddle-factor butterflies

.twiddledone:
    ex af,af'           ; need to recover direction flag to a

// - - - - - end of current same-twiddle-factor butterflies - - - - - - -

; first check if we've finished all the twiddle factors for this fold

    ld hl,(sp+@sp+Twiddlecounter)   ; decrement Twiddlecounter
    dec hl                          ; when it reaches zero, we're done
    ld (sp+@sp+Twiddlecounter),hl
    bool hl
    jr z,.SET_UP_NEXT_FOLD      ; (v) done with this fold

; UPDATE TWIDDLE FACTOR

    and 0fh                     ; first clear previous special-case flags
    ld hl,(sp+@sp+curanglestep) ; get angle step, neg in 1st quad, pos in 2nd
    ex de,hl
    ld hl,(sp+@sp+cosbindex)    ; get cosine byte index
    or a                        ; clear carry for adc
    adc hl,de                   ; update cosbindex, adc sets flags for jr below
    ld (sp+@sp+cosbindex),hl    ; save updated cosbindex
    jr nz,.notpiby2              ; (^) not at pi/2 turning point

.piby2:                          ; hl is zero, de has curanglestep
    or a                        ; clear carry for sbc
    sbc hl,de                   ; negate angle step to reverse direction
    ld (sp+@sp+curanglestep),hl ; save negated angle step
    or a,040h                   ; set pi/2 special-case flag
    jr .twiddle_factor_updated   ; (v) special case needs no curcos or cursin

.notpiby2:                       ; (^) hl has updated cosbindex,
                                ;     de has curanglestep
    bit 7,d                     ; check sign bit of step, result used below
    ex de,hl                    ; open up hl, de gets cosbindex
    ld hl,sinetable             ; address of first sine entry
    add hl,de                   ; hl gets address of cosine value
    ld hl,(hl)                  ; hl gets cosine value

; cosval cosbindex  -
;    -      -       -

    jr nz,.firstquad             ; (v) nonzero implies negative step, and
                                ;     negative step implies first quadrant
.secquad:                        ; cosine negative in second quadrant
    ld b,h                      ; cosine value into bc
    ld c,l
    bool hl                     ; zero hl and carry for sbc
    ld l,h
    sbc hl,bc                   ; hl gets minus cosine value
.firstquad:
    ld (sp+@sp+curcos),hl       ; done with cosine

; To get sine value via the cosine pointer, need to look up
; sinetable + (byteindex of pi/2 - cosbindex)

    ld hl,sinetable             ; address of sinetable[0] (sine 0)
    ld bc,PIBY2BINDEX           ; byte index of pi/2 (512 in 257-element table)
    add hl,bc                   ; address of sine(pi/2)
    or a                        ; clear carry for sbc
    sbc hl,de                   ; hl has address of sine value
    ld hl,(hl)
    ld (sp+@sp+cursin),hl       ; done with sine

.twiddle_factor_updated:

; With new twiddle factor calculated, set up to perform corresponding butterfly
; in first DFT of this fold.

    ld hl,(sp+@sp+curtopbase)   ; upper leg of next butterfly starts one
    inc hl                      ;   complex element (4 bytes) further down
    inc hl
    inc hl
    inc hl
    ld (sp+@sp+curtopbase),hl

    ld hl,(sp+@sp+curbottom)    ; lower leg of next butterfly ends one
    inc hl                      ;   complex element (4 bytes) further down
    inc hl
    inc hl
    inc hl
    ld (sp+@sp+curbottom),hl

    jp .NEXTTWIDDLE                  ; (^)

// - - - - - end of current fold  - - - - - - - - - - - - - - - - - - - - - -

.SET_UP_NEXT_FOLD:                   ; (^)

    #ifdef DebugBfly
    #endasm
        printf("\n  bflywidth %.2d  blockexp %.2d\n", bflywidth, *blockexp);
        for (m = 0; m < fsize; m++) {
            printf("%4d  %6d  %6d \n", m, x[2*m], x[2*m + 1]);
        }
    #asm
    #endif

; If we just did a butterfly width of four bytes, i.e. two adjacent complex
; entries, we've finished the butterflies.  If we're doing an IFFT adjust
; blockexp to reflect 1/N factor.  Then unscramble the array and return.

;   DFTstep        = bflywidth;     ; DFTstep not used in first fold
;   bflywidth     /= 2;
;
;   if ( bflywidth == 2) {
;       if (inverse DFT) adjust blockexp to reflect 1/N factor;
;       fft_unscramble( x, Npts );
;       return;                     ; all done
;   }

    ld hl,(sp+@sp+bflywidth)        ; update bflywidth
    ld (sp+@sp+DFTstep),hl          ; new DFTstep same as old bflywidth
    or a                            ; clear carry bit for shift
    rr hl                           ; want next bflywidth /= 2
    ld (sp+@sp+bflywidth),hl
                                    ; bflywidth = 2 means no more folds
    dec hl                          ; if next bflywidth is now 2
    dec hl                          ; two decs will make hl zero
    bool hl                         ; which means we're almost done
    jr z,.almost_done                ; (v)

; update curanglestep and DFTcount

; curanglestep *= - 2;            ; as folds progress, step doubles
                                    ; minus to toggle back to 1st quad
    ld hl,(sp+@sp+curanglestep)     ; curanglestep is negative from being
    ex de,hl                        ; in the second quadrant
    bool hl                         ; clear hl and carry for sbc
    ld l,h                          ; flip sign negative for first quadrant
    sbc hl,de                       ;  since we're starting a new fold
    add hl,hl                       ; double the step
    ld (sp+@sp+curanglestep),hl     ; curanglestep *= -2

; DFTcount *= 2;                  ; twice as many DFTs, each half the size

    ld hl,(sp+@sp+DFTcount)         ; successive folds see twice as many
    add hl,hl                       ;   DFTs left to do,
    ld (sp+@sp+DFTcount),hl         ;   but they're half the size

    jp __DC_NEXTFOLD                     ; (^)

.almost_done:                        ; (^)
    bit 0,a                         ;     a(0) has direction flag
    jr z,.SkipOneOverN               ; (v) a(0) = 0 means forward DFT, no 1/N

; Doing inverse FFT - factor 1/N factor into blockexp

    ld hl,(sp+@sp+log2Npts)
    ex de,hl                        ; adjust blockexp by log2 Npts
    ld ix,(sp+@sp+blockexp)         ; blockexp is a pointer to int
    ld hl,(ix)                      ; ix has address of blockexp value
    or a                            ; clear carry for sbc
    sbc hl,de                       ; blockexp now includes 1/N factor
    ld (ix),hl                      ;   for inverse DFT
.SkipOneOverN:                       ; (^)
    jp .done


// - - - - - end of main FFT code - - - - - - - - - - - - - - - - - - - - -

/*
                         SINE/COSINE LOOKUP TECHNIQUE

A single 0-pi/2 sine table is used to obtain values for both the sin and
cosine of the current angle.  We take advantage of the fact that the
twiddle-factor angles increase regularly and monotonically from zero to (pi -
curstepsize).

The sine table is accessed via a byte-index variable named cosbindex that
contains the byte index of the current cosine value.  cosbindex is
initialized to the byte index of sin(pi/2), which is the same as cos(0).  For
successive accesses cosbindex is at first decremented by the
current-angle-step (stored initially as a negative value and added to
cosbindex).  When cosbindex has been stepped down to zero, corresponding to
the twiddle-factor angle of pi/2, the algebraic sign of the step is made
positive so that subsequent steps, which correspond to the twiddle-factor
angle advancing into the second quadrant, will now move forward in the sine
table (back in the direction of sin(pi/2) and cos(0)).  In the second
quadrant, however, the cosine value is negative, so the value obtained from
sinetable[cosbindex] is negated.  We can tell when the twiddle-factor angle
is in the second quadrant, for which the sine-table value for the cosine is
negative, by looking at the algebraic sign of the current-angle step
(negative for the first quadrant, positive for the second).

Since sinetable[cosbindex] gives us a cosine value, we use the trigonometric
identity sin(x) = cos(pi/2 - x) to get the corresponding sine value.  We
construct

          sinbindex = byte index of pi/2 - cosbindex

and then look up sintable[sinbindex] to get the sine value.

-----------------------------------------------------------------------------*/


; Overflow fixup function.  First fix hl, then divide by two the remaining five
; five 16-bit arithmetic registers and all data stored in array x.

.fixovr:
    call fft_fixupregs  ; scale hl, hl', de, de', bc, bc'

    push hl             ; hl and ix used below
    push ix

adj1: equ 2*(1 + 2)     ; adj1 accounts for return address and pushing
                        ; af, hl, ix that have changed the value of sp
                        ; from before the call to .fixovr.

; Bump blockexp to reflect right shift divide by two

    ld ix,(sp+@sp+adj1+blockexp)    ; blockexp is a pointer to int
    ld  hl,(ix)                     ; ix has address of blockexp
    inc hl
    ld (ix),hl

; Now call fft_blockshifter to scale the array.
; First save the remaining normal registers.

;   push hl                         ; reminder - already pushed
;   push ix                         ; reminder - already pushed
    push iy
    push de
    push bc
    push af
    exx
      push hl                       ; save the alternate regs
      push de
      push bc
      push af
adj2: equ adj1 + 2*8                ; 8 more words were pushed

      ld hl,(sp+@sp+adj2+Npts)      ; number of complex points to shift
      add hl,hl                     ; number of integers to shift
      push hl                       ; last arg pushed first
adj3: equ adj2 + 2

      ld hl,(sp+@sp+adj3+x)         ; pass array pointer
      push hl                       ; first arg pushed last

      call fft_blockshifter         ; no need to exchange register sets
      add sp,4                      ; dispose of args

      pop af                        ; restore alternate regs
      pop bc
      pop de
      pop hl
      exx                           ; restore normal regs
    pop af
    pop bc
    pop de
    pop iy
    pop ix
    pop hl
    ret                             ; end of .fixovr


.done:
    ld ix,(sp+@sp+saveix)           ; restore ix
#endasm

    fft_unscramble ( x, Npts );     // unscramble the DIF outputs
}  // end of fftcomplex()

__nodebug
__nouseix
void
fft_unscramble( int *x, int Npts ) {

// Unscramble a DIF array of n complex points exchanging each element with
// the element having the bit-reversed address.
//
//  *x points to the array of complex elements
//   N is the number of complex elements in the array; must be a power of two
//
// Registers ix and iy are used as byte indexes into the x array.  They take on
// values that are multiples of four, i.e. 4*i for 0 <= i < Npts.  The bit
// position corresponding to the single one bit in the number 2N is the msb
// position of normal-counting byte index and also the lsb position of the
// bit-reversed byte index.

    auto saveix;

#asm

; register usage
;
;   hl  working
;   de' base of array (*x)
;
;   bc  lsb position of bit-reversed counter, 2N
;   bc' bitwise cmpl of lsb position of reversed counter, ~(2N)
;
;   de  current bit position to increment, initially 2N
;   hl' compl of current bit to increment, initially ~(2N)
;
;   iy  byte index of complex element; a counter incremented by 4
;   ix  byte index of complex element; a bit-reversed counter

; initialize
; bookunscramble

   ld (sp+@sp+saveix),ix    ; save ix
   ld iy,0                  ; byte index of complex element
   ld ix,0                  ; bit-reversed byte index

   ld hl,(sp+@sp+Npts)      ; number of complex points
   add hl,hl                ; double to get lsb position of bit-reversed ctr
   ld b,h                   ; keep it handy in bc
   ld c,l

;   compute complement of bit-reversed lsb position = ~x(2N)
;   we use the logical complement in an AND operation to clear a
;   selected bit in the bit-reversed byte-index counter.
;   keep the complement handy in bc' and
;   initialize current position in de

   ld hl,0
   scf              ; scf makes 0 - bc into bitwise complement
   sbc hl,bc
   ex de,hl
   ld bc',de        ; keep complement handy in bc'

   ld hl,(sp+@sp+x) ; save array base address in de'
   ex de',hl

; iy counts normally and ix counts in bit-reversed order
; msb position of iy = lsb position of ix = 2N
;
; if no propagate of carry, 167 clocks per step
; if    propagate of carry, 187 clocks per step
; about 190 clocks per swap. if 512 complex, then 240 swaps
; or 190*256 = 48000 clocks = 1.6 ms at 30 MHz

.unscrloop:

; first test for count complete
; return if (iy+4)/2 == cplx element ctr == bc == 2N

; registers hl, de, hl' are free here

   ld hl,iy         ; byte index of current complex element
   ld de,4          ; increment to next complex element
   add hl,de
   rr hl            ; (iy+4)/2 = integer index
   or a             ; clear carry for sbc
   sbc hl,bc        ; compare with integer count = 2N
   jr z,.done        ; (v) equal means we've done all of them

   add iy,de        ; bump byte index to next complex element (+4)

; about to increment bit-reversed byte-index counter
; first reinitialize current-bit positions to lsb position

   ld d,b           ; reinitialize current-bit position
   ld e,c           ;  to lsb position

   exx
     ld h,b         ; reinitialize complement of current-bit position
     ld l,c         ;  to lsb position
     exx

; now increment bit-reversed byte-index counter in ix
; simulate a counter that propagates carries to right

.carryloop:          ; (v) de has current position, hl' its complement

   ld hl,ix         ; ix is bit-reversed byte index
   and hl,de        ; see if bit in current position is set.
   jr z,.bitoff      ; (v) if it is, adding 1 to it will make it zero
                    ;  and produce a rightward carry to the next
                    ;  bit position
.biton:              ; ()

   ex de,hl'        ; get complement of current-bit position
   and ix,de        ; turn bit off

; shift current-bit positions right one place
; first the complement, then the normal

   scf              ; carry bit must be on to shift a complement
   rr de            ; shift complement of current-bit position
   ex de,hl'        ; put it away and recover current-bit position

   or a             ; carry bit off for the shift
   rr de            ; shift current-bit position right
   jr .carryloop     ; (^) continue propagating carry rightward until
                    ;  we reach a zero bit

.bitoff:             ; (^)

   or ix,de         ; bit was off; set it; there's no carry to
                    ;  propagate so we're done

; check if entries should be swapped
; if ix <= iy (i.e. bit-reversed index <= normal index),
;    don't swap because they will have already been swapped
;
; de, hl and hl' are free now

   ld hl,ix         ; first get bit-reversed byte index
   ex de,hl         ; need it in de for sbc instruction
   ld hl,iy         ; next get normal byte index
   or a             ; zero carry bit for sbc
   sbc hl,de        ; iy - ix; no carry if iy >= ix
   jr nc,.unscrloop  ; (v) skip this swap. happens about half the time

; swap

   exx              ; array memory address is in de'
     add ix,de      ; temporarily make byte indexes into memory addresses
     add iy,de
     exx

; hl and de are free

   ld hl,(iy)       ; swap reals
   ex de,hl
   ld hl,(ix)
   ld (iy),hl
   ex de,hl
   ld (ix),hl       ; reals swapped

   ld hl,(iy+2)     ; swap imaginaries
   ex de,hl
   ld hl,(ix+2)
   ld (iy+2),hl
   ex de,hl
   ld (ix+2),hl     ; imaginaries swapped

; now take array base address back out of ix, iy
; easy way is to add its negative to ix, iy

   or a             ; ***** ? *****
   exx              ; take array base address out from iy, ix
     bool hl        ; zero hl and carry for sbc
     ld l,h
     sbc hl,de      ; hl has negative of base address
   exx

   ex de,hl'        ; can't use hl in add iy, use de instead
   add iy,de        ; restore ix, iy to byte indexes
   add ix,de
   jr .unscrloop     ; (^) continue unscrambling

.done:               ; (^)
   ld ix,(sp+@sp+saveix)    ; restore ix and fall off the end
#endasm

//                   | 2^(n-1) - 2^((n-2)/2),  order n even
// number of swaps = |
//                   | 2^(n-1) - 2^((n-1)/2),  order n odd

} // end of fft_unscramble()

// end of fftcomplex, unscramble

/*** BeginHeader powerspectrum */

     void powerspectrum( int *x, int n, int *blockexp );

/*** EndHeader   powerspectrum */

/* START FUNCTION DESCRIPTION *************************************
powerspectrum       <FFT.LIB>

       SYNTAX:  void powerspectrum ( int *x, int n, int *blockexp );

  DESCRIPTION:  Calculates the (long int) power of the elements of the
                complex array stored in x according to

                *(long *)&x[2k] = ((long)x[2k])^2 + ((long)x[2k+1])^2

                for 0 <= k < N.

   PARAMETERS:         *x   pointer to array of integers to be shifted
                        n   number of complex entries in x
                *blockexp   pointer to block exponent

 RETURN VALUE:  (long int) sum of squares replaces complex spectrum in
                array x.  The more significant half of the power is
                returned in x[2k+1], the less significant half in x[2k].
                Together they constitute a long integer whose memory
                address is the same as that of the real part.

                The power of the kth complex entry can be retrieved via

                    Power[k] = *(long *)&x[2k] * 2^blockexp

    KEY WORDS:  fft power spectrum

END DESCRIPTION **************************************************/

__nodebug
__nouseix
void
powerspectrum ( int *x, int n, int *blockexp ) {

// Calculate the power of the elements of the complex array stored in x
// according to
//
//          X[k] = X[k]^2 + X[k+1]^2    0 <= k < n
//
// The real and imaginary parts of X[] represent signed 16-bit fractions whose
// values ranges from -1 to 1 - 2^15.
//
// The more significant half of the power is returned in the imaginary part of
// X[k], the less significant half in the real part.  Together they constitute
// a long integer whose memory address is the same as that of the real part, as
// would be specified by the c construct
//
//          union { struct { int real;
//                           int imag; } i;
//                  long Power;
//                } X[n];
//
// The long result can also be retrived via
//
//          Power[k] = *(long *)&x[2k] * 2^blockexp
//
// powerspectrum() does not treat the zero-frequency array element differently
// from any other element.  If the array x contains a positive-frequency
// spectrum that contains the Re fmax term in x[1], and if the power of the
// zero-frequecy term or the fmax term is important, Re fmax should be
// retrieved from x[1] and x[1] set to zero.

// blockexp undergoes two modifications.  First it is doubled to reflect the
// squaring operation.  The second modification is less obvious and is explained
// as follows.  The product of two 16-bit fractions is a 31-bit fraction that is
// usually normalized by shifting left one place.  powerspectrum() does not
// normalize the product but rather leaves the squares of the real and imaginary
// parts as 31-bit fractions to avoid the possibility of overflow when they are
// added.  blockexp is incremented by 1 to reflect this implicit division by 2
// in the values of the squares.

    auto int savix;

#asm

    ld (sp+@sp+savix),ix    ; Dynamic C convention
    ld ix,(sp+@sp+x)        ; first array element

// The index counter uses a' and a as the high and low bytes of a 16-bit
// counter.  At the bottom of the loop the low byte is decremented before it
// is tested for zero.  If the low bye was initially zero, the decrement
// will take it to 255, resulting in 255 more iterations, for a total of
// 256.  To accommodate this behavior in the case where the low byte is
// initially zero and the high byte is NOT initially zero (e.g., the initial
// count is 256, 512, etc), the high byte is decremented before entering the
// loop, thereby subtracting 256 from the counter value and accounting for
// the 256 iterations that will follow.  If the low byte is not zero, no
// predecrement is necessary.  If both the low byte and the high byte are
// initially zero, the function exits immediately (nothing to do).

    ld hl,(sp+@sp+n)        ; number of complex points
    ld a,l                  ; low byte in a
    or a                    ; test low byte for zero
    jr nz,.h_ok              ; a is nonzero, leave h alone
    cp h                    ; a is zero, so l is zero; see if also h is zero
    jr z,.blockexp_done      ; (v) hl is zero; nothing to do
    dec h                   ; hl nonzero; subtract 256 from the count
.h_ok:
    ex af,af'
    ld a,h                  ; high byte in a
    ex af,af'               ; high byte in a', low byte in a

.ploop:                      ; (v}

    ld hl,(ix)              ; the real part
    ld b,h
    ld c,l
    ex de,hl
    mul                     ; hl:bc = de*bc
    exx                     ; retain both halves of real^2

    ld hl,(ix+2)            ; the imaginary part
    ld b,h
    ld c,l
    ex de,hl
    mul

; I^2H  -  I^2L
; R^2H  -  R^2L

    ld d,b
    ld e,c
    ex de,hl'

; I^2H  R^2H   -
; I^2L   -    R^2L

    exx
    add hl,bc               ; sum the less significant halves, use carry below
    ld (ix),hl              ; return it in the real-part position of X[k]

;  -     -    -
; I^2H  R^2H  -

    exx
    adc hl,de               ; hl gets R^2H + I^2H + carry from R^2L + I^2L
    ld (ix+2),hl            ; return MSH in the imaginary-part position of X[k]

    ld de,4                 ; four bytes per complex entry
    add ix,de               ; point to next x entry

    dec a                   ; loop counter low byte
    jr nz,.ploop             ; more to do
    ex af,af'               ; check high byte
    or a
    jr z,.ploopdone          ; done
    dec a
    ex af,af'
    jr .ploop                ; (^) back for more
.ploopdone:

; first double blockexp to because we squared the elements of the array.
; Then increment blockexp by one to compensate for not shifting the squares
; left one place.

    ld ix,(sp+@sp+blockexp) ; blockexp is a pointer to int
    ld hl,(ix)              ; ix has address of blockexp
    add hl,hl               ; double blockexp since we squared the array
    inc hl                  ; add one since we didn't normalize the squares
    ld (ix),hl              ; and save blockexp
.blockexp_done:              ;

    ld ix,(sp+@sp+savix)    ; Dynamic C convention
#endasm
}  // end of powerspectrum()

/*** BeginHeader fft_fixupregs, fft_blockshifter */

     __root void fft_fixupregs( );
     void fft_blockshifter( );

/*** EndHeader   fft_fixupregs, fft_blockshifter */

/* START _FUNCTION DESCRIPTION **************************************
fft_fixupregs       <FFT.LIB>

       SYNTAX:  call fft_fixupregs   ** Pure assembly function **

  DESCRIPTION:  Fix up hl which has wrong sign by shifting hl right
                with new, opposite sign.  Shift right all remaining
                five 16-bit working registers by 2.

   PARAMETERS:  Registers hl, hl', de, de', bc, bc'

 RETURN VALUE:  Modifies  hl, hl', de, de', bc, bc'

    KEY WORDS:  overflow fixup

END DESCRIPTION ****************************************************/

#asm

; Fix up hl, which has a inverted sign bit, by shifting hl right with new,
; opposite sign.  Shift right all remaining five 16-bit working registers by 2.

; For all six registers, if a one bit is shifted off the right end, OR it back
; into the msb of the shifted register.

; bookfixupregs

fft_fixupregs::         ; scale hl, de, bc, hl', de', bc'

    push af             ; need to use a
    or a                ; start with zero carry
    bit 7,h             ; test sign bit of hl
    jr nz,.carrygood     ; if hl negative, zeroed carry is proper new sign
    ccf                 ; if hl positive, complement zeroed carry
.carrygood:
    rr hl               ; carry into hl sign, hl lsb to carry
    jr nc,.hldone        ; if hl lsb was zero, we're done
    set 0,l             ; if hl lsb was one, make new lsb one
.hldone:

    ld a,d
    rla                 ; de sign to carry
    rr de               ; propagate sign bit
    jr nc,.dedone
    set 0,e
.dedone:

    ld a,b
    rla                 ; bc sign to carry
    rr b                ; propagate sign bit
    rr c                ; no rr bc instruction
    jr nc,.bcdone
    set 0,c
.bcdone:

    exx                 ; now divide alternate registers by 2
      ld a,h            ; hl' sign to carry
      rla
      rr hl
      jr nc,.althldone
      set 0,l
.althldone:

      ld a,d            ; de' sign to carry
      rla
      rr de
      jr nc,.altdedone
      set 0,e
.altdedone:

      ld a,b            ; bc' sign to carry
      rla
      rr b
      rr c
      jr nc,.altbcdone
      set 0,c
.altbcdone:
      exx
    pop af

    ret

#endasm

// end of fft_fixupregs()

/* START _FUNCTION DESCRIPTION *************************************
fft_blockshifter    <FFT.LIB>

       SYNTAX:  void fft_blockshifter( int *x, int Npts );

  DESCRIPTION:  shifts Npts integers starting with x[0] right one
                place.  If original lsb was one, new lsb is made one.

   PARAMETERS:    *x   pointer to array of integers to be shifted
                Npts   number of integers to shift right

 RETURN VALUE:  shifts each entry in array x right one position

    KEY WORDS:  block shift

END DESCRIPTION **************************************************/

__nodebug
__nouseix
void
fft_blockshifter( int *x, int Npts ) {

// fft_blockshifter divides all the elements of the array x by two using a
// right shift.  It ORs the bit shifted off into the lsb to minimize bias.

//    x   pointer to first integer
// Npts   number of contiguous integers to scale

    auto int saveix;

#asm

; bookblockshifter

    ld (sp+@sp+saveix),ix   ; save ix
    ld ix,(sp+@sp+x)        ; get pointer to data array
    exx
    ld hl,(sp+@sp+Npts)   ; hl' - word count
    ld bc,-8              ; bc' - step in count
    ld de,16              ; de' - step in data pointer
    exx
    ld de,0                 ; a zero for use in bias-control shifting

.blkshft1:

    ld hl,(ix)              ; 1st of 8
    ld a,h                  ; sign bit into a(7)
    rla                     ; sign bit into carry
    rr hl                   ; divide by 2, propagating original sign bit
                            ;   save lsb bit shifted off in carry
    rl de                   ; shift saved bit into e(0)
    or hl,de                ; or the saved bit into lsb; clears carry
    rr de                   ; restore de to zero
    ld (ix),hl              ; done
                            ; [11+9+12 = 32 clocks / step]

    ld hl,(ix+2)            ; 2nd of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+2),hl

    ld hl,(ix+4)            ; 3rd of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+4),hl

    ld hl,(ix+6)            ; 4th of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+6),hl

    ld hl,(ix+8)            ; 5th of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+8),hl

    ld hl,(ix+10)           ; 6th of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+10),hl

    ld hl,(ix+12)           ; 7th of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+12),hl

    ld hl,(ix+14)           ; 8th of 8
    ld a,h
    rla
    rr hl
    rl de
    or hl,de
    rr de
    ld (ix+14),hl

    exx
    add ix,de             ; step data pointer in de'
    or a
    adc hl,bc             ; decrement cycle counter in hl'
    exx
    jr nz,.blkshft1          ; continue loop
                            ; 17/8+32 per = 34 clocks per word shifted,

    ld ix,(sp+@sp+saveix)   ; restore ix

#endasm

} // end of fft_blockshifter()

// end of fft_fixupregs, fft_blockshifter

/*** BeginHeader sinetable */

     extern const int sinetable[257];
     #define INTSPERQUAD 256

//   Athough it would be better to define INTSPERQUAD as
//
//       sizeof(sinetable)/sizeof(sinetable[0]) - 1
//
//   rather than hard-code it, the assembler chokes on sizeof().

/*** EndHeader   sinetable */

// values of sine from 0 to pi/2 in 1/256 steps.
// large enough for real-complex transforms of 1024 real points
// or complex-complex transforms of 1024 complex points.

// booksinetable

   const int sinetable[257] = {
        0,   201,   402,   603,   804,  1005,  1206,  1407,
     1608,  1809,  2009,  2210,  2411,  2611,  2811,  3012,
     3212,  3412,  3612,  3812,  4011,  4211,  4410,  4609,
     4808,  5007,  5205,  5404,  5602,  5800,  5998,  6195,
     6393,  6590,  6787,  6983,  7180,  7376,  7571,  7767,
     7962,  8157,  8351,  8546,  8740,  8933,  9127,  9319,
     9512,  9704,  9896, 10088, 10279, 10469, 10660, 10850,
    11039, 11228, 11417, 11605, 11793, 11980, 12167, 12354,
    12540, 12725, 12910, 13095, 13279, 13463, 13646, 13828,
    14010, 14192, 14373, 14553, 14733, 14912, 15091, 15269,
    15447, 15624, 15800, 15976, 16151, 16326, 16500, 16673,
    16846, 17018, 17190, 17361, 17531, 17700, 17869, 18037,
    18205, 18372, 18538, 18703, 18868, 19032, 19195, 19358,
    19520, 19681, 19841, 20001, 20160, 20318, 20475, 20632,
    20788, 20943, 21097, 21251, 21403, 21555, 21706, 21856,
    22006, 22154, 22302, 22449, 22595, 22740, 22884, 23028,
    23170, 23312, 23453, 23593, 23732, 23870, 24008, 24144,
    24279, 24414, 24548, 24680, 24812, 24943, 25073, 25202,
    25330, 25457, 25583, 25708, 25833, 25956, 26078, 26199,
    26320, 26439, 26557, 26674, 26791, 26906, 27020, 27133,
    27246, 27357, 27467, 27576, 27684, 27791, 27897, 28002,
    28106, 28209, 28311, 28411, 28511, 28610, 28707, 28803,
    28899, 28993, 29086, 29178, 29269, 29359, 29448, 29535,
    29622, 29707, 29792, 29875, 29957, 30038, 30118, 30196,
    30274, 30350, 30425, 30499, 30572, 30644, 30715, 30784,
    30853, 30920, 30986, 31050, 31114, 31177, 31238, 31298,
    31357, 31415, 31471, 31527, 31581, 31634, 31686, 31737,
    31786, 31834, 31881, 31927, 31972, 32015, 32058, 32099,
    32138, 32177, 32214, 32251, 32286, 32319, 32352, 32383,
    32413, 32442, 32470, 32496, 32522, 32546, 32568, 32590,
    32610, 32629, 32647, 32664, 32679, 32693, 32706, 32718,
    32729, 32738, 32746, 32753, 32758, 32762, 32766, 32767,
    0x8000}; // this the 257th entry should never be referenced

// end of sinetable