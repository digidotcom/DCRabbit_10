/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader */
#ifndef __DKCORE_LIB
#define __DKCORE_LIB
/*** EndHeader */



/*** BeginHeader dkStatusFlags, dkRequest, dkAckToSend, dkStepFlags,
					  dkSendFlags, dkptrASMbuf, dkASMbuf, dkRegisters, dkNextAddress,
					  dkBreakAddress, dkEntryCount, dkLastAsmStart, dkLastAsmEnd,
					  dkLocks, dkRST28State, dkRST20State, rstvectorreturn, */


#define TC_TYPE_DEBUG						0x01

#define TC_DEBUG_NOREQUEST					0x00
#define TC_DEBUG_SINGLESTEP				0x01
#define TC_DEBUG_TOGGLEBREAKPOINT		0x02
#define TC_DEBUG_CLEARBREAKPOINTS		0x03
#define TC_DEBUG_TOGGLEALLBREAKPOINTS	0x04
#define TC_DEBUG_ATBREAKPOINT				0x05
#define TC_DEBUG_STARTPROGRAM				0x06		// start from beginning
#define TC_DEBUG_RUNPROGRAM				0x07		// only stop for breakpoints
#define TC_DEBUG_STOPPROGRAM				0x08		// stop running program
#define TC_DEBUG_ADDWATCH					0x09
#define TC_DEBUG_DELETEWATCH				0x0a
#define TC_DEBUG_DELETEALLWATCHES		0x0b
#define TC_DEBUG_EXECWATCH					0x0c
#define TC_DEBUG_EXECALLWATCHES			0x0d
#define TC_DEBUG_SENDCHAR					0x0e
#define TC_DEBUG_RESET						0x0f
#define TC_DEBUG_SETSENDFLAGS          0x10
#define TC_DEBUG_REGDATA               0x11
#define TC_DEBUG_WATCHDATA             0x12
#define TC_DEBUG_ASMDATA               0x13
#define TC_DEBUG_STACKDATA             0x14
#define TC_DEBUG_STDIO						0x15
#define TC_DEBUG_WRITEREGDATA				0x16
#define TC_DEBUG_STDIOCHARREADY			0x17
#define TC_DEBUG_NOOP						0x18
#define TC_DEBUG_ENABLEDOPTIONS			0x19
#if (DK_ENABLE_TRACING == 1)
#define TC_DEBUG_TRACEMSG					0x1a
#define TC_DEBUG_SETTRACEFLAGS			0x1b
#endif
#if (DK_ENABLE_STACK_TRACING == 1)
#define TC_DEBUG_WRITESTACKSIZE        0x1c
#define TC_DEBUG_STACKTRACEDATA        0x1d
#endif

#if (DK_ENABLE_TRACING == 1)
// debug kernel trace flags
#define DKF_TRACE_FULL              0
#define DKF_TRACE_WATCH             1
#define DKF_TRACE_MACRO             2
#define DKF_TRACE_RST               3
#define DKF_TRACE_FENTRY            4
#define DKF_TRACE_FEXIT             5
#define DKF_TRACE_INIT              6
#define DKF_TRACE_ON                7

#define DKF_TRACERESET_FUNC         0

//  bytes,  cycles
#define _TRACE    asm push  af                        $\
                      push  hl                        $\
                      ld    hl,dkSendFlags            $\
                      set   DKF_SEND_STATUS,(hl)      $\
                      set   DKF_SEND_TRACE,(hl)       $\
                      ld    hl,dkTraceFlags           $\
                      set   DKF_TRACE_MACRO,(hl)      $\
                      lcall dkEnableRST28             $\
                      rst   0x28                      $\
                      ld    a,(dkRST28State)          $\
                      cp    _OP_JP                    $\
                      jr    z,@pc+6                   $\
                      lcall dkDisableRST28            $\
                      pop   hl                        $\
                      pop   af

// 13 bytes, 40 cycles
#define _TRACEON  asm lcall dkSetTraceOn

// 6 bytes, 24 cycles
#define _TRACEOFF asm lcall dkSetTraceOff

#else
#define _TRACE
#define _TRACEON
#define _TRACEOFF
#endif

//#define DK_SEND_STACK_LENGTH			32
#define DK_SEND_ASM_LENGTH				256 - TC_HEADER_RESERVE
//debug kernel send flags
#define DKF_SEND_STACK		 0
#define DKF_SEND_WATCHES	 1
#define DKF_SEND_ASM			 2
#define DKF_SEND_REGS		 3
#define DKF_SEND_STATUS		 4
#define DKF_SEND_ACK			 5
#if (DK_ENABLE_TRACING == 1)
#define DKF_SEND_TRACE		 6
#endif
#if (DK_ENABLE_STACK_TRACING == 1)
#define DKF_SEND_STACKTRACE 7
#endif

// debug kernel error messages for unsupported commands
// these are returned to dc when dc makes a request that
// has been compiled out of the debug kernel
#define DK_ERROR_BPNOTENABLED							0xff
#define DK_ERROR_ASMSINGLESTEPNOTENABLED			0xfe
#define DK_ERROR_WATCHNOTENABLED						0xfd

#define DKF_STDIO_LOCK		     0
#define DKF_GETCHAR_LOCK	     1
#define DKF_RESET_LOCK		     2
#define DKF_DK_LOCK			     3
#define DKF_GETCHARTIMEOUT_LOCK 4
#define DK_STDIO_TIMEOUT	100
#define DK_GETCHAR_TIMEOUT	500

#define  dkIOI		0xD3
#define  dkIOE		0xDB
#define  dkALTD	0x76

#define	DK_RST20 0xe7
#define	DK_RST28 0xef

// Z = esc or 4 byte instruction
// S = single byte instruction
// D = double byte instruction
// T = triple byte instruction

#define	dkZZ		0x0
#define	dkZS		0x1
#define	dkZD		0x2
#define	dkZT		0x3
#define 	dkSZ		0x4
#define	dkSS		0x5
#define  dkSD		0x6
#define 	dkST		0x7
#define	dkDZ		0x8
#define 	dkDS		0x9
#define	dkDD		0xa
#define  dkDT		0xb
#define	dkTZ		0xc
#define	dkTS		0xd
#define	dkTD		0xe
#define	dkTT		0xf

struct __dkregisters
{
	unsigned int	_sp;
	unsigned int	_xpc;
	unsigned int	_afPrime;
	unsigned int	_bcPrime;
	unsigned int	_dePrime;
	unsigned int	_hlPrime;
   unsigned int   _jkPrime;
	unsigned int	_af;
	unsigned int	_bc;
	unsigned int	_de;
	unsigned int	_hl;
   unsigned int   _jk;
	unsigned int	_ix;
	unsigned int	_iy;
   unsigned long  _pwPrime;
   unsigned long  _pxPrime;
   unsigned long  _pyPrime;
   unsigned long  _pzPrime;
   unsigned long  _pw;
   unsigned long  _px;
   unsigned long  _py;
   unsigned long  _pz;
	unsigned char	_ip;
	unsigned int	_pc;
};

#if (DK_ENABLE_STACK_TRACING == 1)
struct __dkStackTraceMsg
{
   uint16 _size;
   uint16 _maxSize;
   uint16 _sp;
   uint16 _xpc;
   uint16 _pc;
};
#endif

#if (DK_ENABLE_TRACING == 1)
#define DK_TRACEMSG_FULL   0x01
#define DK_TRACEMSG_FUNC   0x02

struct __dkTrace
{
   uint8 flags;
};

#define DK_TRACE_RUNNING   0
#define DK_TRACE_STEPPING  1
#define DK_TRACEMSG_MACRO  2
#define DK_TRACEMSG_RST    3
#define DK_TRACEMSG_FENTRY 4
#define DK_TRACEMSG_FEXIT  5
#define DK_TRACE_FUNCRESET 7

struct __dkDebugTraceMsg
{
   uint8 type;
   struct __dkregisters registers;
};
#endif

struct __dkaddress
{
	unsigned int offset;
	unsigned int lxpc;
};

struct __dkbreakpoint
{
	unsigned long addr;
   unsigned long mask;
	char	 		  flags;
	int	 		  (*condition)();
   int			  stopAfter;
};

#define DK_MAX_WATCHES _DK_MAX_WATCHES_			// must not be greater than 256

struct __dkwatch
{
	TypedArg WatchResult;
	unsigned long Address;
	unsigned short Size;
};

#if (DK_ENABLE_TRACING == 1)
extern unsigned int				dkTraceCount;
extern char							dkTraceFlags;
extern char							dkTraceInit;
#endif
extern char							dkStatusFlags;
//extern char							dkInBiosStack;
extern char							dkSendFlags;
extern char 						dkRequest;
extern char 						dkAckToSend;
extern char 						dkStepFlags;
extern char*						dkptrASMbuf;
extern char		 					dkASMbuf[];
extern struct __dkregisters 	dkRegisters;
#if (DK_ENABLE_TRACING == 1)
extern struct __dkTrace 			dkTrace;
extern struct __dkDebugTraceMsg	dkDebugTraceMsg;
#endif
extern struct __dkaddress		dkNextAddress;
extern struct __dkaddress		dkBreakAddress;
extern struct __dkbreakpoint	dkBreakPoint;
extern int dkEntryCount;
#if (DK_ENABLE_STACK_TRACING == 1)
extern unsigned int dkStackTop;
extern unsigned int dkStkAddrToSend;
extern struct __dkStackTraceMsg	dkStackTraceMsg;
#endif
extern unsigned int dkLastAsmStart;
extern unsigned int dkLastAsmEnd;
extern char dkLocks;
#if (DK_ENABLE_STACK_TRACING == 1)
extern char dkUCos;
#endif
extern char dkRST28State;
extern char dkRST20State;
extern byte dkHWBP_enabled;

extern int rstvectorreturn;
extern char dkSUval;

#define _DISABLE_DEBUG asm ld hl, dkLocks $ set DKF_DK_LOCK,(hl)
#define _ENABLE_DEBUG asm ld hl, dkLocks $ res DKF_DK_LOCK,(hl)

/*** EndHeader */

#if (DK_ENABLE_TRACING == 1)
unsigned int				dkTraceCount;
char                    dkTraceFlags;
char                    dkTraceInit;
#endif
char							dkStatusFlags;
//char							dkInBiosStack;
char							dkSendFlags;
char 							dkRequest;
char 							dkAckToSend;
char 							dkStepFlags;
char*							dkptrASMbuf;

#orgact run_in_ram resume
char		 					dkASMbuf[8];
#orgact rootdata resume

struct __dkregisters 	dkRegisters;
struct __dkaddress		dkNextAddress;
struct __dkaddress		dkBreakAddress;
struct __dkbreakpoint	dkBreakPoint;
#if (DK_ENABLE_TRACING == 1)
struct __dkTrace 				dkTrace;
struct __dkDebugTraceMsg	dkDebugTraceMsg;
#endif
int dkEntryCount;
unsigned int dkLastAsmStart;
unsigned int dkLastAsmEnd;
#if (DK_ENABLE_STACK_TRACING == 1)
unsigned int dkStackTop;
unsigned int dkStkAddrToSend;
struct __dkStackTraceMsg dkStackTraceMsg;
#endif
char dkLocks;
#if (DK_ENABLE_STACK_TRACING == 1)
char dkUCos;
#endif
char dkRST28State;
char dkRST20State;

int rstvectorreturn;

/*** BeginHeader dkCheckEntry */
__xmem void dkCheckEntry(void);
/*** EndHeader */
#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; destroys af, af should be saved prior to calling
dkCheckEntry::
	push	hl
	ld		hl,dkLocks
	bit	DKF_DK_LOCK,(hl)
	set	DKF_DK_LOCK,(hl)
	pop	hl
	lret
#endasm

/*** BeginHeader dkSaveContext */
__root void dkSaveContext(void);
/*** EndHeader */
#asm __root
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save all registers into a structure.
dkSaveContext::
	call	dkClearBxCR  ; going from program to debug kernel, turn off all hw bps
	push	af

     ; omid7-13-07 The following block decides if the current IP
     ; should be on the stack, or a modified copy of it. This is necessary in
     ; order to maintain interrupt priority for "Hard" hardware breakpoints.
   ld    a,(dkUseSavedIPReg)
   bit   0,a
   jr    nz,.dkUseSavedIP
   push  ip ; 1
   jr    .dkContinueSaveContext
.dkUseSavedIP:
   ld    a,(dkSavedIPReg)
   push  af
   add   sp,1 ; 1

.dkContinueSaveContext:
   push  pz ; 5
   push  py ; 9
   push  px ; 13
   push  pw ; 17
#if _RAB6K
   alts push  pz ; 21
   alts push  py ; 25
   alts push  px ; 29
   alts push  pw ; 33
#else
   exp
   push  pz ; 21
   push  py ; 25
   push  px ; 29
   push  pw ; 33
#endif
	push	iy ; 35
	push	ix ; 37
	push	jkhl ; 41
	push	de ; 43
	push	bc ; 45
   ld		hl, (sp + 45) ; Load previously saved af clobbered by ip check above.
   push	hl
	exx
	ex		af,af'
	push	jkhl ; 51
	push	de ; 53
	push	bc ; 55
	push	af ; 57

	push	af										; pad for lxpc
	push	af										; pad for sp
	ld		hl, 67
	add	hl,sp
	ld		ix,dkRegisters+__dkregisters+_sp
	ld		(ix),hl								; save sp into register structure
	bool  hl
	ld    l, h									; zero hl
	add	hl,sp
	inc	hl
	inc	hl
	ld		de,dkRegisters+__dkregisters+_xpc
	ld		bc,__dkregisters+@LENGTH-2
	ldir

	ld		hl,__dkregisters+@LENGTH
	add	hl,sp
	ld		sp,hl									; unwind stack

	ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

/*** BeginHeader dkSavepc */
__xmem void dkSavepc(void);
/*** EndHeader */
#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save lxpc:pc of next instruction to execute into appropriate
; position in register structure
dkSavepc::
	ld		hl,(dkNextAddress+__dkaddress+lxpc)
	ld		(dkRegisters+__dkregisters+_xpc),hl
	ld		hl,(dkNextAddress+__dkaddress+offset)
	ld		(dkRegisters+__dkregisters+_pc),hl
	lret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

/*** BeginHeader dkPollSerialPort */
__xmem void dkPollSerialPort();
/*** EndHeader */

#asm __xmem __nodebug
dkPollSerialPort::
	push	ip
	push 	ip
	pop	hl				; put ip into hl
	ld		a,l
	and	3				; check if current interrupt priority is > 0
	jr		z,__dk_pspexit

	push	ip
	; dkDoHook is a root function that saves the lxpc, calls the desired function
	; which may modify the lxpc, and restores the lxpc prior to returning.
	ld		hl,dkcDoSerial
	call	dkDoHook
	pop	ip

__dk_pspexit:
	lret
#endasm

/*** BeginHeader dkSavepcrst2028, dkCore */
__root void dkSavepcrst2028(void);
__xmem void dkCore(void);
/*** EndHeader */

__xmem void dkSendStatus(void);

#asm __root
dkSavepcrst2028::
	; pc pushed on stack when rst encountered
	ld		hl,(sp+2)
	ld		(dkNextAddress+__dkaddress+offset),hl
	ld		hl,lxpc
	ld		(dkNextAddress+__dkaddress+lxpc),hl

	call	dkSavepc
	ret
#endasm

#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
dkCore::
	call	bioshitwd
	lcall	dkPollSerialPort
	ld		a,(dkSendFlags)					; send target information to DC only if
	bit	DKF_SEND_STATUS,a					; send status flag is set
	jr		z,__dk_get_command
	ljp	dkSendStatus						; send target information to DC
__dk_sendstatusret::
	push	ip
	ipset	1
	ld		a,(dkSendFlags)
	res	DKF_SEND_STATUS,a
#if (DK_ENABLE_TRACING == 1)
   res	DKF_SEND_TRACE,a
#endif
	ld		(dkSendFlags),a
	pop	ip

__dk_get_command:
	ld		a,(dkRequest)						; if DC has sent a command, handle it
	cp		TC_DEBUG_NOREQUEST
	jp		nz,__dk_core_handle_command

	ld		a,(dkStatusFlags)
   bit	DKF_STAT_ATEXIT,a
   jr		z,.checkrunmode
   jp		StartUserCode

.checkrunmode:
	ld		a,(dkStatusFlags)					; if no command is sent, and we're in run mode, return to
	bit	DKF_STAT_RUNMODE,a				; user program
#if (DK_ENABLE_TRACING == 1)
   jr		z,__dk_tracingautostep
   ld		a,(dkRST28State)              ; restore RST28 vector to ret or jp
	cp		_OP_JP
   jr		z,__dk_ssr_enablerst28
   lcall	dkDisableRST28
   jr		__dk_ssr_setrst28done
__dk_ssr_enablerst28:
	lcall	dkEnableRST28
__dk_ssr_setrst28done:
   jp		dkRestoreContext
	ex		af,af'
#endif
	jr		z,dkCore
	ld		a,(dkRST28State)					; restore RST28 vector to ret or jp
   cp		_OP_JP
   jr		z,__dk_corerst28enable
   lcall	dkDisableRST28
   jr		__dk_corerst28done
__dk_corerst28enable:
   lcall	dkEnableRST28
__dk_corerst28done:
	jp		dkRestoreContext

#if (DK_ENABLE_TRACING == 1)
__dk_tracingautostep:
	ld		hl,dkTraceFlags
   bit	DKF_TRACE_ON,(hl)
   jr		z,dkCore
   ld		a,(dkStatusFlags)
   bit	DKF_STAT_STEPMODE,a
   jp		z,dkCore
   ld		a,(dkStepFlags)
   bit	DKF_STEP_OVER,a
   jp		z,dkCore
   ld		hl,(dkEntryCount)
   bool	hl
   jp		z,dkCore

   ld    a,(dkSendFlags)
   set   DKF_SEND_STATUS,a
   ld    (dkSendFlags),a

   jp  dkRestoreContext
#endif

__dk_core_handle_command:
	cp		TC_DEBUG_SINGLESTEP
	jr		nz,__dk_notss
	ljp	dkSingleStep
__dk_notss:
	cp		TC_DEBUG_RUNPROGRAM
	jr		nz,__dk_notrun
	ljp	dkRunProgram
__dk_notrun:
	cp		TC_DEBUG_STOPPROGRAM
	jr		nz,__dk_notstop
	ljp	dkStopProgram
__dk_notstop:
	cp		TC_DEBUG_STARTPROGRAM
	jr		nz,__dk_notstart
	ljp	dkStartProgram
__dk_notstart:
#if (DK_ENABLE_WATCHEXPRESSIONS == 1)
	cp		TC_DEBUG_EXECWATCH
	jr		nz,__dk_notexecwatch
	ljp	dkExecuteWatch
__dk_notexecwatch:
	cp		TC_DEBUG_EXECALLWATCHES
	jr		nz,__dk_notexecwatches
	ljp	dkExecuteAllWatches
__dk_notexecwatches:
#endif
	ljp	dkCore
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

#asm __xmem
dkSendStatus::
	; send debug info back to dc based on flags set
	ld		a,(dkSendFlags)					; get send flags into a
	or		a
	jp		z,__dk_exitsendstatus			; exit if no flags are set

	ld		a,(dkSendFlags)					; get send flags into a
	bit	DKF_SEND_REGS,a					; check if registers should be sent
	jr		z,__dk_noregsend					; skip if bit not set

	ld		hl,dkRegisters						; hl has pointer to reg struct
	ld		bc,sizeof(dkRegisters)			; bc has length of reg struct
	ld		d,TC_TYPE_DEBUG					; d has packet type
	ld		e,TC_DEBUG_REGDATA				; e has packet subtype

   call 	dkRespond							; send packet

__dk_noregsend:
	ld		a,(dkSendFlags)					; get send flags into a
	bit   DKF_SEND_STACK,a					; check if stack should be sent
	jp		z,__dk_nostacksend				; skip if bit not set
   ld		hl,(dkRegisters+__dkregisters+_sp)
	ld		bc,0x20
	ld		d,TC_TYPE_DEBUG					; d has packet type
	ld		e,TC_DEBUG_STACKDATA				; e has packet subtype
	call	dkRespond							; send packet

__dk_nostacksend:
#if (DK_ENABLE_WATCHEXPRESSIONS == 1)
	ld		a,(dkSendFlags)					; get send flags into a
	bit	DKF_SEND_WATCHES,a				; check if watches should be sent
	jr		z,__dk_nowatchsend				; skip if bit not set
	jp		dkExecuteAllWatches				; run the watches prior to sending table
__dk_eawret::
	ld		hl,dkWatchTable					; hl has pointer to watchtable
	ld		bc,sizeof(dkWatchTable)			; bc has length of watchtable
	ld		d,TC_TYPE_DEBUG					; d has packet type
	ld		e,TC_DEBUG_WATCHDATA				; e has packet subtype

	call	dkRespond							; send packet
#endif
__dk_nowatchsend:
#if (DK_ENABLE_TRACING == 1)
	ld		hl,dkTraceFlags
   bit	DKF_TRACE_MACRO,(hl)
   jr		nz,__dk_tracesendcont
   bit	DKF_TRACE_ON,(hl)
   jr		z,.dk_TraceNWS_0
   bit	DKF_TRACE_WATCH,(hl)
   res	DKF_TRACE_WATCH,(hl)
   jr		z,__dk_tracesendcont
   lret                        ; dkExecuteAllWatches called from dkSetTraceFlags
__dk_tracesendcont:
   ld    hl,dkDebugTraceMsg
   lcall  dkSendTrace
	ld		hl,dkTraceFlags
   bit	DKF_TRACE_FENTRY,(hl)
   res	DKF_TRACE_FENTRY,(hl)
   res	DKF_TRACE_FEXIT,(hl)
   jr		nz,__dk_tracesendcont    ; now repeat Entry trace with Execute or MACRO
   res	DKF_TRACE_RST,(hl)
.dk_TraceNWS_0:
#endif

__dk_exitsendstatus:
#if (DK_ENABLE_TRACING == 1)
	ld		hl,dkTraceFlags
   bit	DKF_TRACE_ON,(hl)
   jr		z,.dk_TraceESS_0
   ld  a,(dkStatusFlags)
   bit DKF_STAT_STEPMODE,a
   jr  z,__dk_exitsendstatus01

   ld  a,(dkStepFlags)
   bit DKF_STEP_OVER,a
   jr  z,__dk_exitsendstatus01

   ld  hl,(dkEntryCount)
   bool hl
   jr  nz,__dk_noacksend

__dk_exitsendstatus01:
   ld		a,(dkTraceFlags)
   bit	DKF_TRACE_MACRO,a
   jr		nz,__dk_noacksend
.dk_TraceESS_0:
#endif
	ld		a,(dkSendFlags)               ; get send flags into a
   bit   DKF_SEND_ACK,a                ; check if last command needs to be acked
   jr    z,__dk_noacksend              ; skip if bit not set

   res   DKF_SEND_ACK,a                ; clear the send ack bit
   ld    (dkSendFlags),a               ; save send flags
   ld    a,(dkAckToSend)               ; get command to ack
   or    TC_ACK                        ; set ack bit
	ld		e,a
	ld		bc,0
	call	dkRespond
   xor   a                             ; clear a
   ld    (dkAckToSend),a               ; clear ack to send

__dk_noacksend:
	ljp 	__dk_sendstatusret
#endasm

/*** BeginHeader dkStartProgram */
__xmem void dkStartProgram(void);
/*** EndHeader */
#asm __xmem
dkStartProgram::

	; push StartUserCode address onto stack, restore context,
	; and return to start the user program.

	ld		a,(dkSendFlags)					; get send flags into a
	set	DKF_SEND_STATUS,a
	ld		(dkSendFlags),a					; save send flags

	xor	a										; clear a
	ld		(dkRequest),a						; clear request
	ld		hl,startupcode+3							; load hl with addr to start running from
	ld		(dkRegisters+__dkregisters+_pc),hl	; set pc to start address
	jp		dkRestoreContext							; restore context and jump to start of program
#endasm

/*** BeginHeader dkRunProgram */
__xmem void dkRunProgram(void);
/*** EndHeader */
#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clear all flags.  Set run mode flag so that debug kernel will
; let user program continue to run until DC requests the program
; be stopped
dkRunProgram::
	xor	a
	ld		(dkRequest),a
   ld		(dkStepFlags),a
	ld		a,(dkStatusFlags)
	set	DKF_STAT_RUNMODE,a
	res	DKF_STAT_STEPMODE,a
	res	DKF_STAT_AT_BP,a
	res	DKF_STAT_AT_HARD_BP,a
	ld		(dkStatusFlags),a
	jp		dkRestoreContext
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

/*** BeginHeader dkStopProgram */
__xmem void dkStopProgram(void);
/*** EndHeader */
#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clear run mode flag so that debug kernel will not allow user
; program to continue running.
dkStopProgram::
	xor	a
	ld		(dkRequest),a
	ld		a,(dkStatusFlags)
	res	DKF_STAT_RUNMODE,a		; clear run mode flag
	res	DKF_STAT_STEPMODE,a
	ld		(dkStatusFlags),a
	ld		a,(dkSendFlags)
	set	DKF_SEND_STATUS,a			; send status back to dc
	ld		(dkSendFlags),a
	ljp	dkCore
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

///////////////////////////////////////////////////////////////
/*			Breakpoint handling											 */
///////////////////////////////////////////////////////////////

/*** BeginHeader dkBPTableFindEmpty, dkBPTableFindBP, dkToggleBreakpoint,
	  dkClearBPTable, dkToggleAllBreakpoints, dkBPTable, dkResetBreakpoints */

__xmem void dkBPTableFindEmpty(void);
__xmem void dkBPTableFindBP(void);
__xmem void dkToggleBreakpoint(void);
__xmem void dkClearBPTable(void);
__xmem void dkToggleAllBreakpoints(void);
__xmem void dkResetBreakpoints(void);

// breakpoint bit flags, number corresponds to
// bit position set if flag is on
#define DKF_BP_ACTIVE		0
#define DKF_BP_DELETED		1
#define DKF_BP_CONDITIONAL 2
#define DKF_BP_HARD			3
#define DKF_BP_HARDWARE		4
#define DKF_BP_HWDATAREAD	5
#define DKF_BP_HWDATAWRITE 6
#define DKF_BP_HWINSFETCH	7

// internal breakpoint handling flags
#define DKF_BP_INSERT		0
#define DKF_BP_FOUND			1
#define DKF_BP_NOTFOUND		2
#define DKF_BP_EMPTYFOUND	3
#define DKF_BP_EXHAUSTED	4


// the macro will be defineable via a gui option.  Make sure that the number of
// breakpoints is a power of 2 and less than 256, just to be safe
#define DK_MAX_BREAKPOINTS	_DK_MAX_BREAKPOINTS_		// must be less than 256

#ifndef DK_MAX_BREAKPOINTS
#define DK_MAX_BREAKPOINTS 32
#warnt "DK_MAX_BREAKPOINTS undefined, defaulting to 32"
#endif

#if (DK_MAX_BREAKPOINTS & (DK_MAX_BREAKPOINTS - 1)) != 0
#undef  DK_MAX_BREAKPOINTS
#define DK_MAX_BREAKPOINTS 32
#warnt "DK_MAX_BREAKPOINTS must be 2^n"
#endif

#if (DK_MAX_BREAKPOINTS > 256)
#undef DK_MAX_BREAKPOINTS
#define DK_MAX_BREAKPOINTS 256
#endif

#define DK_BREAKPOINT_MASK		DK_MAX_BREAKPOINTS-1

//Hardware breakpoint register offsets
#define DK_BxM0R  0
#define DK_BxM1R  1
#define DK_BxM2R  2

#define DK_BxCR   3

#define DK_BxA0R  4
#define DK_BxA1R  5
#define DK_BxA2R  6

extern struct __dkbreakpoint	dkBPTable[DK_MAX_BREAKPOINTS];
extern unsigned int dkBPCount;
/*** EndHeader */

#if (DK_ENABLE_BREAKPOINTS == 1)
struct __dkbreakpoint	dkBPTable[DK_MAX_BREAKPOINTS];
unsigned int dkBPCount;

#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; expects bc-de to contain physical address for breakpoint. On
; return, a will contain information about what was found, and
; hl will either contain a cell address, or zero on failure.

dkBPTableFindEmpty::
	; put DKF_BP_INSERT in alternate a register - table lookup
	; will halt on first inactive or deleted cell, returning
	; address of cell to caller
	ex		af,af'
	xor	a
	set	DKF_BP_INSERT,a					; a has 'inserting' flag
	ex		af,af'
	jr		__dk_bplookup
dkBPTableFindBP::
	; The following code moves root addresses into xmem because this
	; is how they are stored in the breakpoint table.
	ld    a, 0xdf
	cp    d
	jr    c, .dkbpinxmem
	call 	dkcPhysicalToLogical ; move the root code address into xmem code
	ex 	de, hl					; move jk:hl into bc:de
	ex		jk,hl                ; hl now has lxpc dkcPhysicalToLogical
   ex		bc,hl                ; bc now has lxpc dkcPhysicalToLogical
.dkbpinxmem:
	; clear alternate a register - table lookup will halt when
	; breakpoint has been found, or on first inactive (unused)
	; cell
	ex		af,af'
	xor	a
	ex		af,af'

__dk_bplookup:
	; get index for breakpoint using lower n bits of address where n is determined
	; by the size of the breakpoint table
	ld		hl,DK_BREAKPOINT_MASK			; number of bits of address to use for hash
	and	hl,de

	push	bcde									; save bp seg:offset addr

	; get bp struct at hash index in bp table
	ld		bc,DK_MAX_BREAKPOINTS			; load max breakpoints into de
	ex		de,hl									; de has index for bp
	ld		de',de								; save starting index in de'

__dk_bplookupnext:
	ld		bc',bc								; save count int bc'
	ld		bc,__dkbreakpoint+@LENGTH		; bc has length of breakpoint struct
	xor	a										; want base address of struct
	ld		hl,dkBPTable						; hl has base address of bp hash table

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	pop	bcde									; restore seg:offset addr
	ld		iy,hl									; use iy so bp base addr doesn't get destroyed

	ex		af,af'
	bit	DKF_BP_INSERT,a					; check to see if we're inserting

	jr		nz,__dk_bpinserting				; jump if inserting
	ex		af,af'								; restore a and flags

	; check active state, if active check address
	ld		a,(iy+__dkbreakpoint+flags)	; load flags portion of bp into a
	cp		DKF_BP_ACTIVE						; check active flag
	jp		z, __dk_bpinactive		      ; if not active check for inactive

	; check address for possible hash collision.
__dk_bpcheckaddr:
	ld		b, 0                          ; compare within 1Mb, limit for BPs
	xor	a										; clear carry
	ld		hl,(iy+__dkbreakpoint+addr)	; load low 16 bits of bp address into hl
	sbc	hl,de									; compare low 16 bits of address
	jr		nz,__dk_bpindexused 				; jump if address does not match
	ld    a, 0xdf
	cp    d                             ; if address not in xmem, we're done
	jr    nc, __dk_bpfound
   ld		de,_cexpr((1 << (MSB_OFFSET + 7)) - 1) ; mecr meaningful bits of lxpc
   ld		hl,bc                         ; lxpc now in hl
   and	hl,de                         ; compare only mecr meaningful bits
   ld		bc,hl
	ld		hl,(iy+__dkbreakpoint+addr+2)	; load high 16 bits of bp address into hl
   and	hl,de                         ; compare only mecr meaningful bits
	xor	a										; clear carry
	sbc	hl,bc									; compare high 16 bits of address
	jr		nz,__dk_bpindexused				; jump if address does not match
__dk_bpfound:
	ld		hl,iy									; load hl with pointer to correct offset in table
	ld		a,DKF_BP_FOUND						; a contains found bp state
	lret

__dk_bpinactive:
	ld		hl,0									; inactive - set hl to point to nothing
	xor	a										; clear a
	ld		a,DKF_BP_NOTFOUND					; set notfound state in a
   jr __dk_bpindexused


__dk_bpinserting:
	ex		af,af'								; restore a and flags
	ld		a,(iy+__dkbreakpoint+flags)	; get flags from current bp into a
	bit	DKF_BP_ACTIVE,a					; check if cell is active
	jr		nz,__dk_bpcheckaddr 				; if cell is active check addr
	ld		hl,iy									; load hl with pointer to correct offset in table
	ld		a,DKF_BP_EMPTYFOUND				; a contains empty bp found state
	lret

	; if address does not match, check next index, stopping when/if entire table
	; is checked.
__dk_bpindexused:
	push	bc										; save phys addr
	push	de										; save phys addr
	exx
	ld		bc',bc								; load stored count into bc
	ld		de',de								; load stored index into de
	exx
	xor 	a										; clear carry flag
	inc	de										; increment index to check
	ld		hl,DK_MAX_BREAKPOINTS-1
	sbc	hl,de									; check if we need to wrap around
	jr		nc,__dk_bpnowrap					; if de is not larger than hl, don't wrap

	ld		hl,de									; put index into a
	ld		de,DK_MAX_BREAKPOINTS
	sub	hl,de									; wrap back around table
	ld		de,hl									; e has index to lookup
__dk_bpnowrap:
	ld		de',de								; save index in de'
	dwjnz __dk_bplookupnext; decrement count and jump if we haven't hit 0 yet

	ld		hl,0									; hl points at nothing
	ld		a,DKF_BP_EXHAUSTED				; entire table has been checked - bp not found
	add	sp,4									; re-align stack for pushed addr
	lret
#endasm

#asm __root
dkConvertAddress::
; convert base:offset style address in jk:hl to 24-bit phys address in a:iy
	ex		de,hl								; jk=segment, hl=logical address
   ex		jk,hl
   ex		bc,hl
	clr	hl
	rrc	bc
	rr		hl
	rrc	bc
	rr		hl
	rrc   bc
	rr		hl
	rrc   bc
	rr		hl
   ld		a,c

	add	hl,de
	ld		b,0x00
	adc	a,b
	ld		iy,hl
	ret
#endasm

#asm __nodebug __xmem
dkToggleBreakpoint::
	xor	a
	ld		(dkRequest),a

	ld		ix,dkBreakPoint

   ld    a,(ix+__dkbreakpoint+addr+3)  ;save high byte in af'. High nibble is used to retreive
   ex    af,af'                        ;breakpoint index for hardware breakpoints

   ; Check if breakpoint address is Physical (only applies to hardware breakpoints)
  	ld		l,(ix+__dkbreakpoint+flags)	; get flags from current bp into l
  	bit	DKF_BP_HARDWARE,l
   jr    z, __dk_skipPhysCheck         ; Is it a HW breakpoint?
   ld    a,(ix+__dkbreakpoint+addr+3)  ; Retreive high byte for physical addr check
   and   0x80
   jr    z, __dk_skipPhysCheck         ; Is Physical bit set?
   ld    a,(ix+__dkbreakpoint+addr+2)  ; Its a physical address...
  	ld    hl,(ix+__dkbreakpoint+addr)   ; so save it in AIY and skip address conv.
   ld    iy,hl
   jp    __dk_HWbreakpoint

__dk_skipPhysCheck:
	; Check if breakpoint is in xmem
   ld		hl,(ix+__dkbreakpoint+addr)
   ld		a,h
   cp		0xe0
   jp		nc,.__dk_tbinxmem

	push	hl

   ; Convert address received from DC to xmem address using the lower 16-bits
   ; and 0 for the lxpc value
	ex		jk',hl
	clr	hl
   ex		jk,hl
	ex		jk',hl
   call	dkConvertAddress

   ; Convert to lxpc:offset address
   ld		hl,iy
   _LIN2SEG

   ; segmented address in in jk:hl
   ld		(ix+__dkbreakpoint+addr),hl
   ex		jk,hl
   ld		(ix+__dkbreakpoint+addr+2),hl

   ; Convert address to physical address using only the lower 16-bits received
   ; from DC.  Since the address is in instruction space, a is set to non-zero.
   pop	hl

   ;when in seperate I&D space, need to specify what type of address we
   ;are passing to dkcLogicalToPhysical
  	ld		a,(ix+__dkbreakpoint+flags)	; get flags from current bp into a
  	bit	DKF_BP_HARDWARE,a
   jr    z, __dk_instructionAddr
  	bit	DKF_BP_HWINSFETCH,a
   jr    nz, __dk_instructionAddr
   xor	a
   jr __dk_dataAddr
__dk_instructionAddr:
   xor	a
   inc	a
__dk_dataAddr:
	call	dkcLogicalToPhysical

   ; Physical address in bc,de
	ex		de,hl
   ld		iy,hl
   ld		a,c
	jr		.__dk_tbreadopcode

.__dk_tbinxmem:
	ld		hl,(ix+__dkbreakpoint+addr+2)	; get upper 16 bits of addr in hl
	ex		jk,hl                         ; for dkConvertAddress
	ld		hl,(ix+__dkbreakpoint+addr)	; hl has lower 16 bits of addr
	; put bp address into a:iy - address comes from dc in lxpc:offset
	; form, not as a 20-bit physical address
	call	dkConvertAddress					; returns with 24-bit phys addr in a:iy

.__dk_tbreadopcode:

  	ld		l,(ix+__dkbreakpoint+flags)	; get flags from current bp into a
  	bit	DKF_BP_HARDWARE,l					; check if this is a HW breakpoint request
  	jr	   nz,__dk_HWbreakpoint

	; make sure instruction at breakpoint address is an rst 28 or rst 20 prior to
	; changing adding a breakpoint
   push	af
   push	iy
   clr	hl
   and	0x0f                          ; necessary for RCM4300 breakpoints
   ld		l,a
   ex		jk,hl
   ld		hl,iy
   ld		pw,jkhl
   ld		hl,(pw)
	ld		a,DK_RST28							; load a with rst 28 opcode
	cp		l										; compare with opcode at bp addr
	jr		z,__dk_tbcont						; continue if rst 28
	ld		a,DK_RST20							; load a with rst 20 opcode
	cp		l										; compare with opcode at bp addr
	jr		z,__dk_tbcont						; continue if rst 20
	ld		a,TC_DEBUG_TOGGLEBREAKPOINT	; ack request but don't add bp
	or		TC_ACK
   pop	af
   pop	iy
	jp		__dk_tbdone

__dk_tbcont:
	; put bp address into bc:de - address comes from dc in lxpc:offset
	; form, not as a 20-bit physical address
	ld		hl,(ix+__dkbreakpoint+addr+2)	; get upper 16 bits of addr in hl
	ld		bc,hl  								; bc has upper 16 bits of addr
	ld		hl,(ix+__dkbreakpoint+addr)	; hl has lower 16 bits of addr
	ex		de,hl									; put lower 16 bits of addr in de

	; check if bp should be removed or added
	ld		a,(ix+__dkbreakpoint+flags)
	bit	DKF_BP_DELETED,a					; check for deleted flag (remove breakpoint)
	jp		nz,__dk_tbdelete					; jump if bp should be removed


	call	dkBPTableFindEmpty				; find empty bp in table
	cp		DKF_BP_EXHAUSTED					; check if entire table was searched
	jp		z,__dk_tberror						; error if no empty spot was found
	cp		DKF_BP_FOUND						; check if active bp already in table
	jp		z,__dk_tbdone						; if matching deleted bp found, return
	ex		de,hl									; de has dest addr in bp table
	ld		hl,ix									; hl has addr of bp to copy
	ld		bc,__dkbreakpoint+@LENGTH		; bc has length of bp struct
	ldir											; copy bp into table

	ld		a,_OP_JP
	ld		(dkRST20State),a
   lcall	dkEnableRST20
   jp __dk_notHWbreakpoint


__dk_HWbreakpoint:
	ld   hl,iy

   push hl
   ex   af,af'     ;extract HW breakpoint index & store in IY
   and  0x70       ;Note highest bit is masked out since it is simply the Phys.addr flag.
   ld   jk, B1M0R  ;start at HW breakpoint 1 (0 is reserved)
   cp   0x40       ;if HW breakpoint index is higher than 4, add 0x10 to it
   jr   c,__dk_normaladdr
	add  0x10
__dk_normaladdr:
   ld   h,0x00
   ld   l,a
   add  hl,jk
   ld   iy,hl
   ex   af,af'    ;restore af
   pop  hl

ioi ld (iy+DK_BxA2R), a      ;set BP address
ioi ld (iy+DK_BxA0R), hl

   ld a, 0x00 ;clean slate
ioi ld   (iy+DK_BxCR), a

   ; mask
   ld    hl, (ix+__dkbreakpoint+mask)
ioi ld   (iy+DK_BxM0R),hl
   ld    a, (ix+__dkbreakpoint+mask+2)
ioi ld   (iy+DK_BxM2R), a

   ld		a,(ix+__dkbreakpoint+flags)	; a was trashed so do this again
	bit   DKF_BP_HWDATAREAD,a
   jr    z, .checkDataWriteBit
   ld    a, 0x30
ioi ld   (iy+DK_BxCR), a ;enable HW Read breakpoint

.checkDataWriteBit:
  ld		a,(ix+__dkbreakpoint+flags)	; a was trashed so do this again
	bit DKF_BP_HWDATAWRITE,a
   jr    z, .checkHWInsFetchBit
ioi ld   a, (iy+DK_BxCR)
   or		0x0C
ioi ld	(iy+DK_BxCR), a ;enable HW Write breakpoint

.checkHWInsFetchBit:
   ld    a,(ix+__dkbreakpoint+flags)   ; a was trashed so do this again
	bit   DKF_BP_HWINSFETCH,a
	jp		z,	__dk_tbHWbpset
ioi ld   a, (iy+DK_BxCR)
   or		0xC0

ioi ld	(iy+DK_BxCR), a  ;enable HW Instruction fetch breakpoint.

	jp	  __dk_tbHWbpset
   ;END HARDWARE BREAKPOINT SECTION

__dk_notHWbreakpoint:
#ifdef _FLASH_
 #if (_SERIAL_BOOT_FLASH_ == 0)
	; toggle breakpoint if code is in flash
   pop	iy
   pop	af

	ld		hl,(ix+__dkbreakpoint+addr)
   ld		bcde, 0
   ld		de, hl

	ld		hl,(ix+__dkbreakpoint+addr+2)
   ex		jk, hl
   clr	hl
   srl	4, jkhl
   add	jkhl, bcde	; Physical address now in jkhl
   ex		jkhl, bcde
   ld		a, 0x0F		; Mask addresses above 1 meg.
                     ; Will need change for large code support.
   and	a, c
   ld		c, a

 #ifdef _ENABLE_16BIT_FLASH_
   bit	0, e
   jr		nz, __dk_oddwrite		; If it's odd, write a different pattern to the
                              ; word address.
   ld		hl, 0xFF00 | DK_RST20 ; Upper byte 0xFF in case we have a 16-bit flash.
   jr		__dk_evenodd_done
__dk_oddwrite:
	res	0, e
   ld		hl, 0x00FF | DK_RST20<<8
__dk_evenodd_done:
#else
   ld		hl, 0xFF00 | DK_RST20 ; Upper byte irrelevant in 8-bit mode.
#endif
   ld		py, bcde		; Destination for flash write

	call  _ProgramFlashUnit

 #endif   // #if (_SERIAL_BOOT_FLASH_ == 0)
#endif   // #ifdef _FLASH_

#if (FAST_RAM_COMPILE || RAM_COMPILE) || ( _SERIAL_BOOT_FLASH_ == 1)
 	pop	iy
   pop	af
 ; toggle breakpoint if code is in ram
   clr	hl
   and	0x0f                    ; necessary for RCM4300 breakpoints
   ld		l,a
   ex		jk,hl
   ld		hl,iy
   ld		pw,jkhl
   ld		hl,(pw)
   ld		L,DK_RST20
   ld		(pw),hl
   jp		__dk_tbbpset
#endif


__dk_tbbpset:
	ld		hl,dkBPCount						; increment breakpoint count
	inc	(hl)
__dk_tbHWbpset:
	call	dkSaveBxCR                     ; save all dkBxCR from DxCR
	call	dkClearBxCR                    ;
	ld 	a, (dkStatusFlags)
	bit	DKF_STAT_RUNMODE,a
	jr		z,__dk_skipclrbp
	call	dkUpdateBxCR

__dk_skipclrbp:
	ld		a,TC_DEBUG_TOGGLEBREAKPOINT
	or		TC_ACK
	jr		__dk_tbdone


__dk_tbdelete:
	add	sp,4
	call	dkBPTableFindBP					; find bp in table to remove
	cp		DKF_BP_EXHAUSTED					; check if entire table was searched
	jr		z,__dk_tberror						; error if no empty spot was found

	cp		DKF_BP_NOTFOUND					; check if bp was not found
	jr		z,__dk_tberror						; if bp not found, error

	ld		iy,hl									; point iy at bp in table
	ld		a,(iy+__dkbreakpoint+flags)	; put flags from bp in table into a
	bit	DKF_BP_DELETED,a					; check if bp already deleted
	jr		nz,__dk_tbdone						; if already deleted, we're done

	set	DKF_BP_DELETED,a
	res	DKF_BP_ACTIVE,a
	ld		(iy+__dkbreakpoint+flags),a	; mark bp as deleted

   ex		jk',hl
	ld		hl,(dkBPCount)						; decrement breakpoint count
	dec	hl
	ld		(dkBPCount),hl
	test	hl
   ex		jk',hl
	jr		nz,__dk_tbdeletedone
	ld		a,(dkStatusFlags)
	bit	DKF_STAT_RUNMODE,a
	jr		z,__dk_tbdeletedone
	ld		a,0xc9
	ld		(dkRST20State),a
   lcall	dkDisableRST20

__dk_tbdeletedone:
	ld		a,TC_DEBUG_TOGGLEBREAKPOINT
	or		TC_ACK
	jr		__dk_tbdone

__dk_tberror:
	; NAK request!!!
	ld		a,TC_DEBUG_TOGGLEBREAKPOINT
	or		TC_NAK

__dk_tbdone:
	lret
#endasm

#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set all breakpoints to unused state.  This should only be done
; at the start of a debugging session.  Doing this in the middle
; could cause problems
dkClearBPTable::
	ld		hl,dkBPTable					; hl has base addr of bp table
	ld		(hl),0x0							; seed base addr with 0
	ld		d,h								; set de to base addr of table
	ld		e,l
	inc	de									; move de to base+1
	ld		bc,sizeof(dkBPTable)-1		; bc has size of bp table
	ldir										; copy zeroes into bp table

	xor	a									; clear bp count
	ld		(dkBPCount),a
	lret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Turn all breakpoints off by setting all active bp's to deleted
; state
dkToggleAllBreakpoints::
	ld		de,0
	ld		bc,DK_MAX_BREAKPOINTS			; have to go through entire table
__dktab_loop:
	ld		bc',bc							; save count for later
	ld		a,__dkbreakpoint+flags		; just get addr of flags for each entry
	ld		bc,__dkbreakpoint+@LENGTH	; length of each bp struct
	ld		hl,dkBPTable					; base addr of table

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	set 	DKF_BP_DELETED,(hl)			; inactivate breakpoint
	exx										; restore count
	ld		bc',bc							; load count into bc
	exx										; count now in bc
	inc	de									; move to next index
	dwjnz	__dktab_loop					; if not done
	lret
#endasm

#asm __xmem
dkResetBreakpoints::
   lret
#endasm

#else

#asm __xmem
dkBPTableFindBP::
dkBPTableFindEmpty::
dkToggleBreakpoint::
dkClearBPTable::
dkToggleAllBreakpoints::
dkResetBreakpoints::
	lret
#endasm

#endif

#asm __root
; Convert base:offset style address in jk:hl to 20-bit physical address in
; bcde. This differs from the above function in that it accounts for the
; memory mapping.
; WARNING: This function clobbers the lxpc, so you must lcall it.
dkConvertCodeAddress::
   ldl	px,hl
   ex		jk,hl
   ld		lxpc,hl  ; lxpc = parameter
   convc px
   ld 	bcde,px ; bcde = result
   lret
#endasm

///////////////////////////////////////////////////////////////
/*			End Breakpoint handling										 */
///////////////////////////////////////////////////////////////


/*** BeginHeader dkRestoreContext */
__root void dkRestoreContext(void);
/*** EndHeader */
#asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
dkRestoreContext::
	call	dkUpdateBxCR  ; going from dk to program, update all BxCR from dkBxCR
	ipset	1
   call dkExit
	;ld		hl,(dkExitHook)
	;call 	dkDoHook

	clr	hl
	add	hl,sp
	ld		de,-(__dkregisters+@LENGTH-4)	; make room for registers on stack
	add	hl,de
	ld		sp,hl
	ex		de,hl									; de points to top of stack
	ld		hl,dkRegisters+4					; hl points to register structure
	ld		bc,__dkregisters+@LENGTH-4
	ldir											; move registers onto stack

	call	dkEpilog
	;ld		hl,(dkEpilogHook)
	;call	dkDoHook

	ld		hl,dkLocks
	res	DKF_DK_LOCK,(hl)					; reset debug kernel lock

	ld		iy,TCState								; enable nesting of interrupts during tc callbacks
	xor	a
	TC_STOR(dont_nest_interrupts,a)

   ld    hl,(dkRegisters+__dkregisters+_xpc)
	ld		lxpc,hl
	pop	af										; restore prime registers
	pop	bc
	pop	de
	pop	jkhl

	exx
	ex		af,af'

	pop	af
	pop	bc
   pop	de
	pop	jkhl
	pop	ix
	pop	iy
#if _RAB6K
   altd pop   pw
   altd pop   px
   altd pop   py
   altd pop   pz
#else
   pop   pw
   pop   px
   pop   py
   pop   pz
   exp      ; Exchange the 32-bit pointer registers
#endif
   pop   pw
   pop   px
   pop   py
   pop   pz

;	pop ip
;	ipset 0

;	ret
	reti
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

/*** BeginHeader dkDoHook */
__root void dkDoHook(void);
/*** EndHeader */
#asm __root
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; expects address of root hook function in hl
dkDoHook::
   ex		jk',hl
	ld		hl,lxpc
	push	hl
   ex		jk',hl
	xor	a
	or		h
	or		l							; make sure address isn't zero
	jr		z,__dk_dh_done
	ld		de,__dk_dh_done		; load and push return addr on stack
	push	de
	jp		(hl)						; jump to hook function
__dk_dh_done:
   ex		jk',hl               ; save any return code
	pop	hl
	ld		lxpc,hl
   ex		jk',hl               ; restore any return code
	ret
#endasm


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

/*** BeginHeader dkSingleStep */
__xmem void dkSingleStep(void);
/*** EndHeader */
#asm __xmem
dkSingleStep::
	xor	a
	ld		(dkRequest),a			; clear request

	; debug kernel needs to send status information on next entry
	ld		a,(dkStatusFlags)
	set	DKF_STAT_STEPMODE,a
	res	DKF_STAT_RUNMODE,a
	res	DKF_STAT_AT_BP,a
	res	DKF_STAT_AT_HARD_BP,a
	ld		(dkStatusFlags),a
	ld		a,(dkSendFlags)
	set	DKF_SEND_STATUS,a
	ld		(dkSendFlags),a

   ld		a,0x01
	ld		a,(dkStepFlags)		; jump to appropriate handler
	bit   DKF_STEP_SOURCE,a
	jr		z,__dk_asmss
	ljp	dkCSingleStep
__dk_asmss:
	ljp	dkAsmSingleStep
#endasm

/*** BeginHeader dkCSingleStep */
__xmem void dkCSingleStep(void);
/*** EndHeader */
#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
dkCSingleStep::
	; stepping into/over function calls is handled inside _fentry and
	; _fexit.

   ex		jk',hl
   ld		hl,lxpc
   push	hl
   ex		jk',hl
   call	dkSingleStepExit
   pop	hl
   ld		lxpc,hl

	bool	hl
	ld		l,h
	ld		(dkEntryCount),hl
	lcall	dkEnableRST28
	ld		a,_OP_JP					; enable rst 0x28
	ld		(dkRST28State),a
	ld		hl,(dkNextAddress+__dkaddress+offset)
	ld		ix,dkRegisters+__dkregisters+_pc
	ld		(ix),hl

	jp		dkRestoreContext
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endasm

#asm __root
; Code in root, but need to be called via lcall and returns via lret
; to save/restore lxpc!
; Given an address in a:iy, use ldp to load 16 bit value
; into hl, if iy is below 0xe000, then A is ignored and IY is read as
; translated into a physical address assuming it is located in code space.
; If iy is in xmem (in e000-ffff) then use value in A as XPC.
; Designed to read out of code space when
; separate I&D is on, but also works w/o I&D.
; - destroys af, bc, de, af'

__dk_ldp_LogToPhyCode::
   ex		jk,hl
   ld		lxpc,hl
   ld		hl,iy
	ld	 	a,1						; Translate as a logical I-space address
   call  dkcLogicalToPhysical
   ld		pw,bcde
   ld		hl,(pw)
	lret ; lret to restore lxpc!!
#endasm

/*** BeginHeader dkAsmSingleStep */
__xmem void dkAsmSingleStep(void);
#if (DK_ENABLE_ASMSINGLESTEP == 1)
extern struct __dkaddress		dkStackAddress;
extern struct __dkaddress		dkReturnAddress;
#endif
/*** EndHeader */

// if DK_ENABLE_ASMSINGLESTEP is 0, then dkAsmSingleStep,
// dkGetOplength, dkOplen will not be compiled, and the tables used
// by dkGetOplength and dkOplen (dkOpsize and dkPrefixed) will not
// be placed into memory
#if (DK_ENABLE_ASMSINGLESTEP == 1)

struct __dkaddress		dkStackAddress;
struct __dkaddress		dkReturnAddress;

char dknextasm[8];

#asm __root
dkCopyNextInstruction::
	ld		hl,lxpc
	push	hl
	ld		hl,(dkNextAddress+__dkaddress+lxpc)
	ld		lxpc,hl
	ld		hl,(dkNextAddress+__dkaddress+offset)
   #if __SEPARATE_INST_DATA__
	; Note that for xmem addresses this just to physical and then back again
	ld		a, TC_SYSREAD_LOGICAL_CODE					; read from code space
	call  dkcLogicalToPhysical                   ; convert to physical address
   call  dkcPhysicalToLogical							; convert to XPC:eXXX address
   ex		jk',hl
   ex		jk,hl                                  ; lxpc in jk from dkcPhysicalToLogical
   ld		lxpc,hl                                ; set lxpc
   ex		jk',hl
.dk_inxmem:
   #endif
	ld		de,dknextasm
	ld		bc,sizeof(dknextasm)
	ldir
	pop	hl		;restore the lxpc
	ld		lxpc,hl
	ret
#endasm

#asm __xmem
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;

dkAsmSingleStep::
	push	hl
	clr	hl
	ld		(dkEntryCount),hl

   lcall	dkEnableRST28
	ld		a,0xc3

	ld		(dkRST28State),a
	pop	hl

	call	dkCopyNextInstruction
	ld		iy, dknextasm ;< iy points to the copied instruction.

   ld a, (iy)

   cp 0xCD ;< call
   jp eq, __dk_call

   cp 0xCF ;< lcall
   jp eq, __dk_lcall

   cp 0xE7 ;< rst 0x20
   jp eq, __dk_rst2028

   cp 0xEF
   jp eq, __dk_rst2028

   cp	0xF9 ;< ld sp, hl
   jr neq, __dk_checkspixiy
   ld bcde, 1 ;< It's just a byte.
   ljp __dkCopyToRam

__dk_checkspixiy:
	cp 0xDD
   jr eq, __dk_twobytesp
   cp 0xFD
   jr neq, __dk_checkbitB_hl
__dk_twobytesp:
   ld a, (iy+1)	; Check next byte
   cp 0xF9 ; ld sp, ix
   jr neq, __dk_default_step
   ld bcde, 2 ;< Two byte instruction
   ljp __dkCopyToRam

   ; This magic bit pattern here is 01xxx110
__dk_checkbitB_hl:
   cp 0xCB
   jr neq, __dk_checkED_page
   ld a, (iy+1)
   and 0xC7
   cp 0x46
   jr neq, __dk_default_step
   ld bcde, 2
   ljp __dkCopyToRam

__dk_checkED_page:
   cp 0xED ;< Check for the ed page prefix.
   jr nz, __dk_default_step

   inc iy ;< Skip the prefix byte.
   ld a, (iy)

   ; Check for the repeat family of instructions.
   ; DEV: This instruction emulation is broken if the copy is done in xmem. In the future, we
   ; intend to move instruction emulation to the stack segment.
   ; The mask is 1xxxx000.
   and 0x87 ; and with 10000111, passing the bits we care about.
   cp  0x80
   jr z, __dk_copy_ed_inst

   ; Check for chained atomic instruction family. There is some overlap with
   ; ld a, iir type of instructions, but it's not a big loss.
   ; The magic mask is 01xxx11x
   ld	a, (iy)
   and 0xC6
   cp	0x46
   jr z, __dk_copy_ed_inst

   ; Check for some special case instructions in this page.
   ld a, (iy)
   cp	0x83                     ; sysret
   jr z, __dk_copy_ed_inst
   cp 0x4D                     ; reti
   jr z, __dk_copy_ed_inst
   cp 0x5D                		 ; ipres
   jr z, __dk_copy_ed_inst
   cp 0x7D                     ; sures
   jr z, __dk_copy_ed_inst
   cp 0xB1                     ; setsysp mn
   jr z, __dk_copy_ed_4
   cp 0xB5                     ; setusrp mn
   jr nz, __dk_default_step
__dk_copy_ed_4:
	dec iy
   ld bcde, 4
   ljp __dkCopyToRam

__dk_copy_ed_inst:

   dec iy ;< We're copying the entire instruction.
   ld bcde, 2 ;< It's two bytes long.
   ljp __dkCopyToRam
__dk_skip_rep_ops:

   ; *** Default handling ***

__dk_default_step::
	ld		hl, (dkRegisters + __dkregisters + _xpc) ; Load the low lxpc into a.
   ld		de,hl
   ld		hl,lxpc
   ex		jk',hl  ; save lxpc prior to lcall to dkConvertCodeAddress
   ld		hl,de
   ex		jk,hl   ; for dkConvertCodeAddress
   ld 	hl, (dkRegisters + __dkregisters + _pc) ; Get the pc into hl.

   lcall dkConvertCodeAddress

   ex		jk',hl
   ld		lxpc,hl ; restore lxpc after lcall clobbered high bits

   ; Copy address into breakpoint register.
   ioi ld (B0A2R), bc ; This is ok because the memory location above B0A2R is
                      ; currently unused.
   ioi ld (B0A0R), de
   ; DEVNOTE:
   ; ioi ld (B0A0R), bcde

   ; Set status register.
   ld 	a, 0xC0 ; 0xC0 means break on execution.
   ioi ld (B0CR), a

   ljp	dkRestoreContext
__dk_call::
   ld		de, 3       ; In 3000, __dkCopyToRam fills DE
	ld		a,(dkStepFlags)
	bit	DKF_STEP_INTO,a
	jp		nz,__dk_stepintocall
	; the following code takes care of the case where a function being stepped over has a
	; breakpoint in it.  The rst 20 handler will be able to restore the stack properly in
	; such a case.
	ioi	ld	hl,(STACKSEGL)
	ld		(dkStackAddress+__dkaddress+lxpc),hl	    ; save stack seg for current stack
	bool	hl
	ld		l,h
	add	hl,sp												 ; hl = sp;
	dec	hl
	dec	hl
	ld		(dkStackAddress+__dkaddress+offset),hl	 ; save stack logical offset
	ld		hl,(dkNextAddress+__dkaddress+offset)
	add	hl,de												 ; get return address
	ld		(dkReturnAddress+__dkaddress+offset),hl ; save return address that should be on stack
	ld		hl,(dkRegisters+__dkregisters+_xpc)
	ld		(dkReturnAddress+__dkaddress+lxpc),hl	 ; save return lxpc
	ld		a,(dkStepFlags)								 ; get step flags
	res	DKF_STEP_LCALL,a								 ; reset lcall flag
	set	DKF_STEP_CALL,a								 ; set call flag
	ld		(dkStepFlags),a								 ; save step flags
	jp		__dkCopyToRam
__dk_stepintocall::							; stepping into function call:
	ld		a,_OP_JP								; put jp instruction at rst 0x28 vector
	ld		(dkRST28State),a
	ld		hl,(dkNextAddress+__dkaddress+offset)
	add	hl,de
	push	hl										; push return address on stack+
	ld		hl,(iy+1)							; hl now contains address where call address is located
	ld		(dkNextAddress+__dkaddress+offset),hl		; save address following call instruction
	jp		__dkReenterRST18

__dk_lcall::
   ld    de, 4     ; In 3000, __dkCopyToRam fills DE.
	ld		a,(dkStepFlags)
	bit	DKF_STEP_INTO,a
	jp		nz,__dk_default_step
	; the following code takes care of the case where a function being stepped over has a
	; breakpoint in it.  The rst 20 handler will be able to restore the stack properly in
	; such a case.
	ioi	ld	hl,(STACKSEGL)
	ld		(dkStackAddress+__dkaddress+lxpc),hl	    ; save stack seg for current stack
	bool	hl
	ld		l,h
	add	hl,sp												 ; hl = sp;
	dec	hl
	dec	hl
	dec	hl
	ld		(dkStackAddress+__dkaddress+offset),hl	 ; save stack logical offset
	ld		hl,(dkNextAddress+__dkaddress+offset)
	add	hl,de												 ; get return address
	ld		(dkReturnAddress+__dkaddress+offset),hl ; save return address that should be on stack
	ld		hl,(dkRegisters+__dkregisters+_xpc)
	ld		(dkReturnAddress+__dkaddress+lxpc),hl	 ; save return lxpc
	ld		a,(dkStepFlags)								 ; get step flags
	res	DKF_STEP_CALL,a								 ; reset lcall flag
	set	DKF_STEP_LCALL,a								 ; set call flag
	ld		(dkStepFlags),a								 ; save step flags
	jp		__dkCopyToRam
#endasm

#asm __root
__dk_copylcallreturn::
	ld		hl,(dkNextAddress+__dkaddress+offset)
	add   hl, de
	exx									; save the next address in hl' so we can return it to the caller
	ld    hl, iy						; next instruction is stored in buffer pointed to by iy
	inc   hl								; advance to address of instruction
	ld		de,dkNextAddress
	ld		bc,3
	ldir									; Copy lxpc:offset into dkNextAddress
	exx
	ret
#endasm

#asm __xmem
__dk_stepintolcall:
	call	__dk_copylcallreturn
   ex		jk',hl                                ; save hl
	ld		hl,(dkRegisters+__dkregisters+_xpc)
	push	hl								              ; push lxpc onto stack
   ex		jk',hl                                ; restore hl
	inc	sp								; adjust sp for single byte push
	push	hl								; push address following lcall as return value on stack
	jp		__dkReenterRST18

; ldir-family single-stepping handler code (assumes hl contains the address
; of the appropriate handler function, see __dk_lxxx functions below)
__dk_do_ldir::
	ld		(dkRegisters+__dkregisters+_pc), hl			; set handler (executes in root so xmem dest/src ldir's work)
	ld		hl,(dkNextAddress+__dkaddress+offset)
	add	hl,de
	ld		(dkNextAddress+__dkaddress+offset),hl		; set return address

	call	dkSingleStepExit
	ljp	dkRestoreContext

__dk_ldir::
	ld		hl, __dk_handle_ldir
   jp		__dk_do_ldir

__dk_lddsr::
	ld		hl, __dk_handle_lddsr
   jp		__dk_do_ldir

__dk_ldisr::
	ld		hl, __dk_handle_ldisr
   jp		__dk_do_ldir

__dk_lsdr::
	ld		hl, __dk_handle_lsdr
   jp		__dk_do_ldir

__dk_lsir::
	ld		hl, __dk_handle_lsir
   jp		__dk_do_ldir

__dk_lsddr::
	ld		hl, __dk_handle_lsddr
   jp		__dk_do_ldir

__dk_lsidr::
	ld		hl, __dk_handle_lsidr
   jp		__dk_do_ldir
; --------------------------------------------

__dk_ljp::
	ld		de,dkNextAddress
	ld		hl,iy
	inc	hl
	ld		bc,3
	ldir											; save ljp target address to dkNextAddress
	jp		__dkReenterRST18
#endasm

#asm __xmem
__dk_rst2028::
	ld		hl,(dkNextAddress+__dkaddress+offset)
	inc	hl
	ld		(dkNextAddress+__dkaddress+offset),hl		; skip rst instruction
	jp		__dkReenterRST18

__dkReenterRST18::
	ld		hl,(dkptrASMbuf)
	ld		(hl),0xdf							; rst 0x18
	jp		__dkExecInRAM						; debug kernel will be immediately reentered

__dkCopyToRam::								; copy instruction to RAM
	ld		hl,(dkNextAddress+__dkaddress+offset)
	add	hl,de
	ld		(dkNextAddress+__dkaddress+offset),hl
	ld		b,d
	ld		c,e
	ld		de,(dkptrASMbuf)
	ld		hl,iy
	ldir
	; place rst after instruction to execute to bring control back to dk
	ld		a,0xdf								;rst 0x18
	ld		(de),a

__dkExecInRAM::

   ex jk', hl
   ld hl, lxpc
   push hl
   ex		jk', hl
	call	dkSingleStepExit
	pop 	hl
	ld lxpc, hl

	ld		hl,(dkptrASMbuf)
	/*
	In the 1Mb code space model, the address must be left as a data address and
	  not converted to xmem or the lxpc will have its high bits chopped by any
	  xmem call. This will not work in separate I&D unless the address executing
	  is in a RAM hole.

	; normalize data buffer address to xmem window and execute in the xmem window
   xor   a										; Equiv to "ld	a, TC_SYSREAD_LOGICAL_DATA"
   												; Address is from data space
   call  dkcLogicalToPhysical				; Convert to physical
   call  dkcPhysicalToLogical				; convert to XPC:EXXX
	; put the lxpc
	*/
	ld		(dkRegisters+__dkregisters+_pc),hl
   ;ex		jk,hl
   ld hl, lxpc
	ld		(dkRegisters+__dkregisters+_xpc),hl

	ljp	dkRestoreContext
#endasm

#asm __xmem
__dk_handle_ldir::											; Special handler to execute ldir in root code space so xmem dest/src work correctly.
	ldir
	rst	0x18
#endasm

#asm __root
__dk_handle_lddsr::
	lddsr
   rst   0x18

__dk_handle_ldisr::
	ldisr
   rst   0x18

__dk_handle_lsdr::
	lsdr
   rst   0x18

__dk_handle_lsir::
	lsir
   rst   0x18

__dk_handle_lsddr::
	lsddr
   rst   0x18

__dk_handle_lsidr::
	lsidr
   rst   0x18
#endasm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#else  // Assembly level single stepping is not supported

#asm __xmem
dkAsmSingleStep::
	ljp		dkCore
#endasm

#endif


/*** BeginHeader dkGetStructMemberAddr */
__xmem void dkGetStructMemberAddr(void);
/*** EndHeader */

#asm __xmem
; expects -
; a  = member offset in struct
; bc = struct length
; de = logical index into table
; hl = table start address
; returns struct member address in hl
; limitations -
; 1) index * length cannot be larger than 64k
; 2) length of struct member cannot be greater than 256 bytes
dkGetStructMemberAddr::
	push	hl
	mul
	pop	hl
	add	hl,bc
	ld		c,a
	ld		b,0
	add	hl,bc
	lret
#endasm

///////////////////////////////////////////////////////////////
/*			Watch expression handling 									 */
///////////////////////////////////////////////////////////////

/*** BeginHeader dkAddWatch, dkDeleteWatch, dkDeleteAllWatches, dkExecuteWatch,
	  dkExecuteAllWatches, dkSendWatches, dkWatchIndex, dkWatchExpression */
__root void dkAddWatch(void);
__xmem void dkDeleteWatch(void);
__xmem void dkDeleteAllWatches(void);
__xmem void dkExecuteWatch(void);
__xmem void dkExecuteAllWatches(void);
__xmem void dkSendWatches(void);
extern unsigned int dkWatchIndex;
extern TypedArg dkWatchExpression;
extern int dkStructWatchBufferOffset;
#if (DK_ENABLE_WATCHEXPRESSIONS == 1)
extern struct __dkwatch dkWatchTable[DK_MAX_WATCHES];
extern char dkWatchCount;
#endif

/*** EndHeader */

#if (DK_ENABLE_WATCHEXPRESSIONS == 1)
char dkWatchCount;
TypedArg dkWatchExpression;
struct __dkwatch dkWatchTable[DK_MAX_WATCHES];
unsigned int dkWatchIndex;
char __dk_watchcurindex;
char __dk_watchnumleft;
unsigned int __dk_watchcurxpc;
unsigned int __dk_watchcuroffset;
unsigned int __dk_ptrexecwatchret;


#asm __root
; expects ix to contain address of watch address to add to table and
; a to contain the size of the watch being added.  This function must be
; in root since lxpc:ix point to a system buffer containing the watch to add
dkAddWatch::
	ex		af,af'
	ld		a,(dkWatchCount)			; don't add a watch if the table is full
	cp		DK_MAX_WATCHES
	ret	z

	bool	hl
	ld		l,h
	ld		a,(dkWatchCount)
	ld		l,a
	ex		de,hl							; de = logical index into watch table
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable
	ld		a,__dkwatch+Address

	ex		jk',hl                        ; preserving lxpc here required for
	ld		hl,lxpc                       ;  watches to work for xmem code
	push	hl
	ex		jk',hl
	call	dkGetStructMemberAddr			; get base address of bp struct from hash table
	ex		jk',hl
	pop	hl
	ld		lxpc,hl
	ex		jk',hl

	ex		de,hl
	ld		hl,ix
	ld		bc,__dkwatch+Size-Address
	ldir
	ex		af,af'
	ld		(de),a						; put size of watch after address
	ld		hl,dkWatchCount
	inc	(hl)
	ret
#endasm

#asm __xmem

; expects de to contain the index to delete
; returns with zero flag set if attempting to delete from empty table
; This function first determines the number of bytes to copy to
; slide all of the compiled watch code down once the desired watch is
; deleted.  All compiled watches after the deleted watch are moved down
; to cover the hole left by the deleted watch.  The watch is then deleted
; from dkWatchTable, and each starting address for each watch in
; dkWatchTable is then modified to reflect its new starting address. End of
; watch code is computed as the starting address of the last watch in the
; table + its size and this value is returned to DC so the compiler knows
; where to compile the next watch.
; Returns next free address to compile watch in hl.
dkDeleteWatch::
	; need to make sure that index is not beyond end of list!
	ld		a,(dkWatchCount)
	cp		0
	jr		nz,__dk_dwindexok
	lret

__dk_dwindexok:
	ld		hl',de						; hl' = index to delete in table
	xor	a
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	ld		iy,hl							; iy = start address of watch to delete in table

	ld		hl,(iy+__dkwatch+Size)
	ex		de',hl						; de' = size of watch deleted

	ld		a,(dkWatchCount)
	dec	a
	cp		e
	jp		z,__dk_dwdone

	; determine number of bytes to copy to move compiled watch code
;	BytesToCopy =
;	(dkWatchTable[dkWatchCount - 1].Address + dkWatchTable[dkWatchCount - 1].Size) -
;	(dkWatchTable[index].Address + dkWatchTable[index].Size);

	; remove compiled watch code
	inc	de								; increment de to next watch in table
	ld		a,__dkwatch+Address
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	ld		hl,(hl)
	push	hl								; hl = start address for bytes to copy

	ld		de,(dkWatchCount)
	ld		d,0
	dec	de
	ld		a,0
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	ld		ix,hl
	ld		hl,(hl+__dkwatch+Address)	; hl = end address of bytes to copy upon return

	xor 	a								; clear carry
	pop	de
	sbc	hl,de							; end - start = length of bytes to copy
	jr		nz,__dk_dwmovewatches
	ld		hl,(ix+__dkwatch+Size)	; at end of list, just copy size of last watch

__dk_dwmovewatches:
	ld		b,h								; bc = number of bytes to copy
	ld		c,l								; de = destination address for bytes to copy
	ld		hl,(iy+__dkwatch+Address)	; hl = source address for bytes to copy
	ex		de,hl								; source,destination reversed????
	ldir										; shift all compiled watches down

	; remove watch from watch table
	ld		de,__dkwatch+@LENGTH
	ld		hl,iy
	add	hl,de
	push	hl								; sp = number of bytes to remove

	xor	a
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable
	ld		de,(dkWatchCount)
	ld		d,0

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	xor	a								; clear carry flag
	pop	de
	sbc	hl,de
	ld		b,h
	ld		c,l
	ld		hl,iy
	ex		de,hl
	jr		z,__dk_dwdone				; if z was set from sbc, bc is zero - done
	ldir									; remove watch from table

	; set start address for each of the moved watches in table
	bool	hl
	ld		hl,(dkWatchCount)
	altd	ex	de,hl						; de = index to delete (was in hl')
	sbc	hl,de
	dec	hl
	ld		b,l							; b = number of watches to update

__dk_dwupdateaddress:
	push 	bc
	ld		a,__dkwatch+Address
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	ld		ix,hl
	ld		hl,(hl)
	inc	de
	ex		de,hl'						; hl' = next index to update
	exx
	ld		de',de
	exx									; de = size of watch being deleted
	xor	a
	sbc	hl,de							; hl = new watch address
	ld		(ix),hl
	ex		de,hl'						; de = next index to update
	pop	bc
	djnz	__dk_dwupdateaddress

__dk_dwdone:
	ld		hl,dkWatchCount			; decrement the watch count
	dec	(hl)
	lret
#endasm

#asm __xmem
dkDeleteAllWatches::
	xor	a
	ld		(dkWatchCount),a
	ld		bc,sizeof(dkWatchTable)
   ld		hl,dkWatchTable
   call	dkcClearMemory
	lret
#endasm

#asm __root
; expects index of watch to execute in de
__dk_executewatch::
	ld		hl,lxpc							; save current lxpc
	ld		(__dk_watchcurxpc),hl

	xor 	a									; want the start address of structure
	ld		bc,__dkwatch+@LENGTH
	ld		hl,dkWatchTable

	call	dkGetStructMemberAddr			; get base address of bp struct from hash table

	push	hl

	; disable rst entry points to debug kernel
	#ifdef DK_ENABLE_ASMSINGLESTEP
   lcall	dkDisableRST18
	#endif
	#if (DK_ENABLE_BREAKPOINTS == 1)
   lcall	dkDisableRST20
	#endif
   lcall	dkDisableRST28

   pop	hl

	ld		ix,hl								; ix = start of watch in table
	ld		(__dk_watchcuroffset),hl
	ld		de,__dkwatch+Address
	add	ix,de
	ld		hl,(ix+2)
   ld		lxpc,hl
	ld		hl,(ix)							; lxpc:hl = watch address
	ld		ix,(dkRegisters+__dkregisters+_ix) ; restore ix for useix functions
	ld		de,__dk_ewreturn

	push	de									; push return on stack before running watch

   ;disable HW breakpoint interrupt code
   ld     a, 0x00
   ld    (dkHWBP_enabled),a

	jp		(hl)

__dk_ewreturn:
   ;reenable HW breakpoint interrupt code
   ld    a, 0x01
   ld    (dkHWBP_enabled),a
	ld		de,(__dk_watchcuroffset)	; de = address expression result in table
	ld		hl,dkWatchExpression
	ld		bc,__dkwatch+Address
	ldir										; copy watch value to correct location in table

	; re-enable rst entry points to debug kernel
	#ifdef DK_ENABLE_ASMSINGLESTEP
	lcall	dkEnableRST18
	#endif
	#if (DK_ENABLE_BREAKPOINTS == 1)
	lcall	dkEnableRST20
	#endif
	lcall	dkEnableRST28

	ld		hl,(__dk_watchcurxpc)		; restore lxpc
   ld		lxpc,hl
	ld		hl,(__dk_ptrexecwatchret)	; get return address
	jp		(hl)								; jump to proper ret addr
#endasm

int dkStructWatchBufferOffset;

#asm __xmem
dkExecuteWatch::
	xor	a
	ld		(dkRequest),a
	ld		de,(dkWatchIndex)
	ld		hl,__dk_ewret
	ld		(__dk_ptrexecwatchret),hl
	jp		__dk_executewatch
__dk_ewret:
	ld		a,(dkRST28State)
   cp		_OP_JP
   jr		nz,__dk_ewdisablerst28
	lcall	dkEnableRST28
   jr		__dk_ewrst28done
__dk_ewdisablerst28:
   lcall	dkDisableRST28
__dk_ewrst28done:
	ld		a,(dkRST20State)
   cp		_OP_JP
   jr		nz,__dk_ewdisablerst20
	lcall	dkEnableRST20
   jr		__dk_ewrst20done
__dk_ewdisablerst20:
   lcall	dkDisableRST20
__dk_ewrst20done:
	call	dkSendWatches
	ld		a,(dkStatusFlags)				; clear watch status flag
   res	DKF_STAT_INWATCH,a
   ld		(dkStatusFlags),a
	jp		dkCore

dkExecuteAllWatches::
   ld    a,(dkInBiosStack)
   or    a
   jr    nz,__dk_eawdone
	ld		a,(dkWatchCount)				; make sure watch table is not empty
	cp		0
	jr		z,__dk_eawdone

	ld		a,(dkStatusFlags)				; set watch status flag
   set	DKF_STAT_INWATCH,a
   ld		(dkStatusFlags),a

	lcall	dkDisableRST28

	ld		a,(dkWatchCount)
	ld		b,a
	ld		(__dk_watchnumleft),a
	xor	a
	ld		(__dk_watchcurindex),a
   bool  hl
   ld    l,h
   ld    (dkStructWatchBufferOffset),hl

__dk_eawexecwatch:						; while there are still watches, execute them
	ld		d,0
	ld		a,(__dk_watchcurindex)
	ld		e,a
	ld		hl,__dk_eawexecret
	ld		(__dk_ptrexecwatchret),hl
	jp		__dk_executewatch
__dk_eawexecret:
	ld		hl,__dk_watchcurindex
	inc	(hl)
	ld		a,(__dk_watchnumleft)
	ld		b,a
	ld		hl,__dk_watchnumleft
	dec	(hl)
	djnz	__dk_eawexecwatch

__dk_eawdone:
	ld		a,(dkRST20State)
   cp		_OP_JP
   jr		nz,__dk_eawdisablerst20
	lcall	dkEnableRST20
   jr		__dk_eawrst20done
__dk_eawdisablerst20:
   lcall	dkDisableRST20
__dk_eawrst20done:
	ld		a,(dkRequest)					; get current command
	cp		TC_DEBUG_EXECALLWATCHES		; check to see if explicitly running watches
	jr		nz,__dk_eawend					; if not, defer sending watches
	xor	a
	ld		(dkRequest),a
	ld		a,(dkStatusFlags)				; clear watch status flag
   res	DKF_STAT_INWATCH,a
   ld		(dkStatusFlags),a
#if (DK_ENABLE_TRACING == 1)
	ld		hl,dkTraceFlags
   bit	DKF_TRACE_ON,(hl)
   jr		z,__dk_eawdone_0
   ld		hl,dkTraceFlags
   bit   DKF_TRACE_WATCH,(hl)
   jr		z,__dk_eawdone_0
   lret
__dk_eawdone_0:
#endif
	jp		dkCore
__dk_eawend:
	xor	a
	ld		(dkRequest),a
	ld		a,(dkStatusFlags)				; clear watch status flag
   res	DKF_STAT_INWATCH,a
   ld		(dkStatusFlags),a
	ljp	__dk_eawret

dkSendWatches::
	ld		hl,dkWatchTable					; hl has pointer to watchtable
	ld		bc,sizeof(dkWatchTable)			; bc has length of watchtable
	ld		d,TC_TYPE_DEBUG					; d has packet type
	ld		e,TC_DEBUG_WATCHDATA				; e has packet subtype

	call	dkRespond							; send packet
	lret
#endasm

#else
#asm __root
dkAddWatch::
	ret
#endasm
#asm __xmem
dkDeleteWatch::
dkDeleteAllWatches::
dkExecuteWatch::
dkExecuteAllWatches::
dkSendWatches::
	lret
#endasm

#endif

/*** BeginHeader dkDoWatchExpression*/
__nodebug __root Typed dkDoWatchExpression();
enum DKSymbolType {
	_DK_T_CHAR = 1,
	_DK_TINT = 2,
	_DK_TUNSIGNED = 3,
	_DK_TLONG = 4,
	_DK_TULONG = 5,
	_DK_TFLOAT = 7,
	_DK_TSTRING = 9,
   _DK_TSIGNEDCHAR = 13,  // Signed char type
	_DK_TSTRUCT = 16
};

#if (DK_ENABLE_WATCHEXPRESSIONS == 1)
extern unsigned long dkStructWatchMem;
#asm
__dkDoWatchExpression: equ dkDoWatchExpression
#endasm
#endif
/*** EndHeader */

#if (DK_ENABLE_WATCHEXPRESSIONS == 1)
// use old style non-prototype declaration to inhibit type checking
//nodebug Typed dkDoWatchExpression(WatchExpression)

#define _DK_POINTER 2
#define _DK_ID_MASK 3
unsigned long dkStructWatchMem;

__nodebug __root
Typed
dkDoWatchExpression(WatchExpression)
TypedArg WatchExpression;
{
	#GLOBAL_INIT
   {
   	dkStructWatchMem = xalloc(_DK_WATCH_MEM_);
   }

#if (_DK_WATCH_MEM_ != 0)
	#asm
   ;push	ix
   ;push	iy
   ;  if (WatchExpression.TypedData.Type >= _DK_TSTRUCT)
   ;  {
   ld		hl,_DK_WATCH_MEM_
   bool	hl
   jr    z,.dwe_na
   ld	  	de,[WatchExpression]+TypedData+Type
   ld	  	hl,WatchExpression
   add  	hl,sp
   add  	hl,de
   ld	  	hl ,(hl)
   cp    hl, _DK_TSTRUCT
   jr	  	z,.dwe_Type_GE_TSTRUCT
	jr    nc,.dwe_Type_GE_TSTRUCT

.dwe_na:

	jp		.dwe_end

.dwe_Type_GE_TSTRUCT:
   ld	  	de,[WatchExpression]+TypedData+Mods
   ld	  	hl,WatchExpression
   add	hl,sp
   add	hl,de
   ld		a,(hl)
   and   a, _DK_ID_MASK
   cp    _DK_POINTER
   jp		z,.dwe_end

   ;      if (WatchExpression.TypedData.Mods != _DK_POINTER)
   ;      {

.dwe_Mods_NE_POINTER:
   ld		de,[WatchExpression]+TypedData+Size
   ld		hl,WatchExpression
   add	hl,sp
   add	hl,de
   ld		hl,(hl)
   ld		c,l                  ; bc: WatchExpression.TypedData.Size for ldir
   ld		b,h

   ld		hl,(dkStructWatchBufferOffset)
   add   hl,bc
   ld    de,_DK_WATCH_MEM_
   ex		de,hl
   sub   hl,de
   jr    nc,.dwe_ok           ; limit Offset+count to bufferSize
   add   hl,bc
   test	hl
   jp    z,.dwe_end           ; quit if no mem left
   ld    bc,hl

.dwe_ok:
   ld		de,[WatchExpression]+Value+Integer
   ld		hl,WatchExpression
   add	hl,sp
   add	hl,de

   ex		jk',hl
   ld		hl,lxpc
   push	hl
   ex		jk',hl
   push  hl                   ; ldir source address

   push  bc                   ; save count before reusing bc
   ld		iy,dkStructWatchMem
   ld		hl,(iy)
   ld		de,(dkStructWatchBufferOffset)
   add   hl,de
   ex    de,hl                ; de: lo word phys addr watchMem + Offset, carry?
   ld		hl,(iy+2)
   ld    bc,0
   adc   hl,bc
   ld    b,h
   ld    c,l                  ; bc: hi word phys addr watchMem + Offset + carry
   push	de
   pop	ix                   ; ix: lo byte of dest xmem address
   push	hl
   pop	iy                   ; iy: hi byte of dest xmem address
   call  dkcPhysicalToLogical ; xmem address of ldir dest now in a:hl
   ex    de,hl                ; de: ldir dest,   watchMem+Offset (xmem address)
   ex		jk,hl
   ld    lxpc,hl
   pop   bc                   ; bc: ldir count,  WatchExpression.TypedData.Size
   pop   hl                   ; hl: ldir source, &WatchExpression.Value union
   push	hl                   ; Address, to update with xmem dest after ldir
   push	bc

   ldir                       ; source is &WatchExpression.Value on stack, 1st 4
                              ;  bytes of struct, the rest were pushed on stack
   pop	bc                   ; bc=0 after ldir, now is 16 bit Size (count)
   ld		hl,(dkStructWatchBufferOffset)
   add	hl,bc
   ld    (dkStructWatchBufferOffset),hl ; dkStructWatchBufferOffset += ..Size

   push	ix
   pop	hl
   push	iy
   pop	bc
   pop   ix                   ; &WatchExpression.Value union
   ld		(ix),hl              ; lo word phys addr to WatchExpression.Value.Addr
   ld		h,b
   ld		l,c
   ld		(ix+2),hl            ; hi word phys addr to WatchExpression.Value.Addr
   pop	hl
   ld		lxpc,hl

.dwe_end:
	;pop	iy
	;pop	ix
   #endasm
#endif // (_DK_WATCH_MEM_ != 0)

	dkWatchExpression = WatchExpression; // WatchExpression.Value already updated
}
#endif



/*** BeginHeader dkGetCharFromStdio, dkCharData, dkCharReady, dkSendChar */
__xmem void dkGetCharFromStdio(void);
extern char dkCharData;
extern unsigned int dkCharReady;
struct __dksendchar
{
   unsigned char  chartosend;
   unsigned int   charcount;
   unsigned char  retransmit;
};
struct __dksendchar dkSendChar;

/*** EndHeader */

char dkCharData;
unsigned int dkCharReady;

#asm __xmem
dkGetCharFromStdio::
	push	ix
	ld		hl,dkLocks

   ld 	bc,5
   xor	a
   ld		(dkSendChar+__dksendchar+retransmit),a
.retry:
.getlock:
	bit	DKF_GETCHAR_LOCK,(hl)
	set	DKF_GETCHAR_LOCK,(hl)
	jr		nz,.getlock

   res	DKF_GETCHARTIMEOUT_LOCK,(hl)
   push	bc
	ld		e,TC_DEBUG_SENDCHAR
	ld		bc,sizeof(dkSendChar)
   ld		hl,dkSendChar
	call	dkRespond

	call	dkSetGetCharTimer
__dk_gcfswaitforlock:
	call	dkPollSerialPort
	call	dkCheckGetCharTimeOut
	ld		hl,dkLocks
	bit	DKF_GETCHAR_LOCK,(hl)
	jr		nz,__dk_gcfswaitforlock
   bit	DKF_GETCHARTIMEOUT_LOCK,(hl)
   pop	bc
   jr		z,.done
   ld    a,1
   ld		(dkSendChar+__dksendchar+retransmit),a
   dwjnz .retry
.done:
	pop	ix
	lret
#endasm

#if (DK_ENABLE_TRACING == 1)
#asm __xmem
dkSendTrace::
	push	af
	ex		af,af'
	push	af
	push	bc
	push	de
	push	hl
	exx
	push	bc
	push	de
	push	hl
	push	ix
	push	iy

	call	dkProlog

; assign dkDebugTraceMsg.type
	ld		hl,dkDebugTraceMsg+__dkDebugTraceMsg+type
   xor	a
   ld		(hl),a
   ld		a,(dkTraceFlags)
   bit	DKF_TRACE_ON,a
   jr		nz,.__dk_sendtracefentry
   bit   DKF_TRACE_MACRO,a
   jp		z,.__dk_sendtracedone
.__dk_sendtracefentry:
   bit	DKF_TRACE_FENTRY,a
   jr		z,.__dk_sendtrace_fexit
   set   DK_TRACEMSG_FENTRY,(hl)
   jr    .__dk_sendtracechecklock
.__dk_sendtrace_fexit:
   bit	DKF_TRACE_FEXIT,a
   jr		z,.__dk_sendtrace_macro
   set   DK_TRACEMSG_FEXIT,(hl)
   jr    .__dk_sendtracechecklock
.__dk_sendtrace_macro:
   bit	DKF_TRACE_MACRO,a
	res	DKF_TRACE_MACRO,a            ; **
   ld		(dkTraceFlags),a             ; **
   jr		z,.__dk_sendtrace_rst
   set   DK_TRACEMSG_MACRO,(hl)
   jr    .__dk_sendtracechecklock
.__dk_sendtrace_rst:
   set   DK_TRACEMSG_RST,(hl)
.__dk_sendtracechecklock:
	ld		a,(dkStatusFlags)
   bit	DKF_STAT_STEPMODE,a
   jr		z,.__dk_sendtracerun
	ld		a,(dkStepFlags)
   bit	DKF_STEP_OVER,a
   jr		z,.__dk_sendtracepostrun
   set   DK_TRACE_STEPPING,(hl)
   push	hl
	ld		hl,(dkEntryCount)
   bool	hl
   pop	hl
	jr		z,.__dk_sendtracepostrun
.__dk_sendtracerun:
   set   DK_TRACE_RUNNING,(hl)
.__dk_sendtracepostrun:
	call	dkPollSerialPort
	ld		hl,dkLocks
	bit	DKF_STDIO_LOCK,(hl)
	set	DKF_STDIO_LOCK,(hl)
	jr		nz,.__dk_sendtracepostrun

c   dkDebugTraceMsg.registers = dkRegisters;
	ld		hl,dkDebugTraceMsg
	ld		bc,sizeof(dkDebugTraceMsg)
	ld		d,TC_TYPE_DEBUG				; d has packet type
	ld		e,TC_DEBUG_TRACEMSG			; e has packet subtype

	call	dkRespond						; send packet (bc has length)

	ld		a,(dkStatusFlags)				; get status flags
	bit	DKF_STAT_INWATCH,a			; check if watch is executing
	jr		z,.__dk_sendtracenotinwatch; jump if not executing watch expression
   call	dkUnlockStdio					; this is a watch, clear stdio lock
	jr		.__dk_sendtracedone

.__dk_sendtracenotinwatch:
	call	dkSetStdioTimer

.__dk_sendtracewaitforlock:
	call	dkPollSerialPort
	call	dkCheckStdioTimeOut
	bool	hl
   jr		nz,.__dk_sendtracedone
	ld		hl,dkLocks
	bit	DKF_STDIO_LOCK,(hl)
	jr		nz,.__dk_sendtracewaitforlock

.__dk_sendtracedone:
	call	dkEpilog

	pop	iy
	pop	ix
	pop	hl
	pop	de
	pop	bc
	exx
	pop	hl
	pop	de
	pop	bc
	pop	af
	ex		af,af'
	pop	af
	lret
#endasm
#endif

/*** BeginHeader dkSendStdio */
__xmem void dkSendStdio(void);
/*** EndHeader */
#asm __xmem
; expects hl to contain address of zero-terminated string to send
dkSendStdio::
	push	ix
	ld		ix,hl							; save address in ix

	call	dkProlog

__dk_sschecklock:
	ld		hl,dkLocks
	bit	DKF_STDIO_LOCK,(hl)
	set   DKF_STDIO_LOCK,(hl)

__dk_ssgotlock:
	ld		bc,0							; set bc to zero
	ld		hl,ix							; restore pointer to string

__dk_ssloop:
	ld		a,(hl)						; check byte for 0 terminator
	or		a								; check if current byte is 0
	jr		z,__dk_ssatend				; found end
	inc	bc								; bump counter
	inc	hl								; move to next byte
	jr		__dk_ssloop

__dk_ssatend:
	ld		hl,ix							; restore pointer to string
	ld		d,TC_TYPE_DEBUG			; d has packet type
	ld		e,TC_DEBUG_STDIO			; e has packet subtype

	call	dkRespond					; send packet (bc has length)

	ld		a,(dkStatusFlags)			; get status flags
	bit	DKF_STAT_INWATCH,a		; check if watch is executing
	jr		z,__dk_ssnotinwatch		; jump if not executing watch expression
   call	dkUnlockStdio				; this is a watch, clear stdio lock
	jr		__dk_ssdone

__dk_ssnotinwatch:
	call	dkSetStdioTimer

__dk_sswaitforlock:
	call	dkPollSerialPort
	call	dkCheckStdioTimeOut
	bool	hl
	jr		nz,__dk_ssdone
	ld		hl,dkLocks
	bit	DKF_STDIO_LOCK,(hl)
	jr		nz,__dk_sswaitforlock

__dk_ssdone:
	call	dkEpilog

	pop	ix
	lret
#endasm

/*** BeginHeader dkRespond */
__root void dkRespond(void);
/*** EndHeader */

#asm __root
; expects -
; jk: source lxpc
; hl: pointer to root data buffer
; bc: length of data
; e : subtype of packet
dkRespond::
	jp		dkBuildResponse
	ret
#endasm

/*** BeginHeader dkEnableRST28, dkDisableRST28 */
__xmem void dkEnableRST28(void);
__xmem void dkDisableRST28(void);
__xmem void dkEnableRST20(void);
__xmem void dkDisableRST20(void);
__xmem void dkEnableRST18(void);
__xmem void dkDisableRST18(void);

#define DKF_RST_RST28	0
#define DKF_RST_RST20	1
#define DKF_RST_RST18	2

/*** EndHeader */

#asm __xmem
dkEnableRST28::
   xor	a
   ioi	ld (BDCR),a
   lret
dkDisableRST28::
   ld		a,0x80
   ioi	ld (BDCR),a
   lret

dkEnableRST20::
	ld		a,_OP_JP
   ld		(INTVEC_BASE+RST20_OFS),a
   lret
dkDisableRST20::
	ld		a,_OP_RET
   ld		(INTVEC_BASE+RST20_OFS),a
   lret


dkEnableRST18::
	ld		a,_OP_JP
   ld		(INTVEC_BASE+RST18_OFS),a
   lret
dkDisableRST18::
	ld		a,0xc9
   ld		(INTVEC_BASE+RST18_OFS),a
   lret
#endasm

/*** BeginHeader */
#endif
/*** EndHeader */

