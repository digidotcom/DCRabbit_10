/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
BOARDTYPES.LIB

DESCRIPTION:   Definition of board types. Includes board type macro
               definitions and board-specific initializations. This
               file is intended to be included at the top of the BIOS,
               and should only contain board-specific initalizations.

NOTES:      1) Most of the initialization macros are defined with a
               default value in the macro defaults section. Board-
               specific initializations #undef any of these macros that
               need to be changed. This way, board-specific changes do
               not affect the BIOS or code for other boards. In special
               cases, board-specific macros may be created, if none of
               the existing macros are sufficient.
            2) Only macros that are defined by the compiler or defined
               in this file should be used for the board-specific
               initializations below.

END DESCRIPTION **********************************************************/

/*** BeginHeader */

//Without a known board type it is impossible to proceed with compilation.
#ifndef _BOARD_TYPE_
   #error "No ID Block found on the target board."
   #fatal "Please contact Rabbit Technical Support at " \
          "http://www.digi.com/support for assistance."
#endif

// RabbitNet boards
#define RIO_PRDID 0xF0     // ID for RIO as an end device on RabbitNet

#define  RN1100A  0x1900   // RabbitNet RN1100 Digital I/O board
#define  RN1200A  0x1A00   // RabbitNet RN1200 Analog-to-Digital board
#define  RN1300A  0x1B00   // Rabbitnet RN1300 Digital-to-Analog board
#define  RN1500A  0x1C00   // Rabbitnet RN1500 Display/Keypad Module
#define  RN1600A  0x2000   // Rabbitnet RN1600 Keypad/Display Interface Card
#define  RN1400A  0x2100   // Rabbitnet RN1400 Relay Card

// Rabbit Core Module boards
#define RCM4000   0x2700   // Rabbit 4000, 59 MHz, 512K flash (16-bit),
                           //  512K SRAM (16-bit), 32MB Nand flash, analog
#define RCM4000A  0x2702   // Rabbit 4000, 59 MHz, 512K flash (16-bit),
                           //  512K SRAM (16-bit), 32MB Nand flash, analog
#define RCM4010   0x2701   // Rabbit 4000, 59 MHz, 512K flash (16-bit),
                           //  512K SRAM (16-bit)
#define RCM4050   0x2703   // Rabbit 4000, 59 MHz, 1MB flash (16-bit),
                           //  1MB SRAM (16-bit), 32MB Nand flash
#define RCM4000_SERIES     ((_BOARD_TYPE_ & 0xFF00) == RCM4000)

#define RCM4100   0x2800   // Rabbit 4000, 59 MHz, 512K flash, 512K+512K SRAM,
                           //  analog
#define RCM4110   0x2801   // Rabbit 4000, 29 MHz, 512K flash, 512K SRAM
#define RCM4120   0x2802   // Rabbit 4000, 59 MHz, 512K flash, 512K+512K SRAM
#define RCM4100_SERIES     ((_BOARD_TYPE_ & 0xFF00) == RCM4100)

#define RCM4200   0x2900   // Rabbit 4000, ASIX, 59 MHz, 512K flash, 512K SRAM,
                           //  512K FSRAM, 8M sflash
#define RCM4210   0x2901   // Rabbit 4000, ASIX, 29 MHz, 512K flash, 512K SRAM,
                           //  4M sflash
#define RCM4200_SERIES     ((_BOARD_TYPE_ & 0xFF00) == RCM4200)

#define RCM4300   0x2A00   // Rabbit 4000, ASIX, 59 MHz, 2M sflash (shared),
                           //  512K SRAM, 1M FSRAM, analog, SDcard socket
#define RCM4310   0x2A01   // Rabbit 4000, ASIX, 59 MHz, 1M sflash (shared),
                           //  512K SRAM, 512K FSRAM, SDcard socket
#define RCM4320   0x2A02   // Rabbit 4000, ASIX, 59 MHz, 4M sflash (shared),
                           //  512K SRAM, 1M FSRAM, SDcard socket
#define RCM4300_SERIES     ((_BOARD_TYPE_ & 0xFF00) == RCM4300)

#define RCM4400W  0x2C00   // Rabbit 4000, 59 MHz, 512K flash, 512K SRAM,
                           //  512K FSRAM, 802.11b wireless
#define RCM4400W_SERIES    ((_BOARD_TYPE_ & 0xFF00) == RCM4400W)

#define  RCM4500W 0x2B00   // reserved
#define  RCM4510W 0x2B01   // Rabbit 4000, 29MHz, 512K SRAM, 512K Flash, XBee
#define  RCM4500W_SERIES   ((_BOARD_TYPE_ & 0xFF00) == RCM4500W)

#define RCM5400W  0x2E00   // Rabbit 5000, 74 MHz, 512K flash, 512K SRAM,
                           //  512K FSRAM, 802.11b/g wireless
#define RCM5450W  0x2E50   // Rabbit 5000, 74 MHz, 1M flash, 512K SRAM,
                           //  1M FSRAM, 802.11b/g wireless
#define RCM5400W_SERIES    ((_BOARD_TYPE_ & 0xFF00) == RCM5400W)

#define RCM5700   0x3100   // Rabbit 5000, 50 MHz, 1M flash, 128K internal SRAM
#define RCM5710   RCM5700  // Rabbit 5000, 50 MHz, 1M flash, 128K internal SRAM
#define RCM5750   0x3101   // Rabbit 5000, 50 MHz, 1M flash, 512K FSRAM,
                           //  128K int. SRAM, 2M sflash
#define RCM5760   RCM5750  // Rabbit 5000, 50 MHz, 1M flash, 512K FSRAM,
                           //  128K int. SRAM, 2M sflash
#define RCM5700_SERIES     ((_BOARD_TYPE_ & 0xFF00) == RCM5700)

#define RCM5600W  0x3200   // Rabbit 5000, 74MHz, 1M sflash, 1M SRAM (16-bit),
                           //  128K internal SRAM, 802.11b/g wireless
#define RCM5650W  0x3201   // Rabbit 5000, 74MHz, 4M sflash, 1M SRAM (16-bit),
                           //  128K internal SRAM, 802.11b/g wireless
#define RCM5600W_SERIES    ((_BOARD_TYPE_ & 0xFF00) == RCM5600W)

#define RCM6600W  0x3500   // Rabbit 6000, 162 MHz, 1M sflash, 1M+32K int. RAM,
                           //  802.11b/g wireless
#define RCM6650W  0x3501   // Rabbit 6000, 162 MHz, 4M sflash, 1M+32K int. RAM,
                           //  1M ext. SRAM, 802.11b/g wireless
#define RCM6600W_SERIES    ((_BOARD_TYPE_ & 0xFF00) == RCM6600W)

#define RCM6700   0x3400   // Rabbit 6000, 162 MHz, 1M sflash, 1M+32K int. RAM
#define RCM6710   0x3402   // Rabbit 6000, 162 MHz, 1M sflash, 1M+32K int. RAM,
                           //  10/100 Ethernet Jack
#define RCM6720   0x3401   // Rabbit 6000, 162 MHz, 4M sflash, 1M+32K int. RAM
#define RCM6730   0x3403   // Rabbit 6000, 162 MHz, 4M sflash, 1M+32K int. RAM,
                           //  10/100 Ethernet Jack
#define RCM6750   0x3404   // Rabbit 6000, 162 MHz, 4M sflash, 1M+32K int. RAM,
                           //  1M ext. SRAM
#define RCM6760   0x3405   // Rabbit 6000, 162 MHz, 4M sflash, 1M+32K int. RAM,
                           //  1M ext. SRAM, 10/100 Ethernet Jack
#define RCM6700_SERIES     ((_BOARD_TYPE_ & 0xFF00) == RCM6700)

// Rabbit (CPU or Core Module based) SBCs
#define BL4S100   0x2F00   // BL4S100, 40MHz, 1M sflash, 512K FSRAM, 512K SRAM,
                           //  XBee
#define BL4S110   0x2F01   // BL4S110, 40MHz, 1M sflash, 512K FSRAM, 512K SRAM
#define BL4S150   0x2F02   // BL4S150, 40MHz, 2M sflash, 1M FSRAM, 512K SRAM,
                           //  XBee
#define BL4S160   0x2F03   // BL4S160, 40MHz, 2M sflash, 1M FSRAM, 512K SRAM
#define BL4S100_SERIES     ((_BOARD_TYPE_ & 0xFF00) == BL4S100)

#define R6000TEST  0x4000
#define R6000TESTW 0xFE00
#define R6000TEST_SERIES   (((_BOARD_TYPE_ & 0xFF00) == R6000TEST) || \
                            ((_BOARD_TYPE_ & 0xFF00) == R6000TESTW))

// Force use of internal RAM for 6000 fpga
#if R6000TEST_SERIES
  #ifdef CS_RAM
    #undef CS_RAM
    #define CS_RAM 0x03
  #endif
  #define NUM_RAM_WAITST     2     // Set wait states for running in /CS1 RAM
  #define NUM_FLASH_WAITST   4
#endif

// On certain boards, the WDTOUT asserts the RESET.
// On these boards, a reset status of watchdog time out
// cannot be detected. They should be listed here to flag
// that condition.
#if RCM4300_SERIES || BL4S100_SERIES || R6000TEST_SERIES
   #define _WDTO_ASSERTS_RESET_
#endif

//*********************************************************************
//***** Memory Device Configuration Defaults and Options **************
//*********************************************************************

// Macros for setting MBxCR - Memory Bank Control Registers
#define CS0OE0  0x00 // CS0/OE0/WE0
#define CS0OE1  0x04 // CS0/OE1/WE1
#define CS1OE0  0x01 // CS1/OE0/WE0
#define CS1OE1  0x05 // CS1/OE1/WE1
#define CS2OE0  0x02 // CS2/OE0/WE0
#define CS2OE1  0x06 // CS2/OE1/WE1
#define CS3OE0  0x03 // CS3/OE0/WE0 - available on Rabbit 5000 (internal RAM)
#define CS3OE1  0x07 // CS3/OE1/WE1 - available on Rabbit 6000 (internal BBRAM)

#define WSTATES0 0xC0
#define WSTATES1 0x80
#define WSTATES2 0x40
#define WSTATES4 0x00

// Macros for setting ACSxCR - Advanced Chip Select Control Registers
#if (CPU_ID_MASK(_CPU_ID_) == R4000)
	#define ACSCR_READ_WS7		0x00
	#define ACSCR_READ_WS6		0x20
	#define ACSCR_READ_WS5		0x40
	#define ACSCR_READ_WS4		0x60
	#define ACSCR_READ_WS3		0x80
	#define ACSCR_READ_WS2		0xA0
	#define ACSCR_READ_WS1		0xC0

	#define ACSCR_LATER_WS3    0x00
	#define ACSCR_LATER_WS2    0x08
	#define ACSCR_LATER_WS1    0x10
	#define ACSCR_LATER_WS0    0x18

	#define ACSCR_WRITE_WS9		0x00
	#define ACSCR_WRITE_WS8		0x01
	#define ACSCR_WRITE_WS7		0x02
	#define ACSCR_WRITE_WS6		0x03
	#define ACSCR_WRITE_WS5		0x04
	#define ACSCR_WRITE_WS4		0x05
	#define ACSCR_WRITE_WS3		0x06
#else
	#define ACSCR_FIRST_WS0    0x00
	#define ACSCR_FIRST_WS1    0x20
	#define ACSCR_FIRST_WS2    0x40
	#define ACSCR_FIRST_WS3    0x60
	#define ACSCR_FIRST_WS4    0x80
	#define ACSCR_FIRST_WS5    0xA0
	#define ACSCR_FIRST_WS6    0xC0
	#define ACSCR_FIRST_WS7    0xE0

	#define ACSCR_LATER_WS0    0x00
	#define ACSCR_LATER_WS1    0x08
	#define ACSCR_LATER_WS2    0x10
	#define ACSCR_LATER_WS3    0x18

 #if CPU_ID_MASK(_CPU_ID_) >= R6000
	#define ACSCR_ADD_WS8      0x04
 #endif

	#define ACSCR_BYTE_WRITE   0x01
	#define ACSCR_PAGESIZE_8   0x02
	#define ACSCR_PAGESIZE_16  0x00
#endif

#define _MBC_CS_MASK       0x0F
#define _MBC_WS_MASK       0xC0

#define _DF_SIZE_MASK      0xFF000000
#define _DF_TYPE_MASK      0x00FF0000
#define _DF_SUB_MASK       0x0000FFFF
#define _DF_TYPE_SER       ((_DC_DFLASH0_ & _DF_TYPE_MASK) == 0x00010000)
#define _DF_TYPE_NAND      ((_DC_DFLASH0_ & _DF_TYPE_MASK) == 0x00020000)

#ifndef _DC_MD3_
   #define _DC_MD3_           0       // unknown, assume absent
#endif

#ifndef _DC_DFLASH0_
   #define _DC_DFLASH0_       0L
#endif

#ifndef _DC_BRD_OPT0_
   #define _DC_BRD_OPT0_      0L      // unknown, assume absent
#endif

// Battery-Backable RAM (BBRAM) Device Options, used in combination with the
// User defined, board-specific or default (defined later, herein)
// _BBRAMS_LOCATION macro value.
//
// The _BBRAMS_LOCATION macro, a bit-field of installed RAMs' battery-
// backability, is used to make the appropriate choice of "bbramorg" vs.
// "xmemorg" types for RAM devices' memory orgs. Bit 0 corresponds to the
// primary RAM, bit 1 to the second RAM, and so on.
//
// For example, bit 0 set (e.g. _BBRAMS_LOCATION == 0x01) indicates that the
// board's primary RAM is battery-backable (BB). If the _BBRAM1_LOCATION macro
// is nowhere else defined by the time this library's board-specific memory
// setup sections have been parsed, in keeping with traditional behavior, the
// board is assumed to have a BB primary RAM and the _BBRAM1_LOCATION macro is
// given the default value of _BBRAM1_LOCATION.
//
// Exceptions: For typical fast RAM compile capable boards the default value is
// set to _BBRAM2_LOCATION (i.e. primary RAM is non-BB but RAM2 is BB). For
// atypical fast RAM compile capable boards and for RCM57x0 boards the default
// is set to _BBRAMS_NONE (i.e. all RAM devices are non-BB).
//
// For a custom board, the User can override the _BBRAMS_LOCATION macro in the
// Project Options' Defines box.
#define _BBRAM1_LOCATION 0x01	// this bit set if primary RAM is BBRAM
#define _BBRAM2_LOCATION 0x02	// this bit set if RAM2 is BBRAM
#define _BBRAM3_LOCATION 0x04	// (future) this bit set if RAM3 is BBRAM
#define _BBRAM4_LOCATION 0x08	// (future) this bit set if RAM4 is BBRAM
#define _BBRAM5_LOCATION 0x10	// (future) this bit set if RAM5 is BBRAM
#define _BBRAM6_LOCATION 0x20	// (future) this bit set if RAM6 is BBRAM
#define _BBRAM7_LOCATION 0x40	// (future) this bit set if RAM7 is BBRAM
#define _BBRAM8_LOCATION 0x80	// (future) this bit set if RAM8 is BBRAM
#define _BBRAMS_NONE     0x00	// no battery-backable RAM device exists

//***** End of Memory Device Configuration Defaults and Options *******

//*********************************************************************
//***** PWM definitions ***********************************************
//*********************************************************************

#if _BOARD_TYPE_ == RCM4000A
   // RCM4000A has no outputs available for PWM usage
   #define PWM_ONBOARD 0
#else
   // otherwise, assume PWM outputs are available
   //  (pending check on CPU type, revision)
   #define PWM_ONBOARD 1
#endif

//***** End of PWM definitions ****************************************

//*********************************************************************
//***** _DC_BRD_OPT0_ bitmask definitions *****************************
//*********************************************************************

#define BRDOPT0_16BITFLASHMASK   0x00000001L
#define BRDOPT0_16BITRAMMASK     0x00000002L
#define BRDOPT0_ADC12ONBOARDMASK 0x00000004L
#define BRDOPT0_ADC14ONBOARDMASK 0x00000008L
#define BRDOPT0_NANDFLASHMASK    0x00000010L
#define BRDOPT0_PB1UNAVAILMASK   0x00000020L

//***** End of _DC_BRD_OPT0_ bitmask definitions **********************

//*********************************************************************
//***** Board-specific initializations ********************************
//*********************************************************************

// CS1_ALWAYS_ON incompatible with RCM5400W and RCM4200 series.
// Defining CS1_ALWAYS_ON to 1 causes Dynamic C to always assert /CS1. On the
// RCM42xx and RCM54xxW, BBRAM is on CS1/OE1, but there is also a fast SRAM on
// OE1. This causes these boards to not come up when CS1_ALWAYS_ON is true.
#if (RCM5400W_SERIES || RCM4200_SERIES) && CS1_ALWAYS_ON == 1
	#if RCM5400W_SERIES
		#error "CS1_ALWAYS_ON must not be enabled for the RCM5400W series."
	#else
		#error "CS1_ALWAYS_ON must not be enabled for the RCM4200 series."
	#endif
#endif

#if (! defined(_SERIAL_BOOT_FLASH_) || !_SERIAL_BOOT_FLASH_) && \
    (RCM5600W_SERIES || RCM4300_SERIES || BL4S100_SERIES || \
    RCM6600W_SERIES  || RCM6700_SERIES || R6000TEST_SERIES)
	#warns "_SERIAL_BOOT_FLASH_ should be defined - fix TCData.ini or UserBlock."
	#define _SERIAL_BOOT_FLASH_ 1
#endif

//if board is a fast RAM board
#if _SERIAL_BOOT_FLASH_ || _BOARD_TYPE_ == RCM4100 || _BOARD_TYPE_ == RCM4120 \
    || _BOARD_TYPE_ == RCM4200 || _BOARD_TYPE_ == RCM4500W || RCM4400W_SERIES \
    || RCM5400W_SERIES
	#define _RUN_FROM_RAM	1			// board runs firmware from fast SRAM
#else
	#define _RUN_FROM_RAM	0			// board runs firmware from parallel flash
#endif

#if _RUN_FROM_RAM
	// If RAM compile is selected, just change to fast RAM compile mode and
	// set SUPPRESS_FAST_RAM_COPY to tell the BIOS to skip the fast RAM copy.
	#if !defined TRUE_FLASH_MODE
		#if defined _RAM_
			#undef _RAM_
			#define SUPPRESS_FAST_RAM_COPY 1
		#endif
		#if defined _FLASH_
			#undef _FLASH_
		#endif
		#define _FAST_RAM_                1
	#else
		#warns "Flash mode is not supported and is designed for testing only."
	#endif

	#define RAM2_START _cexpr(1 << (MSB_BIT - 12)) //RAM2 is mapped to MB2

	#ifndef _RAM_ //if !TRUE_FLASH_MODE || (TRUE_FLASH_MODE && _FLASH_)
		#if RCM4300_SERIES || BL4S100_SERIES
			// _RAM_SIZE_ is not always correct for fast RAM boards.
			// It is safest to redefine it to the correct value.
			#undef _RAM_SIZE_
			#if _BOARD_TYPE_ == RCM4310 \
			    || _BOARD_TYPE_ ==  BL4S100 || _BOARD_TYPE_ ==  BL4S110
				#define _RAM_SIZE_    0x80	//512K
			#else
				// larger memory boards have extra FSRAM
				#define _RAM_SIZE_    0x100 //1M
				#define CS_RAM3       (CS2OE1 & _MBC_CS_MASK)
				#define RAM3_WSTATES  (WSTATES0 & _MBC_WS_MASK)
			#endif
			#define CS_RAM           (CS0OE0 & _MBC_CS_MASK)
			#define CS_RAM2          (CS1OE1 & _MBC_CS_MASK) //BB RAM
			#define RAM_WSTATES      (WSTATES0 & _MBC_WS_MASK)
			#define RAM2_WSTATES     (WSTATES2 & _MBC_WS_MASK)
			#define RAM_START        0x0
			#define RAM2_SIZE        0x80	//512K

			#if !defined XMEMCODE_SIZE && _BOARD_TYPE_ == RCM4310 \
			    && __SEPARATE_INST_DATA__
				#define XMEMCODE_SIZE 0x60000
			#endif

		#elif RCM5600W_SERIES
			#if defined BBROOTDATA_SIZE_4K && BBROOTDATA_SIZE_4K != 0
				#if __SEPARATE_INST_DATA__
//					#error "Separate I&D space is incompatible with the use of" \
//					                                           " battery-backed root"
//					#error " variables on this core module."
//					#error "Either disable separate I&D space or remove the custom"
//					#fatal " BBROOTDATA_SIZE_4K definition."
				#else
					#warns "Using battery-backed root variables will not be" \
					                                        " compatible with future"
					#warns " versions of this core module and is not recommended."
				#endif
			#else
				#undef BBROOTDATA_SIZE_4K
				#define BBROOTDATA_SIZE_4K 0
			#endif
			#undef _RAM_SIZE_
			#define _RAM_SIZE_            0x100	//1M
			#define RAM_START             0x0
			// For future compatibility reasons, only 32k of the 128k internal RAM
			//  is made available for use.
			#define RAM2_SIZE             0x08	//32k (internal RAM)
			#define CS_RAM                (CS1OE1 & _MBC_CS_MASK)
			#define CS_RAM2               (CS3OE0 & _MBC_CS_MASK)
			// wait states for primary RAM will be determined by ACS1R, not this
			#define RAM_WSTATES           (WSTATES0 & _MBC_WS_MASK)
			#define ACS1CR_SETTING        ACSCR_FIRST_WS3 | ACSCR_BYTE_WRITE
			#define RAM2_WSTATES          (WSTATES0 & _MBC_WS_MASK)

			#if !defined XMEMCODE_SIZE
				// Special value to allow larger WiFi libs to compile without
				//  complaint.
				#define XMEMCODE_SIZE      0x60000
			#endif

		#elif RCM5400W_SERIES
			#undef _RAM_SIZE_
			#if _BOARD_TYPE_ == RCM5400W
				#define _RAM_SIZE_          0x80	//512K
			#else
				//larger memory boards have extra FSRAM
				#define _RAM_SIZE_          0x100	//1M
				#define CS_RAM3             (CS2OE0 & _MBC_CS_MASK)
				#define RAM3_WSTATES        (WSTATES0 & _MBC_WS_MASK)
			#endif
			#define RUN_IN_RAM_CS          0x02
			#define CS_RAM                 (CS2OE1 & _MBC_CS_MASK)
			#define CS_RAM2                (CS1OE1 & _MBC_CS_MASK)
			#define RAM_WSTATES            (WSTATES0 & _MBC_WS_MASK)
			#define RAM2_WSTATES           (WSTATES4 & _MBC_WS_MASK)
			#define RAM2_SIZE              0x80	//512K
			#define FLASH_WSTATES          (WSTATES4 & _MBC_WS_MASK)

			#if !defined XMEMCODE_SIZE
				// Special values to allow larger WiFi libs to compile without
				//  complaint.
				#if _BOARD_TYPE_ == RCM5400W
					#define XMEMCODE_SIZE    0x60000
				#elif _BOARD_TYPE_ == RCM5450W
					#if __SEPARATE_INST_DATA__
						#define XMEMCODE_SIZE 0x90000
					#else
						#define XMEMCODE_SIZE 0x80000
					#endif
				#else
					#fatal "Error, unknown RCM54xxW board type!"
				#endif
			#endif

		#elif RCM6600W_SERIES
			#if defined _DC_CLK_DBL_ && _DC_CLK_DBL_
				#fatal "Must set _DC_CLK_DBL_ = 0 for the RCM66xxW!"
			#endif
			#if defined CLOCK_DOUBLED && CLOCK_DOUBLED
				#fatal "Must set CLOCK_DOUBLED = 0 for the RCM66xxW!"
			#endif

			#if !defined PLL_DEFAULT_PLL_SPEED_MHz
				// RCM66xxW boards run at 162.5 MHz (Rabbit's clock = PLL speed / 2)
				#define PLL_DEFAULT_PLL_SPEED_MHz   325
			#endif

			// MB0 gets the internal 1M fast RAM
			#define CS_RAM                      CS3OE0
			#undef  _RAM_SIZE_
			#define _RAM_SIZE_                  0x100
			#define RAM_START                   0x0
			#define RAM_WSTATES                 WSTATES0

			// MB2 gets the internal 32K battery-backable RAM
			#define CS_RAM2                     CS3OE1
			#define RAM2_SIZE                   0x8
			#define RAM2_WSTATES WSTATES0

			#if _BOARD_TYPE_ == RCM6600W
				#define MACR_SETTING             0x80	// normal 16 bit for /CS3
			#elif _BOARD_TYPE_ == RCM6650W
				// both RAM2 and RAM3 are battery-backable SRAMs
				#define _BBRAMS_LOCATION         (_BBRAM2_LOCATION|_BBRAM3_LOCATION)
				// MB1 gets the external 1M battery-backable SRAM
				//  (set for 9 wait states)
				#define CS_RAM3                  CS1OE1
				#define RAM3_SIZE                0x100
				#define RAM3_START               _cexpr(1 << (MSB_BIT - 13))
				#define RAM3_WSTATES             WSTATES4
				#define ACS1CR_SETTING           ACSCR_FIRST_WS5|ACSCR_BYTE_WRITE
				#define MACR_SETTING             0xA8	// normal 16 bit for all /CSx
			#else
				#fatal "Unsupported / unknown RCM6600W_SERIES board type."
			#endif

			#ifndef MECR_VALUE
				//internal 1M RAM, so default to 1M quadrant size
				#define MECR_VALUE               0x40
			#endif

			#if defined DISABLE_ETHERNET
				#define DISABLE_ENET_STATUS
			#endif
			#if !defined DISABLE_ENET_STATUS
				// enabled Ethernet link and / or activity status output(s)
				#define _ENABLED_ENET_STATUS
				#if defined ENET_ACTIVITY_ON_PE3
					#define ENET_ACTIVITY_PORT    E
					#define ENET_ACTIVITY_MASK    0x08
					#define ENET_LINK_PORT        G
					#define ENET_LINK_MASK        0x01
				#elif defined ENET_ACTIVITY_ON_PE5
					#define ENET_ACTIVITY_PORT    E
					#define ENET_ACTIVITY_MASK    0x20
					#define ENET_LINK_PORT        G
					#define ENET_LINK_MASK        0x01
				#endif
				// off-core Ethernet jack, default to PG0 combined link+activity
				#if !defined ENET_ACTIVITY_PORT
					#define ENET_ACTIVITY_PORT G
				#endif
				#if !defined ENET_ACTIVITY_MASK
					#define ENET_ACTIVITY_MASK 0x01
				#endif
				#if !defined ENET_LINK_PORT
					#define ENET_LINK_PORT     G
				#endif
				#if !defined ENET_LINK_MASK
					#define ENET_LINK_MASK     0x01
				#endif
				// create the minimum set of required _ENET_.* macros
				#define _ENET_ACT_D              CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DR))
				#define _ENET_ACT_DSHADOW        CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DRShadow))
				#define _ENET_ACT_DD             CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DDR))
				#define _ENET_ACT_DDSHADOW       CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DDRShadow))
				#define _ENET_LINK_D             CONCAT(P,CONCAT(ENET_LINK_PORT,DR))
				#define _ENET_LINK_DSHADOW       CONCAT(P,CONCAT(ENET_LINK_PORT,DRShadow))
				#define _ENET_LINK_DD            CONCAT(P,CONCAT(ENET_LINK_PORT,DDR))
				#define _ENET_LINK_DDSHADOW      CONCAT(P,CONCAT(ENET_LINK_PORT,DDRShadow))
			#endif

			#if !defined XMEMCODE_SIZE && _BOARD_TYPE_ == RCM6600W
				#if __SEPARATE_INST_DATA__
					#define XMEMCODE_SIZE         0xD0000
				#else
					#define XMEMCODE_SIZE         0xC0000
				#endif
			#endif

		#elif RCM6700_SERIES
			#if defined _DC_CLK_DBL_ && _DC_CLK_DBL_
				#fatal "Must set _DC_CLK_DBL_ = 0 for the RCM67xx!"
			#endif
			#if defined CLOCK_DOUBLED && CLOCK_DOUBLED
				#fatal "Must set CLOCK_DOUBLED = 0 for the RCM67xx!"
			#endif

			#if !defined PLL_DEFAULT_PLL_SPEED_MHz
				// RCM67xx boards run at 162.5 MHz (Rabbit's clock = PLL speed / 2)
				#define PLL_DEFAULT_PLL_SPEED_MHz   325
			#endif

			// MB0 gets the internal 1M fast RAM
			#define CS_RAM                      CS3OE0
			#undef  _RAM_SIZE_
			#define _RAM_SIZE_                  0x100
			#define RAM_START                   0x0
			#define RAM_WSTATES                 WSTATES0

			// MB2 gets the internal 32K battery-backable RAM
			#define CS_RAM2                     CS3OE1
			#define RAM2_SIZE                   0x8
			#define RAM2_WSTATES                WSTATES0

			#if _BOARD_TYPE_ == RCM6700 || _BOARD_TYPE_ == RCM6710 || \
			    _BOARD_TYPE_ == RCM6720 || _BOARD_TYPE_ == RCM6730
				#define MACR_SETTING             0x80	// normal 16 bit for /CS3
			#elif _BOARD_TYPE_ == RCM6750 || _BOARD_TYPE_ == RCM6760
				// both RAM2 and RAM3 are battery-backable SRAMs
				#define _BBRAMS_LOCATION         (_BBRAM2_LOCATION|_BBRAM3_LOCATION)
				// MB1 gets the external 1M battery-backable SRAM
				//  (set for 9 wait states)
				#define CS_RAM3                  CS1OE1
				#define RAM3_SIZE                0x100
				#define RAM3_START               _cexpr(1 << (MSB_BIT - 13))
				#define RAM3_WSTATES             WSTATES4
				#define ACS1CR_SETTING           ACSCR_FIRST_WS5|ACSCR_BYTE_WRITE
				#define MACR_SETTING             0xA8	// normal 16 bit for all /CSx
			#else
				#fatal "Unsupported / unknown RCM6700_SERIES board type."
			#endif

			#ifndef MECR_VALUE
				// internal 1M RAM, so default to 1M quadrant size
				#define MECR_VALUE               0x40
			#endif

			#if !defined DISABLE_ENET_STATUS
				// enabled Ethernet link and / or activity status output(s)
				#define _ENABLED_ENET_STATUS
				#if defined ENET_ACTIVITY_ON_PE3
					#define ENET_ACTIVITY_PORT    E
					#define ENET_ACTIVITY_MASK    0x08
					#define ENET_LINK_PORT        G
					#define ENET_LINK_MASK        0x01
				#elif defined ENET_ACTIVITY_ON_PE5
					#define ENET_ACTIVITY_PORT    E
					#define ENET_ACTIVITY_MASK    0x20
					#define ENET_LINK_PORT        G
					#define ENET_LINK_MASK        0x01
				#endif
				#if _BOARD_TYPE_ == RCM6700 || _BOARD_TYPE_ == RCM6720 || \
				    _BOARD_TYPE_ == RCM6750
					// off-core Ethernet jack, default to PG0 combined link+activity
					#if !defined ENET_ACTIVITY_PORT
						#define ENET_ACTIVITY_PORT G
					#endif
					#if !defined ENET_ACTIVITY_MASK
						#define ENET_ACTIVITY_MASK 0x01
					#endif
					#if !defined ENET_LINK_PORT
						#define ENET_LINK_PORT     G
					#endif
					#if !defined ENET_LINK_MASK
						#define ENET_LINK_MASK     0x01
					#endif
				#else
					// on-core Ethernet jack, default to PG1 link and PG2 activity
					#if !defined ENET_ACTIVITY_PORT
						#define ENET_ACTIVITY_PORT G
					#endif
					#if !defined ENET_ACTIVITY_MASK
						#define ENET_ACTIVITY_MASK 0x04
					#endif
					#if !defined ENET_LINK_PORT
						#define ENET_LINK_PORT     G
					#endif
					#if !defined ENET_LINK_MASK
						#define ENET_LINK_MASK     0x02
					#endif
				#endif
				// create the minimum set of required _ENET_.* macros
				#define _ENET_ACT_D              CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DR))
				#define _ENET_ACT_DSHADOW        CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DRShadow))
				#define _ENET_ACT_DD             CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DDR))
				#define _ENET_ACT_DDSHADOW       CONCAT(P,CONCAT(ENET_ACTIVITY_PORT,DDRShadow))
				#define _ENET_LINK_D             CONCAT(P,CONCAT(ENET_LINK_PORT,DR))
				#define _ENET_LINK_DSHADOW       CONCAT(P,CONCAT(ENET_LINK_PORT,DRShadow))
				#define _ENET_LINK_DD            CONCAT(P,CONCAT(ENET_LINK_PORT,DDR))
				#define _ENET_LINK_DDSHADOW      CONCAT(P,CONCAT(ENET_LINK_PORT,DDRShadow))
			#endif

			#if !defined XMEMCODE_SIZE && \
			    (_BOARD_TYPE_ == RCM6700 || _BOARD_TYPE_ == RCM6710 || \
			     _BOARD_TYPE_ == RCM6720 || _BOARD_TYPE_ == RCM6730)
				#if __SEPARATE_INST_DATA__
					#define XMEMCODE_SIZE         0xD0000
				#else
					#define XMEMCODE_SIZE         0xC0000
				#endif
			#endif

		#elif R6000TEST_SERIES
			//#warnt "BOARDTYPES.LIB recognizes this as a RCM6000"
			#if defined _DC_CLK_DBL_ && _DC_CLK_DBL_
				#fatal "Must set _DC_CLK_DBL_ = 0 for the RCM6000!"
			#endif
			#if defined CLOCK_DOUBLED && CLOCK_DOUBLED
				#fatal "Must set CLOCK_DOUBLED = 0 for the RCM6000!"
			#endif

			// DISABLE_xRAM may be defined in options box in order to eliminate
			// either or both external RAMs on the RCM6000.

			// internal 1MB fast RAM
			#undef _RAM_SIZE_
			#define _RAM_SIZE_ 0x100 //1M
			#define RAM_START 0x0
			#define CS_RAM  CS3OE0
			#define RAM_WSTATES  WSTATES0

			#ifdef DISABLE_BBRAM
				// use internal BBRAM
				#warnt "DISABLE_BBRAM defined; using internal 32K BBRAM"
				#define CS_RAM2 CS3OE1
				#define RAM2_WSTATES WSTATES0
				#define RAM2_SIZE 0x08   // 32K internal BBRAM
			#else
				//#warnt "using external 512KB BBRAM"
				#define CS_RAM2 CS1OE0
				// 200MHz = 5ns, 45ns BBRAM = 9 waitstates (4 + 5)
				#define RAM2_WSTATES WSTATES4
				#define ACS1CR_SETTING ACSCR_FIRST_WS5 | ACSCR_BYTE_WRITE
				#define RAM2_SIZE 0x80   //512K slow RAM
			#endif

			#ifdef DISABLE_FASTRAM
				#if !defined XMEMCODE_SIZE
					// split internal ram between code and data (512k each)
					#warnt "DISABLE_FASTRAM defined; internal split 512k code/data."
					#define XMEMCODE_SIZE 0x80000
				#endif
			#else
				#define RAM3_START _cexpr(1 << (MSB_BIT - 13)) //RAM3 is mapped to MB1
				#define CS_RAM3 CS2OE0
				#define RAM3_WSTATES WSTATES2
				#define RAM3_SIZE 0x100  //1M fsram
				#define ACS2CR_SETTING ACSCR_BYTE_WRITE
			#endif

			#define MACR_SETTING 0xA8	// standard 16 bit for CS1, CS2, and CS3
			//#define _ENABLE_16BIT_RAM_	// Not needed, use above override

			#ifndef MECR_VALUE
				#define MECR_VALUE 0x40	//internal 1M RAM, so use 1M quadrant size
			#endif

		#else	//some other board, use defaults
			#if _RAM_SIZE_ > 0x80
				#undef _RAM_SIZE_
				#define _RAM_SIZE_      0x80
			#endif

			#define CS_RAM             (_DC_MD2_MBC_ & _MBC_CS_MASK)	// CS2/OE1/WE1
			#define RAM_WSTATES        (_DC_MD2_MBC_ & _MBC_WS_MASK)
			#define FLASH_WSTATES      (_DC_MD0_MBC_ & _MBC_WS_MASK)

			#if _DC_MD3_
				#define RAM2_SIZE       _DC_MD3_SIZE_
				#define CS_RAM2         (_DC_MD3_MBC_ & _MBC_CS_MASK)
				#define RAM2_WSTATES    (_DC_MD3_MBC_ & _MBC_WS_MASK)
				#define RUN_IN_RAM_CS   0x2
			#endif

			#if !defined XMEMCODE_SIZE && _BOARD_TYPE_ == RCM4400W
				// Special value to allow larger WiFi libs to compile without
				//  complaint.
				#define XMEMCODE_SIZE 0x60000
			#endif
		#endif

	#else // if TRUE_FLASH_MODE && _RAM_
		#define RUN_IN_RAM_CS      0x1  // Our main program will be running in the
                                      // RAM on CS1, so tell the BIOS that we
                                      // are running on CS1

		#if RCM4100_SERIES || RCM4200_SERIES || RCM4400W_SERIES || RCM5400W_SERIES

			#define FLASH_WSTATES   (_DC_MD0_MBC_ & _MBC_WS_MASK)
			// Check for extra ram, if present use it to compile to ram
			#if _DC_MD3_
				#define CS_RAM       (_DC_MD3_MBC_ & _MBC_CS_MASK)  // CS1/OE1/WE1

				// Set wait states for running in /CS1 RAM
				#define RAM_WSTATES  (_DC_MD3_MBC_ & _MBC_WS_MASK)

				#if _RAM_SIZE_ != _DC_MD3_SIZE_
					#undef _RAM_SIZE_
					#define _RAM_SIZE_     _DC_MD3_SIZE_  // larger, 512K RAM on CS2
				#endif
			// Otherwise use primary RAM.
			#else
				#define CS_RAM           (_DC_MD2_MBC_ & _MBC_CS_MASK)  // CS1/OE1/WE1
				// Set wait states for running in /CS1 RAM
				#define RAM_WSTATES      (_DC_MD2_MBC_ & _MBC_WS_MASK)
				#if _RAM_SIZE_ != _DC_MD2_SIZE_
					#undef _RAM_SIZE_
					#define _RAM_SIZE_    _DC_MD2_SIZE_  // larger, 512K RAM on CS2
				#endif
			#endif

		#else //some other board
			#define CS_RAM          (CS1OE1 & _MBC_CS_MASK)  // CS1/OE1/WE1
			// Set wait states for running in /CS1 RAM
			#define RAM_WSTATES     (WSTATES1 & _MBC_WS_MASK)
			#define FLASH_WSTATES   (WSTATES1 & _MBC_WS_MASK)
		#endif
	#endif

	#ifndef _BBRAMS_LOCATION
		// typical fast RAM compile mode capable boards' primary RAM is fast (i.e.
		//  non-battery-backable) but RAM2 is battery-backable
		#define _BBRAMS_LOCATION _BBRAM2_LOCATION
	#endif

	#ifndef MECR_VALUE
		// typical fast RAM compile mode capable boards default to 512K quadrants
		#define MECR_VALUE 0x20
	#endif

#else // the board does not have fast RAM
	#if _BOARD_TYPE_ == RCM4050 || RCM5700_SERIES
		#define MECR_VALUE 0x20 //512k memory banks
	#else
		#define MECR_VALUE 0x00 //256k memory banks
	#endif

	#if RCM4000_SERIES
		//Usually the advanced chip select registers are used to
		//determine wait states for these boards.  However, at
		//certain points during bootup these wait states need
		//to be set correctly.  These boards are not guaranteed
		//to have the proper settings for these wait states in
		//their ID blocks, so they are explicitly set here.
		#define RAM_WSTATES (WSTATES4 & _MBC_WS_MASK)
		#define FLASH_WSTATES (WSTATES4 & _MBC_WS_MASK)

	#elif RCM5700_SERIES
		#ifdef _RAM_
			#error "RCM57xx family disallows 'Store Program in RAM' compile mode."
			#fatal "Use 'Store Program in Flash' compile mode instead."
		#endif

		#ifndef _BBRAMS_LOCATION
			// all RAM is fast (i.e. non-BB)
			#define _BBRAMS_LOCATION _BBRAMS_NONE
		#endif
		#if _BOARD_TYPE_ == RCM5700
			// RCM5700 or equivalent has only 128k of internal RAM available
			#define CS_RAM (CS3OE0 & _MBC_CS_MASK)
		#else
			// RCM5750 or equivalent has external 512K RAM plus internal 128K RAM2
			#define CS_RAM        (_DC_MD2_MBC_ & _MBC_CS_MASK)
			#define RAM_WSTATES   (_DC_MD2_MBC_ & _MBC_WS_MASK)
			#ifdef _FLASH_
				// FLASH_COMPILE mode (internal RAM2 is mapped to MB3)
				#define RAM2_START _cexpr((1<<(MSB_BIT-12))+(1<<(MSB_BIT-13)))
			#else
				// RAM_COMPILE mode (internal RAM2 is mapped to MB1)
				#define RAM2_START _cexpr(1 << (MSB_BIT - 13))
			#endif
		#endif
	#endif

	#if _DC_MD3_
		// _DC_MD3_.*_ macros (from the system memory devices table) describe RAM2
		#define RAM2_SIZE     _DC_MD3_SIZE_
		#define CS_RAM2       (_DC_MD3_MBC_ & _MBC_CS_MASK)
		#define RAM2_WSTATES  (_DC_MD3_MBC_ & _MBC_WS_MASK)
	#elif defined RAM2_START
		#fatal "System memory devices table lacks required RAM2 information."
	#endif
#endif


//By default, SUPPRESS_FAST_RAM_COPY should be set to 0.
#ifndef SUPPRESS_FAST_RAM_COPY
	#define SUPPRESS_FAST_RAM_COPY 0
#endif


// The .*_COMPILE macros are more convenient than _FLASH_, _RAM_ or _FAST_RAM_.
#ifdef _FLASH_
	#define FLASH_COMPILE 1
#else
	#define FLASH_COMPILE 0
#endif
#ifdef _RAM_
	#define RAM_COMPILE 1
#else
	#define RAM_COMPILE 0
#endif
#ifdef _FAST_RAM_
	#define FAST_RAM_COMPILE 1
#else
	#define FAST_RAM_COMPILE 0
#endif

// Sanity check!  One of these macros should be 1, the other two should be 0.
#if 1 != (FLASH_COMPILE + RAM_COMPILE + FAST_RAM_COMPILE)
	#error "Invalid combination of FLASH_COMPILE, RAM_COMPILE, FAST_RAM_COMPILE."
	#fatal FLASH_COMPILE RAM_COMPILE FAST_RAM_COMPILE
#endif


// *** On-board serial / nand / SD flash mass storage defaults. ***
#if _DC_BRD_OPT0_ & BRDOPT0_NANDFLASHMASK
   #define __BT__FAT_MAXBUFS  128   // Default maximum number of FAT buffers for
                                    //  boards with on-board nand flash.
#elif RCM4200_SERIES || RCM4400W_SERIES || RCM5400W_SERIES || BL4S100_SERIES \
     || RCM5600W_SERIES || RCM6600W_SERIES || RCM6700_SERIES || R6000TEST_SERIES
   #define __BT__FAT_MAXBUFS  8     // Default maximum number of FAT buffers for
                                    //  boards with on-board serial flash.
#elif RCM4300_SERIES
   #define __BT__FAT_MAXBUFS  128   // Default maximum number of FAT buffers for
                                    //  boards with on-board SD flash.
#else
   #define __BT__FAT_MAXBUFS  0     // Default maximum number of FAT buffers for
#endif                              //  boards without on-board mass storage.
// *** End of on-board serial / nand / SD flash mass storage defaults. ***


// *** RCM4000 hardware check ***
// Instruction fixes off by default
#pragma bsi_fix off
#pragma prefetch_fix off

#if _BOARD_TYPE_ == RCM4000  //this board is obsolete
   #warns "Dynamic C has detected that your core module may have a faulty component."
   #warns "Please contact Rabbit Technical Support at http://www.digi.com/support to arrange for a replacement."
   #warns "If you are not experiencing any issues you may ignore this warning."
   #pragma bsi_fix on
#endif

#if RCM4000_SERIES
   #pragma prefetch_fix on
#endif

// *** Ethernet-enabled Boards ***
#ifndef DISABLE_ETHERNET
	#define DISABLE_ETHERNET 0
#else
	#undef DISABLE_ETHERNET
	#define DISABLE_ETHERNET 1
#endif
#if (RCM4000_SERIES || RCM4200_SERIES || RCM4300_SERIES || BL4S100_SERIES \
     || RCM5700_SERIES || RCM6600W_SERIES || RCM6700_SERIES \
     || _BOARD_TYPE_ == R6000TEST || _BOARD_TYPE_ == R6000TESTW) \
     && !DISABLE_ETHERNET
   #define ETHERNET_ONBOARD 1
#else
   #define ETHERNET_ONBOARD 0
#endif

#ifndef DISABLE_WIFI
	#define DISABLE_WIFI 0
#else
	#undef DISABLE_WIFI
	#define DISABLE_WIFI 1
#endif

// *** WiFi-enabled Boards ***
#if (RCM4400W_SERIES || RCM5400W_SERIES || RCM5600W_SERIES || RCM6600W_SERIES || \
		_BOARD_TYPE_ == R6000TESTW || _BOARD_TYPE_ == R6000TEST) && !DISABLE_WIFI
   #define WIFI_ONBOARD 1
#else
   #define WIFI_ONBOARD 0
#endif

// *** XBee-enabled Boards ***
#if RCM4500W_SERIES || _BOARD_TYPE_ == BL4S100 || _BOARD_TYPE_ == BL4S150
   #define XBEE_ONBOARD 1
#else
   #define XBEE_ONBOARD 0
#endif

//*********************************************************************
//***** Macro defaults ************************************************
//*********************************************************************

#define  RAMONLYBIOS    0        // Set this to one if you have a board with
                                 // a RAM installed on CS0/WE0/OE0 and no
                                 // flash installed.  You will also need to
                                 // compile to RAM, and copy the file
                                 // RAMONLYCOLDLOAD.BIN to COLDLOAD.BIN and
                                 // RAMONLYPILOT.BIN to PILOT.BIN.

//***** Macros for 16-bit memory devices ******************************
#if (_DC_BRD_OPT0_ & BRDOPT0_16BITFLASHMASK) != 0
   #define _ENABLE_16BIT_FLASH_
#endif
#if (_DC_BRD_OPT0_ & BRDOPT0_16BITRAMMASK) != 0
   #define _ENABLE_16BIT_RAM_
#endif

//***** ADC Resolution ************************************************
#if (_DC_BRD_OPT0_ & BRDOPT0_ADC12ONBOARDMASK) != 0
   #define ADC_ONBOARD
   #define ADC_RESOLUTION 12
#elif (_DC_BRD_OPT0_ & BRDOPT0_ADC14ONBOARDMASK) != 0
   #define ADC_ONBOARD
   #define ADC_RESOLUTION 14
#endif

//***** NAND flash onboard ********************************************
#if (_DC_BRD_OPT0_ & BRDOPT0_NANDFLASHMASK) != 0
   #define NANDFLASH_ONBOARD 1
#else
   #define NANDFLASH_ONBOARD 0
#endif

//***** Cloning PB1 (CLKA) not available or not pulled up *************
#if (_DC_BRD_OPT0_ & BRDOPT0_PB1UNAVAILMASK) != 0
   #define CL_PB1_NOT_AVAILABLE 1
#else
   #define CL_PB1_NOT_AVAILABLE 0
#endif

//***** Default macro for presence of Battery-Backable RAM (BBRAM) ****
#ifndef _BBRAMS_LOCATION
	#define _BBRAMS_LOCATION  _BBRAM1_LOCATION	// assume primary RAM is BBRAM
#endif

//***** Macros for malloc library ******************************
#ifndef _MALLOC_MEM_TYPE
	// If left undefined, malloc.lib defines this to XALLOC_NOTBB.
	// Boards with small amount of non-BB memory need this to be
	// overridden as follows...
	#if _BOARD_TYPE_ == RCM4400W || _BOARD_TYPE_ == RCM5400W
		#define _MALLOC_MEM_TYPE XALLOC_ANY
	#endif
#endif //ndef _MALLOC_MEM_TYPE

//***** BL4S1xx Stuffing Options **************************************
// possible #defines for the BL4S100 series:
// #define BL4S1XX_RS232         // RS232 stuffing option
// #define BL4S1XX_1WIRE         // 1-wire stuffing option
// #define BL4S1XX_RNET          // RabbitNet stuffing option
// Note: XBEE_ONBOARD defined above

#if _BOARD_TYPE_ == BL4S100 || _BOARD_TYPE_ == BL4S110 || \
    _BOARD_TYPE_ == BL4S150 || _BOARD_TYPE_ == BL4S160
   #define BL4S1XX_RS232               // RS232 stuffing option
#endif

//***** BL4S1xx Serial Routing and Flow Control Options ***************
#if (BL4S100_SERIES)
   // available RS232 serial ports E and F use alternate ports
   #define SERD_TXPORT PCDR
   #define SERD_RXPORT PCDR

   #define SERF_TXPORT PEDR
   #define SERF_RXPORT PEDR
#endif

// Make sure _DC_MB_TYPE_ is defined before SBC board check
#ifndef _DC_MB_TYPE_
  #define _DC_MB_TYPE_ 0
#endif

#define BLXS200_CORE    (\
   _BOARD_TYPE_ == RCM4010 || \
   _BOARD_TYPE_ == RCM4310 || \
   _BOARD_TYPE_ == RCM4400W || \
   _BOARD_TYPE_ == RCM4510W || \
   _BOARD_TYPE_ == RCM5400W)
#define BLXS200_SERIES  (BLXS200_CORE && (_DC_MB_TYPE_ & 0xFF00) == 0x0100)

//***** BLxS2xx Serial Routing and Flow Control Options ***************
#if BLXS200_SERIES
   #if _BOARD_TYPE_ == RCM4310 || _BOARD_TYPE_ == RCM4400W || \
       _BOARD_TYPE_ == RCM4510W || _BOARD_TYPE_ == RCM5400W
      // available RS232 serial ports E and F use alternate ports
      #define SERE_TXPORT PDDR
      #define SERE_RXPORT PDDR

      #define SERF_TXPORT PDDR
      #define SERF_RXPORT PDDR
   #endif
#endif


//***** Check for Rabbit 5000 16-bit instruction fixes *****
#pragma R5000_16bit_fix off
#if (CPU_ID_MASK(_CPU_ID_) == R5000)
   #ifdef _ENABLE_16BIT_RAM_
      #pragma R5000_16bit_fix on
   #endif
   #ifdef _ENABLE_16BIT_FLASH_
      #pragma R5000_16bit_fix on
   #endif
#endif


//***** Default chip selects/write enables for the memory devices *************
// The chip select macros are defined such that the CS for each memory
// device is invisible to the BIOS and user programs. The execution RAM
// (RAM which the code runs in) is defined by the macro RUN_IN_RAM_CS,
// which is set to the CS of the RAM device in which the primary execution
// is to take place. This is specifically for the RAM_COMPILE and
// FAST_RAM_COMPILE compile modes. If a board has a second RAM attached, it
// must be defined in the board-specific initialization section.

#if (RAMONLYBIOS == 1)
   #ifndef CS_RAM
      #define CS_RAM        (CS0OE0 & _MBC_CS_MASK)
   #endif
#else
   #ifndef CS_FLASH
      #define CS_FLASH      (CS0OE0 & _MBC_CS_MASK)
   #endif
   #ifndef CS_RAM
      #if _SERIAL_BOOT_FLASH_== 0
         #define CS_RAM     (CS1OE1 & _MBC_CS_MASK)
      #else
         #ifdef _RAM_
           #define CS_RAM   (CS0OE0 & _MBC_CS_MASK)
         #else
           #define CS_RAM   (CS1OE1 & _MBC_CS_MASK)
         #endif
      #endif
   #endif
#endif


//***** Default wait states for the memory devices *************
//If wait state settings have not been explicitly set, use the values
//provided by the ID block.  Note that for 16-bit memory devices, the
//values from the ID block may not be correct.  However, these macros
//will only apply to the MBxCR registers, which will not affect wait
//state settings for 16-bit mode.  During 16-bit setup the MBxCR
//registers will have the power-up default four wait states, which
//will always be safe.

#ifndef RAM_WSTATES
   #define RAM_WSTATES     (_DC_MD2_MBC_ & _MBC_WS_MASK)
#endif
#ifndef FLASH_WSTATES
   #define FLASH_WSTATES   (_DC_MD0_MBC_ & _MBC_WS_MASK)
#endif


#ifdef _ENABLE_16BIT_FLASH_
   #ifndef ACS0CR_SETTING
      #if (CPU_ID_MASK(_CPU_ID_) == R4000)
      	//2 WS for read, 4 for write
         #define ACS0CR_SETTING \
         	ACSCR_READ_WS2 | ACSCR_LATER_WS0 | ACSCR_WRITE_WS4
      #else
      	//3 WS, byte access enabled
         #define ACS0CR_SETTING ACSCR_FIRST_WS3 | ACSCR_BYTE_WRITE
      #endif
   #endif
#endif
#ifdef _ENABLE_16BIT_RAM_
   #ifndef ACS1CR_SETTING
      #if (CPU_ID_MASK(_CPU_ID_) == R4000)
      	//2 WS for read, 4 for write
         #define ACS1CR_SETTING \
         	ACSCR_READ_WS2 | ACSCR_LATER_WS0 | ACSCR_WRITE_WS4
      #else
      	//3 WS, byte access enabled
         #define ACS1CR_SETTING ACSCR_FIRST_WS3 | ACSCR_BYTE_WRITE
      #endif
   #endif
#endif

//***** Default RAM start information ************************
//If nothing else has been specified, RAM will start in MB2 for
//FLASH_COMPILE and MB0 for RAM_COMPILE or FAST_RAM_COMPILE.
#ifndef RAM_START
   #if FLASH_COMPILE
      #define RAM_START (1 << (MSB_BIT-12))
   #elif RAM_COMPILE
      #define RAM_START 0x0
   #elif FAST_RAM_COMPILE
      #define RAM_START 0x0
   #endif
#endif


#ifndef RUN_IN_RAM_CS
   #if _SERIAL_BOOT_FLASH_ == 0
      #define RUN_IN_RAM_CS   0x1   // This is set to 0, 1, 2 or 3
                                    // based on the chip select of
                                    // the memory the main program
                                    // is to run in. By default, the
                                    // RAM is on CS1
   #else
      #define RUN_IN_RAM_CS   0x0
   #endif
#endif

#ifndef MB0CR_INVRT_A18
   #define MB0CR_INVRT_A18  0
#endif

#ifndef MB1CR_INVRT_A18
   #define MB1CR_INVRT_A18  0
#endif

#ifndef MB2CR_INVRT_A18
   #define MB2CR_INVRT_A18  0
#endif

#ifndef MB3CR_INVRT_A18
   #define MB3CR_INVRT_A18  0
#endif

#ifndef MB0CR_INVRT_A19
   #define MB0CR_INVRT_A19  0
#endif

#ifndef MB1CR_INVRT_A19
   #define MB1CR_INVRT_A19  0
#endif

#ifndef MB2CR_INVRT_A19
   #define MB2CR_INVRT_A19  0
#endif

#ifndef MB3CR_INVRT_A19
   #define MB3CR_INVRT_A19  0
#endif

// DEVNOTE: This logic needs to be reviewed and potentially updated.  It is
// a combination of RCM6000 changes (0x08) and code from StdBIOS.c (0x32, 0x02,
// 0x24).
#ifndef MACR_SETTING
	#if (CPU_ID_MASK(_CPU_ID_) >= R5000)
		#ifdef _ENABLE_16BIT_RAM_
			#define MACR_SETTING	0x08   //enable advanced 16-bit mode on CS1
		#endif
	#endif
#endif
#ifndef MACR_SETTING
	// Logic moved to boardtypes.lib from stdbios.c
	#if (CPU_ID_MASK(_CPU_ID_) == R4000)
      #ifdef __ALLOW_16BIT_AUXIO_DEFECT
         #error "Defining __ALLOW_16BIT_AUXIO_DEFECT exposes an ioe bug in"
         #error "exchange for improved memory performance.  See the Rabbit 4000"
         #error "Users Manual Appendix B (errata section) or TN255 for complete"
         #error "details."
         #error "Comment out these error messages and recompile if you are"
         #error "certain your application is not at risk and absolute top"
         #fatal "performance is required."

			#ifdef _ENABLE_16BIT_RAM_
				#if FLASH_COMPILE && defined(_ENABLE_16BIT_FLASH_)
					#define MACR_SETTING 0x32	// Advanced 16-bit /CS0 & /CS1
				#else
					#define MACR_SETTING 0x30	// 8-bit /CS0, Advanced 16-bit /CS1
				#endif
			#else
				#if FLASH_COMPILE && defined(_ENABLE_16BIT_FLASH_)
					#define MACR_SETTING 0x02	// Advanced 16-bit /CS0, 8-bit /CS1
				#endif
			#endif
		#else
			#ifdef _ENABLE_16BIT_RAM_
				#if FLASH_COMPILE && defined(_ENABLE_16BIT_FLASH_)
					#define MACR_SETTING 0x24	// Basic 16-bit /CS0 & /CS1
				#else
					#define MACR_SETTING 0x22	// Adv. 16-bit /CS0, Basic 16-bit /CS1
				#endif
			#else
				#if FLASH_COMPILE && defined(_ENABLE_16BIT_FLASH_)
					#define MACR_SETTING 0x04	// Basic 16-bit /CS0, 8-bit /CS1
				#endif
			#endif
		#endif
	#endif
#endif
#ifndef MACR_SETTING
	#define MACR_SETTING 0x00					// 8-bit /CS0 & /CS1
#endif

#define MSB_OFFSET (((MECR_VALUE >> 5) + 1) & 7)
#define MSB_BIT (MSB_OFFSET + 18)

#define _FLASH_MASK    (((0ul + _FLASH_SIZE_) << 12) - 1ul)
#define _QUADRANT_SIZE (1ul << (MSB_BIT - 1))
#define _QUADRANT_MASK (_QUADRANT_SIZE - 1ul)

// set _BOARD_NAME_ macro, string describing _BOARD_TYPE_

#if			_BOARD_TYPE_ == BL4S100
	#define	_BOARD_NAME_	"BL4S100"
#elif 		_BOARD_TYPE_ == BL4S110
	#define	_BOARD_NAME_	"BL4S110"
#elif 		_BOARD_TYPE_ == BL4S150
	#define	_BOARD_NAME_	"BL4S150"
#elif 		_BOARD_TYPE_ == BL4S160
	#define	_BOARD_NAME_	"BL4S160"

#elif			BLXS200_SERIES
	#if 			_BOARD_TYPE_ == RCM4010
		#define	_BOARD_NAME_	"BL4S210"
	#elif			_BOARD_TYPE_ == RCM4310
		#define	_BOARD_NAME_	"BL4S200"
	#elif			_BOARD_TYPE_ == RCM4510W
		#define	_BOARD_NAME_	"BL4S230"
	#elif			_BOARD_TYPE_ == RCM5400W
		#define	_BOARD_NAME_	"BL5S220"
	#else
		#define	_BOARD_NAME_	"BL?S2??"
	#endif

#elif			_BOARD_TYPE_ == RCM4000 || _BOARD_TYPE_ == RCM4000A
	#define	_BOARD_NAME_	"RCM4000"
#elif 		_BOARD_TYPE_ == RCM4010
	#define	_BOARD_NAME_	"RCM4010"
#elif 		_BOARD_TYPE_ == RCM4050
	#define	_BOARD_NAME_	"RCM4050"

#elif			_BOARD_TYPE_ == RCM4100
	#define	_BOARD_NAME_	"RCM4100"
#elif 		_BOARD_TYPE_ == RCM4110
	#define	_BOARD_NAME_	"RCM4110"
#elif 		_BOARD_TYPE_ == RCM4120
	#define	_BOARD_NAME_	"RCM4120"

#elif			_BOARD_TYPE_ == RCM4200
	#define	_BOARD_NAME_	"RCM4200"
#elif			_BOARD_TYPE_ == RCM4210
	#define	_BOARD_NAME_	"RCM4210"

#elif			_BOARD_TYPE_ == RCM4300
	#define	_BOARD_NAME_	"RCM4300"
#elif			_BOARD_TYPE_ == RCM4310
	#define	_BOARD_NAME_	"RCM4310"
#elif			_BOARD_TYPE_ == RCM4320
	#define	_BOARD_NAME_	"RCM4320"

#elif			_BOARD_TYPE_ == RCM4400W
	#define	_BOARD_NAME_	"RCM4400W"

#elif			_BOARD_TYPE_ == RCM4510W
	#define	_BOARD_NAME_	"RCM4510W"

#elif			_BOARD_TYPE_ == RCM5400W
	#define	_BOARD_NAME_	"RCM5400W"
#elif			_BOARD_TYPE_ == RCM5450W
	#define	_BOARD_NAME_	"RCM5450W"

#elif			_BOARD_TYPE_ == RCM5600W
	#define	_BOARD_NAME_	"RCM5600W"
#elif			_BOARD_TYPE_ == RCM5650W
	#define	_BOARD_NAME_	"RCM5650W"

#elif			_BOARD_TYPE_ == RCM5700
	#define	_BOARD_NAME_	"RCM5700"
#elif			_BOARD_TYPE_ == RCM5750
	#define	_BOARD_NAME_	"RCM5750"

#elif		   _BOARD_TYPE_ == RCM6600W
	#define	_BOARD_NAME_	"RCM6600W"
#elif			_BOARD_TYPE_ == RCM6650W
	#define	_BOARD_NAME_	"RCM6650W"

#elif			_BOARD_TYPE_ == RCM6700
	#define	_BOARD_NAME_	"RCM6700"
#elif			_BOARD_TYPE_ == RCM6710
	#define	_BOARD_NAME_	"RCM6710"
#elif			_BOARD_TYPE_ == RCM6720
	#define	_BOARD_NAME_	"RCM6720"
#elif			_BOARD_TYPE_ == RCM6730
	#define	_BOARD_NAME_	"RCM6730"
#elif			_BOARD_TYPE_ == RCM6750
	#define	_BOARD_NAME_	"RCM6750"
#elif			_BOARD_TYPE_ == RCM6760
	#define	_BOARD_NAME_	"RCM6760"

#else
	#define	_BOARD_NAME_	"UNKNOWN"
#endif

/*** EndHeader */