/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
 BLxS2xx.LIB

 DESCRIPTION:
   This library provides an API for the BLxS2xx single board computers
   family which use the Rabbit I/O chip (RIO).  Three Rabbit I/O chips
   are used to drive most of the SBC's digital I/O structure. This adds
   significant run time configurability to these single board computers.

   This library offers functions to simplify the use of on-board ADC, DAC,
   RS232 port(s), RS485 port and Rabbitnet ports.  There are functions for
   both setup and use of the configurable and high current digital I/O.

 CONFIGURATION MACROS:
   The following macros may be defined (before #use of BLxS2xx.lib):

   #define BL_USER_INIT
      Tells the library that the user code will be supplying the array
      of initialization codes for the digital initialization.  This is a
      constant character array of size RSB_DIGITAL_IN + RSB_DIGITAL_OUT
      and must be named bl_init.  This array should also be declared
      before the #use of the BLxS2xx library.
      The configuration values are:
         RSB_INP for defining an input  (should not be used on output only pin)
         RSB_LOW for defining an output that starts out low
         RSB_HI  for defining an output that starts out high
         RSB_TRI for defining an output that starts out tri-state (Hi Z)

   #define BL_IRQ_PRIORITY
      Sets the priority of RIO based digital interrupt sources on the
      Rabbit processor.  This is a value from 1 to 3, with 1 being the
      lowest priority and 3 being the highest.  Default if not defined
      is to use priority 1.

   #define BL_POLL_MODE
      Defining BL_POLL_MODE disables the use of hardware interrupts and
      signifies the intention to poll for pending RIO interrupts using
      the tickISR() function.

   #define BL_NO_RT_ERRORS
      Defining BL_NO_RT_ERRORS will disable the BLxS2xx function from
      generating runtime exceptions on detected errors.  Errors will
      still be checked, but will only be reported through return codes
      from the functions, leaving runtime error handling to the program
      which called the function.

   #define BL_LIMIT_ERRORS
      Defining BL_LIMIT_ERRORS will disable most of the error checking
      on parameters passed to BLxS2xx functions.  This will improve the
      speed of the code, but will not catch all errors.  It is not
      advisable to set this define during program development.

   #define BL_DEBUG
      Define BL_DEBUG will enable debugging for BL4S2xx series functions


 REVISION HISTORY:

  Rev 1.0   WTS   Initial release.

END DESCRIPTION *************************************************************/


/*** Beginheader */
#ifndef __BLS2XX_LIB
#define __BLS2XX_LIB

#ifdef BL_DEBUG
#define _bl_nodebug __debug
   #undef DB_IP_SET3
   #define DB_IP_SET3
   #undef DB_IP_RES
   #define DB_IP_RES
#else
#define _bl_nodebug __nodebug
   #undef DB_IP_SET3
   #define DB_IP_SET3 ipset 3
   #undef DB_IP_RES
   #define DB_IP_RES  ipres
#endif

#use "idblock_api.lib"

#ifdef BL_NO_RT_ERRORS
  #define BL_ERROR(Z) {return(Z);}
#else
  #define BL_ERROR(Z) {exception(Z);return(Z);}
#endif

#define BL_IOBASE 0x0000          // Base address for external I/O addresses
#define BL_LATCH (BL_IOBASE+0x30) // External I/O Latch address on the SBC

#define PORTA_AUX_IO             // Required for RIO SBC Library
#define RSB_MAX_RIOS 3           // Number of RIO's on the SBC
#define RSB_MAX_PINS 40          // Number of Digital I/O pins on the SBC
#define RSB_DIGITAL_IN 32        // Number of pins w/ digital input ability
#define RSB_DIGITAL_OUT 8        // Number of pins w/ digital output drive only
#define RSB_ANALOG_IN 8          // Number of pins w/ analog input ability
#define RSB_ANALOG_4TO20 4       // Number of above pins w/ 4-20 mA loop ability
#define RSB_ANALOG_OUT 2         // Number of pins w/ analog output drivers
#define RSB_AUX_BASE BL_IOBASE   // Base address of Aux I/O Bus
#define RSB_GB_LATCH BL_LATCH    // Address of Latch hosting the G//B output
#define RSB_GB_PIN   2           // Pin number of G//B output
#define RSB_GB_SHADOW __latch_sr // Shadow variable for GB port
#ifdef  BL_POLL_MODE
#define RSB_POLL_MODE
#else
#define RSB_EXT_INT1            // Set RIO Library to use External Int 1
#endif

#define RIO_CLOCK_FREQ  16000000L // frequency of the RIO clock
#define RIO_PRESCALE_FREQ 100000L // frequency of RIO after prescalar
#define BL_PWM_MAX_FREQ   50000.0 // Maximum frequency for Pulse Modulation
#define BL_PWM_MIN_FREQ   2.0     // Minimum frequency for Pulse Modulation

#define BL_BIND_LEAD     0x40     // bind to leading edge of pin output ORed in
#define BL_BIND_TRAIL    0x20     // bind to trailing edge of pin output
#define BL_BIND_PIN_MASK 0x1F     // mask for pin number portion of binding

#define BL_SAME_CHANNEL  0x40     // Sets same channel for begin/end capture

#ifndef BL_IRQ_PRIORITY
  #define BL_IRQ_PRIORITY 1
#endif
#define BL_DIGITAL_IO    RSB_DIGITAL_IN
#define BL_DIGITAL_HC    RSB_DIGITAL_OUT
#define BL_ANALOG_IN     RSB_ANALOG_IN
#define BL_ANALOG_4TO20  RSB_ANALOG_4TO20
#define BL_ANALOG_OUT    RSB_ANALOG_OUT
#define BL_MAX_DAC       8              // Maximum overall DAC channels
#define BL_MAX_GAINS     8              // Maximum number of ADC Gain codes

#use "RIO_SBC.lib"
#use "rn_cfg_bls2xx.lib"

// Map of RIO Index, block, and port to RSB_IOdef/RSB_IOpin index
extern const __far char rsb_map[RSB_MAX_RIOS][RSB_MAX_BLOCKS][RSB_BLOCK_PINS];

/*** Endheader */

//------------------------------------------------------------------------
//    API global variable section
//------------------------------------------------------------------------
/*** Beginheader  __brdInitFlag,
                  __TriStateConfig,
                  __TriStateConfigFlag,
                  __HoutConfigFlag,
                  __HoutConfig,
                  __SoutConfigFlag,
                  __SoutConfig,
                  __DACConfig,
                  __RangeChecking,
                  __tdivisor,
                  __SPIShadow,
                  __numcycles_1us,
                  __latch_sr

*/

// Variables for API function usage
extern int __brdInitFlag;
extern int __TriStateConfig;
extern int __TriStateConfigFlag;
extern int __HoutConfigFlag;
extern int __HoutConfig;
extern int __SoutConfigFlag;
extern int __SoutConfig;
extern int __DACConfig;
extern int __RangeChecking;
extern int __tdivisor;
extern char __dacSynchronicity;
extern char __SPIShadow;
extern int __numcycles_1us;

// ADC calibration data structure
typedef struct
{  float gain;
   int offset;
} calib_t;

extern int gain_codes[BL_MAX_GAINS];
extern char ADC_Cmd_Bias[BL_ANALOG_IN];
extern char ADC_Cmd_Calb[BL_ANALOG_IN];
extern calib_t ADC_Cal_Table[BL_ANALOG_IN];

extern int DAC_Command[BL_MAX_DAC];
extern calib_t DAC_vCal_Table[BL_MAX_DAC];
extern calib_t DAC_iCal_Table[BL_MAX_DAC];

#if ! BLXS200_SERIES
	#fatal "This library is for BLxS2xx series SBC boards only."
#endif

#define SxER SDER
#define SxERShadow SDERShadow

#if _BOARD_TYPE_ == RCM4010
   // available RS232 serial port B uses default port/pins
   // available RS485 serial port C uses default port/pins
   #define SET_GS(X) BitWrPortI(PEDR,&PEDRShadow,X,2)
   #define BL_BUSY_REG PBDR
   #define BL_BUSY_BIT 0
#else
   #define SET_GS(X) BitWrPortI(PDDR,&PDDRShadow,X,4)
   #define BL_BUSY_REG PEDR
   #define BL_BUSY_BIT 4
#endif

#define RN_ACCESS_PROTECTION
#define RN_SPIBUSY BL_SPIBUSY
#define RN_ACCESS_FN(i) _bl_SPIgetSemaphore(&_bl_spi_dev[i])
#define RN_RELEASE_FN(i) _bl_SPIfreeSemaphore(&_bl_spi_dev[i])

// I/O Latch shadow register
extern char __latch_sr;

#define DIO_PIN(X) (&(rsb_pin[X]))
#define HCO_PIN(X) (&(rsb_pin[(X)+BL_DIGITAL_IO]))

/*
 * The following enumerated values represent different drive settings for
 * high current PWM/PPM outputs.
 */
enum {
  HCPWM_TRI_LOW,   // Begin with output tri-stated, and pulse sinking driver
  HCPWM_TRI_HIGH,  // Begin with output tri-stated, and pulse sourcing driver
  HCPWM_LOW_HIGH,  // Begin with output sinking, and pulse to sourcing
  HCPWM_HIGH_LOW,  // Begin with output sourcing, and pulse to sinking
  HCPWM_LOW_TRI,   // Begin with output sinking, and pulse to tri-state
  HCPWM_HIGH_TRI   // Begin with output sourcing, and pulse to tri-state
};

// ISR block selector values
enum {
  BL_INPUT_BLOCK = 1,
  BL_OUTPUT_BLOCK
};

// Board I/O Definition structure
// Order of Pin Groups: Digital In or I/O, Digital Out, Analog In, Analog Out
// RIO,C1,B1,C2,B2, TYPE, POLARITY, SHADOW PTR.
const struct RSB_IOdef bl_def[RSB_MAX_PINS] = {
 { 0, 5, 0, 4, 0, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  0
 { 0, 5, 1, 4, 1, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  1
 { 0, 5, 2, 4, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  2
 { 0, 5, 3, 4, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  3
 { 1, 1, 0, 0, 0, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  4
 { 1, 1, 1, 0, 1, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  5
 { 1, 1, 2, 0, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  6
 { 1, 1, 3, 0, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  7
 { 1, 3, 0, 2, 0, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  8
 { 1, 3, 1, 2, 1, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O  9
 { 1, 3, 2, 2, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 10
 { 1, 3, 3, 2, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 11
 { 1, 5, 0, 4, 0, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 12
 { 1, 5, 1, 4, 1, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 13
 { 1, 5, 2, 4, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 14
 { 1, 5, 3, 4, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 15
 { 2, 0, 0, 0, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 16
 { 2, 0, 1, 0, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 17
 { 2, 1, 0, 1, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 18
 { 2, 1, 1, 1, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 19
 { 2, 2, 0, 2, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 20
 { 2, 2, 1, 2, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 21
 { 2, 3, 0, 3, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 22
 { 2, 3, 1, 3, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 23
 { 2, 4, 0, 4, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 24
 { 2, 4, 1, 4, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 25
 { 2, 5, 0, 5, 2, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 26
 { 2, 5, 1, 5, 3, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 27
 { 0, 7, 0, 6, 0, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 28
 { 1, 7, 0, 6, 0, RSB_TYPE_DIGINOUT, 1, NULL },       // Config. I/O 29
 { 2, 6, 0, 8, 1, RSB_TYPE_DIGINOUT, 1, &__latch_sr}, // Config. I/O 30
 { 2, 7, 0, 8, 0, RSB_TYPE_DIGINOUT, 1, &__latch_sr}, // Config. I/O 31
 { 0, 0, 0, 0, 1, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 0
 { 0, 0, 2, 0, 3, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 1
 { 0, 1, 0, 1, 1, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 2
 { 0, 1, 2, 1, 3, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 3
 { 0, 2, 0, 2, 1, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 4
 { 0, 2, 2, 2, 3, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 5
 { 0, 3, 0, 3, 1, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 6
 { 0, 3, 2, 3, 3, RSB_TYPE_PUSHPULL, 0, NULL },     // High Current Out 7
};

#ifndef BL_USER_INIT
const char bl_init[RSB_MAX_PINS] =
{
   RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP,
   RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP,
   RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP,
   RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP, RSB_INP,
   RSB_TRI, RSB_TRI, RSB_TRI, RSB_TRI, RSB_TRI, RSB_TRI, RSB_TRI, RSB_TRI,
};
#endif


// Map of RIO Index, Block and Pin to position in rsb_IOpin & bl_def
const __far char rsb_map[RSB_MAX_RIOS][RSB_MAX_BLOCKS][RSB_BLOCK_PINS] =
{
  // RIO 0
  { 32, 32, 33, 33,   34, 34, 35, 35,   36, 36, 37, 37,   38, 38, 39, 39,
     0,  1,  2,  3,    0,  1,  2,  3,   28, 28, 28, 28,   28, 28, 28, 28 },
  // RIO 1
  {  4,  5,  6,  7,    4,  5,  6,  7,    8,  9, 10, 11,    8,  9, 10, 11,
    12, 13, 14, 15,   12, 13, 14, 15,   29, 29, 29, 29,   29, 29, 29, 29 },
  // RIO 2
  { 16, 17, 16, 17,   18, 19, 18, 19,   20, 21, 20, 21,   22, 23, 22, 23,
    24, 25, 24, 25,   26, 27, 26, 27,   30, 30, 30, 30,   31, 31, 31, 31 }
};

// Defines for counter function
#define BL_UP_COUNT     RSB_UP_COUNT     // Continuous up count mode
#define BL_DOWN_COUNT   RSB_DOWN_COUNT   // Up/down counter mode
#define BL_MATCH_ENABLE RSB_MATCH_ENABLE // Stop on any match mode
#define BL_EDGE_RISE    RSB_POL_RISING   // Up count/sync on rising edge
#define BL_EDGE_FALL    RSB_POL_FALLING  // Up count/sync on falling edge
#define BL_EDGE_BOTH    RSB_POL_EITHER   // Up count/sync on either edge

// Defines for capture functions (some edge/event defines used by counter also)
#define BL_CNT_RUN       RSB_CNT_RUN        // Continuous count mode
#define BL_CNT_BEGIN_END RSB_CNT_BEGIN_END  // Start on begin, count until end
#define BL_CNT_TIL_END   RSB_CNT_TIL_END    // Count until end event detected
#define BL_CNT_ON_BEGIN  RSB_CNT_ON_BEGIN   // Count while BEGIN signal active

#define BL_EVENT_RISE RSB_EDGE_RISE      // Begin/End/Down event on rising edge
#define BL_EVENT_FALL RSB_EDGE_FALL      // Begin/End/Down event on falling edge
#define BL_EVENT_BOTH RSB_EDGE_BOTH      // Begin/End/Down event on either edge
#define BL_BEGIN_HIGH RSB_BEGIN_HIGH     // Begin active while signal is high
#define BL_BEGIN_LOW  RSB_BEGIN_LOW      // Begin active while signal is low

#define BL_PRESCALE   RSB_PRESCALE       // Use prescaled clock
#define BL_SAVE_LIMIT RSB_SAVE_LIMIT     // Save current limit register value

// Defines for external interrupt function
#define BL_IRQ_RISE    RSB_FUNC_RISING   // Interrupt event on rising edge
#define BL_IRQ_FALL    RSB_FUNC_FALLING  // Interrupt event on falling edge
#define BL_IRQ_BOTH    RSB_FUNC_EITHER   // Interrupt events on both edges
// Interrupt enable flags
#define BL_IER_DQE     RSB_IER_DQE		  // Decrement/Quadrature/End
#define BL_IER_IIB     RSB_IER_IIB		  // Increment/Inphase/Begin
#define BL_IER_ROLL_D  RSB_IER_ROLL_D	  // Counter rollover on decrement
#define BL_IER_ROLL_I  RSB_IER_ROLL_I	  // Counter rollover on increment
#define BL_IER_MATCH3  RSB_IER_MATCH3	  // Match 3 condition
#define BL_IER_MATCH2  RSB_IER_MATCH2	  // Match 2 condition
#define BL_IER_MATCH1  RSB_IER_MATCH1	  // Match 1 condition
#define BL_IER_MATCH0  RSB_IER_MATCH0	  // Match 0 condition

// Defines for getMatch and getMatch_H functions
#define BL_TRAIL_ONLY  1   // Primary match register, used by PxM's and counter
#define BL_LEAD_ONLY   2   // Secondary match register, used by PPM only

// Assembly macro which delays 'Z' cycles of the RIO prescaled clock
#define BL_RIO_DELAY(Z) \
	   ld    bc,_cexpr((Z * 1000000 / (7 * RIO_PRESCALE_FREQ)) + 1) $ \
	   ld    de,(__numcycles_1us) $ \
	   mul $ dwjnz @PC

#ifndef SER_NO_FLOWCONTROL
 #if _BOARD_TYPE_ != RCM4010
   // Defaults for RS232 handshaking RTS/CTS (All others)
   #define SERE_RTS_SHADOW PDDRShadow
   #define SERE_RTS_PORT    PDDR  // RTS I/O control port
   #define SERE_RTS_BIT     2     // RTS on port D, PD2
   #define SERE_CTS_PORT    PDDR  // CTS I/O control port
   #define SERE_CTS_BIT     3     // CTS on Port D, PD3
 #endif
#endif

// semaphore ownership ID for SPI management
#define BL_SPI_ID_NONE 0
#define BL_SPI_ID_RN1  1
#define BL_SPI_ID_RN2  2
#define BL_SPI_ID_ADC  3
#define BL_SPI_ID_DAC  4

// Shared SPI Port MACRO's
#define BL_SPI_RN1    0      // RabbitNet Port 1
#define BL_SPI_RN2    1      // RabbitNet Port 2
#define BL_SPI_ADC    2      // ADC (ADS7870)
#define BL_SPI_DAC    3      // DAC (DAC128S085)

// Shared SPI Port Selection MACRO's
#define BL_SPI_RN_PORT1  0x00
#define BL_SPI_RN_PORT2  0x10
#define BL_SPI_ADC_CHIP  0x20
#define BL_SPI_DAC_CHIP  0x30

#define BL_SPI_MODE_ADC  0x38   // Set SPI mode 0 and reversed bit order
#define BL_SPI_MODE_DAC  0x38   // Set SPI mode 0 and reversed bit order

#define BL_SPI_PORT_ADDR   SDDR        // Serial port data register for SPI
#define BL_SPI_PORT_CTRL   SDCR        // Serial port control register for SPI
#define BL_SPI_PORT_STATUS SDSR        // Serial port status register for SPI
#define BL_SPI_MUX_ADDR    BL_LATCH    // I/O bus address for I/O Latch
#define BL_SPI_MUX_SHADOW  __latch_sr  // Shadow register for I/O Latch
#define BL_SPI_MUX_MASK    0x30        // Mask of latch bits used by SPI mux
#define BL_SPI_RN_PORT1    0x00        // Mux address to select RabbitNet Port 1
#define BL_SPI_RN_PORT2    0x10        // Mux address to select RabbitNet Port 2
#define BL_SPI_ADC_CHIP    0x20        // Mux address to select ADC (ADS7870)
#define BL_SPI_DAC_CHIP    0x30        // Mux address to select DAC (DAC128S085)

// CLK divisor for SF1000 accesses
#define SBC_SPI_DIVISOR __tdivisor
#define BL_SPI_CLK_DIVISOR 10

#define MAXDACCOUNT  4095
#define MINDACCOUNT  0

#define ADCBOARD  1     //board type

#define CAL_ANALOG_SIZE  sizeof(calib_t)

#define CAL_ADC_SE0  (4096*GetIDBlockSize()-ZWORLD_RESERVED_SIZE)
#define CAL_ADC_SE1  (CAL_ADC_SE0 + (CAL_ANALOG_SIZE*BL_ANALOG_IN*BL_MAX_GAINS))
#define CAL_ADC_DIFF (CAL_ADC_SE1 + (CAL_ANALOG_SIZE*BL_ANALOG_IN*BL_MAX_GAINS))
#define CAL_ADC_MA   (CAL_ADC_DIFF +(CAL_ANALOG_SIZE*BL_ANALOG_IN*BL_MAX_GAINS))

#define CAL_DACV_UNIPOLAR  (CAL_ADC_MA + (CAL_ANALOG_SIZE * BL_ANALOG_4TO20))
#define CAL_DACV_BIPOLAR   (CAL_DACV_UNIPOLAR +(CAL_ANALOG_SIZE*BL_MAX_DAC))
#define CAL_DACI_UNIPOLAR  (CAL_DACV_BIPOLAR +(CAL_ANALOG_SIZE*BL_MAX_DAC))

// ADC Mode
#define DIRECTMODE   0x80
#define REGISTERMODE 0x00

// ADC modes for user selection
#define SE0_MODE     0x00    //  Single-Ended unipolar (0 - 20V Max.)
#define SE1_MODE     0x10    //  Single-Ended bipolar  (±10V Max.)
#define DIFF_MODE    0x20    //  Differential bipolar  (±20V Max.)
#define mAMP_MODE    0x30    //  4-20ma operation

#define GAIN_X1      0       // gaincode for gain=1
#define GAIN_X2      1       // gaincode for gain=2
#define GAIN_X4      2       // gaincode for gain=4
#define GAIN_X5      3       // gaincode for gain=5
#define GAIN_X8      4       // gaincode for gain=8
#define GAIN_X10     5       // gaincode for gain=10
#define GAIN_X16     6       // gaincode for gain=16
#define GAIN_X20     7       // gaincode for gain=20

#define DAC_BIAS_FOR_UNIPOL  dac_bias[8]  // offset for unipolar or 4-20ma
#define BL_UNIPOL_BIAS       0x80  // Bias code for unipolar or milliamp modes
                                   // (Shifted into upper nibble)

// Raw DAC bias counts for different ADC gains and modes.  Creates bias
//  voltages (in mV) of 1200, 600, 300, 240, 150, 120, 75, 60, 20
//  (These counts include adjustment for inherent 20mV offset on the DAC)
const word dac_bias[9] = { 1933, 950, 459, 360, 213, 164, 90, 65, 0 };

// ADC control bytes for mode of operation
#define SINGLE_ENDED 0x08
#define DIFFERENTIAL 0x00

#ifndef mAMP_GAINCODE
#define mAMP_GAINCODE   4
#endif

#define DAC_VOLT0_INDEX 0  // UNIPOLAR volts
#define DAC_VOLT1_INDEX 1  // BIPOLAR  volts
#define DAC_mAMPS_INDEX 2  // UNIPOLAR mAmps

#define DAC_ASYNC 0 // Write Through Mode - immediate update
#define DAC_SYNC  1 // Write Register Mode
                    //  ( requires anaOutDriver(0xA000 | ch_mask) )

// ADC Register address
#define REG0         0x00
#define REG1         0x01
#define REG2         0x02
#define REG3         0x03
#define REG4         0x04
#define REG5         0x05
#define REG6         0x06
#define REG7         0x07
#define REG24        0x18
#define REG31        0x1F

// ADC Read/Write operation
#define RD_REG       0x40
#define WR_REG       0x00

// ADC Word length
#define BITS16       0x20
#define BITS8        0x00

// SPI Clock Rate ~5Mbits/sec
#define BL_SPI_CLK 5000000L

#define BL_GAIN_MASK 0x0F    // Bias and calb both have gain in low nibble
#define BL_BIAS_MASK 0xF0    // Bias stored in upper nibble of ADC_Cmd_Bias
#define BL_MODE_MASK 0xF0    // Mode stored in upper nibble of ADC_Cmd_Calb

/*** Endheader */

// Function execution flags
int __brdInitFlag;
int __TriStateConfig;
int __TriStateConfigFlag;
int __HoutConfigFlag;
int __HoutConfig;
int __SoutConfigFlag;
int __SoutConfig;
int __DACConfig;
int __RangeChecking;
int __tdivisor;
char __dacSynchronicity;
char __SPIShadow;
int __numcycles_1us;

int gain_codes[BL_MAX_GAINS];
char ADC_Cmd_Bias[BL_ANALOG_IN];
char ADC_Cmd_Calb[BL_ANALOG_IN];
calib_t ADC_Cal_Table[BL_ANALOG_IN];

int DAC_Command[BL_MAX_DAC];
calib_t DAC_vCal_Table[BL_MAX_DAC];
calib_t DAC_iCal_Table[BL_MAX_DAC];

char __latch_sr;

void _bl_global_init(void)
{
  #GLOBAL_INIT {
   __brdInitFlag = FALSE;
   __SPIShadow = 0xFB;
   // Number of CPU cycles required to obtain a period of 1 usec
   __numcycles_1us = (int)(19200L*32*freq_divider/1000000L)+1;

   // Analog initialization
   __RangeChecking = TRUE;
   __DACConfig = -1;

   // High current initialization
   __HoutConfig = 0x00;
   __HoutConfigFlag = FALSE;
   __TriStateConfigFlag = FALSE;
   __TriStateConfig = 0x00;

   memset(ADC_Cmd_Bias, 0xFF, BL_ANALOG_IN);
   memset(ADC_Cmd_Calb, 0xFF, BL_ANALOG_IN);
   memset(DAC_Command, 0xFF, BL_MAX_DAC);
  }
}


#asm __root
;;;entry data byte must be in l
_txadcbyte::
    ld   a,l
ioi ld   (BL_SPI_PORT_ADDR),a  ;load instruction byte first into transmit data reg
    ld   a,0x8c             ;use pport C
ioi ld   (BL_SPI_PORT_CTRL),a  ;transmit byte

.txshiftdone:              ;wait for empty shift reg
ioi ld   a,(BL_SPI_PORT_STATUS)
    bit  2,a
    jp   nz,.txshiftdone
    ret
#endasm

#asm __root
;;;exit data byte will be in l
_rxadcbyte::
    ld   a,0x4c               ;receive byte one
ioi ld   (BL_SPI_PORT_CTRL),a

.rxdatafull:
ioi ld   a,(BL_SPI_PORT_STATUS)
    bit  7,a
    jr   z,.rxdatafull
ioi ld   a,(BL_SPI_PORT_ADDR)    ;get byte from receive data reg
    ld   l,a
    ret
#endasm


#asm __root _bl_nodebug
_delay100usec::
      ld		a,b   ; save b to a
      ld    hl,(__numcycles_1us)
      ld    b,l
      // 105 usec delay  = __numcycles_1us * code cycles
.delay100cycles:
      push  af       ; Code = 105 cycles
      pop   af
      push  af
      pop   af
      push  af
      pop   af
      push  af
      pop   af
      push  af
      pop   af
      djnz  .delay100cycles
      ld		b,a   ; restore b from a
      ret
#endasm
////////////////////////////// SPI control ///////////////////////////////

/*** BeginHeader */

#define BL_ERRCODESTART (-4096)
#define BL_EINVAL     (BL_ERRCODESTART - 1)
#define BL_TIMEOUT    (BL_ERRCODESTART - 2)
#define BL_OVERFLOW   (BL_ERRCODESTART - 3)
#define BL_WRONG_MODE (BL_ERRCODESTART - 4)
#define BL_BADPARAM   (BL_ERRCODESTART - 5)
#define BL_NOT_CAL    (BL_ERRCODESTART - 6)
#define BL_SPIBUSY    (BL_ERRCODESTART - 7)
#define BL_SPI_SHARED_DEVS  4

enum BL_POWER_MODES {BL_HIGH_Z, BL_OHM100, BL_OHM2_5};
typedef enum BL_POWER_MODES BL_POWER_T;

#define DAC_UNIPOLAR 0
#define DAC_BIPOLAR  1
#define DAC_PWR_ON  0xFF
#define DAC_PWR_OFF 0xFC

#ifndef BL_DEFSPIDIVISOR
  #define BL_DEFSPIDIVISOR      0x00  // Default SPI divisor
#endif
#define BL_SPI_RN1_DIVISOR BL_DEFSPIDIVISOR
#define BL_SPI_RN2_DIVISOR BL_DEFSPIDIVISOR
#define BL_SPI_ADC_DIVISOR BL_DEFSPIDIVISOR
#define BL_SPI_DAC_DIVISOR BL_DEFSPIDIVISOR

#ifndef _BL_SPI_MAXTIME
  #define _BL_SPI_MAXTIME 5000UL  // In milliseconds
#endif

 struct _bl_SPI_Dev{
   char ID;            // 0
   char SCLCKdiv;      // 1
 };

//*** Controlling structure for the SPI port semaphore ***
 struct _bl_spiSemaphore{
   char owner;         // Owner ID
   char timerState;    // 1 = initialized, 0 = not, 2 = timeout occurred
   char lastDiv;       // last divisor
 };
/*** EndHeader */

/*** BeginHeader  _bl_shared_port_init, _bl_SPIgetSemaphore,
                    _bl_SPIfreeSemaphore */
 __root void _bl_shared_port_init();
 __root int _bl_SPIgetSemaphore(const struct _bl_SPI_Dev *dev);
 __root int _bl_SPIfreeSemaphore(const struct _bl_SPI_Dev *dev);
 extern unsigned long _bl_SPI_t0_;
 extern struct _bl_SPI_Dev _bl_spiActiveDev;
 extern const unsigned long _BL_SPI_TIMEOUT;
 extern struct _bl_spiSemaphore _bl_SPI_semaphore;
/*** EndHeader */

unsigned long _bl_SPI_t0_;
const unsigned long _BL_SPI_TIMEOUT = (long)_BL_SPI_MAXTIME;
struct _bl_SPI_Dev _bl_spiActiveDev;
struct _bl_spiSemaphore _bl_SPI_semaphore;

_bl_nodebug
__root void _bl_shared_port_init(){

   // Initialize device struct
   _bl_SPI_semaphore.owner = 0;
   memset(&_bl_spiActiveDev, 0, sizeof(_bl_spiActiveDev));
}

/***************************************************************

 int _bl_SPIgetSemaphore(const struct _bl_SPI_Dev *dev)

This function grabs a semaphore to prevent  devices from
trying to use the shared SPI lines at the same time. The first
attempt to grab the semaphore by a device when the semaphore
is already in use by another device starts a timeout timer.
If the device specified by dev is already the owner, it will
return 0 for success.

Only a call to _bl_SPIfreeSemaphore by the owning dev can free the
semaphore. When the semaphore is successfully grabbed, SBER is
written with the correct mode and TAT7R is written with the
correct baud divisor. If the divisor has changed, a small loop
allows the baud clock to run down.

Input:
   dev - one of BL_SPI_ID_RN1, BL_SPI_ID_RN2, BL_SPI_ID_ADC
                 or BL_SPI_ID_DAC

Return Values:
     0 - Success. Semaphore wasn't in use and the device
         specified by dev now owns it. (Or already owned)

     1 - Semaphore is already in use by RabbitNet1
     2 - Semaphore is already in use by RabbitNet2
     3 - Semaphore is already in use by the ADC chip
     4 - Semaphore is already in use by the DAC chip

      If more than _BL_SPI_MAXTIME milliseconds elapsed since
      the last attempt to grab the semaphore by device
      specified in dev, a fatal run-time error -ETIME results.

****************************************************************/
const int bl_structSize = sizeof(struct _bl_SPI_Dev);
#ifndef _SPI_USE_UCOS_MUTEX
#asm
_bl_SPIgetSemaphore::
#ifndef  BL_SPI_NODEVSHARING
    DB_IP_SET3
    ld    a,(_bl_SPI_semaphore)
    ld    b,a                 ; B = semaphore owner ID
    and   0xff                ; BL_SPI_ID_NONE (0) in a if free
    ld    a,(hl)              ; HL = ptr to dev struct, A = device ID
    jr    nz,.spiGSdone       ; In use (maybe by cur. dev)
    ld    (_bl_SPI_semaphore),a  ; Calling dev owns it now
    xor    a                  ; Reset timeout timer
    ld    (_bl_SPI_semaphore+_bl_spiSemaphore+timerState),a
    ld    bc,(bl_structSize)     ; Make caller active
    ld    de,_bl_spiActiveDev
    ldir                      ; Load structure
    DB_IP_RES

    ; If baud rate changed, run down clock
    ld    hl, _bl_spiActiveDev+_bl_SPI_Dev+SCLCKdiv
    ld    a,(hl)              ; A =  _bl_spiActiveDev.SCLCKdiv
    ld    hl,_bl_SPI_semaphore+_bl_spiSemaphore+lastDiv
    cp    (hl)                ; Compare with last divisor
    ld    (hl),a
    jr    z,.spiGSdone1       ; Return success if no change
ioi ld    (TAT7R),a           ; Otherwise change divisor
    ld    b,16                ; and delay for baud run down
.spiBCdelay:
    djnz  .spiBCdelay
.spiGSdone1:
    clr  hl                   ; Return 0 for success
    ret

.spiGSdone:
    cp    b
    jr    nz,.spiGSnotsame
    ld    b,0                   ; Caller already has semaphore
    DB_IP_RES
    jr    .spiGSdone2

.spiGSnotsame:
    ld    hl,_bl_SPI_semaphore+_bl_spiSemaphore+timerState  ; Get timer state
    bit   0,(hl)
    jr    z,.spiInitTimer

    //  MS_TIMER-t0 > _SF_TIMEOUT ?
    exx
    ld    jkhl,(MS_TIMER)
    ld    bcde,(_bl_SPI_t0_)
    sub   jkhl,bcde
    ld    bcde,(_BL_SPI_TIMEOUT)
    cp    jkhl,bcde
    exx
    jr    c,.spiNoSemTimeOut

    DB_IP_RES
c   exit(-ETIME);             // Timed out

.spiInitTimer:                ; Init timeout test
    inc   (hl)                ; _bl_SPI_semaphore.timerstate = 1
    ld    jkhl,(MS_TIMER)
    ld    (_bl_SPI_t0_),jkhl     ; t0 = MS_TIMER
.spiNoSemTimeOut:
    DB_IP_RES

.spiGSdone2:
    clr   hl    ; B=0 if have sem. already or not busy
    ld    l,b   ;  else B = current owner ID
#else
    clr   hl
#endif
    ret
#endasm

#else // Using SPI uC/OS-II mutex
_bl_nodebug
int _bl_SPIgetSemaphore(const struct _bl_SPI_Dev *dev)
{
    auto int i,rc;

    OS_ENTER_CRITICAL();
    // If calling device already owns, just return success
    if(_bl_spiActiveDev.ID && dev->ID == _bl_spiActiveDev.ID)
    {
       OS_EXIT_CRITICAL();
       return 0;
    }
    else
    {
       // Wait for semaphore
       OSMutexPend((OS_EVENT*)spi_Mutex,(int)_BL_SPI_TIMEOUT,(char*)&rc);
       memcpy(&_bl_spiActiveDev, dev, bl_structSize);
       OS_EXIT_CRITICAL();
      if ((char)rc != OS_NO_ERR)
      {
         exception(ERR_SPI_MUTEX_ERROR);   // Mutex errors are fatal
         exit(ERR_SPI_MUTEX_ERROR);
      }
       //WrPortI(SBER,&SBERShadow,_bl_spiActiveDev.SBERvalue);
       WrPortI(TAT7R,&TAT7RShadow,_bl_spiActiveDev.SCLCKdiv);
      for (i = 0; i < 5; ++i)
      {
      	// Let baud clock run down
      }
       return 0;
    }
}
#endif

/***************************************************************

 int _bl_SPIfreeSemaphore(const struct _bl_SPI_Dev *dev)

 Should be called by device specified by dev when the device
 no longer needs to use the SPI lines. Must be called by the
 owning device before the semaphore can grabbed by any device
 again.

****************************************************************/
#ifndef _BL_SPI_USE_UCOS_MUTEX
#asm
_bl_SPIfreeSemaphore::
#ifndef  BL_SPI_NODEVSHARING
    DB_IP_SET3
    ld    a,(_bl_SPI_semaphore)  ; A = ID
    cp    (hl)                ; Only owner can free it
    jr    nz,.spiFSdone
    ld    a,BL_SPI_ID_NONE       ; 0
    ld    (_bl_SPI_semaphore),a  ;  _bl_SPI_semaphore.ID = 0
    ld    (_bl_spiActiveDev),a   ;  _bl_spiActiveDev.owner = 0
.spiFSdone:
    DB_IP_RES
    ld    h,0
    ld    L,a                 ; 0 for success or owner
#else
    clr   hl
#endif
    ret
#endasm

#else // Using uC/OS-II mutex
_bl_nodebug
int _bl_SPIfreeSemaphore(const struct _bl_SPI_Dev *dev)
{
    auto rc;

    OS_ENTER_CRITICAL();
    // If calling device already owns, just return success
    if(_bl_spiActiveDev.ID==0)
    {
       OS_EXIT_CRITICAL();
       return 0;
    }
    else
    {
       // Signal semaphore free
       rc = OSMutexPost((OS_EVENT*)spi_Mutex);
       _bl_spiActiveDev.ID = 0;
       OS_EXIT_CRITICAL();
       if(rc != OS_NO_ERR)
       {
          exception(ERR_SPI_MUTEX_ERROR);
          exit(ERR_SPI_MUTEX_ERROR);
       }
       return 0;
    }
 }

#endif

/*** BeginHeader _bl_spi_dev */
// Define shared SPI devices
const struct _bl_SPI_Dev _bl_spi_dev[BL_SPI_SHARED_DEVS] = {
   {BL_SPI_ID_RN1, BL_SPI_RN1_DIVISOR}, // RabbitNet1
   {BL_SPI_ID_RN2, BL_SPI_RN2_DIVISOR}, // RabbitNet2
   {BL_SPI_ID_ADC, BL_SPI_ADC_DIVISOR}, // ADC
   {BL_SPI_ID_DAC, BL_SPI_DAC_DIVISOR}  // DAC
};
/*** EndHeader */

//////////////////////////////////////////////////////////////////////////

/*** BeginHeader ledOut*/
void ledOut(int led, int value);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
ledOut                              <BLxS2xx.LIB>

SYNTAX:			void ledOut(int led, int value);

DESCRIPTION:	placeholder to prevent compile-time errors.  There are
no LED's to blink on a BLxS2xx.

PARAMETER:		N/A

RETURN VALUE:	none.

END DESCRIPTION **********************************************************/
__nodebug void ledOut (int led, int value)
{
	#warnt "There are no LED's on a BLxS2xx to blink."
}

/*** BeginHeader serMode */
int serMode(int mode);
/*** EndHeader */

#ifndef SER_NO_FLOWCONTROL
 #if _BOARD_TYPE_ == RCM4010
   #warns "The RCM4010 based board does not support full flow control."
   #warns "Define SER_NO_FLOWCONTROL to supress this message."
 #endif
#endif

/* START FUNCTION DESCRIPTION ********************************************
serMode                 <BLxS2xx.LIB>

SYNTAX:        int serMode(int mode)

DESCRIPTION:   This function sets serial interfaces to be used by your
               application program. This function must be called after
               executing the serXopen function(s) and before using any
               of the other serial port functions. This function is non-
               reentrant.

PARAMETER1:    Defines the serial port configuration, modes are as
               follows.  Mode parameter has no effect on BL4S210.

               BL4S200, BL4S230 or BL5S220 only:
               Mode     Serial C    Serial E          Serial F
               ----     --------    --------          --------
               0        RS485       RS232, 3 wire     RS232, 3 wire
               1        RS485       RS232, 5 wire     CTS/RTS

               BL4S210:
               Mode     Serial C    Serial B
               ----     --------    --------
               X        RS485       RS232, 3 wire

RETURN VALUE:  0  = Valid mode selected.
               -EINVAL = Invalid mode selected.

SEE ALSO:      ser485Tx, ser485Rx and serX functions

END DESCRIPTION **********************************************************/

_bl_nodebug
int serMode(int mode)
{
   if (mode != 0 && mode != 1)
   {
      return -EINVAL;
   }
#if _BOARD_TYPE_ != RCM4010
   else if (mode == 0) // PD2 will be used for TXF (alternate function 3)
   {
      WrPortI(PDFR, &PDFRShadow, PDFRShadow | 0x04);
   }
   else                // PD2 will be used for RTS (GPIO)
   {
      WrPortI(PDFR, &PDFRShadow, PDFRShadow & ~0x04);
   }
#endif

   ser485Rx();
   return 0;
}


/*** BeginHeader ser485Tx */
void ser485Tx(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ser485Tx                <BLxS2xx.LIB>

SYNTAX:        void ser485Tx(void)

DESCRIPTION:   Enables the RS485 transmitter. The serMode function must
               be executed before running this function. This function
               is non-reentrant.

               Note:
               -----
               Transmitted data is echo'ed back into the receive data
               buffer. This echo'ed data could be used to identify when
               to disable the transmitter by using one of the following
               methods:

               a) Byte mode...disable the transmitter after the byte that
               is transmitted, is detected in the receive data buffer.

               b) Block data mode...disable the transmitter after the
               same number of bytes transmitted, are detected in the
               receive data buffer.

PARAMETER1:    None.

RETURN VALUE:  None.

SEE ALSO:      brdInit, serMode, ser485Rx

END DESCRIPTION **********************************************************/

#asm _bl_nodebug
ser485Tx::
   ld    de, _cexpr(BL_LATCH)    ; external port address
   ld    hl, _cexpr(__latch_sr)    ; shadow address
   push  ip
   ipset 1                       ; stop normal ISRs to prevent race
   set   3, (hl)                 ; set shadow bit 3
ioe   ldd                        ; copy shadow to port [ioe](de) <- (hl)
   pop   ip
   ret
#endasm


/*** BeginHeader ser485Rx */
void ser485Rx(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ser485Rx                <BLxS2xx.LIB>

SYNTAX:        void ser485Rx(void)

DESCRIPTION:   Disables the RS485 transmitter. This puts you in listen
               mode which allows you to receive data from the RS485
               interface. The serMode function must be executed before
               running this function. This function is non-reentrant.

PARAMETER1:    None.

RETURN VALUE:  None.

SEE ALSO:      brdInit, serMode, ser485Tx

END DESCRIPTION **********************************************************/

#asm _bl_nodebug
ser485Rx::
   ld    de, _cexpr(BL_LATCH)    ; external port address
   ld    hl, _cexpr(__latch_sr)    ; shadow address
   push  ip
   ipset 1                       ; stop normal ISRs to prevent race
   res   3, (hl)                 ; reset (clear) shadow bit 3
ioe   ldd                        ; copy shadow to port [ioe](de) <- (hl)
   pop   ip
   ret
#endasm



/////////////////////////////////
// Interrupt Handler Functions //
/////////////////////////////////

/*** BeginHeader addISR */
int addISR(int channel, int io, int ier, void (*handler)());
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
addISR                  <BLxS2xx.LIB>

SYNTAX:        int addISR(int channel, int io, int ier, void (*handler)())

DESCRIPTION:   Adds an interrupt handler for the interrupts specified
               in ier for the given RIO block hosting the given
               configurable I/O pin.  The ISR is always disabled when
               created.  To enable the ISR, call enableISR.  The ISR
               handler function is responsible for clearing the
               interrupt(s) within the hosting RIO block when called.

PARAMETER1:    Configurable I/O channel to bind to ISR, 0 - 31.

PARAMETER2:    io - BL_INPUT_BLOCK for input block
                    BL_OUTPUT_BLOCK for output block

PARAMETER3:    ier - Bit mask of interrupt(s) this handler services
                      BL_IER_DQE    - Decrement/Quadrature/End
                      BL_IER_IIB    - Increment/Inphase/Begin
                      BL_IER_ROLL_D - Counter rollover on decrement
                      BL_IER_ROLL_I - Counter rollover on increment
                      BL_IER_MATCH3 - Match 3 condition
                      BL_IER_MATCH2 - Match 2 condition
                      BL_IER_MATCH1 - Match 1 condition
                      BL_IER_MATCH0 - Match 0 condition

PARAMETER4:    handler - Pointer to the interrupt service function

RETURNS:       On Success, returns the handler ID number (0..RSB_MAX_ISR-1)
                -EINVAL  Invalid parameter given
                -ENOSPC  No more room in ISR table (increase RSB_MAX_ISR)

SEE ALSO:      addISR_H, tickISR, enableISR, setIER

END DESCRIPTION **********************************************************/

_bl_nodebug
int addISR(int channel, int io, int ier, void (*handler)())
{
   auto int rc;

   if (channel < 0 || channel >= BL_DIGITAL_IO || io < 1 || io > 2)
   {
      BL_ERROR(-EINVAL);   // Parameter invalid
   }
   rc = _addISR(DIO_PIN(channel), io, ier, handler);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader addISR_H */
int addISR_H(int channel, int ier, void (*handler)());
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
addISR_H                <BLxS2xx.LIB>

SYNTAX:        int addISR_H(int channel, int ier, void (*handler)())

DESCRIPTION:   Adds an interrupt handler for the interrupts specified
               in ier for the given RIO block hosting the given
               high current output pin.  The ISR is always disabled when
               created.  To enable the ISR, call enableISR.  The ISR
               handler given is responsible for clearing the interrupt(s)
               within the hosting RIO block.

PARAMETER1:    High current output channel to bind to ISR, 0 - 7.

PARAMETER2:    ier - Bit mask of interrupt(s) this handler services
                      BL_IER_DQE    - Decrement/Quadrature/End
                      BL_IER_IIB    - Increment/Inphase/Begin
                      BL_IER_ROLL_D - Counter rollover on decrement
                      BL_IER_ROLL_I - Counter rollover on increment
                      BL_IER_MATCH3 - Match 3 condition
                      BL_IER_MATCH2 - Match 2 condition
                      BL_IER_MATCH1 - Match 1 condition
                      BL_IER_MATCH0 - Match 0 condition

PARAMETER3:    handler - Pointer to the interrupt service function

RETURNS:       On Success, returns the handler ID number (0..RSB_MAX_ISR-1)
                -EINVAL  Invalid parameter given
                -ENOSPC  No more room in ISR table (increase RSB_MAX_ISR)

SEE ALSO:      addISR, tickISR, enableISR, setIER

END DESCRIPTION **********************************************************/

_bl_nodebug
int addISR_H(int channel, int ier, void (*handler)())
{
   auto int rc;

   if (channel < 0 || channel >= BL_DIGITAL_HC)
   {
      BL_ERROR(-EINVAL);   // Parameter invalid
   }
   rc = _addISR(HCO_PIN(channel), BL_OUTPUT_BLOCK, ier, handler);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader _addISR */
int _addISR(struct RSB_IOpin* chPtr, int io, int ier, void (*handler)());
/*** EndHeader */

/**************************************************************************
 Internal function for setting the ISR for any RIO-based pin.  Uses
 mostly the same parameters as addISR, with the exception of the first
 parameter.  The chPtr is a pointer to the RIO-based pin to bind the
 ISR to.  This can be any RIO based pin, I/O or high current.
 The ier parameter should have a bitmask of block interrupt sources to
 be handled by the ISR handler.  The ISR is always initially disabled.
 The handler parameter is a pointer to the user supplied Interrupt Service
 Routine to handle the given interrupt sources.  It is responsible for
 clearing the interrupt condition within the RIO block it is hosted by.
**************************************************************************/
_bl_nodebug
int _addISR(struct RSB_IOpin* chPtr, int io, int ier, void (*handler)())
{
   auto int block, rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag)
   {
      // the brdInit function hasn't been executed as of yet
      return (-EINVAL);
   }
#endif

   // Set block to use based on channel function
   block = (io == BL_INPUT_BLOCK ? chPtr->block1 : chPtr->block2);

   // setup the ISR function for the given channel and return ISR handle
   return _riosbc_add_isr(chPtr->index, block, ier, handler);
}

/*** BeginHeader setIER */
int setIER(int isr_handle, int ier);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
setIER                     <BLxS2xx.LIB>

SYNTAX:     int setIER(int isr_handle, int ier)

DESCRIPTION:   Sets the IER mask for an interrupt handler.  Note that
               the interrupt handler must be currently disabled to set
               the IER value.  Disabling the ISR can be done by calling
               enableISR with a zero in the enable parameter.

PARAMETER1:    isr_handle - Index to the desired ISR

PARAMETER2:    ier - Bit mask of interrupts this handler services
                     (Bit positions match RIO IER and Status registers)

RETURNS:       0 on Success
                -EINVAL  Invalid parameter given
                -EPERM   Handler is enabled, can't change IER

SEE ALSO:      addISR, addISR_H, enableISR, tickISR

END DESCRIPTION **********************************************************/
_bl_nodebug
int setIER(int isr_handle, int ier)
{
   auto int rc;

   rc = _riosbc_set_ier(isr_handle, ier);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader enableISR */
int enableISR(int isr_handle, int enable);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
enableISR                  <BLxS2xx.LIB>

SYNTAX:     int enableISR(int isr_handle, int enable)

DESCRIPTION:   Enables or disables an interrupt handler.

PARAMETER1:    isr_handle - Index to the desired ISR

PARAMETER2:    enable - Non-zero enables the ISR, zero disables the ISR

RETURNS:       0 on Success
                -EINVAL  Invalid parameter given

SEE ALSO:      addISR, addISR_H, setIER, tickISR

END DESCRIPTION **********************************************************/
_bl_nodebug
int enableISR(int isr_handle, int enable)
{
   auto int rc;

   rc = _riosbc_enable_isr(isr_handle, enable);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader tickISR */
void tickISR(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
tickISR                 <BLxS2xx.LIB>

SYNTAX:     void tickISR(void)

DESCRIPTION:   Polls the RIO chip(s) for ISR events if interrupts are
               not being used.  Any enabled ISR events will be passed
               on to the appropriate ISR handler.

SEE ALSO:      addISR, addISR_H, enableISR, setIER

END DESCRIPTION **********************************************************/
_rsb_debug
void tickISR(void)
{
   _riosbc_process_irq();
   return;
}



/////////////////////////////
// Digital Input Functions //
/////////////////////////////

/*** BeginHeader setDigIn */
int setDigIn(int channel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setDigIn                <BLxS2xx.LIB>

SYNTAX:        int setDigIn(int channel)

DESCRIPTION:   Sets the input capable channel to be a general digital input.
               This function is non-reentrant.

PARAMETER1:    Configurable I/O channel to be set as input, 0 - 31.

               0  - 31 = pins DIO0 - DIO31.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value.

SEE ALSO:      brdInit, digIn, digInBank

END DESCRIPTION **********************************************************/

_bl_nodebug
int setDigIn(int channel)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed or channel bad
      BL_ERROR(-EINVAL);
   }
#endif

   // set the channel to be a Digital Input
   rc = _riosbc_set_function(DIO_PIN(channel), RSB_FUNC_DIGIN, 0);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader digIn */
int digIn(int channel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digIn                   <BLxS2xx.LIB>

SYNTAX:        int digIn(int channel)

DESCRIPTION:   Reads the state of a channel set to any form of digital
               input functionality. This function is non-reentrant.

PARAMETER1:    Channel set to input functionality, 0 - 31.

               0  - 31 = pins DIO0 - DIO31.

RETURN VALUE:  The logic state of the specified channel.
               0 = Logic low.
               1 = Logic High.
               -EINVAL: channel value is out of range
               -EPERM:  pin functionality does not permit this operation

SEE ALSO:      brdInit, setDigIn, digInBank

END DESCRIPTION **********************************************************/

_bl_nodebug
int digIn(int channel)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _riosbc_get_pin(DIO_PIN(channel));
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader digInBank */
int digInBank(int bank);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digInBank            <BLxS2xx.LIB>

SYNTAX:        int digInBank(int bank)

DESCRIPTION:   Reads the state of 32 digital input capable channels
               DIO0-DIO31.  This function is non-reentrant.

RETURN VALUE:  Data read from digital input bank.

               Data    Bank    Bank    Bank    Bank
               Bits     0       1       2       3
               -------------------------------------
         (LSB) D0   =  DIO0    DIO8   DIO16   DIO24
               D1   =  DIO1    DIO9   DIO17   DIO25
               D2   =  DIO2   DIO10   DIO18   DIO26
               D3   =  DIO3   DIO11   DIO19   DIO27
               D4   =  DIO4   DIO12   DIO20   DIO28
               D5   =  DIO5   DIO13   DIO21   DIO29
               D6   =  DIO6   DIO14   DIO22   DIO30
         (MSB) D7   =  DIO7   DIO15   DIO23   DIO31

               -EINVAL: invalid parameter value
               -EPERM:  pin functionality does not permit this operation

SEE ALSO:      brdInit, digIn, setDigIn

END DESCRIPTION **********************************************************/
_bl_nodebug
int digInBank(int bank)
{
   auto int ch_data, data, i;
   auto int j;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || bank < 0 || bank > ((BL_DIGITAL_IO + 7) >> 3))
   {
      // the brdInit function hasn't been executed as of yet or bank invalid
      BL_ERROR(-EINVAL);
   }
#endif

   // Get data from groups of blocks based on bank selection
   if (bank & 2)
   {
      if (bank & 1)
      {  // Bank 3
         data  = _riosbc_get_block(DIO_PIN(24)) & 3;
         data |= (_riosbc_get_block(DIO_PIN(26)) & 3) << 2;
         for (i = 28; i < 32; i++) {
            if (_riosbc_get_pin(DIO_PIN(i))) data |= _rsb_bitmap[i & 7];
         }
      }
      else
      {   // Bank 2
         for (i = 22, data = 0; i > 15; i -= 2) {
            data |= _riosbc_get_block(DIO_PIN(i)) & 3;
            if (i > 17) data <<= 2;
         }
      }
   }
   else
   {  // Banks 0 & 1 (Both hosted on just 2 blocks)
      i = (bank & 1) << 3;
      data = _riosbc_get_block(DIO_PIN(i));
      data |= _riosbc_get_block(DIO_PIN(i + 4)) << 4;
   }

   return(data);
}

/*** BeginHeader setExtInterrupt */
int setExtInterrupt(int channel, char edge, int handle);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setExtInterrupt               <BLxS2xx.LIB>

SYNTAX:    int setExtInterrupt(int channel, char edge, int handle)

DESCRIPTION:   Sets the given channel to be an interrupt.  The interrupt can
               be configured as a rising edge, falling edge, or either
               edge.

               Note: The RIO supports a maximum of two external interrupt
               channels per block, due to the existence of just two edge
               detection circuits per block.

PARAMETER1:    Input channel to be configured as an interrupt.

PARAMETER2:    Edge of the interrupt:
               BL_IRQ_RISE = Interrupt event on rising edge
               BL_IRQ_FALL = Interrupt event on falling edge
               BL_IRQ_BOTH = Interrupt events on both edges

PARAMETER3:    Handle for the ISR handler to service this interrupt.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected

SEE ALSO:      brdInit, digIn, setDigIn

END DESCRIPTION **********************************************************/
_bl_nodebug
int setExtInterrupt(int channel, char edge, int handle)
{
   auto int rc;
   auto struct RSB_IOpin *ptr;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   // set function of the channel
   ptr = DIO_PIN(channel);
   rc = _riosbc_set_function(ptr, RSB_FUNC_INTERRUPT, edge);
   if (rc) {BL_ERROR(rc);}

   // Set the Interrupt Enable return value based on IIB or DQE usage
   rc = _riosbc_set_ier(handle, ((rsb_rio[ptr->index].block[ptr->block1].ic_use
               & _rsb_bitmap[ptr->bit1]) ? RSB_IER_IIB: RSB_IER_DQE));

   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader setDecoder */
int setDecoder(int channel_a, int channel_b, int channel_index,
                 char index_polarity);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setDecoder                       <BLxS2xx.LIB>

SYNTAX:    int setDecoder(int channel_a, int channel_b, int channel_index,
                           char index_polarity)

DESCRIPTION:   Sets up the Quadrature Decoder functionality on the given
               channels. The quadrature decoder can optionally utilize an
               index channel.

PARAMETER1:    Channel to use as A input (also known as in-phase or I)

PARAMETER2:    Channel to use as B input (also known as Quadrature or Q)

PARAMETER3:    Channel to use as Index input
                 (-1 if not used, NOTE: Count may still be reset by Sync
                    signals existing or setup on the same RIO & Block)

PARAMETER4:    Polarity of the index channel.
               0 for index on low level
               non-zero for index on hi level
               (not used when channel_index set to -1)

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EACCES: resource needed by this function is not available

SEE ALSO:      brdInit, getCounter, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int setDecoder(int channel_a, int channel_b, int channel_index,
                              char index_polarity)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel_a < 0 || channel_a >= BL_DIGITAL_IO ||
         channel_b < 0 || channel_b >= BL_DIGITAL_IO ||
          channel_index >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _riosbc_set_decoder(DIO_PIN(channel_a), DIO_PIN(channel_b),
          (channel_index < 0 ? NULL : DIO_PIN(channel_index)), index_polarity);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setCounter */
int setCounter(int channel, int mode, int edge, word options);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setCounter                       <BLxS2xx.LIB>

SYNTAX:    int setCounter(int channel, int mode, int edge, word options)

DESCRIPTION:   Sets up the channel as a counter input, with selectable
               modes and edge settings.  The counter will increment or
               decrement on each selected edge event.  Use getCounter()
               to read the current count and resetCounter() to force a
               reset of the counter.

PARAMETER1:    Channel to use for the up count input.

PARAMETER2:    Mode of the counter:
                  BL_UP_COUNT     = Continuous up count mode
                  BL_DOWN_COUNT   = Up/down counter mode (2 pins used)
                  BL_MATCH_ENABLE = Continuous up count mode with count
                                     stopping on any match event
PARAMETER3:    Edge setting for the up count event:
                  BL_EDGE_RISE   = Up count on rising edge
                  BL_EDGE_FALL   = Up count on falling edge
                  BL_EDGE_BOTH   = Up count on either edge

PARAMETER4:    Options based on mode:  (N/A if continuous up mode selected)
                - If up/down mode is selected, options has down count pin
                  and event edge settings (can't be same pin as up count).
                   Low 5 bits is channel number for down count input
                   BL_EVENT_RISE   = Down count on rising edge
                   BL_EVENT_FALL   = Down count on falling edge
                   BL_EVENT_BOTH   = Down count on either edge
                - If stop on match mode is selected, options has the match
                  count to stop at. (Sets other match reg's on block to max.)

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value or pin usage
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected
               positive number: Mode Conflict - See Appendix D of the
                                                BL4S200 User's Manual

SEE ALSO:      brdInit, getCounter, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int setCounter(int channel, int mode, int edge, word options)
{
   auto struct RSB_IOpin *chPtr, *chPtr2;
   auto struct _RSB_BLOCK_USE *use;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO ||
        mode > BL_DOWN_COUNT || (mode == BL_DOWN_COUNT &&
            (options & (BL_EVENT_RISE - 1)) >= BL_DIGITAL_IO))
   {
      // the brdInit function hasn't been executed as of yet
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct
   if (mode & BL_DOWN_COUNT) {
      // Up/down count mode, get pointer to down count channel
      chPtr2 = DIO_PIN(options & 0x1F);
      if ((chPtr->index != chPtr2->index) || (chPtr->block1 != chPtr2->block1)
            || (chPtr->bit1 == chPtr2->bit1))
      {  // Up and down count channels NOT on same RIO and block or attempt
         BL_ERROR(-EINVAL);  // to use the same pin for both up & down count
      }
	   // Set counter input functionality to down count channel
      rc = _riosbc_set_function(chPtr2, RSB_FUNC_COUNTER_INPUT, 0);
      if (rc) {
         BL_ERROR(rc);
      }
   }

   // Set counter input functionality to the given channel
   rc = _riosbc_set_function(chPtr, RSB_FUNC_COUNTER_INPUT, 0);
   if (rc) {BL_ERROR(rc);}

   // Always reset counter and add in edge selection
   mode |= RSB_COUNT_RESET | edge;
   // Additional setup based on mode setting
   if (mode & BL_DOWN_COUNT) {
      // Set the up count input using main channel (remove down mode flag)
      rc = _riosbc_set_counter(chPtr, mode ^ BL_DOWN_COUNT);
      if (rc < 0) {BL_ERROR(rc);}
      // Set down count ptr as main channel
      chPtr = chPtr2;
      // Setup the down count mode
      mode = RSB_COUNT_RESET | BL_DOWN_COUNT | ((options & BL_EVENT_BOTH) >> 8);
   }
   else if (mode & BL_MATCH_ENABLE) {
      // Max out all match registers if using stop on match
      mode |= RSB_MAX_MATCHES;
   }
   // Setup counter and return with result in rc
   rc = _riosbc_set_counter(chPtr, mode);
   if ((mode & BL_MATCH_ENABLE) && (rc == 0)) {
      // Set match register to value in options
      rc = _riosbc_set_match(chPtr, 0, options);
      chPtr->match = RSB_RES_MATCH0;    // Show use of Match 0 for active value
      // Reset counter to latch match value into block
	   WrPortE(chPtr->addr1, NULL, RSB_CMD);
	   WrPortE(chPtr->addr1 + 1, NULL, RSB_CMD_ZERO);
   }
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setCapture */
int setCapture(int channel, int mode, int edge, word options);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setCapture                       <BLxS2xx.LIB>

SYNTAX:    int setCapture(int channel, int mode, int edge, word options)

DESCRIPTION:   Sets up the channel as an event capture input, with
               selectable modes and edge settings.  The counter will run
               from a gated main or prescaled clock signal based on the
               run criteria of the selected mode, and begin/end events
               can be set to capture the count at the time of these
               events.  Optionally, a second channel can be set (which
               shares the same RIO channel input block as 'channel') for
               two signal begin/end event detection.  Use getBegin()
               and getEnd() to read the captured count values and
               resetCounter() to force a reset of the counter.

PARAMETER1:    Channel to use for the begin event input for all modes except
                BL_CNT_TIL_END, then it specifies the end event input.

PARAMETER2:    Mode of the counter/timer:
                  BL_CNT_RUN       = Continuous count mode
                  BL_CNT_BEGIN_END = Start count on begin event, continue
                                      to count until end event detected.
                      NOTE: If an end event occurs before the begin event,
                            the count will begin then end immediately on
                            the begin event and end count will equal to 1.
                            Begin will be 0 or 1 based on the edge which
                            triggered the event (0=rising, 1=falling).
                  BL_CNT_TIL_END   = Count until end event detected
                  BL_CNT_ON_BEGIN  = Count while BEGIN signal is active

PARAMETER3:    Edge/state setting for the begin event for all modes except
                BL_CNT_TIL_END, then it specifies the end event.
                  BL_EVENT_RISE  = Begin event on rising edge
                  BL_EVENT_FALL  = Begin event on falling edge
                  BL_EVENT_BOTH  = Begin event on any edge
                The following two settings are only for the ON_BEGIN mode
                  BL_BEGIN_HIGH = Begin active while signal is high
                  BL_BEGIN_LOW  = Begin active while signal is low

PARAMETER4:    Options based on mode:
                - If BL_CNT_TIL_END, then begin input & edge can be selected.
                - All others modes, then end input & edge can be selected.
                - For all modes, the prescale clock and save limit flags
                  can be used (OR in).
                For input & edge selection use:
                  Low 5 bits for channel to use for begin/end input
                  BL_SAME_CHANNEL  = Begin & End both from same channel
                  BL_EVENT_RISE    = Begin/end event on rising edge
                  BL_EVENT_FALL    = Begin/end event on falling edge
                  BL_EVENT_BOTH    = Begin/end event on any edge
                For clock and limit options use:
                  BL_PRESCALE   = Use prescaled clock
                  BL_SAVE_LIMIT = Save current limit register value
                                   (Otherwise limit set to 0xFFFF)

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected
               positive number: Mode Conflict - See Appendix D of the
                                                BL4S200 User's Manual

SEE ALSO:      brdInit, getBegin, getEnd, getCounter, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int setCapture(int channel, int mode, int edge, word options)
{
   auto struct RSB_IOpin *chPtr, *optPtr;
   auto int rc;
   auto word flags;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO ||
       (mode & (~BL_CNT_ON_BEGIN)) || (edge & (~BL_BEGIN_HIGH)))
   {
      // the brdInit function hasn't been executed or invalid parameter
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   flags = mode | RSB_CAPT_RESET | (options & (BL_PRESCALE | BL_SAVE_LIMIT));
   if ((options & BL_EVENT_BOTH) && !(options & BL_SAME_CHANNEL)) {
      // Optional secondary pin, get ptr. and make sure RIO/block matches
      optPtr = DIO_PIN(options & 0x1F);
      if (chPtr->index != optPtr->index || chPtr->block1 != optPtr->block1)
      {
         BL_ERROR(-EINVAL);
      }
   }
   else {
      optPtr = chPtr;    // Same channel or no options, just copy pointer
   }

   // Setup remaining flags based on mode
   if (mode == BL_CNT_TIL_END) {
      // If edge is for down count, cannot have state based value or no edge
      if (!edge || (edge & 0x2000)) { BL_ERROR(-EINVAL) };
      // Add flags to specify end edge and pin
      flags |= (edge >> 8) | RSB_SEL_PORT0 | chPtr->bit1;
      // See if begin event is also specified
      if (options & BL_EVENT_BOTH) {
         // Add flags to specify begin edge and port pin
         flags |= (options & BL_EVENT_BOTH) |
                    ((RSB_SEL_PORT0 + optPtr->bit1) << 8);
      }
   }
   else {
      if (edge) {
	      // Add flags to specify begin edge and pin
	      flags |= edge | ((chPtr->bit1 + RSB_SEL_PORT0) << 8);
      }
      else {
         if (mode != BL_CNT_RUN) {
            BL_ERROR(-EINVAL);   // Need begin event/state on begin based modes
         }
      }
      // See if end event is also specified
      if (options & BL_EVENT_BOTH) {
         // Add flags to specify end edge and port pin
         flags |= ((options & BL_EVENT_BOTH) >> 8) |
                      RSB_SEL_PORT0 | optPtr->bit1;
      }
   }

   if (optPtr != chPtr) {
      // Set additional event input as a digital input pin
      rc = _riosbc_set_function(optPtr, RSB_FUNC_DIGIN, 0);
      if (rc) {BL_ERROR(rc);}
   }

   // Setup functionality of the pin
   rc = _riosbc_set_function(chPtr, RSB_FUNC_CAPTURE_INPUT, mode);
   if (rc == 0) {
      // Setup capture input and return with result
      rc = _riosbc_set_capture(chPtr, flags);
   }
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader getCounter */
int getCounter(int channel, word *count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
getCounter                       <BLxS2xx.LIB>

SYNTAX:    int getCounter(int channel, word *count)

DESCRIPTION:   Reads the current count of the counter register within
               the counter block hosting the given channel.

PARAMETER1:    A Channel which uses the desired counter block

PARAMETER2:    Pointer to word variable to place count register reading

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, setCounter, setDecoder, setCapture, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int getCounter(int channel, word *count)
{
   auto struct RSB_IOpin* chPtr;
   auto int rc;


#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // The brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   if (chPtr->function >= RSB_FUNC_DIGOUT)
   {
      // The channel isn't an input
      BL_ERROR(-EINVAL);
   }

   rc = _riosbc_get_count(chPtr, count);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader getBegin */
int getBegin(int channel, word *begin);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
getBegin                         <BLxS2xx.LIB>

SYNTAX:    int getBegin(int channel, word *begin)

DESCRIPTION:   Reads the current value of the begin register within
               the counter block hosting the given channel.

PARAMETER1:    A Channel which uses the desired counter block

PARAMETER2:    Pointer to word variable to place begin register reading

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, setCapture, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int getBegin(int channel, word *begin)
{
   auto struct RSB_IOpin* chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   if (chPtr->function >= RSB_FUNC_DIGOUT)
   {
      // the channel isn't an input
      BL_ERROR(-EINVAL);
   }

   rc = _riosbc_get_begin(chPtr, begin);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader getEnd */
int getEnd(int channel, word *end);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
getEnd                           <BLxS2xx.LIB>

SYNTAX:    int getEnd(int channel, word *end)

DESCRIPTION:   Reads the current value of the end register within
               the counter block hosting the given channel.

PARAMETER1:    A Channel which uses the desired counter block

PARAMETER2:    Pointer to word variable to place end register reading

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, setCapture, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int getEnd(int channel, word *end)
{
   auto struct RSB_IOpin* chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   if (chPtr->function >= RSB_FUNC_DIGOUT)
   {
      // the channel isn't an input
      BL_ERROR(-EINVAL);
   }

   rc = _riosbc_get_end(chPtr, end);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader resetCounter */
int resetCounter(int channel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
resetCounter                        <BLxS2xx.LIB>

SYNTAX:    int resetCounter(int channel)

DESCRIPTION:   Resets the current count of the counter register within
               the active counter block hosting the given channel.
               Active block is determined by current channel function.

PARAMETER1:    A Channel which uses the desired counter block

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, getCounter, setDecoder

END DESCRIPTION **********************************************************/
_bl_nodebug
int resetCounter(int channel)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _riosbc_clear_count(DIO_PIN(channel));
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader setLimit */
int setLimit(int channel, word limit);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setLimit                      <BLxS2xx.LIB>

SYNTAX:    int setLimit(int channel, word limit)

DESCRIPTION:   Sets the new value of the limit register within the
               counter block hosting the given channel.  This new value
               will take effect on the next counter overflow or by
               resetting the counter (a call to resetCounter()).

PARAMETER1:    A Channel which uses the desired counter block

PARAMETER2:    New value for the limit register

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, setCapture, resetCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int setLimit(int channel, word limit)
{
   auto struct RSB_IOpin* chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   if (chPtr->function >= RSB_FUNC_DIGOUT)
   {
      // the channel isn't an input
      BL_ERROR(-EINVAL);
   }

   rc = _riosbc_set_limit(chPtr, limit);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setSync */
int setSync(int channel, int source, int edge);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setSync                          <BLxS2xx.LIB>

SYNTAX:    int setSync(int channel, int source, int edge)

DESCRIPTION:   Sets the sync for the block the channel is associated with.
               Note that when synchronizing more than one block to the
               same sync signal (global or external), each block has its
               own independent edge detection circuit.  These circuits
               will sync to the edge within plus or minus one count of
               the block's current clock source (main or prescale).
               This means synchronized blocks may have a small offset
               when compared to each other.

PARAMETER1:    Channel that is on the block that will have its sync set.

PARAMETER2:    Source of the sync signal.
               -1 to use the RIO chip's Global Sync signal
               OR Input capable channel to use as an external Sync signal

PARAMETER3:    Edge of the sync signal.
               BL_EDGE_RISE = Synchronize event on rising edge
               BL_EDGE_FALL = Synchronize event on falling edge
               BL_EDGE_BOTH = Synchronize events on both edges
               OR        0  = Remove Sync on this block
                                (if source of external sync is given,
                                 it will be set to a digital input)

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected

SEE ALSO:      brdInit

END DESCRIPTION **********************************************************/
_bl_nodebug
int setSync(int channel, int source, int edge)
{
   auto struct RSB_IOpin *chPtr, *srcPtr;
   auto char block, sync;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO
            || source >= BL_DIGITAL_IO || (edge & (~BL_EDGE_BOTH)))
   {
      // the brdInit function hasn't been executed or invalid parameter
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   if (source < 0) {
      if (edge) {
	      // Set global sync on host block of channel
	      rc = _riosbc_block_sync(chPtr, edge + RSB_SEL_GLOBAL);
      }
      else {
	      // Turn off global sync on host block of channel
	      rc = _riosbc_block_sync(chPtr, 0);
      }
   }
   else {
      srcPtr = DIO_PIN(source);   // get pointer to source pin struct
      // Make sure active channel RIO/block is same RIO/Block as source input
      block = (chPtr->function < RSB_FUNC_DIGOUT ?
                                      chPtr->block1 : chPtr->block2);
      if (edge) {
	      if (chPtr->index != srcPtr->index || block != srcPtr->block1)
	      {  // Channel and Source not hosted by same RIO/Block
	         rc = -EINVAL;
	      }
         else {
   	      rc = _riosbc_set_function(srcPtr, RSB_FUNC_SYNC, edge << 3);
         }
      }
      else {
         // Verify source pin is an external sync input on same block as chPtr
         if (srcPtr->function != RSB_FUNC_SYNC || srcPtr->block1 != block)
         {
            rc = -EINVAL;
         }
         else {
	         // Turn off external sync on host block of channel
	         rc = _riosbc_block_sync(chPtr, 0);
	         if(!rc)
	         {
	           // Set external sync pin to a digital input
	           rc = _riosbc_set_function(srcPtr, RSB_FUNC_DIGIN, 0);
	         }
         }
      }
   }
	// delay long enough for 4 prescalar clock cycles on the RIO
   #asm __nodebug
   BL_RIO_DELAY(4);
   #endasm

   if (rc) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader globalSync */
int globalSync(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
globalSync                          <BLxS2xx.LIB>

SYNTAX:    int globalSync(void)

DESCRIPTION:   Sends a single pulse to the global sync inputs of all
               RIO chips.

               Note that when synchronizing more than one block to the
               same sync signal (global or external), each block has its
               own independent edge detection circuit.  These circuits
               will sync to the edge within plus or minus one count of
               the block's current clock source (main or prescale).
               This means synchronized blocks may have a small offset
               when compared to each other.

RETURN VALUE:  0 on success
               -EPERM: brdInit was not run before calling this function

SEE ALSO:      brdInit

END DESCRIPTION **********************************************************/
_bl_nodebug
int globalSync(void)
{
   auto int i;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag)
   {
      // the brdInit function hasn't been executed as of yet
      BL_ERROR(-EINVAL);
   }
#endif

#if _BOARD_TYPE_ != RCM4010   // Core type is NOT RCM4010
   // Make sure PE4 is in bit mode
   BitWrPortI(PEFR, &PEFRShadow, 0, 4);
#endif

   // Send single positive pulse to Global Sync line on all RIO's
   SET_GS(0);
   SET_GS(1);

	// delay long enough for 3 prescalar clock cycles on the RIO
   #asm __nodebug
   BL_RIO_DELAY(3);
   #endasm

   // End the pulse
   SET_GS(0);
   return 0;
}

/*** BeginHeader getMatch */
int getMatch(int channel, int source);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
getMatch                        <BLxS2xx.LIB>

SYNTAX:    int getMatch(int channel, int source)

DESCRIPTION:   Returns block match register usage for the given channel.
               May optionally be filtered to specific sources by the
               source parameter.

PARAMETER1:    Channel to get match information on

PARAMETER2:    Source filter
                  BL_TRAIL_ONLY will filter only the 'Trail' match register
                  BL_LEAD_ONLY will filter only the 'Lead' match register
                   Note: Counters will only use the 'Trail' match register

RETURN VALUE:  Bit Flags showing match usage on success:
	                BL_IER_MATCH0 bit set if using Match register 0
	                BL_IER_MATCH1 bit set if using Match register 1
	                BL_IER_MATCH2 bit set if using Match register 2
	                BL_IER_MATCH3 bit set if using Match register 3
               OR
                   -EINVAL: if invalid channel value

SEE ALSO:      brdInit, setPWM, setPPM, setCounter

END DESCRIPTION **********************************************************/
_bl_nodebug
int getMatch(int channel, int source)
{
   auto struct RSB_IOpin *chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);     // get pointer to channel's pin struct

   rc = 0;
   if ((!source || source == BL_TRAIL_ONLY) && (chPtr->match & RSB_RES_MATCH0))
   {
      rc |= _rsb_bitmap[chPtr->match & 3];
   }
   if ((!source || source == BL_LEAD_ONLY) && (chPtr->match & RSB_SET_MATCH0))
   {
      rc |= _rsb_bitmap[(chPtr->match >> 3) & 3];
   }
   return rc;
}


//////////////////////////////
// Digital Output Functions //
//////////////////////////////

/*** BeginHeader setDigOut */
int setDigOut(int channel, int state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setDigOut               <BLxS2xx.LIB>

SYNTAX:        int setDigOut(int channel, int state)

DESCRIPTION:   Configures the output channel as a simple digital output.
               The output state of the channel is also initialized to
               logic 0 or logic 1 based on the state parameter.  The
               digOut function should be used to control the output
               state after configuration as it is more efficient.
               This function is non-reentrant.

PARAMETER1:    Digital output channel 0 - 31.

PARAMETER2:    Set output to one of the following states:
               0 = Connects the load to GND.
               1 = Puts the output in a high-impedance state.

RETURN VALUE:  0 on success.
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, digOut, digOutBank

END DESCRIPTION **********************************************************/

_bl_nodebug
int setDigOut(int channel, int state)
{
   auto struct RSB_IOpin *chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(__brdInitFlag == FALSE || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // The brdInit function has not been executed or channel is invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = DIO_PIN(channel);

   // set state of the channel (when function changed)
   rc = _riosbc_set_pin(chPtr, state);
   if (rc) {BL_ERROR(rc);}

   // set function of the channel
   rc = _riosbc_set_function(chPtr, RSB_FUNC_DIGOUT, 0);
   if (rc) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader digOut */
int digOut(int channel, int state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digOut                  <BLxS2xx.LIB>

SYNTAX:        int digOut(int channel, int state)

DESCRIPTION:   Sets the state of a configurable Digital Out channel
               DIO0 - DIO31 to a logic 0 or a logic 1. This function will
               only allow control of pins that are configured to be a
               general digital output by the setDigOut function.
               This function is non-reentrant.

PARAMETER1:    Digital output channel 0 - 31.

PARAMETER2:    Set output to one of the following states:
               0 = Connects the load to GND.
               1 = Puts the output in a high-impedance state.

RETURN VALUE:  0 on success.
               -EINVAL: invalid parameter value
               -EPERM:  pin function not set to digital output

SEE ALSO:      brdInit, setDigOut, digOutBank

END DESCRIPTION **********************************************************/

_bl_nodebug
int digOut(int channel, int state)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(__brdInitFlag == FALSE || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // The brdInit function has not been executed or channel invalid
      BL_ERROR(-EINVAL);
   }
   if (DIO_PIN(channel)->function != RSB_FUNC_DIGOUT)
   {
      // Pin is not set to digital output function
      BL_ERROR(-EPERM);
   }
#endif

   // set state of the RIO based channel and return
   rc = _riosbc_set_pin(DIO_PIN(channel), state);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader digOutBank */
int digOutBank(char bank, char data);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digOutBank              <BLxS2xx.LIB>

SYNTAX:        int digOutBank(char bank, char data)

DESCRIPTION:   Sets the state (logic 0 or logic 1) of a bank of 8
               digital output pins within one of 4 banks to the states
               contained in 'data'. This function only updates the
               channels that are configured to be digital outputs by
               the setDigOut function. Channels configured to other
               functions will not be affected.

               This function is non-reentrant.

PARAMETER1:    Bank of digital output pins being set. (0..3)

PARAMETER2:    Data value to be written to the specified digital output
               bank, the data format and bitwise value are as follows:

               Data    Bank    Bank    Bank    Bank
               Bits     0       1       2       3
               -------------------------------------
         (LSB) D0  ->  DIO0    DIO8   DIO16   DIO24
               D1  ->  DIO1    DIO9   DIO17   DIO25
               D2  ->  DIO2   DIO10   DIO18   DIO26
               D3  ->  DIO3   DIO11   DIO19   DIO27
               D4  ->  DIO4   DIO12   DIO20   DIO28
               D5  ->  DIO5   DIO13   DIO21   DIO29
               D6  ->  DIO6   DIO14   DIO22   DIO30
         (MSB) D7  ->  DIO7   DIO15   DIO23   DIO31

               Bitwise value:
               --------------
               0 = Connects the load to GND.
               1 = Puts the output in a high-impedance state.

RETURN VALUE:  0 on success
               -EINVAL if parameter invalid or board not initialized

SEE ALSO:      brdInit, digOut, setDigOut

END DESCRIPTION **********************************************************/

_bl_nodebug
int digOutBank(char bank, char data)
{
   auto int i;

#ifndef BL_LIMIT_ERRORS
   if (__brdInitFlag == FALSE || bank > ((BL_DIGITAL_IO + 7) >> 3))
   {
      // Invalid bank or brdInit hasn't executed
      BL_ERROR(-EINVAL);
   }
#endif

   // Write data to groups of blocks based on bank selection
   if (bank & 2)
   {
      if (bank & 1)
      {  // Bank 3
         _riosbc_set_block(DIO_PIN(24), 0xC0 | ((data & 3) << 2));
         _riosbc_set_block(DIO_PIN(26), 0xC0 | (data & 0x0C));
         // Other pins do not share common RIO blocks, set individually
         for (i = 28, data >>= 4; i < 32; i++, data >>= 1) {
            _riosbc_set_pin(DIO_PIN(i), data & 1);
         }
      }
      else
      {   // Bank 2
         _riosbc_set_block(DIO_PIN(16), 0xC0 | ((data & 3) << 2));
         for (i = 18; i < 23; i += 2, data >>= 2) {
            _riosbc_set_block(DIO_PIN(i), 0xC0 | (data & 0x0C));
         }
      }
   }
   else
   {  // Banks 0 & 1 (Both hosted on just 2 blocks)
      i = (bank & 1) << 3;
      _riosbc_set_block(DIO_PIN(i), (data & 0x0F) | 0xF0);
      _riosbc_set_block(DIO_PIN(i + 4), (data >> 4) | 0xF0);
   }
}

/*** BeginHeader setPWM */
int setPWM(int channel, float frequency, float duty, int invert, int bind);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setPWM                           <BLxS2xx.LIB>

SYNTAX:    int setPWM(int channel, float frequency, float duty,
                        int invert, int bind)

DESCRIPTION:   Sets up a PWM on the ouput channel with the specified
               frequency and duty cycle. The output of the PWM can be
               inverted. The duty of the PWM can be bound to a PWM/PPM
               on another channel on the same RIO block so that they
               share an edge.

PARAMETER1:    Channel to use for PWM.

PARAMETER2:    Frequency of the PWM in Hz.  Should be in the range (2Hz-50kHz)
               Use -1 to preserve the existing frequency on the RIO block.

PARAMETER3:    Duty cycle of ON state of the PWM. Should be in the range 0-100%
               Use -1 and bind parameter to use bound edge to set the duty.
               NOTE: A 0% or 100% duty will produce the smallest or largest duty
                     possible, which is 1 count (smallest) or the limit register
                     minus one count (largest). If you need a true 0% or 100%
                     duty, use setDigOut, or pulseDisable to set a steady state.

PARAMETER4:    Whether the PWM is inverted.  Normal starts with the output
               high and inverted starts with the output low.
                                __       __
               0: noninverted  |  |_____|  |_____|
                                   _____    _____
               1: inverted     |__|     |__|     |

PARAMETER5:    Use 0 for no binding or for the initial PWM or PPM that is set up
               on a RIO block.  If a PPM was initially set up on this RIO and
               block then use either BL_BIND_LEAD or BL_BIND_TRAIL to enable
               binding of the trailing edge of this PWM to the initial PPM.  If
               a PWM was initially set up on this RIO and block then use
               BL_BIND_TRAIL to enable binding of the trailing edge of this PWM
               to the initial PWM.  Note that PWMs only allow binding to their
               trailing edge.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected
               positive number: Mode Conflict - See Appendix D of the
                                                BL4S200 User's Manual

SEE ALSO:      brdInit, setFreq, setDuty, setSync, pulseDisable

END DESCRIPTION **********************************************************/
_bl_nodebug
int setPWM(int channel, float frequency, float duty, int invert, int bind)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setPxM(DIO_PIN(channel), RSB_FUNC_PWM, frequency, 0, duty, invert,
                    0, bind);
   if (rc) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setPPM */
int setPPM(int channel, float frequency, float offset, float duty, int invert,
           int bind_offset, int bind_duty);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setPPM                           <BLxS2xx.LIB>

SYNTAX:    int setPPM(int channel, float frequency, float offset,
               float duty, int invert, int bind_offset, int bind_duty)

DESCRIPTION:   Sets up a PPM on the ouput channel with the specified
               frequency and duty cycle. The output of the PPM can be
               inverted. The offset and duty of the PPM can be bound to
               a PWM/PPM on another channel on the same RIO block so that
               they share an edge.

PARAMETER1:    Channel to use for PPM.

PARAMETER2:    Frequency of the PPM.  Should be in the range (2Hz-50kHz).
               Use -1 to preserve the existing frequency on the RIO block.

PARAMETER3:    Offset of the PPM.  Should be in the range (0-100%)
               Use -1 and bind_offset to use bound edge to set the offset.
                NOTE: Offset above 100.0 will be set to 100.0%.
                      A zero offset will produce the smallest offset
                      possible which is one count. If you must have
                      a zero offset, use setPWM instead of setPPM.

PARAMETER4:    Duty cycle of ON state of the PPM. Should be in the range 0-100%
               Use -1 and bind_duty to use bound edge to set the duty.
                NOTE: Duty above 100.0 will be set to 100.0%.

               Note: PPM will not wrap around period of PPM.  If offset is
               set to 25%, duty in range 75-100% will have the same effect
               of Offset = 25%, duty = 75%.  The same waveform as a wrapped
               PPM can be created using an inverted PWM.

PARAMETER5:    Whether the PPM is inverted.  Normal will start low, go
               high at the offset and stay high for the duration of the
               duty.  Inverted will start high, go low at the offset
               and stay low for the duration of the duty.
                                  __      __
               0: noninverted  __|  |____|  |____|
                               __    ____    ____
               1: inverted       |__|    |__|    |

PARAMETER6:    Use BL_BIND_LEAD or BL_BIND_TRAIL to enable binding of the
               leading edge of this PPM signal to another PWM or PPM on a
               channel on the same RIO and block.  Bindings allow PWMs and
               PPMs to align their leading and trailing edges.

PARAMETER7:    Use BL_BIND_LEAD or BL_BIND_TRAIL to enable binding of the
               trailing edge of this PPM signal to another PWM or PPM on a
               channel on the same RIO and block.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected
               positive number: Mode Conflict - See Appendix D of the
                                                BL4S200 User's Manual

SEE ALSO:      brdInit, setFreq, setOffset, setDuty, setSync, pulseDisable

END DESCRIPTION **********************************************************/
_bl_nodebug
int setPPM(int channel, float frequency, float offset, float duty, int invert,
           int bind_offset, int bind_duty)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setPxM(DIO_PIN(channel), RSB_FUNC_PPM, frequency, offset, duty,
                    invert, bind_offset, bind_duty);
   if (rc) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader _setPxM */
int _setPxM(struct RSB_IOpin* chPtr, int function, float frequency, float offset,
              float duty, int mode, int bind_offset, int bind_duty);
/*** EndHeader */

/**************************************************************************
 Internal function for setting of PWM and PPM outputs on any RIO-based
 pin.  Uses mostly the same parameters as setPPM, with the exception of
 the first 2 parameters.  The chPtr is a pointer to the RIO-based pin to
 setup the PWM/PPM function on.  This can be any output capable RIO pin.
 The function parameter must be set to RSB_FUNC_PWM or RSB_FUNC_PPM.
 The offset and bind_offset parameters should be set to zero if the
 function is set to RSB_FUNC_PWM.  For non-PushPull pins, the mode
 parameter is simply the inversion flag.  Otherwise, it defines the two
 states for the on and off segments of the PWM/PPM signal.
**************************************************************************/
_bl_nodebug
int _setPxM(struct RSB_IOpin* chPtr, int function, float frequency, float offset,
              float duty, int mode, int bind_offset, int bind_duty)
{
   auto struct RSB_IOpin *bindPtr;
   auto struct _RSB_BLOCK_USE *use;
   auto long freq_calc, duty_calc, offset_calc;
   auto float freq_ratio;
   auto char hc_offset;
   auto word rsb_mode;
   auto int rc;
   auto int flags;
   auto char i;

   // save a pointer to the channel's block usage for later
   use = &(rsb_rio[chPtr->index].block[chPtr->block2]);
   rsb_mode = 0;
   if (chPtr >= (HCO_PIN(0))) {
      hc_offset = BL_DIGITAL_IO;
   }
   else {
      hc_offset = 0;
	   if (mode)
	   {
	      // set inversion in rsb_mode
	      rsb_mode |= RSB_PWM_INVERT;
	   }
   }

   // calculate frequency, or use the existing frequency on the block
   if (frequency < 0)
   {
      // use the existing frequency on the block
      if (use->mode & RSB_MODE_PRESCALE)
      {
         rsb_mode |= BL_PRESCALE;
      }
      freq_calc = use->clr + 1;
   }
   else if (frequency > RIO_CLOCK_FREQ / 65536.0)
   {
      if (frequency > BL_PWM_MAX_FREQ)
      {
         // Clamp to the maximum frequency
         freq_calc = (long)((RIO_CLOCK_FREQ / BL_PWM_MAX_FREQ) + 0.5);
      } else
      {
         // Calculate limit value for desired frequency from main clock
         freq_calc = (long)((RIO_CLOCK_FREQ / frequency) + 0.5);
      }
   }
   else {
      // set source for block clock to prescaled RIO clock
      rsb_mode |= BL_PRESCALE;
      if (frequency >= BL_PWM_MIN_FREQ)
      {
         // Calculate limit value for desired frequency from prescaled clock
         freq_calc = (long)((RIO_PRESCALE_FREQ / frequency) + 0.5);
      } else {
         // Clamp to the minimum frequency
         freq_calc = (long)((RIO_PRESCALE_FREQ / BL_PWM_MIN_FREQ) + 0.5);
	   }
   }

   if (! (bind_duty || bind_offset))
   {
#ifndef BL_LIMIT_ERRORS
      if (duty < 0 || offset < 0)
      {
         // you have to have a duty assigned in the function call
         // for a new PWM or a PWM that is no longer bound
         return -EINVAL;
      }
#endif
      flags = 0;
   } else
   {
      if (bind_duty)
      {
         // precalculate some values
         bindPtr = DIO_PIN(bind_duty & BL_BIND_PIN_MASK + hc_offset);

#ifndef BL_LIMIT_ERRORS
         if (bindPtr->block2 != chPtr->block2)
         {
            // the bind channel needs to be on the same block
            return -EINVAL;
         }
#endif

         if (bind_duty & BL_BIND_LEAD)
         {
            // we are binding to the lead edge of a PPM
            if (bindPtr->function != RSB_FUNC_PPM)
            {
               // the binding channel must be a PPM
               return (-EINVAL);
            }

            // calculate the match register used for binding
            flags = 0x04 | ((bindPtr->match & 0x18) >> 3);
         } else if (bind_duty & BL_BIND_TRAIL)
         {
            // we are binding to the trailing edge of a PPM or PWM
            if (bindPtr->function != RSB_FUNC_PPM &&
                bindPtr->function != RSB_FUNC_PWM)
            {
               // the binding channel must be a PPM or PWM
               return (-EINVAL);
            }

            // calculate the match register used for binding
            flags = 0x04 | (bindPtr->match & 0x03);
         }
         else {
            // we are not binding to any edge?
            return (-EINVAL);
         }
      }
      else {
         if (duty < 0) {
            return (-EINVAL);
         }
         if (duty > 100.0) {
            duty = 100.0;        // Limit duty to 100.0
         }
         flags = 0;
      }
      if (bind_offset)
      {
         // precalculate some values
         bindPtr = DIO_PIN(bind_offset & BL_BIND_PIN_MASK + hc_offset);

         if (bindPtr->block2 != chPtr->block2)
         {
            // the bind channel needs to be on the same block
            return -EINVAL;
         }

         if (bind_offset & BL_BIND_LEAD)
         {
            // we are binding to the lead edge of a PPM
            if (bindPtr->function != RSB_FUNC_PPM)
            {
               // the binding channel must be a PPM
               return -EINVAL;
            }

            // calculate the match register used for binding
            flags |= 0x20 | (bindPtr->match & 0x18);
         } else if (bind_offset & BL_BIND_TRAIL)
         {
            // we are binding to the trailing edge of a PPM or PWM
            if (bindPtr->function != RSB_FUNC_PPM &&
                bindPtr->function != RSB_FUNC_PWM)
            {
               // the binding channel must be a PPM or PWM
               return -EINVAL;
            }

            // calculate the match register used for binding
            flags |= 0x20 | ((bindPtr->match & 0x03) << 3);
         }
         else {
            // we are not binding to any edge?
            return -EINVAL;
         }
      }
      else {
         if (offset < 0) {
            return -EINVAL;
         }
         if (offset > 100.0) {
		      offset = 100.0;      // Limit offset to 100.0
         }
      }
   }

   // Note: offset_calc will be actual offset count + 1 for calculations.
   if (offset < 0) {
      // base the offset on the offset of the current matching register
      offset_calc = (long)use->mx[(flags & 0x18)>> 3] + 1;
   } else {
      // calculate the offset, in +1 state
      offset_calc = (long) ((offset * 0.01) * freq_calc + 0.5);
   }

   // Note: duty_calc will be actual duty count + 1 for calculations.
   if (duty < 0) {
      // base the duty on the duty of the current matching register, in +1 state
      duty_calc = (long) use->mx[flags & 0x03] + 1;
   }
   else {
      // calculate the duty, with the offset, in +1 state
      duty_calc = (long) (((duty * 0.01) * freq_calc + 0.5) + offset_calc);
   }

   // watch for overflow on the duty
	if (function == RSB_FUNC_PWM) {
	   // watch for duty <= 0
	   if (duty_calc <= 0) {
	      duty_calc = 1;
	   }
      else {
	      // duty must be less than the limit (freq_calc) for PWM
	      if (duty_calc >= freq_calc) {
	         duty_calc = freq_calc - 1;
	      }
      }
   }
   else {
	   // make sure offset is in plus one state, when it is a zero.
	   if (offset_calc < 1) {
	      offset_calc = 1;
	   }
      else {
	      // make sure the offset leaves room for the duty
	      if (offset_calc >= freq_calc) {
	         offset_calc = freq_calc - 1;
	      }
      }

	   // watch for duty <= offset, will give an unexpected signal
	   if (duty_calc <= offset_calc) {
	      duty_calc = offset_calc + 1;
	   }
      else {
	      // duty must be less than or equal to the limit (freq_calc) for PPM
	      if (duty_calc > freq_calc) {
	         duty_calc = freq_calc;
	      }
      }
	}

   if (hc_offset && chPtr->function == RSB_FUNC_DIGOUT) {
      // Make sure HC pin is in tri-state mode if already an output
      rc = _riosbc_set_pin(chPtr, RSB_TRI);
      if (rc < 0) return rc;
   }
   rc = _riosbc_set_function(chPtr, function, flags);
   if (rc < 0) {
      return (rc);
   }

   // set all calculated variables to final values (not +1 state).
   offset_calc--;
   duty_calc--;
   freq_calc--;

   // set frequency of the block
   if (freq_calc != use->clr)
   {
	   // calculate ratio
	   freq_ratio = (float)(freq_calc + 1) / ((float)(use->clr) + 1);

      rc = _riosbc_set_limit(chPtr, (unsigned)freq_calc);
      if (rc < 0) {
         return (rc);
      }

	   // rescale the offset and duty of all of the PWMs and PPMs
	   for (i = 0; i < 4; ++i) {
       	// update the match register if it is used by another PWM or PPM.
	      if (use->mx_use[i] && use->mx_use[i] != _rsb_bitmap[chPtr->bit2])
	      {
	         _riosbc_set_block_pair(chPtr->index, chPtr->block2,
                RSB_MATCH0 + (i << 1), (unsigned)((freq_ratio *
                  ((float)use->mx[i] + 1)) - 0.5), &(use->mx[i]));
	      }
	   }
   }

   if (function == RSB_FUNC_PWM) {
     if (hc_offset) {
        // Setup PWM(s) for the high current output
        if (mode > HCPWM_TRI_HIGH) {
           // Set flag for sink or source selection in rsb_mode
           if (!(mode & 1)) rsb_mode |= RSB_SINK_SEL;
           rc = _riosbc_set_pwm(chPtr, (unsigned)duty_calc,
                                      rsb_mode | RSB_PWM_INVERT);
           if (rc < 0) return rc;
        }
        if (mode < HCPWM_LOW_TRI) {
           // Set flag for sink or source selection in rsb_mode
           if (mode == HCPWM_TRI_LOW || mode == HCPWM_HIGH_LOW) {
              rsb_mode |= RSB_SINK_SEL;
           } else {
              rsb_mode &= ~RSB_SINK_SEL;
           }
           return _riosbc_set_pwm(chPtr, (unsigned)duty_calc, rsb_mode);
        }
     }
     else {
       // Setup PWM output on the configurable I/O pin
       return _riosbc_set_pwm(chPtr, (unsigned)duty_calc, rsb_mode);
     }
   }
   else {
     if (hc_offset) {
        // Setup PPM(s) for the high current output
        if (mode > HCPWM_TRI_HIGH) {
           // Set flag for sink or source selection in rsb_mode
           if (!(mode & 1)) rsb_mode |= RSB_SINK_SEL;
           rc = _riosbc_set_ppm(chPtr, (unsigned)offset_calc,
                                (unsigned)duty_calc, rsb_mode | RSB_PWM_INVERT);
           if (rc < 0) { return rc; };
        }
        if (mode < HCPWM_LOW_TRI) {
           // Set flag for sink or source selection in rsb_mode
           if (mode == HCPWM_TRI_LOW || mode == HCPWM_HIGH_LOW) {
              rsb_mode |= RSB_SINK_SEL;
           } else {
              rsb_mode &= ~RSB_SINK_SEL;
           }
           return _riosbc_set_ppm(chPtr, (unsigned)offset_calc,
                                   (unsigned)duty_calc, rsb_mode);
        }
     }
     else {
       // Setup PPM output on the configurable I/O pin
       return _riosbc_set_ppm(chPtr, (unsigned)offset_calc,
                                 (unsigned)duty_calc, rsb_mode);
     }
   }
   return rc;
}


/*** BeginHeader setFreq */
int setFreq(int channel, float frequency);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setFreq                          <BLxS2xx.LIB>

SYNTAX:    int setFreq(int channel, float frequency)

DESCRIPTION:   Sets the frequency of all of the PWMs or PPMs on the same
               block as the channel.  Will preserve the duty and offset
               percentages for all of the channels on the same block.
               This function is for configurable I/O channels only.
               NOTE: Channels 30 & 31 do not support PWM/PPM functions
               and cannot be used with this function.

PARAMETER1:    All channels on the same RIO and block as this channel
               will have their frequency set.  Duty & offset percentages
               will be maintained.

PARAMETER2:    Frequency of the PWMs and PPMs.  Should be in the range
               (2Hz-50kHz)

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:  brdInit, setPWM, setPPM, setOffset, setDuty, setSync

END DESCRIPTION **********************************************************/
_bl_nodebug
int setFreq(int channel, float frequency)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setFreq(DIO_PIN(channel), frequency);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader _setFreq */
int _setFreq(struct RSB_IOpin* chPtr, float frequency);
/*** EndHeader */

/**************************************************************************
 Internal function for setting of frequency on PWM and PPM outputs on
 any RIO-based channel.  Uses the same parameters as setFreq with the
 exception of the first parameter.  The chPtr is a pointer to the
 RIO-based pin to setup the PWM/PPM frequency on.
**************************************************************************/
_bl_nodebug
int _setFreq(struct RSB_IOpin* chPtr, float frequency)
{
   auto struct _RSB_BLOCK_USE *use;
   auto char i;
   auto char block;
   auto long freq_calc;
   auto char mode;
   float freq_ratio;
   auto int rc;

   // save a pointer to the channel's block usage for later
   use = &(rsb_rio[chPtr->index].block[chPtr->block2]);

   // calculate frequency, or use the existing frequency on the block
   if (frequency <= 0)
   {
      // don't change the frequency
      return 0;
   }

   if (frequency > RIO_CLOCK_FREQ / 65536.0)
   {
      if (frequency > BL_PWM_MAX_FREQ)
      {
         // Clamp to the maximum frequency
         freq_calc = (unsigned) (RIO_CLOCK_FREQ / BL_PWM_MAX_FREQ);
      }
      else
      {
	      // set source for block clock to RIO clock
	      mode = 0;
	      freq_calc = (unsigned) (RIO_CLOCK_FREQ / frequency) + 1;
      }
   }
   else if (frequency > RIO_PRESCALE_FREQ / 65536.0)
   {
      // set source for block clock to prescaled RIO clock
      mode = 1;
      if (frequency >= BL_PWM_MIN_FREQ)
      {
         // Calculate limit value for desired frequency from prescaled clock
         freq_calc = (unsigned) (RIO_PRESCALE_FREQ / frequency);
      } else {
         // Clamp to the minimum frequency
         freq_calc = (unsigned) (RIO_PRESCALE_FREQ / BL_PWM_MIN_FREQ);
	   }
   }

   // store block of channel
   block = chPtr->block2;

   // calculate ratio
   freq_ratio = (float) freq_calc / (((float) use->clr) + 1);

   // rescale the offset and duty of all of the PWMs and PPMs
   for (i = 0; i < 4; ++i)
   {
      // update the match register if it is used by any PWM or PPM.
      if (use->mx_use[i])
      {
    		_riosbc_set_block_pair(chPtr->index, block, RSB_MATCH0 + (i << 1),
					 (unsigned) (freq_ratio * ((float)use->mx[i] + 1) - 0.5),
                            &(use->mx[i]));
      }
   }

   // set mode of block to incorporate whether the prescalar is used
   if (mode && (use->mode | ~RSB_MODE_PRESCALE))
   {
      // prescalar needs to be set
      _riosbc_set_block_reg(chPtr->index, block, RSB_MODE,
                        use->mode | RSB_MODE_PRESCALE,
                        &(use->mode));
   } else if (!mode && (use->mode & RSB_MODE_PRESCALE))
   {
      // prescalar needs to be cleared
      _riosbc_set_block_reg(chPtr->index, block, RSB_MODE,
                        use->mode & ~RSB_MODE_PRESCALE,
                        &(use->mode));
   }

   // set block frequency
   rc = _riosbc_set_limit(chPtr, (unsigned)(freq_calc - 1));
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setDuty */
int setDuty(int channel, float duty);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setDuty                          <BLxS2xx.LIB>

SYNTAX:    int setDuty(int channel, float duty)

DESCRIPTION:   Sets the duty of the PWM or PPM on the channel on a
               configurable I/O channel.  Will affect any PWM/PPM which
               has been bound to this channels PWM/PPM.
               NOTE: Channels 30 & 31 do not support PWM/PPM functions
               and cannot be used with this function.

PARAMETER1:    Channel that is getting its duty set (0-29).

PARAMETER2:    Duty of the PWM/PPM.  Should be in the range (0-100%)
                Note: Duty above 100.0 will be set to 100.0%.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  channel function does not permit this operation

SEE ALSO:  brdInit, setPWM, setPPM, setOffset, setFreq, setSync

END DESCRIPTION **********************************************************/
_bl_nodebug
int setDuty(int channel, float duty)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   // Check for init and valid channel
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setDuty(DIO_PIN(channel), duty);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader _setDuty */
int _setDuty(struct RSB_IOpin* chPtr, float duty);
/*** EndHeader */

/**************************************************************************
 Internal function for setting the duty cycle on PWM and PPM outputs on
 any RIO-based pin.  Uses the same parameters as setDuty with the exception
 of the first parameter.  The chPtr is a pointer to the RIO-based pin to
 setup the PWM/PPM duty cycle on.
**************************************************************************/
_bl_nodebug
int _setDuty(struct RSB_IOpin* chPtr, float duty)
{
   auto struct _RSB_BLOCK_USE *use;
   auto long duty_calc, offset_calc, freq_calc;
   auto int rc;

   // save a pointer to the channel's block usage for later
   use = &(rsb_rio[chPtr->index].block[chPtr->block2]);

   if (chPtr->function == RSB_FUNC_PPM)
   {
   	offset_calc = ((long) use->mx[(chPtr->match & 0x18) >> 3]);
   } else if (chPtr->function == RSB_FUNC_PWM)
   {
   	offset_calc = 0;
   } else {
      BL_ERROR(-EPERM);
   }

   if (duty > 100.0) {
      duty = 100.0;        // Limit duty to 100.0
   }

	// get the current limit for the block
   freq_calc = (long)use->clr;

   // calculate the new duty value
   duty_calc = offset_calc + (long)((duty * 0.01) * (freq_calc + 1));

   // watch for duty <= offset, will give an unexpected signal
   if (duty_calc <= offset_calc)
   {
   	duty_calc = offset_calc + 1;
   }

   // watch for overflow on the duty
   if (duty_calc >= freq_calc)
   {
   	duty_calc = freq_calc - 1;
   }

   rc = _riosbc_set_match(chPtr, chPtr->match & 0x03, (unsigned)duty_calc);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setOffset */
int setOffset(int channel, float offset);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setOffset                           <BLxS2xx.LIB>

SYNTAX:    int setOffset(int channel, float offset)

DESCRIPTION:   Sets the offset of a PPM on a configurable I/O channel.
               Will affect any PWM/PPM which has been bound to this
               channel's PPM signal.
               NOTE: Channels 30 & 31 do not support PWM/PPM functions
               and cannot be used with this function.

PARAMETER1:    Channel that is getting its offset set. (0-29)

PARAMETER2:    Offset of the PPM.  Should be in the range (0-100%)
                NOTE: Offset above 100.0 will be set to 100.0%.
                      A zero offset will produce the smallest offset
                      possible which is one count. If you must have
                      a zero offset, use setPWM instead of setPPM.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  channel function does not permit this operation

SEE ALSO:  brdInit, setPWM, setPPM, setFreq, setDuty, setSync

END DESCRIPTION **********************************************************/
_bl_nodebug
int setOffset(int channel, float offset)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setOffset(DIO_PIN(channel), offset);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader _setOffset */
int _setOffset(struct RSB_IOpin* chPtr, float offset);
/*** EndHeader */

/**************************************************************************
 Internal function for setting the offset on PPM outputs on any RIO-based
 pin.  Uses the same parameters as setOffset with the exception of the
 first parameter.  The chPtr is a pointer to the RIO-based pin to setup
 the PPM offset on.
**************************************************************************/
_bl_nodebug
int _setOffset(struct RSB_IOpin* chPtr, float offset)
{
   auto struct _RSB_BLOCK_USE *use;
   auto long duty_calc, offset_calc, freq_calc;
   auto char duty_update;
   auto int rc;

	if (chPtr->function != RSB_FUNC_PPM)
   {
	   BL_ERROR(-EPERM);
   }

   // save a pointer to the channel's block usage for later
   use = &(rsb_rio[chPtr->index].block[chPtr->block2]);

   if (offset > 100.0) {
      offset = 100.0;      // Limit offset to 100.0
   }

	// initialize duty_reset to 0
   duty_update = 0;

   // lookup value of limit register
   freq_calc = (long)use->clr;

   // calculate offset
   offset_calc = (long)((freq_calc + 1) * (offset * 0.01) - 0.5);

   // make sure the offset leaves room for the duty
   if (offset_calc >= (freq_calc - 1))
   {
   	offset_calc = freq_calc - 2;
   }
   else if (offset_calc < 1) {
      offset_calc = 1;
   }

   // lookup value of duty
   duty_calc = use->mx[chPtr->match & 0x03];
   if (offset_calc != use->mx[(chPtr->match >> 3) & 3]) {
      duty_calc += offset_calc - use->mx[(chPtr->match >> 3) & 3];
   }

   // watch for duty <= offset, will give an unexpected signal
   if (duty_calc <= offset_calc)
   {
   	duty_calc = offset_calc + 1;
      duty_update = 1;
   }
   else {
	   // watch for overflow on the duty
	   if (duty_calc >= freq_calc)
	   {
	      duty_calc = freq_calc - 1;
	      duty_update = 1;
	   }
   }

   // update the duty if need be
   if (duty_update)
   {
	   // set PPM duty
	   rc = _riosbc_set_match(chPtr, chPtr->match & 0x03, (unsigned)duty_calc);
      if (rc < 0) {BL_ERROR(rc);}
	}

   // set PPM offset
   rc = _riosbc_set_match(chPtr,(chPtr->match & 0x18)>>3, (unsigned)offset_calc);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader pulseDisable */
int pulseDisable(int channel, int state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pulseDisable                        <BLxS2xx.LIB>

SYNTAX:    int pulseDisable(int channel, int state)

DESCRIPTION:   Disables a PWM/PPM output and sets the output to the state.
               Pin can be restored to the same PWM/PPM operation as before
               by calling pulseEnable.

PARAMETER1:    Configurable output channel that is getting its PWM/PPM
               disabled.  (0 to 29)

PARAMETER2:    State that the digital output will be set to (0/1).

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  channel function does not permit this operation

SEE ALSO:  brdInit, setPWM, setPPM, pulseEnable

END DESCRIPTION **********************************************************/
_bl_nodebug
int pulseDisable(int channel, int state)
{
   auto struct RSB_IOpin* chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      BL_ERROR(-EINVAL);
   }
#endif

   // get pointer to channel
   chPtr = DIO_PIN(channel);

   // disable the PWM/PPM output
   rc = _riosbc_pulse_disable(chPtr, state);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader pulseEnable */
int pulseEnable(int channel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pulseEnable                         <BLxS2xx.LIB>

SYNTAX:    int pulseEnable(int channel)

DESCRIPTION:   Enables a disabled PWM/PPM output.  Pin is restored to
               the same PWM/PPM operation as before being disabled.

PARAMETER1:    Configurable output channel that is getting its PWM/PPM
               re-enabled.  (0 to 29)

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  channel function does not permit this operation

SEE ALSO:  brdInit, setPWM, setPPM, pulseDisable

END DESCRIPTION **********************************************************/
_bl_nodebug
int pulseEnable(int channel)
{
   auto struct RSB_IOpin* chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_IO)
   {
      BL_ERROR(-EINVAL);
   }
#endif

   // get pointer to channel
   chPtr = DIO_PIN(channel);

   // disable the PWM/PPM output
   rc = _riosbc_pulse_enable(chPtr, 0);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}



///////////////////////////////////////////
// High Current Digital Output Functions //
///////////////////////////////////////////


/*** BeginHeader digOutConfig_H */
int digOutConfig_H(char configuration);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digOutConfig_H          <BLxS2xx.LIB>

SYNTAX:        int digOutConfig_H(char configuration)

DESCRIPTION:   Allows configuration of a High-Current output to be a
               sinking or sourcing type output. This function is
               non-reentrant.

               Note:
               -----
               Configuring a given output channel for tristate operation
               using the digOutTriStateConfig_H function, will temporarily
               override the configuration done by the digOutConfig_H
               function as long as it is kept a tristate channel.  This
               configuration can also be overridden by setting the
               channel to a PWM or PPM output.

PARAMETER1:    Configuration byte to configure output channels HOUT0 -
               HOUT7 as sinking or sourcing type outputs. To configure
               set the corresponding bit 0 - 7 to one of the following
               values.

               0 = Sinking type output configuration
               1 = Sourcing type output configuration

               7 6 5 4 3 2 1 0  Configuration parameter
               ---------------  -----------------------
               ^ ^ ^ ^ ^ ^ ^ ^
               | | | | | | | |- Bits 0 used for setting Hout channel 0
               | | | | | | |--- Bits 1 used for setting Hout channel 1
               | | | | | |----- Bits 2 used for setting Hout channel 2
               | | | | |------- Bits 3 used for setting Hout channel 3
               | | | |--------- Bits 4 used for setting Hout channel 4
               | | |----------- Bits 5 used for setting Hout channel 5
               | |------------- Bits 6 used for setting Hout channel 6
               |--------------- Bits 7 used for setting Hout channel 7

               Example:
               --------
               Configuration = 0x26;

               7 6 5 4 3 2 1 0  HOUT0 - HOUT7 configuration
               ---------------  --------------------------------
               | | | | | | | |- Bit0 = 0...Set Hout0 to sinking output
               | | | | | | |--- Bit1 = 1...Set Hout1 to sourcing output
               | | | | | |----- Bit2 = 1...Set Hout2 to sourcing output
               | | | | |------- Bit3 = 0...Set Hout3 to sinking output
               | | | |--------- Bit4 = 0...Set Hout4 to sinking output
               | | |----------- Bit5 = 1...Set Hout5 to sourcing output
               | |------------- Bit6 = 0...Set Hout6 to sinking output
               |--------------- Bit7 = 0...Set Hout7 to sinking output

RETURN VALUE:  0 for Success
               -EINVAL if board initialization not performed

SEE ALSO:      brdInit, digOut_H, digOutTriStateConfig_H

END DESCRIPTION **********************************************************/

_bl_nodebug
int digOutConfig_H(char configuration)
{

#ifndef BL_LIMIT_ERRORS
   if(__brdInitFlag == FALSE)
   {
      // the brdInit function hasn't been executed
      BL_ERROR(-EINVAL);
   }
#endif
   // Initialize the configuration for the high-current outputs
   __HoutConfig =  configuration;
   __HoutConfigFlag = TRUE;
   return 0;
}

/*** BeginHeader digOut_H */
int digOut_H(int channel, int state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digOut_H                <BLxS2xx.LIB>

SYNTAX:        int digOut_H(int channel, int state)

DESCRIPTION:   Sets the state of the High-Current output channel to a
               logic 0, logic 1, or high-impedance. This function is
               non-reentrant.

PARAMETER1:    High-Current pins 0 to 7.

PARAMETER2:    Sets a given channel to one of the following output
               states depending on how the output was configured by
               the digOutConfig_H function:

               Sinking configuration
               -----------------------
               0 = Connects the load to GND.
               1 = Puts the output in a high-impedance state.

               Sourcing configuration
               ----------------------
               0 = Puts the output in a high-impedance state.
               1 = Connects the load to +K1 or +K2.

RETURN VALUE:  0 for Success
               -EINVAL if not configured correctly or invalid parameter

SEE ALSO:      brdInit, digOutConfig_H

END DESCRIPTION **********************************************************/

_bl_nodebug
int digOut_H(int channel, int state)
{
   auto char mask;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC
          || (state < 0) || (state > 1) || __HoutConfigFlag == FALSE)
   {
      // the brdInit function hasn't been executed or parameter invalid
      BL_ERROR(-EINVAL);
   }
#endif

   mask = _rsb_bitmap[channel];
#ifndef BL_LIMIT_ERRORS
   // Check if channel is intialized as a tristate output
   if(__TriStateConfig & mask)
   {
      BL_ERROR(-EINVAL);
   }
#endif
   // Release resources if channel was set to PWM or PPM function
   if (HCO_PIN(channel)->function != RSB_FUNC_DIGOUT) {
      _rsb_release(HCO_PIN(channel));
   }

   //-----------------------------------------------------------
   // Set output state based on mode of operation
   //------------------------------------------------------------
   if (__HoutConfig & mask) // Sourcing configuration
   {
      rc = _riosbc_set_pin(HCO_PIN(channel), (state ? RSB_HI : RSB_TRI));
   }
   else    // Sinking configuration
   {
      rc = _riosbc_set_pin(HCO_PIN(channel), (state ? RSB_TRI : RSB_LOW));
   }
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader digOutTriStateConfig_H */
int digOutTriStateConfig_H(char configuration);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digOutTriStateConfig_H     <BLxS2xx.LIB>

SYNTAX:        int digOutTriStateConfig_H(char configuration)

DESCRIPTION:   Allows configuration of a High-Current output to be
               a tristate type output. This function is non-reentrant.

               Note:
               -----
               Configuring a given output channel for tristate operation
               will temporarily override any configuration done by the
               digOutConfig_H function as long as it is kept a tristate
               channel.  The tristate configuration can be overridden
               by setting the channel to a PWM or PPM output.

PARAMETER1:    Configuration byte to configure HOUT0 - HOUT3 output
               pins as tristate type outputs. To configure set
               the corresponding 0 - 3 bits to one of the of the
               following values.

               0 = Disable Tristate output operation
               1 = Enable Tristate output operation

               7 6 5 4 3 2 1 0  Configuration parameter
               ---------------  -----------------------
               ^ ^ ^ ^ ^ ^ ^ ^
               | | | | | | | |- Bit 0 used for setting Hout channel 0
               | | | | | | |--- Bit 1 used for setting Hout channel 1
               | | | | | |----- Bit 2 used for setting Hout channel 2
               | | | | |------- Bit 3 used for setting Hout channel 3
               | | | |--------- Bit 4 used for setting Hout channel 4
               | | |----------- Bit 5 used for setting Hout channel 5
               | |------------- Bit 6 used for setting Hout channel 6
               |--------------- Bit 7 used for setting Hout channel 7

               Example:
               --------
               Configuration = 0x59;

               7 6 5 4 3 2 1 0  HOUT0 - HOUT7 configuration
               ---------------  ---------------------------
               | | | | | | | |- Bit0 = 1, Hout0 Tristate output enabled
               | | | | | | |--- Bit1 = 0, Hout1 Tristate output disabled
               | | | | | |----- Bit2 = 0, Hout2 Tristate output disabled
               | | | | |------- Bit3 = 1, Hout3 Tristate output enabled
               | | | |--------- Bit4 = 1, Hout4 Tristate output enabled
               | | |----------- Bit5 = 0, Hout5 Tristate output disabled
               | |------------- Bit6 = 1, Hout6 Tristate output enabled
               |--------------- Bit7 = 0, Hout7 Tristate output disabled

RETURN VALUE:  0 on Success
               -EINVAL if board initialization not performed

SEE ALSO:      brdInit, digOutTriState_H, digOutConfig_H

END DESCRIPTION **********************************************************/

_bl_nodebug
int digOutTriStateConfig_H(char configuration)
{

#ifndef BL_LIMIT_ERRORS
   if(__brdInitFlag == FALSE)
   {
      // the brdInit function hasn't been executed
      BL_ERROR(-EINVAL);
   }
#endif
   // Initialize the shadow registers for the high-current outputs
   __TriStateConfig =  configuration;
   __TriStateConfigFlag = TRUE;
   return 0;
}


/*** BeginHeader digOutTriState_H */
int digOutTriState_H(int channel, int state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
digOutTriState_H        <BLxS2xx.LIB>

SYNTAX:        int digOutTriState_H(int channel, int state)

DESCRIPTION:   Sets the state of the High-Current output channel to a
               logic 0, logic 1, or high-impedance. This function is
               non-reentrant.

PARAMETER1:    High-Current pins 0 to 7.

PARAMETER2:    Sets a given channel to one of the following output
               states as long as it has been enabled as a tri-state
               output by the digOutTriStateConfig_H function:

               TriState configuration
               ----------------------
               0 = Connects the load to GND.
               1 = Connects the load to +K1 or +K2.
               2 = Puts the output in a high-impedance state.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value or not configured as
                        a tri-state output.

SEE ALSO:      brdInit, digOutTriStateConfig_H

END DESCRIPTION **********************************************************/

_bl_nodebug
int digOutTriState_H(int channel, int state)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC
             || (state < 0) || (state > 2) || __TriStateConfigFlag == FALSE)
   {
      // brdInit and/or digOutTriStateConfig_H function hasn't been executed
      //  or invalid parameter
      BL_ERROR(-EINVAL);
   }

   // Is channel configured for Tri-state operation
   if(!(__TriStateConfig & _rsb_bitmap[channel]))
   {
      BL_ERROR(-EINVAL);
   }
#endif

   // Release resources if channel was set to PWM or PPM function
   if (HCO_PIN(channel)->function != RSB_FUNC_DIGOUT) {
      _rsb_release(HCO_PIN(channel));
   }

   rc = _riosbc_set_pin(HCO_PIN(channel), state);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setPWM_H */
int setPWM_H(int channel, float frequency, float duty, int mode, int bind);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setPWM_H                         <BLxS2xx.LIB>

SYNTAX:    int setPWM_H(int channel, float frequency, float duty,
                        int mode, int bind)

DESCRIPTION:   Sets up a PWM on the high current ouput channel with the
               specified frequency and duty cycle. The output of the PWM
               can be set to any of its three states during either phase
               of the PWM signal.  The duty of the PWM can be bound to a
               PWM/PPM on another channel on the same RIO block so that
               they share an edge.

PARAMETER1:    High current output channel to use for PWM.

PARAMETER2:    Frequency of the PWM in Hz.  Should be in the range (2Hz-50kHz)
               Use -1 to preserve the existing frequency on the RIO block.

PARAMETER3:    Duty cycle of ON state of the PWM. Should be in the range 0-100%
               Use -1 and bind_duty to use bound edge to set the duty.
               NOTE: A 0% or 100% duty will produce the smallest or largest duty
                     possible, which is 1 count (smallest) or the limit register
                     minus one count (largest). If you need a true 0% or 100%
                     duty, use setDigOut_H or digOutTriState_H to set a steady
                     state (depending on how channel is configured).

PARAMETER4:    Sets the OFF and ON states for the high current PWM output. The
               PWM output starts by turning ON for the given duty cycle, then
               transitions to OFF for the remainder of the frequency period.
               Set using:
                 HCPWM_TRI_LOW  - Sets tri-stated as OFF & sinking as ON state
                 HCPWM_TRI_HIGH - Sets tri-stated as OFF & sourcing as ON state
                 HCPWM_LOW_HIGH - Sets sinking as OFF & sourcing as ON state
                 HCPWM_HIGH_LOW - Sets sourcing as OFF & sinking as ON state
                 HCPWM_LOW_TRI  - Sets sinking as OFF & tri-state as ON state
                 HCPWM_HIGH_TRI - Sets sourcing as OFF & tri-state as ON state

PARAMETER5:    Use BL_BIND_LEAD or BL_BIND_TRAIL to enable binding of the
               transition or trailing edge of the PWM on this channel to
               another PWM or PPM on a channel on the same RIO and block.
               Bindings allow PWMs and PPMs to align their leading and
               trailing edges.  Note that PWM's only allow binding to their
               trailing edge.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected
               positive number: Mode Conflict - See Appendix D of the
                                                BL4S200 User's Manual

SEE ALSO:      brdInit, setFreq_H, setDuty_H, setSync_H, pulseDisable

END DESCRIPTION **********************************************************/
_bl_nodebug
int setPWM_H(int channel, float frequency, float duty, int mode, int bind)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= (BL_DIGITAL_HC) ||
            (bind & BL_BIND_PIN_MASK) >= (BL_DIGITAL_HC))
   {
      // the brdInit function hasn't been executed or invalid parameter
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setPxM(HCO_PIN(channel), RSB_FUNC_PWM, frequency, 0, duty, mode,
                    0, bind);
   if (rc) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setPPM_H */
int setPPM_H(int channel, float frequency, float offset, float duty, int mode,
              int bind_offset, int bind_duty);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setPPM_H                         <BLxS2xx.LIB>

SYNTAX:    int setPPM_H(int channel, float frequency, float offset,
               float duty, int mode, int bind_offset, int bind_duty)

DESCRIPTION:   Sets up a PPM on the high current ouput channel with the
               specified frequency, offset and duty cycle. The output of
               the PPM can be set to any of its three states during either
               phase of the PPM signal. The offset and duty of the PPM can
               be bound to a PWM/PPM on another channel on the same RIO
               block so that they share an edge.

PARAMETER1:    High current output channel to use for PPM.

PARAMETER2:    Frequency of the PPM.  Should be in the range (2Hz-50kHz).
               Use -1 to preserve the existing frequency on the RIO block.

PARAMETER3:    Offset of the PPM.  Should be in the range (0-100%)
               Use -1 and bind_offset to use bound edge to set the offset.
                NOTE: Offset above 100.0 will be set to 100.0%.
                      A zero offset will produce the smallest offset
                      possible which is one count. If you must have
                      a zero offset, use setPWM_H instead of setPPM_H.

PARAMETER4:    Duty cycle of ON state of the PPM. Should be in the range 0-100%
               Use -1 and bind_duty to use bound edge to set the duty.
                NOTE: Duty above 100.0 will be set to 100.0%.

               Note: PPM will not wrap around period of PPM.  If offset is
               set to 25%, duty in range 75-100% will have the same effect
               of Offset = 25%, duty = 75%.  The same waveform as a wrapped
               PPM can be created using an inverted PWM.

PARAMETER4:    Sets the OFF and ON states for the high current PPM output. The
               PPM output starts in the OFF state and transitions to the ON
               state at the given Offset percentage.  It transitions back to the
               OFF state at the point of Offset + Duty, unless this is >= 100.
               Stays in the OFF state for the remainder of the frequency period.
               Set using:
                 HCPWM_TRI_LOW  - Sets tri-stated as OFF & sinking as ON state
                 HCPWM_TRI_HIGH - Sets tri-stated as OFF & sourcing as ON state
                 HCPWM_LOW_HIGH - Sets sinking as OFF & sourcing as ON state
                 HCPWM_HIGH_LOW - Sets sourcing as OFF & sinking as ON state
                 HCPWM_LOW_TRI  - Sets sinking as OFF & tri-state as ON state
                 HCPWM_HIGH_TRI - Sets sourcing as OFF & tri-state as ON state

PARAMETER6:    Use BL_BIND_LEAD or BL_BIND_TRAIL to enable binding of the
               leading edge of this PPM signal to another PWM or PPM on a
               channel on the same RIO and block.  Bindings allow PWMs and
               PPMs to align their leading and trailing edges.

PARAMETER7:    Use BL_BIND_LEAD or BL_BIND_TRAIL to enable binding of the
               trailing edge of this PPM signal to another PWM or PPM on a
               channel on the same RIO and block.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  pin type does not permit this function
               -EACCES: resource needed by this function is not available
               -EFAULT: internal data fault detected
               positive number: Mode Conflict - See Appendix D of the
                                                BL4S200 User's Manual

SEE ALSO:      brdInit, setFreq_H, setOffset_H, setDuty_H, setSync_H,
               pulseDisable

END DESCRIPTION **********************************************************/
_bl_nodebug
int setPPM_H(int channel, float frequency, float offset, float duty, int mode,
           int bind_offset, int bind_duty)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= (BL_DIGITAL_HC) ||
            (bind_offset & BL_BIND_PIN_MASK) >= (BL_DIGITAL_HC) ||
            (bind_duty & BL_BIND_PIN_MASK) >= (BL_DIGITAL_HC))
   {
      // the brdInit function hasn't been executed or invalid parameter
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setPxM(HCO_PIN(channel), RSB_FUNC_PPM, frequency, offset, duty, mode,
                    bind_offset, bind_duty);
   if (rc) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setFreq_H */
int setFreq_H(int channel, float frequency);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setFreq_H                        <BLxS2xx.LIB>

SYNTAX:    int setFreq_H(int channel, float frequency)

DESCRIPTION:   Sets the frequency of all of the PWMs or PPMs on the same
               block as the channel.  Will preserve the duty and offset
               percentages for all of the pins on the same block. This
               function is for high current output channels only.

PARAMETER1:    All pins on the same block as the channel parameter will
               have their frequency set.  Duty and offset percentages
               will be maintained.

PARAMETER2:    Frequency of the PWMs and PPMs.  Should be in the range
                of 2Hz - 50kHz.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:  brdInit, setPWM_H, setPPM_H, setOffset_H, setDuty_H, setSync_H

END DESCRIPTION **********************************************************/
_bl_nodebug
int setFreq_H(int channel, float frequency)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC)
   {
      // the brdInit function hasn't been executed as of yet
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setFreq(HCO_PIN(channel), frequency);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setDuty_H */
int setDuty_H(int channel, float duty);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setDuty_H                        <BLxS2xx.LIB>

SYNTAX:    int setDuty_H(int channel, float duty)

DESCRIPTION:   Sets the duty of the PWM or PPM on the channel on a
               high current output channel.

PARAMETER1:    Channel that is getting its duty set (0-7).

PARAMETER2:    Duty of the PWM.  Should be in the range (0-100%)
                NOTE: Duty above 100.0 will be set to 100.0%.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  channel function does not permit this operation

SEE ALSO:  brdInit, setPWM_H, setPPM_H, setOffset_H, setFreq_H, setSync_H

END DESCRIPTION **********************************************************/
_bl_nodebug
int setDuty_H(int channel, float duty)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC)
   {
      // the brdInit function hasn't been executed as of yet
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setDuty(HCO_PIN(channel), duty);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader setOffset_H */
int setOffset_H(int channel, float offset);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setOffset_H                      <BLxS2xx.LIB>

SYNTAX:    int setOffset_H(int channel, float offset)

DESCRIPTION:   Sets the offset of a PPM on a high current output channel.

PARAMETER1:    Channel that is getting its offset set. (0-7)

PARAMETER2:    Offset of the PPM.  Should be in the range (0-100%)
                NOTE: Offset above 100.0 will be set to 100.0%.
                      A zero offset will produce the smallest offset
                      possible which is one count. If you must have
                      a zero offset, use setPWM_H instead of setPPM_H.

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value
               -EPERM:  channel function does not permit this operation

SEE ALSO:  brdInit, setPWM_H, setPPM_H, setFreq_H, setDuty_H, setSync_H

END DESCRIPTION **********************************************************/
_bl_nodebug
int setOffset_H(int channel, float offset)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC)
   {
      // the brdInit function hasn't been executed as of yet
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _setOffset(HCO_PIN(channel), offset);
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}

/*** BeginHeader resetCounter_H */
int resetCounter_H(int channel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
resetCounter_H                    <BLxS2xx.LIB>

SYNTAX:    int resetCounter_H(int channel)

DESCRIPTION:   Resets the current count of the counter register within
               the counter block hosting the given channel.  This forces
               update of limit and match registers on PWM/PPM channels.

PARAMETER1:    A High Current Channel which uses the desired counter block

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, set_PWM_H, set_PPM_H

END DESCRIPTION **********************************************************/
_bl_nodebug
int resetCounter_H(int channel)
{
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   rc = _riosbc_clear_count(HCO_PIN(channel));
   if (rc < 0) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader setSync_H */
int setSync_H(int channel, int edge);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setSync_H                        <BLxS2xx.LIB>

SYNTAX:    int setSync_H(int channel, int edge)

DESCRIPTION:   Enables or disables the global sync for the block the
               high current output channel is associated with.

PARAMETER1:    Channel that is on the block that will have its sync set.

PARAMETER2:    Edge of the sync signal.  (Zero will disable the sync)
               BL_EDGE_RISE = Synchronize event on rising edge
               BL_EDGE_FALL = Synchronize event on falling edge
               BL_EDGE_BOTH = Synchronize events on both edges

RETURN VALUE:  0 on success
               -EINVAL: invalid parameter value

SEE ALSO:      brdInit, setPWM_H, setPPM_H

END DESCRIPTION **********************************************************/
_bl_nodebug
int setSync_H(int channel, int edge)
{
   auto struct RSB_IOpin *chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC
          || (edge & (~BL_EDGE_BOTH)))
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = HCO_PIN(channel);     // get pointer to channel's pin struct

   rc = _riosbc_block_sync(chPtr, edge + RSB_SEL_GLOBAL);
   if (rc) {BL_ERROR(rc);}
   return rc;
}


/*** BeginHeader getMatch_H */
int getMatch_H(int channel, int source);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
getMatch_H                        <BLxS2xx.LIB>

SYNTAX:    int getMatch_H(int channel, int source)

DESCRIPTION:   Returns block match register usage for the given channel.
               May optionally be filtered to specific sources by the
               source parameter.

PARAMETER1:    Channel to get match information on

PARAMETER2:    Source filter
                  BL_TRAIL_ONLY will filter only the 'Trail' match register
                  BL_LEAD_ONLY will filter only the 'Lead' match register
                   Note: Counters will only use the 'Trail' match register

RETURN VALUE:  Bit Flags showing match usage on success:
	                BL_IER_MATCH0 bit set if using Match register 0
	                BL_IER_MATCH1 bit set if using Match register 1
	                BL_IER_MATCH2 bit set if using Match register 2
	                BL_IER_MATCH3 bit set if using Match register 3
               OR
                   -EINVAL: if invalid channel value

SEE ALSO:      brdInit, setPWM_H, setPPM_H

END DESCRIPTION **********************************************************/
_bl_nodebug
int getMatch_H(int channel, int source)
{
   auto struct RSB_IOpin *chPtr;
   auto int rc;

#ifndef BL_LIMIT_ERRORS
   if(!__brdInitFlag || channel < 0 || channel >= BL_DIGITAL_HC)
   {
      // the brdInit function hasn't been executed as of yet or channel invalid
      BL_ERROR(-EINVAL);
   }
#endif

   chPtr = HCO_PIN(channel);     // get pointer to channel's pin struct

   rc = 0;
   if ((!source || source == BL_TRAIL_ONLY) && (chPtr->match & RSB_RES_MATCH0))
   {
      rc |= _rsb_bitmap[chPtr->match & 3];
   }
   if ((!source || source == BL_LEAD_ONLY) && (chPtr->match & RSB_SET_MATCH0))
   {
      rc |= _rsb_bitmap[(chPtr->match >> 3) & 3];
   }
   return rc;
}


////////////////////////////
// Analog Input Functions //
////////////////////////////


/*** BeginHeader anaInConfig */
int anaInConfig(int channel, int opmode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaInConfig             <BLxS2xx.LIB>

SYNTAX:        int anaInConfig(int channel, int opmode)

DESCRIPTION:   Configures an ADC input channel for a given mode of
               operation. This function must be called before accessing
               the ADC chip. This function is non-reentrant.

               ADC Configuration is complicated by the fact that channels
               0 through 3 are offset independently while channels 4 through 7
               are biased in pairs. When configured for DIFF_MODE the ADC will
               return diffs for all channel pairs indicated below, with
               calibration constants reducing the effect of bias differences.

               ADC channel 0 - biased by DAC internal channel 2 \
                           1 - biased by DAC internal channel 3 /

                           2 - biased by DAC internal channel 4 \
                           3 - biased by DAC internal channel 5 /

                           4 - biased by DAC internal channel 6 \
                           5 - biased by DAC internal channel 6 /

                           6 - biased by DAC internal channel 7 \
                           7 - biased by DAC internal channel 7 /

               When DIFF_MODE is selected this function configures both the
               channel selected and its DIFF_MODE mate. DIFF_MODE will always
               configure pairs. For all of the pairs indicated above, both or
               neither will be configured for DIFF_MODE depending on the mode
               selected for the channel being configured.

               The upper are allowed to be configured as paired DIFF_MODE or
               as either SE0_MODE or SE1_MODE, but because the upper pairs
               share a DAC bias channel, if a pair has mismatched configurations
               they will incurr extra delays as the common DAC offset switches
               with reads from each. The same is true if they are both
               SE1_MODE but are read with different gains.

PARAMETER1:    Channel number: 0 - 7

PARAMETER2:    Select the mode of operation for the ADC channel pair.
               Values are as follows:

               SE0_MODE   = Single-Ended unipolar 0 - 20V
               SE1_MODE   = Single-Ended bipolar ±10V
               DIFF_MODE  = Differential bipolar ±20V
               mAMP_MODE  = 4-20ma operation

RETURN VALUE:  0, success
               BL_SPIBUSY, SPI port busy,
               -EINVAL, invalid parameter

SEE ALSO:      brdInit, anaInCalib, anaIn, anaInVolts, anaInmAmps,
               anaInDiff

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaInConfig(int channel, int opmode)
{
   auto int ref_val;
   auto int ch_pair, dac_channel;

#ifndef BL_LIMIT_ERRORS
   if (__RangeChecking)
   {
      if (!__brdInitFlag || (opmode & ~mAMP_MODE) || (channel & ~7))
      {
         // brdInit function hasn't been executed or opmode or channel invalid
         BL_ERROR(-EINVAL);
      }

      if (opmode == mAMP_MODE && channel > 3)
      {
         BL_ERROR(-EINVAL);
      }
   }
#endif

   // Disable DAC error checks
   __RangeChecking = FALSE;

   // Set bias to 12.8 mv, unipolar operation for modes SE0_MODE & mAMP_MODE
   // Set bias to 1.2 volts, bipolar operation for SE1_MODE or DIFF_MODE
   if (opmode == SE1_MODE || opmode == DIFF_MODE) {
      // Save bias code of zero & unset gain code
      ADC_Cmd_Bias[channel] = BL_GAIN_MASK;
      ref_val = dac_bias[0];
   }
   else {
      // Save bias code for Unipolar or milliamp modes & unset gain code
      ADC_Cmd_Bias[channel] = BL_UNIPOL_BIAS + BL_GAIN_MASK;
      ref_val = DAC_BIAS_FOR_UNIPOL;
   }
   dac_channel = (channel < 4) ? channel + 2 : (channel >> 1) + 4;
   anaOut(dac_channel, ref_val);

   if (__dacSynchronicity == DAC_SYNC)
   {
      anaOutStrobe(1 << dac_channel);
   }

   // calculate the channel pair for this channel
   ch_pair = channel ^ 0x01;

   // indicates calibration factors not loaded
   ADC_Cmd_Calb[channel] = opmode | BL_GAIN_MASK;

   if (opmode == DIFF_MODE ||
         ADC_Cmd_Bias[ch_pair] & BL_MODE_MASK == DIFF_MODE)
   {
      // configure pair mate calibration & mode same as this channel if
      //   using DIFF_MODE or prior DIFF_MODE pair has just been broken
      ADC_Cmd_Calb[ch_pair] = ADC_Cmd_Calb[channel];
   }
   if (opmode == DIFF_MODE || (channel & 4)) {
      // Set Bias equal if in DIFF_MODE or shared DAC bias
      ADC_Cmd_Bias[ch_pair] = ADC_Cmd_Bias[channel];
      // If DIFF_MODE on independent channel, change DAC bias on paired channel
      if (channel < 4) {
         anaOut(ch_pair + 2, ref_val);
      }
   }

   // Enable DAC error checking....ADC uses DAC for input circuit biasing
   __RangeChecking = TRUE;
   return 0;
}


/*** BeginHeader anaInCalib */
int anaInCalib(int channel, int opmode, int gaincode,
               int value1, float volts1,
               int value2, float volts2);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaInCalib              <BLxS2xx.LIB>

SYNTAX:        int anaInCalib(int channel, int opmode, int gaincode,
                              int value1, float volts1,
                              int value2, float volts2)

DESCRIPTION:   Calibrates the response of a given ADC channel as a linear
               function with using two conversion points provided by the
               user. Gain and offset constants are calculated and placed
               into flash. This function is non-reentrant.

               Note: Recommend using the 10 & 90% points of the MAX
               voltage range when calibrating a channel.


PARAMETER1:    ADC channel number 0 to 7, AIN0-AIN7.

               CH    Single-Ended     Differential       4-20ma
               --    ------------   ----------------     -------
               0        AIN0        +AIN0  and  -AIN1     AIN0
               1        AIN1                              AIN1
               2        AIN2        +AIN2  and  -AIN3     AIN2
               3        AIN3                              AIN3
               4        AIN4        +AIN4  and  -AIN5
               5        AIN5
               6        AIN6        +AIN6  and  -AIN7
               7        AIN7

PARAMETER2:    Select the mode of operation for the ADC channel
               calibration data being read. Values are as follows:

               SE0_MODE   = Single-Ended unipolar 0 - 20V
               SE1_MODE   = Single-Ended bipolar ±10V
               DIFF_MODE  = Differential bipolar ±20V
               mAMP_MODE  = 4-20ma operation

PARAMETER3:    Gaincode of 0 to 7. The table below applies for Single
               Ended, Differential modes, and 4-20ma modes:

               Gaincode  Macro   SE-Unipolar  SE-Bipolar  DIFF_Bipolar
               --------  ------  -----------  ----------  ----------
               0        GAIN_X1     20V         ±10V       ±20V
               1        GAIN_X2     10V          ±5V       ±10V
               2        GAIN_X4      5V        ±2.5V        ±5V
               3        GAIN_X5      4V        ±2.0V        ±4V
               4        GAIN_X8**  2.5V       ±1.25V      ±2.5V
               5        GAIN_X10     2V       ±1.00V        ±2V
               6        GAIN_X16  1.25V         ----     ±1.25V
               7        GAIN_X20  1.00V         ----     ±1.00V

               ** is the only gain code for 4-20ma operation.

               Notes:
               ------
               SE = Signal-Ended mode
               DI = Differential Mode


PARAMETER4:    The first ADC value.
PARAMETER5:    The voltage corresponding to the first ADC value.
PARAMETER6:    The second ADC value.
PARAMETER7:    The voltage corresponding to the second ADC value.

RETURN VALUE:  0, success
               -EINVAL = invalid parameter
               -ERR_ANA_CALIB = error writing calbration constants

SEE ALSO:      brdInit, anaInConfig, anaIn, anaInmAmps, anaInDiff,
               anaInVolts

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaInCalib(int channel, int opmode, int gaincode,
               int value1, float volts1,
               int value2, float volts2)
{
   auto float gain;
   auto int offset;
   auto calib_t cal_data;

#ifndef BL_LIMIT_ERRORS
   if (!__brdInitFlag || channel < 0 || channel >= BL_ANALOG_IN ||
        (opmode & ~mAMP_MODE) || (gaincode & ~7) ||
           (volts1 == volts2) || (value1 == value2))
   {
      // brdInit hasn't been executed or channel, opmode or gaincode invalid
      //  or no range between volts1 and volts2 or value1 and value2
      BL_ERROR(-EINVAL);
   }
#endif

   offset = (int)((volts2*value1 - volts1*value2)/(volts2-volts1));
   if (offset == value1)
   {
      gain = volts2/(offset-value2);
   }
   else
   {
      gain = volts1/(offset-value1);
   }

   cal_data.gain = gain;
   cal_data.offset = offset;

   if (_anaInEEWr(channel, opmode, gaincode, &cal_data))
   {
      BL_ERROR(-ERR_ANA_CALIB);
   }

   // Calibration change, force refresh of calibration factors
   ADC_Cmd_Calb[channel] |= BL_GAIN_MASK;

   return 0;
}

/*** BeginHeader anaIn */
int anaIn(int channel, int gaincode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaIn                   <BLxS2xx.LIB>

SYNTAX:        int anaIn(int channel, int gaincode)

DESCRIPTION:   Reads the state of an analog input channel.
               This function is non-reentrant.

               Note:
               -----
               If the access is for an ADC single-ended bipolar channel
               and the gaincode for the given channel has changed from
               the previous cycle, then the flash will be read to get
               the calibration constants for the new gain value.

PARAMETER1:    ADC channel number 0 to 7, AIN0-AIN7.

               CH    Single-Ended     Differential       4-20ma
               --    ------------   ----------------     -------
               0        AIN0        +AIN0  and  -AIN1     AIN0
               1        AIN1                              AIN1
               2        AIN2        +AIN2  and  -AIN3     AIN2
               3        AIN3                              AIN3
               4        AIN4        +AIN4  and  -AIN5
               5        AIN5
               6        AIN6        +AIN6  and  -AIN7
               7        AIN7


PARAMETER2:    Gaincode of 0 to 7. The table below applies for Single
               Ended, Differential modes, and 4-20ma modes:

               Gaincode  Macro   SE-Unipolar  SE-Bipolar  DIFF_Bipolar
               --------  ------  -----------  ----------  ----------
               0        GAIN_X1     20V         ±10V       ±20V
               1        GAIN_X2     10V          ±5V       ±10V
               2        GAIN_X4      5V        ±2.5V        ±5V
               3        GAIN_X5      4V        ±2.0V        ±4V
               4        GAIN_X8**  2.5V       ±1.25V      ±2.5V
               5        GAIN_X10     2V       ±1.00V        ±2V
               6        GAIN_X16  1.25V         ----     ±1.25V
               7        GAIN_X20  1.00V         ----     ±1.00V

               ** Is used for 4-20ma operation.

               Notes:
               ------
               SE = Signal-Ended mode
               DI = Differential Mode


RETURN VALUE:  A value corresponding to the voltage on the analog input
               channel, which will be:

               0-2047 for 11 bit A/D conversions,

               or a value of BL_ERRCODESTART or less which indicates
               an error condition:
                ADC operation errors: (will not create run-time error)
                  BL_SPIBUSY
                  BL_TIMEOUT
                  BL_OVERFLOW
                  BL_WRONG_MODE
                System errors:  (can create run-time error unless disabled)
                  -ERR_ANA_INVAL Invalid parameter value

SEE ALSO:      brdInit, anaInConfig, anaInCalib, anaInmAmps, anaInDiff,
               anaInVolts

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaIn(int channel, int gaincode)
{
   auto int ch_mate, bias, old;
   auto char mode, bipolar, diff;

#ifndef BL_LIMIT_ERRORS
   if (__RangeChecking)
   {
	   if (!__brdInitFlag || channel < 0 || channel >= BL_ANALOG_IN
	              || (gaincode & ~7))
	   {
	      // brdInit has not executed yet or invalid channel or gaincode
	      BL_ERROR(-ERR_ANA_INVAL);
      }
   }
#endif
   // Mask off mode from upper nibble
	mode = ADC_Cmd_Calb[channel] & BL_MODE_MASK;
   if (mode == mAMP_MODE  && (channel > 3 || gaincode != 4))
   {
      // Invalid channel or gaincode for mA mode
      BL_ERROR(-ERR_ANA_INVAL);
   }

   // Setup differential & bipolar flags and new bias & gain settings
   diff = (mode == DIFF_MODE ? 1 : 0);
   bipolar = ((mode == SE1_MODE ? 1 : 0) | diff);
   bias = (bipolar ? (gaincode << 4) : BL_UNIPOL_BIAS) + gaincode;
   old = ADC_Cmd_Bias[channel];

   // Have bias and gain settings changed from the previous setting?
   if (old != bias)
   {
   	ch_mate = channel ^ 0x01;  // Set channel mate
      old &= BL_GAIN_MASK;       // Mask off just the old gain setting

      // If channel is bipolar, bias has changed, or first use of channel
      //  then re-bias the channel
	   if (bipolar || (old == gaincode) || (old >= BL_MAX_GAINS))
	   {
	      _bias_adc(channel, gaincode);
	   }

      // Save new bias & gaincode to the channel
	   ADC_Cmd_Bias[channel] = bias;

      // Duplicate to mated channel if differential mode or shared DAC biasing
	   if (diff || (channel > 3))
	   {
         // Save new bias & gaincode to the channel's mate, re-bias if needed
	      ADC_Cmd_Bias[ch_mate] = bias;
         if (diff && (channel < 4)) {
            // If differential on low 4 channels, re-bias channel mate
            _bias_adc(ch_mate, gaincode);
         }
	   }
   }

   // Return the rawdata value from the given AD channel.
   return anaInDriver(DIRECTMODE + (gaincode << 4) +
         (diff ? (channel >> 1) + DIFFERENTIAL : channel + SINGLE_ENDED));
}

/*** BeginHeader anaInVolts */
float anaInVolts(int channel, int gaincode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaInVolts              <BLxS2xx.LIB>

SYNTAX:        float anaInVolts(int channel, int gaincode)

DESCRIPTION:   Reads the state of a single-ended analog input channel
               and uses the previously set calibration constants to
               convert it to volts. Voltage ranges given in the table
               below are nominal ranges that will be returned.  However,
               values outside these ranges can often be seen before the
               return of a BL_OVERFLOW error.  This function is
               non-reentrant.

               Note:
               -----
               If the gaincode for a given channel has changed from the
               previous cycle then the following code accesses will occur.

               1. The user block will be read to get the calibration
                  constants for the new gain value.

               2. The DAC will be written to bias the ADC input circuit
                  for proper operation (The DAC access only applies for
                  the single-ended bipolar ADC operation).

PARAMETER1:    ADC channel of 0 - 7, AIN00 - AIN07.

PARAMETER2:    Gaincode of 0 to 7. The table below applies for Single-
               Ended modes only:

               Gaincode  Macro   SE-Unipolar  SE-Bipolar
               --------  ------  -----------  ----------
               0        GAIN_X1     20V         ±10V
               1        GAIN_X2     10V          ±5V
               2        GAIN_X4      5V        ±2.5V
               3        GAIN_X5      4V        ±2.0V
               4        GAIN_X8    2.5V       ±1.25V
               5        GAIN_X10     2V       ±1.00V
               6        GAIN_X16    1.25V      ±0.675V
               7        GAIN_X20    1.00V        ±0.5V

               Note:
               ------
               SE = Signal-Ended mode

RETURN VALUE:  A voltage on the analog input channel, or a value of
               BL_ERRCODESTART or less which indicates an error condition:
                ADC operation errors: (will not create run-time error)
                  BL_NOT_CAL     ADC is not calibrated for this channel/gain
                  BL_OVERFLOW    ADC overflow
                  BL_SPIBUSY     Shared SPI port is already in use
                  BL_TIMEOUT     ADC timeout
                  BL_WRONG_MODE  ADC is in wrong mode (run anaInConfig)
                System errors:  (can create run-time error unless disabled)
                  -ERR_ANA_CALIB Fault detected in reading calibration factor
                  -ERR_ANA_INVAL Invalid parameter value

SEE ALSO:      brdInit, anaInConfig, anaIn, anaInmAmps, anaInDiff,
               anaInCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
float anaInVolts(int channel, int gaincode)
{
   auto int rawdata, ee_err, mode, last_gain;
   auto float anaVolts;

#ifndef BL_LIMIT_ERRORS
   if (!__brdInitFlag || channel < 0 || channel >= BL_ANALOG_IN
                || (gaincode & ~7))
   {
      // The brdInit function hasn't been executed or invalid channel or gain
      BL_ERROR(-ERR_ANA_INVAL);
   }
#endif
   // Check for change in gain
   last_gain = (ADC_Cmd_Calb[channel] & BL_GAIN_MASK);
   mode = ADC_Cmd_Calb[channel] & BL_MODE_MASK;
   if (mode > SE1_MODE)
   {
   	return BL_WRONG_MODE;
   }

   // Read new calibration factor if gain has changed
   if (last_gain != gaincode)
   {
      ee_err = _anaInEERd(channel, mode, gaincode,
                             &ADC_Cal_Table[channel]);
      ADC_Cmd_Calb[channel] = mode | 0x0F;
      if (ee_err)
      {
         // Error reading calibration factor from flash
         BL_ERROR(-ERR_ANA_CALIB);
      }
      if (((long)(ADC_Cal_Table[channel].gain)) == 0x80000000)
      {
         // Return channel not calibrated at this gain error code
         return BL_NOT_CAL;
      }
      ADC_Cmd_Calb[channel] = mode | gaincode;
   }

   rawdata  = anaIn(channel, gaincode);
   if (rawdata <= BL_ERRCODESTART)        // check for error condition
   {
      return rawdata;                  // if detected, return error
   }

   if (rawdata > 2047)
   {
      return BL_OVERFLOW;
   }
   rawdata  = ADC_Cal_Table[channel].offset - rawdata;
   anaVolts = ADC_Cal_Table[channel].gain * rawdata;
   return anaVolts;
}

/*** BeginHeader anaInDiff */
float anaInDiff(int channel, int gaincode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaInDiff               <BLxS2xx.LIB>

SYNTAX:        float anaInDiff(int channel, int gaincode)

DESCRIPTION:   Reads the state of differential analog input channels and
               uses the previously set calibration constants to convert
               it to volts. Voltage ranges given in the table below are
               the nominal ranges that will be returned.  However, values
               outside these ranges can often be seen before the return
               of a BL_OVERFLOW error.  This function is non-reentrant.

               Note:
               -----
               If the gaincode for a given channel has changed from the
               previous cycle, then the flash will be read to get the
               calibration constants for the new gain value.

PARAMETER1:    channel 0, 2, 4, or 6 as indicated by the differential
               positive line input. See below.

               ==============================================
                Channel    Differential inputs
               ----------  -------------------------------
                   0       +AIN0    -AIN1
                   2       +AIN2    -AIN3
                   4       +AIN4    -AIN5
                   6       +AIN6    -AIN7
               ==============================================

PARAMETER2:    Gaincode of 0 to 7. For Differential mode, the overall
               differential range is double the allowable voltage range
               seen by each individual channel as referenced to the
               analog ground of the SBC.

               Gaincode  Defined Macro   Gain   Diff. Range  Voltage Range
               --------  -------------   -----  -----------  -------------
                  0        GAIN_X1       (x1)     +- 20v       +- 10v
                  1        GAIN_X2       (x2)     +- 10v       +- 5v
                  2        GAIN_X4       (x4)     +- 5v        +- 2.5v
                  3        GAIN_X5       (x5)     +- 4v        +- 2v
                  4        GAIN_X8       (x8)     +- 2.5v      +- 1.25v
                  5        GAIN_X10      (x10)    +- 2v        +- 1v
                  6        GAIN_X16      (x16)    +- 1.25v     +- 0.625v
                  7        GAIN_X20      (x20)    +- 1v        +- 0.5v
               ===========================================================

RETURN VALUE:  A voltage value corresponding to the voltage present on the
               analog input channel (+-20.0), or a value of BL_ERRCODESTART
               or less which indicates an error condition:
                ADC operation errors: (will not create run-time error)
                  BL_NOT_CAL      ADC is not calibrated for this channel/gain
                  BL_OVERFLOW     ADC overflow
                  BL_SPIBUSY      Shared SPI port is already in use
                  BL_TIMEOUT      ADC timeout
                  BL_WRONG_MODE   ADC is in wrong mode (run anaInConfig)
                System errors:  (can create run-time error unless disabled)
                  -ERR_ANA_CALIB  Fault detected in reading calibration factor
                  -ERR_ANA_INVAL  Invalid parameter value

SEE ALSO:      brdInit, anaInConfig, anaIn, anaInmAmps, anaInVolts,
               anaInCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
float anaInDiff(int channel, int gaincode)
{
   auto int rawdata, ee_err, ch_mate, ch_diff;
   auto float anaVolts;
   auto calib_t cal_data;

#ifndef BL_LIMIT_ERRORS
   if (channel < 0 || channel >= BL_ANALOG_IN || (gaincode & ~7))
   {
      // The brdInit function hasn't been executed or invalid channel or gain
      BL_ERROR(-ERR_ANA_INVAL);
   }
#endif

   channel &= ~1;  // Mask off least significant bit (force even)
	ch_mate = channel ^ 0x01;
   ch_diff = channel >> 1;
   if ((ADC_Cmd_Calb[channel] & BL_MODE_MASK) != DIFF_MODE ||
       (ADC_Cmd_Calb[ch_mate] & BL_MODE_MASK) != DIFF_MODE)
   {
      return BL_WRONG_MODE;
   }

   if ((ADC_Cmd_Calb[channel] & BL_GAIN_MASK) != gaincode)
   {
      ee_err = _anaInEERd(channel, DIFF_MODE, gaincode,
                                 &ADC_Cal_Table[ch_diff]);
      ADC_Cmd_Calb[channel] = DIFF_MODE | 0x0F;
      if (ee_err)
      {
         // Error reading calibration factor from flash
         BL_ERROR(-ERR_ANA_CALIB);
      }
      if (((long)(ADC_Cal_Table[ch_diff].gain)) == 0x80000000)
      {
         // Return channel not calibrated at this gain error code
         return BL_NOT_CAL;
      }
      ADC_Cmd_Calb[channel] = DIFF_MODE | gaincode;
   }

   rawdata = anaIn(channel, gaincode);
   if (rawdata <= BL_ERRCODESTART) // check for error condition
   {
      return rawdata;           // if detected, return error
   }

   if (rawdata > 2047 || rawdata < -2048)
   {
      return BL_OVERFLOW;
   }

   rawdata  = ADC_Cal_Table[ch_diff].offset - rawdata;
   anaVolts = ADC_Cal_Table[ch_diff].gain * rawdata;
   return anaVolts;
}

/*** BeginHeader anaInmAmps */
float anaInmAmps(int channel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaInmAmps              <BLxS2xx.LIB>

SYNTAX:        float anaInmAmps(int channel)

DESCRIPTION:   Reads the state of an analog input channel and uses the
               previously set calibration constants to convert it to
               current milliamp floating point value. The nominal range
               is 0mA to 20mA, although it is possible to receive values
               outside this range before a BL_OVERFLOW error is returned.
               This function is non-reentrant.

PARAMETER1:    Channel is 0 to 3, AIN0 - AIN3:

RETURN VALUE:  A current value corresponding to the current on the analog
               input channel or a value of BL_ERRCODESTART or less which
               indicates an error condition:
                ADC operation errors: (will not create run-time error)
                  BL_NOT_CAL     ADC is not calibrated for this channel/gain
                  BL_OVERFLOW    ADC overflow
                  BL_SPIBUSY     Shared SPI port is already in use
                  BL_TIMEOUT     ADC timeout
                  BL_WRONG_MODE  ADC is in wrong mode (run anaInConfig)
                System errors:  (can create run-time error unless disabled)
                  -ERR_ANA_CALIB Fault detected in reading calibration factor
                  -ERR_ANA_INVAL Invalid parameter value

SEE ALSO:      brdInit, anaInConfig, anaIn, anaInDiff, anaInVolts,
               anaInCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
float anaInmAmps(int channel)
{
   auto int rawdata, ee_err;
   auto float current;
   auto calib_t cal_data;

#ifndef BL_LIMIT_ERRORS
   if (channel < 0 || channel >= BL_ANALOG_4TO20)
   {
      // The channel is invalid
      BL_ERROR(-ERR_ANA_INVAL);
   }
#endif
   if ((ADC_Cmd_Calb[channel] & BL_MODE_MASK) != mAMP_MODE)
   {
      return BL_WRONG_MODE;
   }
   if (ADC_Cmd_Calb[channel] != mAMP_GAINCODE)
   {
      ee_err = _anaInEERd(channel, mAMP_MODE, mAMP_GAINCODE,
                             &ADC_Cal_Table[channel]);
      ADC_Cmd_Calb[channel] = mAMP_MODE | 0x0F;
      if (ee_err)
      {
         // Error reading calibration factor from flash
         BL_ERROR(-ERR_ANA_CALIB);
      }
      if (((long)(ADC_Cal_Table[channel].gain)) == 0x80000000)
      {
         // Return channel not calibrated at this gain error code
         return BL_NOT_CAL;
      }
      ADC_Cmd_Calb[channel] = mAMP_MODE | mAMP_GAINCODE;
   }

   rawdata  =  anaIn(channel, mAMP_GAINCODE);
   if (rawdata <= BL_ERRCODESTART)  // check for error condition
   {
      return rawdata;            // if detected, return error
   }

   if (rawdata > 2047)
   {
      return BL_OVERFLOW;
   }

   rawdata = ADC_Cal_Table[channel].offset - rawdata;
   current = ADC_Cal_Table[channel].gain * rawdata;
   return current;
}

/*** BeginHeader  _bias_adc */
void _bias_adc(int channel, int gaincode);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_bias_adc         <BLxS2xx.LIB>

SYNTAX:        void _bias_adc(int channel, int gaincode)

END DESCRIPTION **********************************************************/

_bl_nodebug
void _bias_adc(int channel, int gaincode)
{
   auto int dac_channel;
   auto char bipolar;
   auto float rawdata, bias_value;

   dac_channel = (channel < 4) ? channel + 2 : (channel >> 1) + 4;
   bipolar = ADC_Cmd_Calb[channel] & mAMP_MODE;  // mask of mode bits
   if (bipolar) {
      // If not single ended unipolar, set bipolar flag unless in mA mode
      bipolar = ((bipolar == mAMP_MODE) ? 0 : 1);
   }

   // Set ADC bias for channel based on mode and gain settings
   __RangeChecking = FALSE;
   anaOut((dac_channel),
                (bipolar ? dac_bias[gaincode] : DAC_BIAS_FOR_UNIPOL));

   // Update the DAC output if in synchronous mode
   if (__dacSynchronicity == DAC_SYNC)
   {
      anaOutStrobe(1 << dac_channel);
   }
   __RangeChecking = TRUE;

   // Delay 600 usec for DAC settling time
   #asm
   ld    b,6
._bias_adc_delay_loop:
   call  _delay100usec           ; b preserved by _delay100usec
   djnz  ._bias_adc_delay_loop
   #endasm
}



/*** BeginHeader  _ads7870command */
int _ads7870command(char cmd, char wrdata);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_ads7870command         <BLxS2xx.LIB>

SYNTAX:        int _ads7870command(char cmd, char wrdata)

DESCRIPTION:   This driver is for the ADS7870 and is designed to serially
               clock an instruction byte and serially read from or write
               the command to the designated register of the ADS7870.

               Refer to an ADS7870 specification for addressing registers.

PARAMETER1:    The instruction byte will initiate a read/write operation
               at eight or sixteen bits on the designated register address.
               Put a 1 in bit 6 of cmd to perform a read operation.

PARAMETER2:    Command data configures the registers addressed by the
               instruction byte.

RETURN VALUE:  - Write Operation returns a zero value.
               - Read operation returns the data read from the ADC chip.

SEE ALSO:      anaInConfig, _txadcbyte, _rxadcbyte

END DESCRIPTION **********************************************************/

_bl_nodebug
int _ads7870command(char cmd, char wrdata)
{
   auto int rddata;
   auto char SxERShadow_Save;

   if (_bl_SPIgetSemaphore(&_bl_spi_dev[BL_SPI_ADC])) return BL_SPIBUSY;

   SxERShadow_Save = SxERShadow;
   WrPortI(SxER, &SxERShadow, SxERShadow | BL_SPI_MODE_ADC);
   WrPortE(BL_SPI_MUX_ADDR, &BL_SPI_MUX_SHADOW,
            ((BL_SPI_MUX_SHADOW & ~BL_SPI_MUX_MASK) | BL_SPI_ADC_CHIP));


#asm

   ld    hl,(sp+@sp+cmd)
   bit   6,l               ;check for write or read operation
   jp    nz,.read8

.write8:
   call  _txadcbyte        ;Send Command to ads7870
   ld    hl,(sp+@sp+wrdata)
   call  _txadcbyte        ;Send Data to ads7870
   ld    hl,0              ;return 0
   jp    .done

.read8:
   call  _txadcbyte        ;Send Command to ads7870
   call  _rxadcbyte        ;received clocked data
   ld    h,0               ;return value in hl
.done:
   ld    (SP+@SP+rddata),hl
#endasm

   WrPortE(BL_SPI_MUX_ADDR, &BL_SPI_MUX_SHADOW,
                  (BL_SPI_MUX_SHADOW & ~BL_SPI_MUX_MASK));
   WrPortI(SxER, &SxERShadow, SxERShadow_Save);

   _bl_SPIfreeSemaphore(&_bl_spi_dev[BL_SPI_ADC]);

   return(rddata);
}


/*** BeginHeader anaInDriver */
int anaInDriver(char cmd);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaInDriver             <BLxS2xx.LIB>

SYNTAX:        int anaInDriver(char cmd)

DESCRIPTION:   Low-level driver to read the ADS7870 ADC chip. This
               function is non-reentrant.

PARAMETER1:    The cmd parameter contains a gain code, channel code and
               the MSB set high for direct mode access. The format is as
               follows:

               D7    D6 - D4     D3 - D0
               --    ---------   ------------
               1     gain_code   channel_code

               Use the following calculation and tables below to
               determine cmd:

               cmd = 0x80 | (gain_code<<4) + channel_code

               ===========================================
                  gain_code   multiplier
                  ---------   ----------
                     0            1
                     1            2
                     2            4
                     3            5
                     4            8
                     5           10
                     6           16
                     7           20
               ===========================================

               ===========================================

               channel_code   Differential input lines
               ------------   ----------------------------
                  0           +AIN0 -AIN1
                  1           +AIN2 -AIN3
                  2           +AIN4 -AIN5
                  3           +AIN6 -AIN7
                  4           Reserved
                  5           Reserved
                  6           Reserved
                  7           Reserved

                              Single-ended      milliamp
                              input lines       input lines
                              ----------------------------
                  8           +AIN0             +AIN0
                  9           +AIN1             +AIN1
                  10          +AIN2             +AIN2
                  11          +AIN3             +AIN3
                  12          +AIN4             Reserved
                  13          +AIN5             Reserved
                  14          +AIN6             Reserved
                  15          +AIN7             Reserved
               ==============================================

               ADC input circuit configuration infor:
               --------------------------------------
               The BLxS2xx series board has been designed to extend the ADC input
               circuit configurations, which is done by the anaInConfig
               function. Here's a table that maps the BLxS2xx ADC circuit
               configurations to the ADC channel_code listed above:

               BLxS2xx ADC input              ADC chip channel_code
               ----------------              ---------------------
               Differential           --->    0 - 4
               Single-Ended unipolar  --->    8 - 15
               Single-Ended bipolar   --->    8 - 15
               4-20ma                 --->    8 - 11

RETURN VALUE:  A value corresponding to the voltage on the analog input
               channel, which will be in the range of -2048 to 2047 if
               a valid reading was taken.  Otherwise, it will be set to
               an error code of BL_ERRCODESTART or less as follows:
                  BL_SPIBUSY
                  BL_TIMEOUT
                  BL_OVERFLOW

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaInDriver(char cmd)
{
   auto int rawdata;
   auto char SxERShadow_Save;

   if (_bl_SPIgetSemaphore(&_bl_spi_dev[BL_SPI_ADC])) return BL_SPIBUSY;

   // Set SPI Multiplexor to the ADC chip
   SxERShadow_Save = SxERShadow;
   WrPortI(SxER, &SxERShadow, SxERShadow | BL_SPI_MODE_ADC);
   WrPortE(BL_SPI_MUX_ADDR, &BL_SPI_MUX_SHADOW,
                ((BL_SPI_MUX_SHADOW & ~BL_SPI_MUX_MASK) | BL_SPI_ADC_CHIP));

#asm _bl_nodebug
.wr_cmd:
   ld    hl,(sp+@sp+cmd)
   call  _txadcbyte           ;Send command Data to ads7870

#ifndef ADC_X1CYC_DELAY
// If ADC_X1CYC_DELAY is defined, then the data read from the ADC
// will be data converted from the previous ADC cycle, otherwise
// it will be data converted during this cycle.

   ; Wait for busy to go high
   ; >2usec delay  = (__numcycles_1us/2) * code cycles
   ld    a,(__numcycles_1us)
   ld    b,a
   srl   b
.busydelay:
   djnz  .busydelay     ; Code = 5 cycles

   ld    b,0xFF
.busyhigh:
ioi ld   a,(BL_BUSY_REG)
   bit   BL_BUSY_BIT,a
   jp    z,.read16            ;Wait for conversion to complete
   djnz  .busyhigh
   ld    hl,_cexpr(BL_TIMEOUT)
   jr    .done
#endif

.read16:
   call	_rxadcbyte					; read first byte in hl, assumes mode2 (LS byte
											; first) and LS bit for SPI
	ld		e,l							; save upper byte
	call	_rxadcbyte					; read LS byte
	ld		h,e							; restore upper byte

.checkovr:								; check for valid or analog over-range
   sra	h 								; shift right, preserve sign, c = bit 0
   rr		l								; shift value right one bit
   										; c goes to bit 7, bit 0 goes to c
   jr		c,.overrange            ; check if c (was bit zero) shows error

; convert to 12-bit data (bit shift to the right), one shift done above.
; this will preserve the sign.
	sra	h
   rr		l
	sra	h
   rr		l
	sra	h
   rr		l

   jr		.done
.overrange:
	ld		hl,_cexpr(BL_OVERFLOW); over-range
	jr		.done
.done:
   ld    (SP+@SP+rawdata),hl
#endasm

   WrPortE(BL_SPI_MUX_ADDR, &BL_SPI_MUX_SHADOW,
                              (BL_SPI_MUX_SHADOW & ~BL_SPI_MUX_MASK));
   WrPortI(SxER, &SxERShadow, SxERShadow_Save);
   _bl_SPIfreeSemaphore(&_bl_spi_dev[BL_SPI_ADC]);
   return rawdata;
}

/////////////////////////////
// Analog Output Functions //
/////////////////////////////

/*** BeginHeader anaOutConfig,  */
int anaOutConfig(char polarity, char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOutConfig            <BLxS2xx.LIB>

SYNTAX:        int anaOutConfig(char polarity, char mode)

DESCRIPTION:   Configures the DAC chip for a given voltage output range,
               either 0-10v or ±10v operation and loads the calibration
               data for use by the DAC API functions. This function must
               be called before accessing any of the DAC channels. This
               function is non-reentrant.

PARAMETER1:    To set the output configuration polarity, set the value to one
               of following:

               DAC_UNIPOLAR (0) = Unipolar operation. (0 - 10V)
               DAC_BIPOLAR  (1) = Bipolar operation.  (±10V)

               NOTE: This parameter has no effect on DAC current outputs.

PARAMETER2:    Mode of operation:
               0 = Asynchronous...An output will be updated at the time
                                  the data is written to the given channel.
               1 = Synchronous....All outputs will be updated with data
                                  previously written when the anaOutStrobe
                                  function is executed.

RETURN VALUE:  0 - success
               BL_SPIBUSY, SPI port busy
               -EINVAL, invalid config parameter.
               -ERR_ANA_CALIB, error reading calibration constants

SEE ALSO:      brdInit, anaOut, anaOutmAmps, anaOutStrobe, anaOutConfig,
               anaOutCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOutConfig(char polarity, char mode)
{
   auto calib_t cal_data;
   auto int ch, cmd, ee_err;

   cmd = REGISTERMODE + WR_REG + BITS8 + REG7;

   // set reference voltage from ADC to 2.5 volt
   _ads7870command(cmd, 0x3c);   // enable internal clock and 2.5V buf ref;

   // Initialize DAC command byte for each DAC channel
   DAC_Command[0] = 0x0000;
   DAC_Command[1] = 0x1000;

   // Following channels are used by the BLxS2xx ADC circuit.
   DAC_Command[2] = 0x2000;
   DAC_Command[3] = 0x3000;
   DAC_Command[4] = 0x4000;
   DAC_Command[5] = 0x5000;
   DAC_Command[6] = 0x6000;
   DAC_Command[7] = 0x7000;

   if (mode == DAC_SYNC)
   {
      // Initialize D/A to DAC_SYNC (Write Register Mode) to set up values
      anaOutDriver(0x8000);
   }
   else if (mode == DAC_ASYNC)
   {
      // Initialize D/A to DAC_ASYNC (Write Through Mode) for immediate uptput
      anaOutDriver(0x9000);
   }
   else
   {
      BL_ERROR(-EINVAL);
   }

   if (polarity  == DAC_UNIPOLAR)
   {
      __DACConfig = DAC_UNIPOLAR;
      for (ch=0; ch<BL_ANALOG_OUT; ch++)
      {
         // Load voltage unipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_VOLT0_INDEX, &cal_data);
         if (ee_err)
         {
	         // Error reading calibration factor from flash
	         BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_vCal_Table[ch].gain   = cal_data.gain;
            DAC_vCal_Table[ch].offset = cal_data.offset;
         }

         // Load 4-20ma unipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_mAMPS_INDEX, &cal_data);
         if (ee_err)
         {
	         // Error reading calibration factor from flash
	         BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_iCal_Table[ch].gain   = cal_data.gain;
            DAC_iCal_Table[ch].offset = cal_data.offset;
         }
      }

      anaOut(0, 4095);          // 0 volts
      anaOut(1, 4095);       // 0 volts
   }
   else
   {
      __DACConfig = DAC_BIPOLAR;
      for (ch = 0; ch < BL_ANALOG_OUT; ++ch)
      {
         // Load voltage bipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_VOLT1_INDEX, &cal_data);
         if (ee_err)
         {
	         // Error reading calibration factor from flash
	         BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_vCal_Table[ch].gain   = cal_data.gain;
            DAC_vCal_Table[ch].offset = cal_data.offset;
         }
      }

      anaOut(0, 2047);          // 0 volts
      anaOut(1, 2047);       // 0 volts
   }

   if (__dacSynchronicity == DAC_SYNC)
   {
      anaOutDriver(0xa003);
   }

   return 0;
}


/*** BeginHeader anaOutStrobe */
int anaOutStrobe(char channels);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOutStrobe            <BLxS2xx.LIB>

SYNTAX:        int anaOutStrobe(int channels)

DESCRIPTION:   Outputs the previously written value of each channel indicated
               by the input paramenter.

               This function is only useful when the DAC is configured for
               synchronous mode because in asynchronous mode each channel is
               updated immediately when a value is written to it. It is called
               internally by anaInConfig to strobe the DAC offsets when the DAC
               is in synchronous mode, but its normal use in programs should
               only be to strobe external DAC channels 0 and 1.

               This function is non-reentrant.

PARAMETER1:    Bitmap of channels to be strobed.
               1 - channel 0
               2 - channel 1
               3 - channels 0 and 1
               etc.

RETURN VALUE:  0, success
               BL_SPIBUSY, SPI port busy

SEE ALSO:      brdInit, anaOut, anaOutmAmps, anaOutStrobe, anaOutConfig,
               anaOutCalib,

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOutStrobe(char channels)
{
   return anaOutDriver(0xa000 | channels);
}


/*** BeginHeader anaOutPwrOff */
int anaOutPwrOff(BL_POWER_T mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION *********************************************
anaOutPwrOff            <BLxS2xx.LIB>

SYNTAX:        int anaOutPwrOff(BL_POWER_T mode)

DESCRIPTION:   Function to enable or disable the BLxS2xx power supply that
               is used to power the DAC voltage or current output circuits.
               This function is non-reentrant.

               Warning:
               --------
               This function should be called after configuring all DAC
               channels to a desired voltage and/or current. Unconfigured
               voltage and 4-20ma DAC channels will be set to approx. zero
               volts or 4 milliamps, respectively.


PARAMETER1:    DAC power off mode.
               BL_HIGH_Z (0) = High output impedence
               BL_OHM100 (1) = 100K ohm to ground
               BL_OHM2_5 (2) = 2.5K ohm to ground

RETURN VALUE:  0, success
               -EINVAL, invalid parameter

SEE ALSO:      anaOut, anaOutVolts, anaOutmAmps

END DESCRIPTION ***********************************************************/

_bl_nodebug
int anaOutPwrOff(BL_POWER_T mode)
{

#ifndef BL_LIMIT_ERRORS
   if (__DACConfig != DAC_UNIPOLAR && __DACConfig != DAC_BIPOLAR)
   {
      // The brdInit function hasn't been executed
      BL_ERROR(-EINVAL);
   }
#endif

   if (mode == BL_HIGH_Z)
   {
      anaOutDriver(0xD000 | 0x03); // High-Z outputs
   }
   else if (mode == BL_OHM100)
   {
      anaOutDriver(0xE000 | 0x03); // 100 K Ohm outputs
   }
   else if (mode == BL_OHM2_5)
   {
      anaOutDriver(0xF000 | 0x03); // 2.5 K Ohm outputs
   }
#ifndef BL_LIMIT_ERRORS
   else
   {
      // The mode is invalid.
      BL_ERROR(-EINVAL);
   }
#endif

   return 0;
}

/*** BeginHeader anaOut */
int anaOut(int ch,  int rawdata);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOut                  <BLxS2xx.LIB>

SYNTAX:        int anaOut(int ch, int rawdata)

DESCRIPTION:   Sets the voltage on a given analog output channel. This
               function is non-reentrant.

PARAMETER1:    The DAC output channel to write (0 - 1).

PARAMETER2:    A data value corresponding to the desired voltage on the
               analog output channel (0-4095).  If value larger than
               4095 is given, the channel will be set to maximum (4095).

RETURN VALUE:  0, success
               BL_SPIBUSY, SPI port busy

SEE ALSO:      anaOutDriver, anaOutVolts, anaOutCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOut(int ch, int rawdata)
{

#ifndef BL_LIMIT_ERRORS
   if (__RangeChecking)
   {
      if (!__brdInitFlag || ch < 0 || ch >= BL_ANALOG_OUT)
      {
         // The brdInit function hasn't been or the channel is invalid
         BL_ERROR(-EINVAL);
      }
   }
#endif

   if (DAC_Command[ch] == 0xFFFF)
   {
      DAC_Command[ch] = (ch << 12);
   }

   if (rawdata > MAXDACCOUNT || rawdata < MINDACCOUNT)
   {
      rawdata = (rawdata > MAXDACCOUNT) ? MAXDACCOUNT : 0;
   }

   return anaOutDriver(DAC_Command[ch] | rawdata);
}


/*** BeginHeader anaOutVolts */
int anaOutVolts(int ch, float voltage);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOutVolts             <BLxS2xx.LIB>

SYNTAX:        int anaOutVolts(int ch, float voltage)

DESCRIPTION:   Sets the voltage of an analog output channel by using
               the previously set calibration constants to calculate
               the correct data values. This function is non-reentrant.

PARAMETER1:    The DAC output channel (0 - 1).

PARAMETER2:    The desired voltage on the output channel.

RETURN VALUE:  0, SUCCESS
               BL_SPIBUSY, SPI port busy
               -ERR_ANA_INVAL, invalid config parameter.
               -ERR_ANA_CALIB, error reading calibration data

SEE ALSO:      brdInit, anaOut, anaOutStrobe, anaOutConfig, anaOutCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOutVolts(int ch, float voltage)
{
   auto int rawdata;
   auto int ee_err;
   auto calib_t cal_data;

   if (DAC_Command[ch] == 0xFFFF)
   {
      DAC_Command[ch] = (ch << 12);
      if (__DACConfig == DAC_UNIPOLAR)
      {
         // Load voltage unipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_VOLT0_INDEX, &cal_data);
         if (ee_err)
         {
            BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_vCal_Table[ch].gain   = cal_data.gain;
            DAC_vCal_Table[ch].offset = cal_data.offset;
         }

         // Load 4-20ma unipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_mAMPS_INDEX, &cal_data);
         if (ee_err)
         {
            BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_iCal_Table[ch].gain   = cal_data.gain;
            DAC_iCal_Table[ch].offset = cal_data.offset;
         }
      }
      else
      {
         // Load voltage bipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_VOLT1_INDEX, &cal_data);
         if (!ee_err)
         {
            DAC_vCal_Table[ch].gain   = cal_data.gain;
            DAC_vCal_Table[ch].offset = cal_data.offset;
         }
         else
         {
            BL_ERROR(-ERR_ANA_CALIB);
         }
      }
   }
   rawdata = (int)(DAC_vCal_Table[ch].offset -
             (voltage / DAC_vCal_Table[ch].gain));
   return anaOut(ch, rawdata);
}


/*** BeginHeader anaOutmAmps */
int anaOutmAmps(int ch, float current);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOutmAmps             <BLxS2xx.LIB>

SYNTAX:        int anaOutmAmps(int ch, float current)

DESCRIPTION:   Sets the current of an analog output channel by using
               the previously set calibration constants to calculate
               the correct data values. This function is non-reentrant.


PARAMETER1:    The DAC output channel (0 - 1).

PARAMETER2:    The desired current on the output channel, valid range
               is 4 - 20ma.

RETURN VALUE:  0, success
               BL_SPIBUSY, SPI port busy
               -ERR_ANA_CALIB, error reading calibration data

SEE ALSO:      brdInit, anaOut, anaOutVolts, anaOutStrobe, anaOutConfig,
               anaOutCalib

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOutmAmps(int ch, float current)
{
   auto int rawdata, ee_err;
   auto calib_t cal_data;

   if (DAC_Command[ch] == 0xFFFF)
   {
      DAC_Command[ch] = (ch << 12);
      if (__DACConfig == DAC_UNIPOLAR)
      {
         // Load voltage unipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_VOLT0_INDEX, &cal_data);
         if (ee_err)
         {
            BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_vCal_Table[ch].gain   = cal_data.gain;
            DAC_vCal_Table[ch].offset = cal_data.offset;
         }

         // Load 4-20ma unipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_mAMPS_INDEX, &cal_data);
         if (ee_err)
         {
            BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_iCal_Table[ch].gain   = cal_data.gain;
            DAC_iCal_Table[ch].offset = cal_data.offset;
         }
      }
      else
      {
         // Load voltage bipolar calibration data
         ee_err = _anaOutEERd(ch, DAC_VOLT1_INDEX, &cal_data);
         if (ee_err)
         {
            BL_ERROR(-ERR_ANA_CALIB);
         }
         else
         {
            DAC_vCal_Table[ch].gain   = cal_data.gain;
            DAC_vCal_Table[ch].offset = cal_data.offset;
         }
      }
   }
   rawdata = (int)(DAC_iCal_Table[ch].offset -
             (current / DAC_iCal_Table[ch].gain));
   return anaOut(ch, rawdata);
}


/*** BeginHeader anaOutCalib */
int anaOutCalib(int channel, int calib_index,
                int value1, float volts1,
                int value2, float volts2);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOutCalib             <BLxS2xx.LIB>

SYNTAX:        int anaOutCalib(int channel, int calib_index,
                               int value1, float volts1,
                               int value2, float volts2)

DESCRIPTION:   Calibrates the response of a given DAC channel as a linear
               function using two conversion points provided by the user.
               A Gain and offset constant is calculated and written to
               user block for use by the DAC API functions. This
               function is non-reentrant.

               Note: Recommend using the 10 & 90% points of the MAX
               voltage range when calibrating a channel.

PARAMETER1:    Channel number 0 to 1, AOUT00-AOUT01.

PARAMETER2:    Index used to go to the proper location in the lookup
               table for writing the calibration data.

               0 = 0 - 10V calibration data.
               1 = ±10V calibration data.
               2 = 4 - 20ma calibration data (unipolar configuration).

PARAMETER3:    The first DAC value (0 - 4095).

PARAMETER4:    The voltage/current corresponding to the first DAC value
               (0- 10V, ±10V or 4 - 20 mA).

PARAMETER5:    The second DAC value (0 - 4095).

PARAMETER6:    The voltage/current corresponding to the second DAC value
               (0- 10V, ±10V or 4 - 20 mA).

RETURN VALUE:  0, sucess
               -EINVAL, invalid parameter
               -ERR_ANA_CALIB, error writing calibration constants

SEE ALSO:      brdInit, anaOut, anaOutVolts, anaOutmAmps, anaOutStrobe,
               anaOutConfig

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOutCalib(int channel, int calib_index,
                int value1, float volts1,
                int value2, float volts2)
{
   auto float gain;
   auto int offset;
   auto calib_t cal_data;
   auto ee_err;

#ifndef BL_LIMIT_ERRORS
   if (__brdInitFlag == FALSE || channel < 0 || channel >= BL_MAX_DAC)
   {
      // The brdInit function hasn't been executed and/or
      // the channel is invalid.
      BL_ERROR(-EINVAL);
   }

   if (volts1 == volts2 || value1 == value2)
   {
      BL_ERROR(-EINVAL);
   }
#endif

   offset = (int) ((volts2*value1 - volts1*value2)/(volts2-volts1));
   if (offset == value1)
   {
      gain = volts2/(offset-value2);
   }
   else
   {
      gain = volts1/(offset-value1);
   }

   cal_data.gain = gain;
   cal_data.offset = offset;
   DAC_Command[channel] = 0xFFFF;
   ee_err = _anaOutEEWr(channel, calib_index, &cal_data);
   if (ee_err)
   {
      BL_ERROR(-ERR_ANA_CALIB);
   }

   return 0;
}

/*** BeginHeader  anaOutDriver */
int anaOutDriver(unsigned int cmd);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
anaOutDriver            <BLxS2xx.LIB>

SYNTAX:        int anaOutDriver(unsigned int cmd)

DESCRIPTION:   This is the low-level driver for the DAC128S085 DAC chip, it
               handles writing the rawdata output value to the DAC chip.
               The synch/asynch DAC mode is critical for determining whether
               a strobe needs to follow anaOut in _bias_adc, so mode change
               is detected here, not relying on that mode to only be changed
               through the high-level anaOutConfig. This function is
               non-reentrant.

PARAMETER1:    DAC command value, format is as follows:

               D15 - D12         D11 - D0
               ---------------   ------------------------
               Channel = 0 - 7   Rawdata value = 0 - 4095

               Use the following calculation to determine cmd:

               cmd = (Channel<<12) | Rawdata value

RETURN VALUE:  0, success
               BL_SPIBUSY, SPI port busy

END DESCRIPTION **********************************************************/

_bl_nodebug
int anaOutDriver(unsigned int cmd)
{
   auto char SxERShadow_Save;

   if (_bl_SPIgetSemaphore(&_bl_spi_dev[BL_SPI_DAC]))
   {
      return BL_SPIBUSY;
   }

   if ((cmd & 0xf000) == 0x8000)
   {
      __dacSynchronicity = DAC_SYNC;
   }
   else if ((cmd & 0xf000) == 0x9000)
   {
      __dacSynchronicity = DAC_ASYNC;
   }

   SxERShadow_Save  = SxERShadow;
   WrPortI(SxER, &SxERShadow, SxERShadow | BL_SPI_MODE_DAC);
   WrPortE(BL_SPI_MUX_ADDR, &BL_SPI_MUX_SHADOW,
                                  (BL_SPI_MUX_SHADOW | BL_SPI_DAC_CHIP));

#asm _bl_nodebug
   ld    hl,(sp+@sp+cmd)      ; Send upper command byte to DAC
   ld    l,h
   call  _txadcbyte

   ld    hl,(sp+@sp+cmd)
   call  _txadcbyte           ; Send lower command byte to DAC
#endasm

   // Deassert DAC chip select
   WrPortE(BL_SPI_MUX_ADDR, &BL_SPI_MUX_SHADOW,
                              (BL_SPI_MUX_SHADOW & ~BL_SPI_MUX_MASK));
   WrPortI(SxER, &SxERShadow, SxERShadow_Save);
   _bl_SPIfreeSemaphore(&_bl_spi_dev[BL_SPI_DAC]);
   return 0;
}


/*** BeginHeader _anaInEERd */
int _anaInEERd(int channel, int opmode, int gaincode, calib_t *pcal_data);
/*** EndHeader */

/***************************************************************************
_anaInEERd              <BLxS2xx.LIB>

SYNTAX:        _anaInEERd(int channel, int opmode, int gaincode,
                          calib_t *pcal_data)

DESCRIPTION:   Reads the calibration constants, gain and offset,  from
               the user block located on the BLxS2xx base unit. This
               function is non-reentrant.

               NOTE: This is an internal function not intended for
               for use by the application program.

PARAMETER1:    ADC channel number 0 to 7, AIN0-AIN7.

               CH    Single-Ended     Differential       4-20ma
               --    ------------   ----------------     -------
               0        AIN0        +AIN0  and  -AIN1     AIN0
               1        AIN1                              AIN1
               2        AIN2        +AIN2  and  -AIN3     AIN2
               3        AIN3                              AIN3
               4        AIN4        +AIN4  and  -AIN5
               5        AIN5
               6        AIN6        +AIN6  and  -AIN7
               7        AIN7

PARAMETER2:    Select the mode of operation for the ADC channel
               calibration data being read. Values are as follows:

               SE0_MODE   = Single-Ended, unipolar 0 - 20V
               SE1_MODE   = Single-Ended, bipolar ±10V
               DIFF_MODE  = Differential, bipolar ±20V
               mAMP_MODE  = 4-20ma operation

PARAMETER3:    Gaincode of 0 to 7. The table below applies for Single
               Ended, Differential modes, and 4-20ma modes:

               Gaincode  Macro   SE-Unipolar  SE-Bipolar  DIFF_Bipolar
               --------  ------  -----------  ----------  ----------
               0        GAIN_X1     20V         ±10V       ±20V
               1        GAIN_X2     10V          ±5V       ±10V
               2        GAIN_X4      5V        ±2.5V        ±5V
               3        GAIN_X5      4V        ±2.0V        ±4V
               4        GAIN_X8**  2.5V       ±1.25V      ±2.5V
               5        GAIN_X10     2V       ±1.00V        ±2V
               6        GAIN_X16  1.25V         ----     ±1.25V
               7        GAIN_X20  1.00V         ----     ±1.00V

               ** is used for 4-20ma operation.

               Notes:
               ------
               SE = Signal-Ended mode
               DI = Differential Mode

PARAMETER4:    Calibration structure pointer to gain and offset values.

RETURN VALUE:   0, success
               -1, invalid address or range
               -2, no valid ID block found (block version 3 or later)

SEE ALSO:      _anaInEEWr, _anaOutEEWr, _anaOutEERd

**************************************************************************/

_bl_nodebug
int _anaInEERd(int channel, int opmode, int gaincode, calib_t *pcal_data)
{
   auto int status;
   auto int ee_address;

   if (channel < 0 || channel >= BL_MAX_DAC)
   {
      // channel is incorrect for differential mode
      BL_ERROR(-EINVAL);
   }

   switch (opmode)
   {
   case SE0_MODE:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_ADC_SE0;
      ee_address += gaincode * (CAL_ANALOG_SIZE * BL_ANALOG_IN);
      break;

   case SE1_MODE:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_ADC_SE1;
      ee_address += gaincode * (CAL_ANALOG_SIZE * BL_ANALOG_IN);
      break;

   case DIFF_MODE:
      channel >>= 1;

      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_ADC_DIFF;
      ee_address += gaincode * (CAL_ANALOG_SIZE * (BL_ANALOG_IN / 2));
      break;

   case mAMP_MODE:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_ADC_MA;
      break;

   default:
      BL_ERROR(-EINVAL);
   }

   // add the channel offset to the address
   ee_address += channel  * CAL_ANALOG_SIZE;
   // read calibration constants from flash
   status = readUserBlock((void *)pcal_data, ee_address, CAL_ANALOG_SIZE);
   return status;
}

/*** BeginHeader _anaInEEWr */
int _anaInEEWr(int channel, int opmode, int gaincode, calib_t *pcal_data);
/*** EndHeader */

/***************************************************************************
_anaInEEWr              <BLxS2xx.LIB>

SYNTAX:        int _anaInEEWr(int channel, int opmode, int gaincode,
                              calib_t *pcal_data)

DESCRIPTION:   Writes the calibration constants, gain and offset, to
               the user block located on the BLxS2xx base unit.
               This function is non-reentrant.

               NOTE: This is an internal function not intended for
               for use by the application program.

PARAMETER1:    ADC channel number 0 to 7, AIN0-AIN7.

               CH    Single-Ended     Differential       4-20ma
               --    ------------   ----------------     -------
               0        AIN0        +AIN0  and  -AIN1     AIN0
               1        AIN1                              AIN1
               2        AIN2        +AIN2  and  -AIN3     AIN2
               3        AIN3                              AIN3
               4        AIN4        +AIN4  and  -AIN5
               5        AIN5
               6        AIN6        +AIN6  and  -AIN7
               7        AIN7

PARAMETER2:    Select the mode of operation for the ADC channel
               calibration data being read. Values are as follows:

               SE0_MODE   = Single-Ended, unipolar 0 - 20V
               SE1_MODE   = Single-Ended, bipolar ±10V
               DIFF_MODE  = Differential, bipolar ±20V
               mAMP_MODE  = 4-20ma operation

PARAMETER3:    Gaincode of 0 to 7. The table below applies for Single
               Ended, Differential modes, and 4-20ma modes:

               Gaincode  Macro   SE-Unipolar  SE-Bipolar  DIFF_Bipolar
               --------  ------  -----------  ----------  ----------
               0        GAIN_X1     20V         ±10V       ±20V
               1        GAIN_X2     10V          ±5V       ±10V
               2        GAIN_X4      5V        ±2.5V        ±5V
               3        GAIN_X5      4V        ±2.0V        ±4V
               4        GAIN_X8**  2.5V       ±1.25V      ±2.5V
               5        GAIN_X10     2V       ±1.00V        ±2V
               6        GAIN_X16  1.25V         ----     ±1.25V
               7        GAIN_X20  1.00V         ----     ±1.00V

               ** is used for 4-20ma operation.

               Notes:
               ------
               SE = Signal-Ended mode
               DI = Differential Mode

PARAMETER4:    Calibration structure pointer to gain and offset values.

RETURN VALUE:   0 = successful write to user block.
               -1 invalid address or range
               -2 No valid user block found (block version 3 or later)
               -3 flash writing error
               -EINVAL = invalid parameter


SEE ALSO:      _anaInEERd, _anaOutEEWr, _anaOutEERd

**************************************************************************/

_bl_nodebug
int _anaInEEWr(int channel, int opmode, int gaincode, calib_t *pcal_data)
{
   auto int status;
   auto int ee_address;

   switch (opmode)
   {
   case SE0_MODE:
      // Calculate the offset into the user block of where the
      // calibration constants are stored for a given A/D channel.
      ee_address = CAL_ADC_SE0;
      ee_address += gaincode * (CAL_ANALOG_SIZE * BL_ANALOG_IN);
      break;

   case SE1_MODE:
      // Calculate the offset into the user block of where the
      // calibration constants are stored for a given A/D channel.
      ee_address = CAL_ADC_SE1;
      ee_address += gaincode * (CAL_ANALOG_SIZE * BL_ANALOG_IN);
      break;

   case DIFF_MODE:
      if (channel < 0 || channel > 7)
      {
         // channel is incorrect for differential mode
         BL_ERROR(-EINVAL);
      }

      channel >>= 1;

      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_ADC_DIFF;
      ee_address += gaincode * (CAL_ANALOG_SIZE * (BL_ANALOG_IN / 2));
      break;

   case mAMP_MODE:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_ADC_MA;
      break;

   default:
      BL_ERROR(-EINVAL);
   }

   // add the channel offset to the address
   ee_address += channel * CAL_ANALOG_SIZE;
   // write calibration constants to flash
   status = writeUserBlock(ee_address, (void *)pcal_data, CAL_ANALOG_SIZE);
   return status;
}

/*** BeginHeader _anaOutEERd */
int _anaOutEERd(int channel, int config, calib_t *pcal_data);
/*** EndHeader */

/***************************************************************************
_anaOutEERd             <BLxS2xx.LIB>

SYNTAX:        int _anaOutEERd(int channel, int config, calib_t *pcal_data)

DESCRIPTION:   Reads the calibration constants, gain and offset,  from
               the user block. This function is non-reentrant.

               NOTE: This is an internal function not intended for
               for use by the application program.

PARAMETER1:    The D/A output channel (0 - 1) for which the calibration
               constants will be read.

PARAMETER2:    DAC configuration used to index into the calibration
               constants lookup table.

               DAC_VOLT0_INDEX = 0 - 10V calibration data.
               DAC_VOLT1_INDEX = ±10V calibration data.
               DAC_mAMPS_INDEX = 4 - 20ma calibration data

PARAMETER3:    Calibration structure pointer to gain and offset values.

RETURN VALUE:   0, if successful.
               -1, invalid address or range.
               -2, no valid ID block found.
               -EINVAL, invalid config parameter.

SEE ALSO:       _anaInEEWr, _anaInEEWr, _anaOutEEWr

**************************************************************************/

_bl_nodebug
int _anaOutEERd(int channel, int config, calib_t *pcal_data)
{
   auto int status;
   auto int ee_address;

   switch (config)
   {
   case DAC_VOLT0_INDEX:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_DACV_UNIPOLAR;
      break;

   case DAC_VOLT1_INDEX:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_DACV_BIPOLAR;
      break;

   case DAC_mAMPS_INDEX:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_DACI_UNIPOLAR;
      break;

   default:
      BL_ERROR(-EINVAL);
   }

   // add the channel offset to the address
   ee_address += channel * CAL_ANALOG_SIZE;
   // read calibration constants from flash
   status = readUserBlock((void *)pcal_data, ee_address, CAL_ANALOG_SIZE);
   return status;
}

/*** BeginHeader _anaOutEEWr */
int _anaOutEEWr(int channel, int config, calib_t *pcal_data);
/*** EndHeader */

/***************************************************************************
_anaOutEEWr             <BLxS2xx.LIB>

SYNTAX:        int _anaOutEEWr(int channel, int config, calib_t *cal_data)

DESCRIPTION:   Writes the calibration constants, gain and offset,  to
               the user block. This function is non-reentrant.

               NOTE: This is an internal function not intended for
               for use by the application program.

PARAMETER1:    The D/A output channel (0 - 1) for which the calibration
               constants will be written.

PARAMETER2:    DAC configuration used to index into the calibration
               constants lookup table.

               DAC_VOLT0_INDEX = 0 - 10V calibration data.
               DAC_VOLT1_INDEX = ±10V calibration data.
               DAC_mAMPS_INDEX = 4 - 20ma calibration data.

PARAMETER3:    Calibration structure pointer to gain and offset values.

RETURN VALUE:   0 = Data was successfully written to the user block.
               -1 = Invalid address or range.
               -2 = No valid user block found (block version 3 or later)
               -3 = flash writing error
               -EINVAL = invalid config parameter

SEE ALSO:      _anaInEEWr, _anaInEEWr, _anaOutEERd

**************************************************************************/

_bl_nodebug
int _anaOutEEWr(int channel, int config, calib_t *pcal_data)
{
   auto int status;
   auto int ee_address;

   switch (config)
   {
   case DAC_VOLT0_INDEX:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_DACV_UNIPOLAR;
      break;

   case DAC_VOLT1_INDEX:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_DACV_BIPOLAR;
      break;

   case DAC_mAMPS_INDEX:
      // Calculate the offset into the user block of where the calibration
      // constants are stored for a given A/D channel.
      ee_address = CAL_DACI_UNIPOLAR;
      break;

   default:
      BL_ERROR(-EINVAL);
   }

   // add the channel offset to the address
   ee_address += channel * CAL_ANALOG_SIZE;
   // write calibration constants to flash
   status = writeUserBlock(ee_address, (void *)pcal_data, CAL_ANALOG_SIZE);
   return status;
}


/*** BeginHeader brdInit */
void brdInit(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
brdInit                 <BLxS2xx.LIB>

SYNTAX:        void brdInit(void)

DESCRIPTION:   Call this function at the beginning of application code
               to initialize the controller's I/O ports.

               Port  Function             I/O      brdInit State
               ----- -------------------  -------  ------------
               PA0   ID0                  I/O      Pulled-up
               PA1   ID1                  I/O      Pulled-up
               PA2   ID2                  I/O      Pulled-up
               PA3   ID3                  I/O      Pulled-up
               PA4   ID4                  I/O      Pulled-up
               PA5   ID5                  I/O      Pulled-up
               PA6   ID6                  I/O      Pulled-up
               PA7   ID7                  I/O      Pulled-up
               PB0   ADC Busy (BL4S210)   Input    Pulled-up
               PB1   N/C                  Input    Pulled-up
               PB2   IA0                  Output   High
               PB3   IA1                  Output   High
               PB4   IA2                  Output   High
               PB5   IA3                  Output   High
               PB6   IA4                  Output   High
               PB7   IA5                  Output   High
               PC0   TXD SPI(ADC/DAC/RN)  Output   High
               PC1   RXD SPI(ADC/DAC/RN)  Input    Pulled-up
               PC2   TXC UART (RS485*)    Output   High
               PC3   RXC UART (RS485*)    Input    Pulled-up
               PC4   TXB (RS232/RS485*)   Output   High
               PC5   RXB (RS232/RS485*)   Input    Pulled-up
               PC6   Prog Port            Output   Low
               PC7   Prog Port            Input    Pulled-up
               PD0   N/C                  Output   See Note
               PD1   N/C                  Output   See Note
               PD2   TXF UART (RS232*)    Output   Low
               PD3   RXF UART (RS232*)    Output   Low
               PD4   N/C                  Output   Low
               PD5   N/C                  Output   Low
               PD6   TXE UART (RS232*)    Output   Low
               PD7   RXE UART (RS232*)    Output   Low
               PE0   I/O Enable (RIO's)   Output   High
               PE1   RIO Interrupt In     Input    Pulled-up
               PE2   RIO Global Sync      Output   Low
               PE3   CLKD SPI(ADC/DAC/RN) Output   High
               PE4   ADC Busy (**)        Input    Pulled-up
               PE5   N/C                  Input    Pulled-up
               PE6   N/C                  Output   Low
               PE7   N/C                  Output   Low

               (*)Note:
               --------
               The serial port configuration varies depending
               on board version being used, here's a list of
               the possible configuration.

               Port  BL4S200  BL4S210  BL4S230  BL5S220
               ----  -------  -------  -------  -------
                B      N/A     RS232     N/A      N/A
                C     RS485    RS485    RS485    RS485
                D     RS232     N/A     RS232    RS232
                E     RS232     N/A     RS232    RS232

                (**)Note:  All versions except BL4S210

PARAMETER1:    None

RETURN VALUE:  None

SEE ALSO:      Please refer to the user manual for a complete listing
               of all API functions for the BLxS2xx controller.

END DESCRIPTION **********************************************************/

_bl_nodebug
void brdInit(void)
{
   auto long clkrate;
   auto char cmd, i;

   i = __SPIShadow;

   _bl_shared_port_init();

   //---------------------------------------------------------------------
   // Port A configuration
   //
   // PA0   ID0      I/O    Pulled-up
   // PA1   ID1      I/O    Pulled-up
   // PA2   ID2      I/O    Pulled-up
   // PA3   ID3      I/O    Pulled-up
   // PA4   ID4      I/O    Pulled-up
   // PA5   ID5      I/O    Pulled-up
   // PA6   ID6      I/O    Pulled-up
   // PA7   ID7      I/O    Pulled-up
   // Initialize port A & B for Aux I/O BUS operation.
   //---------------------------------------------------------------------
   WrPortI(SPCR, &SPCRShadow, 0x8C);
   WrPortI(PADR, &PADRShadow, 0xFF);      //set to output all high

   //---------------------------------------------------------------------
   // Port B configuration
   //
   // PB0   ADC Busy (*)   Input    Pulled-up
   // PB1   N/C            Input    Pulled-up
   // PB2   IA0            Output   High
   // PB3   IA1            Output   High
   // PB4   IA2            Output   High
   // PB5   IA3            Output   High
   // PB6   IA4            Output   High
   // PB7   IA5            Output   High
   // Port B is initialized for Aux I/O BUS operation via SPCR register.
   // (*) On the BL4S210 version only
   //---------------------------------------------------------------------
   // Set port B pins PB2 - PB7 lines to be outputs, PB0 and PB1 as inputs
   WrPortI(PBDR, &PBDRShadow, 0xFC);
   WrPortI(PBDDR, &PBDDRShadow, 0xFC);

   //---------------------------------------------------------------------
   // Port C configuration
   //
   // PC0   TXD SPI     Output   High
   // PC1   RXD SPI     Input    Pulled-up
   // PC2   TXC UART    Output   High
   // PC3   RXC UART    Input    Pulled-up
   // PC4   TXB UART    Output   High
   // PC5   RXB UART    Input    Pulled-up
   // PC6   Prog Port   Output   Low
   // PC7   Prog Port   Input    Pulled-up
   // Notes:
   // 1. SPI Port D is initialized after all uP pins are initialized.
   // 2. UART serial port A will be initialized by the BIOS.
   // 3. UART serial ports B & C will be initialized by the serial open
   //    API function if used by the application program.
   //---------------------------------------------------------------------
   WrPortI(PCDDR, &PCDDRShadow, 0x55);
#if _BOARD_TYPE_ == RCM4310   // Core type is RCM4310
   WrPortI(PCFR, &PCFRShadow, 0x51);
#else
   WrPortI(PCFR, &PCFRShadow, 0x41);
#endif

   //---------------------------------------------------------------------
   // Port D configuration  (NOTE* Entire port not used on RCM4010)
   //
   // PD0   N/C
   // PD1   SP Control 3     Output   High (Low for RCM4210)
   // PD2   TXF UART       Output   High
   // PD3   RXF UART       Input    Pulled-up
   // PD4   RIO Global Sync  Output   Low
   // PD5   N/C
   // PD6   TXE UART       Output   High
   // PD7   RXE UART       Input    Pulled-up
   //---------------------------------------------------------------------
#if _BOARD_TYPE_ != RCM4010   // Core type is NOT RCM4010
   WrPortI(PDDR,  &PDDRShadow,  0x46);
   WrPortI(PDDDR, &PDDDRShadow, 0x77);
   WrPortI(PDDCR, &PDDCRShadow, 0x00);
   WrPortI(PDCR,  &PDCRShadow,  0x00);
#endif

   //---------------------------------------------------------------------
   // Port E configuration
   //
   // PE0   Ext Strobe (RIO's/Latch)  Output   High
   // PE1   Ext Interrupt 1 (RIO's)   Input    Pulled-up
   // PE2   RIO Global Sync (BL4S210) Output*  Low*
   // PE3   CLKD SPI (RN/ADC/DAC)     Output   High
   // PE4   ADC Busy (Ext Int 0)      Input*   Pulled-up*
   // PE5   N/C
   // PE6   N/C
   // PE7   N/C
   //
   // * The ADC Busy input is on PE4 for all versions except the
   // BL4S210, which uses PB0 (no Ext. Int.).  On the BL4S210 version,
   // Global Sync is an output port on PE2.
   //---------------------------------------------------------------------
   WrPortI(PEDR,  &PEDRShadow,  (PEDRShadow | 9));
   WrPortI(PECR,  &PECRShadow,  0x00);
#if _BOARD_TYPE_ == RCM4010   // Core type is RCM4010 (BL4S210)
   WrPortI(PEDDR, &PEDDRShadow, ((PEDDRShadow & 0xE0) | 0x1D));
   WrPortI(PEFR,  &PEFRShadow,  ((PEFRShadow  & 0xF9) | 0x19));
#else
 #if _BOARD_TYPE_ == RCM4310
   // Core type is RCM4310  (BL4S200)
   WrPortI(PEDR,  &PEDRShadow,  (PEDRShadow  &~ 0x05));
   WrPortI(PEDDR, &PEDDRShadow, ((PEDDRShadow & 0xE4) | 0x09));
   WrPortI(PEFR,  &PEFRShadow,  ((PEFRShadow  & 0xE4) | 0x09));
 #else
   // Core type is RCM4400W, RCM4510W or RCM5400W
   WrPortI(PEDR,  &PEDRShadow,  (PEDRShadow &~ 0x01));
   WrPortI(PEDDR, &PEDDRShadow, ((PEDDRShadow & 0xE4) | 0x09));
   WrPortI(PEFR,  &PEFRShadow,  ((PEFRShadow  & 0xE4) | 0x09));
 #endif
#endif

   //---------------------------------------------------------------------
   // I/O Latch configuration
   //
   // LB0   Conf. Output 31             Output   Low
   // LB1   Conf. Output 30             Output   Low
   // LB2   RIO Shared G//C Line        Output   High
   // LB3   RS485 TX Enable (Act. Low)  Output   High
   // LB4   Shared SPI Addr 0           Output   Low
   // LB5   Shared SPI Addr 1           Output   Low
   // LB6   Serial Routing Control 1    Output*  Low*
   // LB7   Serial RTS Output (RCM4010) Output*  Low*
   //
   // * The Serial Routing Control 1 output on LB6 allows the connection
   // of serial port B to the primary RS-232 transceiver pair on the RCM4010
   // core module.  Since the RCM4010 does not have any CPU Port D pins due
   // to the 16-bit memory structure, this routing allows serial port B to
   // handle the one RS-232 port available with this core.  Since no other
   // UART's are available, latch pin LB7 is attached to the secondary
   // transceiver output to allow hardware handshaking out from the SBC,
   // but there is no handshaking input.  Since this is not full duplex
   // handshaking, it would be up to the user software to control this
   // line.  These connections happen when LB6 is pulled high.
   //---------------------------------------------------------------------
// Set startup latch value (written to latch in _riosbc_init)
#if _BOARD_TYPE_ == RCM4010   // Core type is RCM4010 (BL4S210)
   __latch_sr = 0x4C;
#else
   __latch_sr = 0x0C;
#endif

   //---------------------------------------------------------------------
   // Customized initialization by core module type
   //---------------------------------------------------------------------
   #if _BOARD_TYPE_ == RCM4310   // Core type is RCM4310 (BL4S200)
   // Nothing to be done....
   #endif

   #if _BOARD_TYPE_ == RCM5400W   // Core type is RCM5400W (BL5S220)
   // Nothing to be done....
   #endif

   #if _BOARD_TYPE_ == RCM4510W   // Core type is RCM4510W (BL4S230)
   // Nothing to be done....
   #endif

   //---------------------------------------------------------------------
   // Initially set the SPI port for serial data transfers of 1MBit and
   // set CLK/DATA phase for ADC and DAC operation.
   //---------------------------------------------------------------------
   clkrate = BL_SPI_CLK / 16;
   // calculation is async baud (16 clocks/bit), we need sync (1 clock/bit)
   __tdivisor = (int)((2.0 * freq_divider * 19200.0/(float)clkrate + 0.5) - 1L);
   WrPortI(SDCR, &SDCRShadow, 0x0C);         // Use internal clock for serial D
   WrPortI(SDDLR, NULL, __tdivisor);
   WrPortI(SDDHR, NULL, (__tdivisor >> 8) | 0x80);

   //---------------------------------------------------------------------
   // Set SPI for 1Msec and Rabbitnet Normal/inactive high CLK timing.
   // (ie default for Rabbitnet operation)
   //
   // Note: ADC and DAC API calls will change the CLK/DATA phase timing
   // parameter and the SPI clock parameters for proper ADC/DAC operation.
   //---------------------------------------------------------------------

   WrPortI(PEALR,&PEALRShadow,PEALRShadow | 0xC0);  //

   if (_riosbc_init(bl_def, bl_init))
   {
     printf("RIO initialization failed, invalid board definition.\n");
     exit(-EINVAL);
   }
   // Set all three RIO's to prescale frequency (16Mhz / 160)
   _riosbc_set_clk_prescale(0, (RIO_CLOCK_FREQ / RIO_PRESCALE_FREQ) - 1);
   _riosbc_set_clk_prescale(1, (RIO_CLOCK_FREQ / RIO_PRESCALE_FREQ) - 1);
   _riosbc_set_clk_prescale(2, (RIO_CLOCK_FREQ / RIO_PRESCALE_FREQ) - 1);
   // Set push-pull protection time to maximum (4.096ms = 65536 / 16Mhz)
   _riosbc_set_prot_prescale(0, 0xFFFF);
   _riosbc_set_prot_prescale(1, 0xFFFF);
   _riosbc_set_prot_prescale(2, 0xFFFF);

   // values used in _bias_adc(..)
   gain_codes[0] = 1;
   gain_codes[1] = 2;
   gain_codes[2] = 4;
   gain_codes[3] = 5;
   gain_codes[4] = 8;
   gain_codes[5] = 10;
   gain_codes[6] = 16;
   gain_codes[7] = 20;

   // Set ADC and DAC to default operating ranges
   // - DAC set for 0 - 10v unipolar operation
   // - ADC set for 0 - 20v unipolar operation

   // Disable DAC application program error checks
   __RangeChecking = FALSE;

   if (anaOutConfig(DAC_UNIPOLAR, DAC_ASYNC) != BL_SPIBUSY)
   {
      // Initialize ADC reference voltage generator and buffer
      // D5 sets voltage generator to internal clock source
      // D4 enables the 2.5Mhz internal oscillator
      // D3 enables reference voltage generator
      // D2 enables power to buffer (buffers the reference voltage)
      _ads7870command(REGISTERMODE + WR_REG + BITS8 + REG7, 0x3C);

      // Initialize ADC control register, read-back = mode 1
      // D3:D2 (command data parameter 0x04 sets D3:D2 = 0x01)
      //  0x01: Sets ADC to return most significant byte first
      _ads7870command(REGISTERMODE + WR_REG + BITS8 + REG3, 0x04);

	   // Set ADC inputs to single ended mode
      for (i = 0; i < 8; i++)
      {
	      // Disable analog application range checking
	      __RangeChecking = FALSE;
         if (anaInConfig(i, SE0_MODE)) break;
         if (i == 7)
	      {
	         // Set flag to indicate brdInit has been executed
	         __brdInitFlag = TRUE;
	      }
      }
   }

   // Enable DAC error checking....ADC uses DAC for input circuit biasing
   __RangeChecking = TRUE;

#ifndef BL_POLL_MODE
   // Enable RIO Interrupts on PE1 with BL_IRQ_PRIORITY setting
   WrPortI(I1CR, &I1CRShadow, BL_IRQ_PRIORITY + 4);
   _riosbc_irq_enable(0,1);
   _riosbc_irq_enable(1,1);
   _riosbc_irq_enable(2,1);
#endif
}

/*** BeginHeader */
#endif
/*** EndHeader */


