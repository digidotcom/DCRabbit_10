/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION **************************************************
SPI.LIB 1.09

This library is intended for use only with the Rabbit 4000 - 6000 processors.

This library contains several functions which allow connection to an
SPI device via a serial interface.  It is the responsibility of the caller to
activate whatever Chip Select signal which may be necessary.

The user MUST set up the serial port Tx, Rx and Clk to the desired parallel
I/O bits BEFORE executing any of the functions in the library.

This library is NOT interrupt driven.  It is strictly a polled operation.
The functions block until the requested operation is complete.

The Transmit and Receive functions automatically use MSBit first.

Modification list
	20 Sep 2011		1.09	modified SPIWait4Last_0 to account for SPImode function
   								added SPI_ClockLast variable
	18 Aug 2011		1.08	changed jr SPIWait4Last_0 to call SPIWait4Last_0
	11 Aug 2011		1.07	added  API function SPImode
                        added jump to SPIWait4Last_0 in SPIWrRd to compensate
    								for R6000 bug
    8 Jul 2011		1.06	added jump to SPIWait4Last_0 in SPITx to compensate
    								for R6000 bug
	23 Jun 2011		1.05	added dummy read to SPITx to compensate for 6000 SPI bug
    3 Dec 2010    1.04  added CLOCK_PORT macros
	 4 Aug 2010		1.03	corrected SPI_MASTER_CS_REG to SPI_MASTER_CS_PORT
	 6 Aug 2007		1.02	added SPI_RX_PORT feature
	14 June 2007	1.01	Initial release


The following is a description of the values which the user may define
BEFORE the #use SPI.lib statement:

(1) Interface (default is SPI_SER_B)
	SPI_SER_A			use serial port A
	SPI_SER_B			use serial port B
	SPI_SER_C			use serial port C
	SPI_SER_D			use serial port D
	SPI_CLOCK_MODE		clock and data phase
	SPI_RX_PORT			define to one of the following to select which parallel
   							port is used for the receive bit
   	SPI_RX_PC		if using parallel port C
   	SPI_RX_PD		if using parallel port D
   	SPI_RX_PE		if using parallel port E

	SPI_SLAVE			defines the Rabbit as a slave device

		This signal is generated by the Slave to tell the
      Master that the slave is ready.  It is used for
      handshaking between each byte.
	SPI_SLAVE_RDY_PORT	defines the port for SLAVE_RDY signal
	SPI_SLAVE_RDY_SHADOW defines the shadow register for SPI_SLAVE_RDY_PORT
	SPI_SLAVE_RDY_BIT	defines the bit for the SLAVE_RDY signal

		This signal is read by the slave and is used by it
      to determine that it has been enabled by the Master.
	SPI_SLAVE_CS_REG	defines the register for the incoming CS signal
	SPI_SLAVE_CS_BIT	defines the bit for the incoming CS signal - Low True
	SPI_SLAVE_HIGH_TRUE define if high true chip select is desired

		This signal is generated by the Master.
		The user is responsible for setting/clearing this
      bit before/after every transaction.
      MASTER OPERATION: If SPI_MASTER_CS_PORT is defined it
      will be toggled during the data transfer.  The value of
      SPI_SLAVE_HIGH_TRUE is used to determine the true state.
      SLAVE OPERATION: If SPI_MASTER_CS_PORT is defined the
      slave receive function will use the CS input for
      handshaking between each byte.
	SPI_MASTER_CS_PORT	define CS port from master to Slave
	SPI_MASTER_CS_SHADOW	define shadow register for CS (Master only)
  	SPI_MASTER_CS_BIT		define CS bit number

(2) SPI Bit Rate Divisor (default is 5)
	SPI_CLK_DIVISOR	This is the divisor for the appropriate Timer A register.
	Warning: a small value for the SPI_CLK_DIVISOR can result in unstable operation.
	Recommendation is that values should be >= 5.
	NOTE: this library uses the dedicated bit rate divider - not timer A.

END DESCRIPTION **********************************************************/


/*** BeginHeader */
#ifndef __SPILIB
#define __SPILIB
/*** EndHeader */

/*** BeginHeader */

#ifndef SPI_DEBUG
	#define SPI_DEBUG __nodebug
#endif

#if (_CPU_ID_ < R4000)
	#fatal "This library is ONLY for Rabbit 4000, 5000, and 6000 products"
#endif

//								**** test for type of interface ****
#ifndef SPI_SLAVE
	#define SPI_MASTER
#endif

#ifndef SPI_SER_A
	#ifndef SPI_SER_B
		#ifndef SPI_SER_C
			#ifndef SPI_SER_D
				#warnt "No SPI interface defined: using SPI_SER_B"
				#define SPI_SER_B
			#endif // SPI_SER_D
		#endif // SPI_SER_C
	#endif // SPI_SER_B
#endif // SPI_SER_A

//								**** set up to use serial port A ****
#ifdef SPI_SER_A
	#define SPI_DR	SADR
	#define SPI_CR	SACR
	#define SPI_ShCR	SACRShadow
	#define SPI_SR	SASR
	#define SPI_ER	SAER
	#define SPI_ShER	SAERShadow
#endif // SPI_SER_A

//								**** set up to use serial port B ****
#ifdef SPI_SER_B
	#define SPI_DR	SBDR
	#define SPI_CR	SBCR
	#define SPI_ShCR	SBCRShadow
	#define SPI_SR	SBSR
	#define SPI_ER	SBER
	#define SPI_ShER	SBERShadow
#endif // SPI_SER_B

//								**** set up to use serial port C ****
#ifdef SPI_SER_C
	#define SPI_DR	SCDR
	#define SPI_CR	SCCR
	#define SPI_ShCR	SCCRShadow
	#define SPI_SR	SCSR
	#define SPI_ER	SCER
	#define SPI_ShER	SCERShadow
#endif // SPI_SER_C

//								**** set up to use serial port D ****
#ifdef SPI_SER_D
	#define SPI_DR	SDDR
	#define SPI_CR	SDCR
	#define SPI_ShCR	SDCRShadow
	#define SPI_SR	SDSR
	#define SPI_ER	SDER
	#define SPI_ShER	SDERShadow
#endif // SPI_SER_D

#ifndef SPI_CLOCK_MODE
	#define SPI_CLOCK_MODE 0
#endif

#ifndef SPI_SLAVE
	#ifndef SPI_CLK_DIVISOR
		#define SPI_CLK_DIVISOR		5		// divisor for the bit rate generator
	#endif // SPI_CLK_DIVISOR
	#if (SPI_CLK_DIVISOR<5)
		#warnt "SPI_CLK_DIVISOR may be too small!"
	#endif
#endif // not SPI_SLAVE

// mask for selecting the parallel port used by the rcvr via SPI_CR
#define 	SPI_RX_PC	0x00
#define 	SPI_RX_PD	0x10
#define 	SPI_RX_PE	0x20
#ifndef SPI_RX_PORT
	#warnt "No value for SPI_RX_PORT, default to SPI_RX_PC"
   #define SPI_RX_PORT SPI_RX_PC
#endif

#if (_CPU_ID_ == R6000)
	#ifndef CLOCK_PORT
		#error "CLOCK_PORT must be defined for Rabbit 6000 processors"
   #endif
	#define _CLOCK_PORT CONCAT ( CONCAT (P,CLOCK_PORT), DR)
#endif

/*** EndHeader */


/*** Beginheader SPIinit, SPIWrite, SPIRead, spi_swap, SPIWait4Last, SPImode */

void	SPIinit	( void );
int	SPIWrite ( const void *DataAddress, int NbrBytes );
int	SPIRead  ( const void *DataAddress, int NbrBytes );
void	SPIWait4Last ( void );
void	SPImode ( int mode );

extern char	SPIxor;					// flag for inverting the received byte
extern char	SPITXxor;				// flag for inverting the transmitted byte
extern int	SPIdivisor;				// bit rate divisor

// SPI control register Definitions
#ifdef SPI_SLAVE
	#define SPI_MS 0x08
#else
	#define SPI_MS 0x0C
#endif
#define SPI_TX					0x80
#define SPI_RX					0x40

/*** endheader */

char	SPIxor;
char	SPITXxor;
int	SPIdivisor;				// bit rate divisor
char	SPI_ClockLast;

/* START FUNCTION DESCRIPTION ********************************************
SPIinit                  <SPI.LIB>

SYNTAX:	      void SPIinit ();

DESCRIPTION:   initialize the SPI port parameters - serial interface only!

PARAMETER1:		none

RETURN VALUE:	none

This library is intended for use only with the Rabbit 4, 5 and 6000 processors.

The user MUST set up the serial port Tx, Rx and Clk to the desired parallel
I/O bits BEFORE executing any of the functions in the library.  Do not forget
to set the Clk pin direction properly: output for master, input for Slave.

IMPORTANT: the macros CLOCK_PORT and CLOCK_BIT (see description below) must be
defined if you are using the Rabbit 6000.

This library is NOT interrupt driven.  It is strictly a polled operation.
The functions block until the requested operation is complete.

The Transmit and Receive functions automatically use MSBit first.

The following is a description of the values which the user may define
BEFORE the #use SPI.lib statement:

(1) Interface (default is SPI_SER_B)
	SPI_SER_A			use serial port A
	SPI_SER_B			use serial port B
	SPI_SER_C			use serial port C
	SPI_SER_D			use serial port D
	SPI_CLOCK_MODE		clock and data phase ( see SPImode function )

	SPI_RX_PORT			define to one of the following to select which parallel
   							port is used for the receive bit
   	SPI_RX_PC		if using parallel port C
   	SPI_RX_PD		if using parallel port D
   	SPI_RX_PE		if using parallel port E

	SPI_SLAVE			defines the Rabbit as a slave device

	SPI_SLAVE_RDY: This signal is generated by the Slave to tell the
      Master that the slave is ready.
		SPI_SLAVE_RDY_PORT	defines the port for SLAVE_RDY signal
		SPI_SLAVE_RDY_SHADOW defines the shadow register for SPI_SLAVE_RDY_PORT
		SPI_SLAVE_RDY_BIT	defines the bit for the SLAVE_RDY signal

	SPI_SLAVE_CS: This signal is read by the slave and is used by it
      to determine that it has been enabled by the Master.
		SPI_SLAVE_CS_REG	defines the register for the incoming CS signal
		SPI_SLAVE_CS_BIT	defines the bit for the incoming CS signal - Low True
		SPI_SLAVE_HIGH_TRUE define if high true chip select is desired

	SPI_MASTER_CS: This signal is generated by the Master.
		The user is responsible for setting/clearing this
      bit before/after every transaction.
      MASTER OPERATION: If SPI_MASTER_CS_PORT is defined it
      will be toggled during the data transfer.  The value of
      SPI_SLAVE_HIGH_TRUE is used to determine the true state.
      SLAVE OPERATION: If SPI_MASTER_CS_PORT is defined the
      slave receive function will use the CS input for
      handshaking between each byte.
		SPI_MASTER_CS_PORT	define CS port from master to Slave
		SPI_MASTER_CS_SHADOW	define shadow register for CS
		SPI_MASTER_CS_BIT		define CS bit number

   The following definitions are required if you are running at a "slow" bit
   rate OR if using a Rabbit 6000.
   CLOCK_PORT	the parallel port letter for the clock
	CLOCK_BIT	the bit number of the clock

(2) SPI Clock Divisor (default is 5)
	SPI_CLK_DIVISOR	This is the VALUE for the baud rate divisor registers.
	Or, you may specify the divisor value via the integer variable SPIdivisor.

(3) Other macros
	SPI_DEBUG	define to enable debugging of the library.

NOTES:
(1) sets SPIxor 0 (see SPIRead) and SPITXxor (see SPIWrite) to 0.
(2) It is the responsibility of the user to develop whatever Chip Select signal
		which may be required.
(3) This library is NOT interrupt driven.  It is strictly a polled operation.

	See also: SPIWrite, SPIRead, SPIWrRd

END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
SPIWrite                  <SPI.LIB>

SYNTAX:	      int SPIWrite ( void *SrcAddr, int ByteCount );

DESCRIPTION:   Write a block of bytes to the SPI port

PARAMETER1:   	address of data to write
PARAMETER2:		number of bytes to write

RETURN VALUE:	Master: none,
					Slave: 0 = no CS signal, no transmitted bytes
							 1 = CS, bytes transmitted

The Transmit and Receive functions automatically use MSBit first.

If SPI_SLAVE_RDY_PORT is defined for a SLAVE device the driver will turn on the
bit immediately after loading the transmit register.  It will then wait for the
buffer to become available then turn off the bit.  The buffer will not become
available until the master supplies the first clock.

If SPI_SLAVE_RDY_PORT is defined for a MASTER device the driver will wait for
the bit to become true before transmitting the byte and then wait for it to
become false after transmitting the byte.

	Note for Master: the receiving device Chip Select must already be active

The variable SPITXxor may be set to 0xFF to invert the data bits in order
account for an invertor on the selected output.

	See also: SPIinit, SPIRead, SPIWrRd
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
SPIRead                  <SPI.LIB>

SYNTAX:	      int SPIRead ( void *DestAddr, int ByteCount );

DESCRIPTION:   Read a block of bytes from the SPI port

PARAMETER1:    address to store the data
PARAMETER2:		number of bytes to read

RETURN VALUE:	Master: none,
					Slave: 0 = no CS signal, no received bytes
							 1 = CS, bytes received

The Transmit and Receive functions automatically use MSBit first.

If SPI_SLAVE_RDY_PORT is defined for a SLAVE device the driver will turn on the
bit immediately upon activating the receiver.  It will then wait for a byte to
become available then turn off the bit.  The byte will not be available until
the master supplies the 8 clock pulses.

If SPI_SLAVE_RDY_PORT is defined for a MASTER device the driver will wait for
the bit to become true before activating the receiver and then wait for it to
become false after receiving the byte.

	Note for Master: the receiving device Chip Select must already be active

	The variable SPIxor needs to be set to either 0x00 or 0xFF depending
	on whether or not the received signal needs to be inverted.  Most
	applications will not need inversion.  SPIinit sets the value to 0.

The variable SPIxor may be set to 0xFF to invert the received data in order
account for an invertor in the data from the "other" device.

	See also: SPIinit, SPIWrite, SPIWrRd
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
SPImode                  <SPI.LIB>

SYNTAX:			void SPImode ( int mode );

DESCRIPTION:	set the SPI mode for the serial port
						This should be executed after SPIinit and can be executed
                  whenever the mode needs to change when multiple SPI devices
                  are being used that have different modes.  This should be
                  executed BEFORE the device Chip Select is activated.

PARAMETER1:		mode value: 0 <= mode <= 3
						There is no error checking.  The value will
                  be truncated to use only bits 0 and 1 of mode.

RETURN VALUE:	none

END DESCRIPTION **********************************************************/


SPI_DEBUG void	SPImode ( int mode )
{

#if (_CPU_ID_ == R6000)
	if ( mode==0  ||  mode==3 ) SPI_ClockLast = 1<<CLOCK_BIT;
   else SPI_ClockLast = 0;
#endif

   mode <<= 4;									// move to bits 4 & 5
	mode &= 0x30;								// keep only the two mode bits
	SPI_ShER &= ~0x30;						// clear mode bits in shadow register
	WrPortI ( SPI_ER, &SPI_ShER, SPI_ShER | mode );
} // SPImode



SPI_DEBUG void SPIinit ( void )
{	auto int i;

#GLOBAL_INIT {
	SPIxor = 0;									// assume no Rx invert
	SPITXxor = 0;								// assume no Tx invert
}

#ifndef SBC_SPI_DIVISOR
	SPIdivisor = SPI_CLK_DIVISOR;			// init divisor value
#else
	SPIdivisor = SBC_SPI_DIVISOR;			// init divisor value
#endif

#ifdef SPI_SER_A
	WrPortI ( SADHR, NULL, (SPIdivisor>>8) | 0x80 );
	WrPortI ( SADLR, NULL,  SPIdivisor & 0xFF );
#endif

#ifdef SPI_SER_B
	WrPortI ( SBDHR, NULL, (SPIdivisor>>8) | 0x80 );
	WrPortI ( SBDLR, NULL,  SPIdivisor & 0xFF );
#endif	// SPI_SER_B

#ifdef SPI_SER_C
	WrPortI ( SCDHR, NULL, (SPIdivisor>>8) | 0x80 );
	WrPortI ( SCDLR, NULL,  SPIdivisor & 0xFF );
#endif	// SPI_SER_C

#ifdef SPI_SER_D
	WrPortI ( SDDHR, NULL, (SPIdivisor>>8) | 0x80 );
	WrPortI ( SDDLR, NULL,  SPIdivisor & 0xFF );
#endif	// SPI_SER_D

#ifndef SPI_SLAVE
	RdPortI ( SPI_DR );						// dummy read to empty the buffer
#endif

   i = SPI_ShCR;								// get shadow contents - should have bits
	   											//		for selected Rx port
	i = ( i &~0x0C ) | SPI_MS;				// set Master vs Slave
	WrPortI ( SPI_CR, &SPI_ShCR, i | SPI_RX_PORT );
	WrPortI ( SPI_ER, &SPI_ShER, (SPI_CLOCK_MODE & 0x03)<<4 ); // set SPI clock mode
	WrPortI ( SPI_ER, &SPI_ShER, SPI_ShER | 0x08 ); // set MSBit first

#if (_CPU_ID_ == R6000)
	if ( SPI_CLOCK_MODE==0  ||  SPI_CLOCK_MODE==3 ) SPI_ClockLast = 1<<CLOCK_BIT;
   else SPI_ClockLast = 0;
#endif
}

#asm SPI_DEBUG __root

;Write multiple bytes to the SPI device
;Input Parameter 1: (int) source address in hl ( also 2(sp) )
;Input Parameter 2: (int) number of bytes to send ( 4(sp) )
;Enter with the SPI device ready to receive the data bytes
;
SPIWrite::
#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_CS_REG
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
		#ifdef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIWrite_cont		; jump if yes - high true
		#else
			jr		z, SPIWrite_cont		; jump if yes - low true
		#endif
			xor	a							; a = 0 = show no CS
			ld		l, a						; set
			ld		h, a						;   return value
			ret
SPIWrite_cont:
	#endif ; SPI_SLAVE_CS_REG
#endif ; SPI_SLAVE

; set up the registers
		push	ix						; preserve (for costates)
      ld		a, 0xFF				; set up for testing end of loop
		ld		d, a
		ld		e, a					; de = 0xFFFF
		ld		ix, hl				; get the source address
		ld		iy, (sp+6)			; get the number of bytes
; send the data bytes
;	de = byte count mask
;	ix = source address
;	iy = byte count
SPIWriteA:
		ld		a, (SPITXxor)		; get bit inversion value
		ld		L, (ix)				; get a byte
		xor	L						; invert if necessary
		ld		L, a					; store for SPITx
		call	SPITx					; send it
		inc	ix						; point to next byte
		dec	iy						; update bytes remaining
		and	iy, de				; check if done (iy = 0): z=1 if done
		jr		nz, SPIWriteA		; jump if not done

		call	SPIWait4Last		; wait for last byte to complete

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_CS_REG
		ld		l, 1					; set
		ld		h, 0					;   return value
	#endif
#endif

		pop	ix
		ret	;SPIWrite


;Read multiple bytes from the SPI device
;Input Parameter 1: (int) destination address in hl ( also 2(sp) )
;Input Parameter 2: (int) number of bytes to read ( 4(sp) )
;Enter with the SPI device ready to transmit the data bytes
;
SPIRead::

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_CS_REG
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
		#ifdef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIRead_cont		; jump if yes - high true
		#else
			jr		z, SPIRead_cont		; jump if yes - low true
		#endif
			xor	a							; a = 0 = show no CS
			ld		l, a						; set
			ld		h, a						;   return value
			ret
SPIRead_cont:
	#endif ; SPI_SLAVE_CS_REG
#endif ; SPI_SLAVE

; set up the registers
		push	ix						; preserve
		ld		a, 0xFF				; set up for testing end of loop
		ld		d, a
		ld		e, a
		ld		ix, hl				; get the destination address
		ld		iy, (sp+6)			; get the number of bytes

; receive the data bytes
;	de = byte count mask
;	ix = destination address
;	iy = byte count
	ioi	ld		a, (SPI_DR)		; dummy read to empty any "junk"					13-Sep-2001
SPIReadA:
		call	SPIRx					; send request
		ld		(ix), l				; store the byte
		inc	ix						; point to next byte
		dec	iy						; calculate bytes remaining
		and	iy, de				; check if done: z=1 if done
		jr		nz, SPIReadA		; jump if not done

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_CS_REG
		ld		l, 1					; set
		ld		h, 0					;   return value
	#endif
#endif ; SPI_SLAVE

		pop	ix
		ret	;SPIRead


SPITx::
; This function will transmit a byte via a serial port
;	set up in its synchronous mode.
; Input parameter: the byte value to transmit - in L
; Return value: none
; Uses: a, hl, (bc)
;
#ifdef SPI_MASTER
	#ifdef SPI_MASTER_CS_PORT
			ld		a, (SPI_MASTER_CS_SHADOW) ; get the shadow register contents
		#ifndef SPI_SLAVE_HIGH_TRUE
			set	SPI_MASTER_CS_BIT, a		; disable the CS bit = 1
		#else
			res	SPI_MASTER_CS_BIT, a		; disable the CS bit = 0
		#endif
			ld		(SPI_MASTER_CS_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_MASTER_CS_PORT), a ; send to I/O port
	#endif ; SPI_MASTER_CS_PORT

	#ifdef SPI_SLAVE_RDY_PORT
SPITx1:
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; is slave ready?
			jr		z, SPITx1		; jump if no
	#endif
#endif ; SPI_MASTER

			ld		a, L				; get the data value
	ioi	ld		(SPI_DR), a		;		load it
   		ld		a, (SPI_ShCR)	; get the current control register value
			ld		L, SPI_TX|SPI_RX ; get TX control value
         							; need to do a dummy read due to bug in 6000
         or		L
	ioi	ld		(SPI_CR), a		; load TX control value - send the byte

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			set	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
	#endif
#endif

; wait for the buffer to be available
Tx1:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x80				; byte rcvd yet?
         jr		z, Tx1			; jump if no
	ioi	ld		a, (SPI_DR)		; read the dummy byte
Tx0:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x0C				; test Tx buffer busy bit & Tx idle
			jr		nz, Tx0			; jump if not done
#ifdef CLOCK_PORT
         call	SPIWait4Last_0
#endif

#ifdef SPI_SLAVE_RDY_PORT
	#ifdef SPI_SLAVE
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			res	SPI_SLAVE_RDY_BIT, a ; clear the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
	#else

		#ifdef SPI_MASTER_CS_PORT
			ld		a, (SPI_MASTER_CS_SHADOW) ; get the shadow register contents
			#ifndef SPI_SLAVE_HIGH_TRUE
			res	SPI_MASTER_CS_BIT, a		; enable the CS bit = 0
			#else
			set	SPI_MASTER_CS_BIT, a		; enable the CS bit = 1
			#endif
			ld		(SPI_MASTER_CS_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_MASTER_CS_PORT), a ; send to I/O port
		#endif ; SPI_MASTER_CS_PORT

SPITx2:
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; has slave released ready bit?
			jr		nz, SPITx2		; jump if no
	#endif ; SPI_SLAVE
#endif ; SPI_SLAVE_RDY_PORT
			ret	;SPITx
;This function waits for a byte to complete

SPIWait4Last::
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x04				; test transmitter busy bit
			jr		nz, SPIWait4Last	; jump if not done

#ifdef CLOCK_PORT
SPIWait4Last_0::
			ld		a, (SPI_ClockLast) ; get desired idle state of clock
         ld		b, a					; save it
	ioi	ld		a, (_CLOCK_PORT)	; get state of clock
			xor	b
			ld		b, 1<<CLOCK_BIT	; mask for clock bit
         and	b						; keep only clock bit
			jr		nz, SPIWait4Last_0 ; jump if not desired state
#endif
			ret

;Receive a byte via a serial port set up in its synchronous mode.
; Return value: the received byte as an integer - in hl
; Uses: a, hl, (bc)
;
SPIRx::
#ifdef SPI_MASTER
	#ifdef SPI_SLAVE_RDY_PORT
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; is slave ready?
			jr		z, SPIRx			; jump if no
	#endif
#endif ; SPI_MASTER

   		ld		a, (SPI_ShCR)	; get the current control register value
			ld		L, SPI_RX		; get RX control value
         or		L					; combine
	ioi	ld		(SPI_CR), a		; load RX control value - receive the byte

#ifdef SPI_SLAVE

	#ifdef SPI_MASTER_CS_PORT
SPIRx1:	; wait for CS false
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
		#ifndef SPI_SLAVE_HIGH_TRUE
			jr		z, SPIRx1		; jump if yes - low true
		#else
			jr		nz, SPIRx1		; jump if yes - high true
		#endif
	#endif ; SPI_MASTER_CS_PORT

	#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			set	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
	#endif
#endif ; SPI_SLAVE

; wait for the receiver to complete
Rx0:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x80				; test receiver bit
			jr		z, Rx0			; jump if not done yet

; get the byte
			ld		a, (SPIxor)		; get the byte invert value
			ld		L, a				; save for later
	ioi	ld		a, (SPI_DR)		; get the byte
			xor	L					; invert the bits - maybe
			ld		L, a				; store for caller
			ld		h, 0				; high byte of integer

#ifdef SPI_SLAVE_RDY_PORT
	#ifdef SPI_SLAVE

		#ifdef SPI_MASTER_CS_PORT
SPIRx2:	; wait for CS true
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
			#ifndef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIRx2		; jump if no - low true
			#else
			jr		z, SPIRx2		; jump if no - high true
			#endif
		#endif ; SPI_MASTER_CS_PORT

			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			res	SPI_SLAVE_RDY_BIT, a ; clear the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
	#else
SPIRx2:
	ioi	ld		a, (SPI_SLAVE_RDY_PORT)
			bit	SPI_SLAVE_RDY_BIT, a ; has slave released ready bit?
			jr		nz, SPIRx2		; jump if no
	#endif ; SPI_SLAVE
#endif ; SPI_SLAVE_RDY_PORT

	ret	;spi_swap

#endasm


/* START FUNCTION DESCRIPTION ********************************************
SPIWrRd                  <SPI.LIB>

SYNTAX:	      int SPIWrRd ( void *SrcAddr, void *DstAddr, int ByteCount );

DESCRIPTION:   Read and Write a block of bytes from/to the SPI port

PARAMETER1:   	address of data to write
PARAMETER2:   	address to put received data
PARAMETER3:		number of bytes to read/write -
						max of 255 bytes - not checked!

The receive buffer MUST be at least as large as the number of bytes!

RETURN VALUE:	Master: none,
					Slave: 0 = no CS signal, no received/transmitted bytes
							 1 = CS, bytes received/transmitted

	Note for Master: the receiving device Chip Select must already be active

See also: SPIinit, SPIRead, SPIWrite
END DESCRIPTION **********************************************************/

/*** Beginheader SPIWrRd */
int SPIWrRd	( void *SrcAddr, void *DstAddr, int ByteCount );
/*** Endheader */

#asm SPI_DEBUG __root

;Write and read multiple bytes to/from the SPI device
;Input Parameter 1: (int) source address in HL ( also 2(sp) )
;Input Parameter 2: (int) dest address ( also 4(sp) )
;Input Parameter 3: (int) number of bytes to send ( 6(sp) )
;Enter with the SPI device ready to receive the data bytes
;
SPIWrRd::

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_CS_REG
	ioi	ld		a, (SPI_SLAVE_CS_REG) ; read the CS register
			bit	SPI_SLAVE_CS_BIT, a	; is CS true?
		#ifdef SPI_SLAVE_HIGH_TRUE
			jr		nz, SPIWrRd_cont		; jump if yes - high true
		#else
			jr		z, SPIWrRd_cont		; jump if yes - low true
		#endif
			xor	a							; a = 0 = show no CS
			ld		l, a						; set
			ld		h, a						;   return value
			ret
SPIWrRd_cont:
	#endif
#endif

; set up the registers
		push	ix
		ld		ix, HL				; get the source address
		ld		iy, (sp+6)			; get the destination address
		ld		hl, (sp+8)			; and byte count
		ld		e, L					; save byte count for processing
; send and receive the data bytes
SPIWrRdA:
		ld		L, (ix)				; get a byte to transmit
		call	SPITxRx				; send and receive a byte
		ld		(iy), L				; save received byte
		inc	ix						; point to next transmit byte
		inc	iy						; point to next receive byte
		dec	e						; update bytes remaining
		jr		nz, SPIWrRdA		; jump if not done
#ifdef CLOCK_PORT
      call	SPIWait4Last_0
#endif

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_CS_REG
		ld		l, 1					; set
		ld		h, 0					;   return value
	#endif
#endif

		pop	ix
		ret	;SPIWrRd

SPITxRx::
; This function will transmit and receive a byte via a serial port
;	set up in its synchronous mode.
; Input parameter: the byte value to transmit - in L
; Return value: the received byte in L
; Uses: a, HL, (bc)
;
			ld		a, L				; get the data value
	ioi	ld		(SPI_DR), a		;		load it

   		ld		a, (SPI_ShCR)	; get the current control register value
			ld		L, SPI_RX|SPI_TX ; get transceive value
         or		L					; create new CR value
	ioi	ld		(SPI_CR), a		; initiate transceive operation

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			set	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
	#endif
#endif

; wait for the receiver to complete - the receiver will complete AFTER the transmitter
SPITxRx0:
	ioi	ld		a, (SPI_SR)		; read the status register
			and	0x80				; test receiver done bit
			jr		z, SPITxRx0			; jump if not done

#ifdef SPI_SLAVE
	#ifdef SPI_SLAVE_RDY_PORT
			ld		a, (SPI_SLAVE_RDY_SHADOW) ; get the shadow register contents
			res	SPI_SLAVE_RDY_BIT, a ; set the ready bit
			ld		(SPI_SLAVE_RDY_SHADOW), a ; save shadow register contents
	ioi	ld		(SPI_SLAVE_RDY_PORT), a ; send to I/O port
	#endif
#endif

	ioi	ld		a, (SPI_DR)		; get the received byte
			ld		L, a				; save for return
			ret	;SPITxRx

#endasm


/*** BeginHeader */
#endif	// __SPILIB
/*** EndHeader */

