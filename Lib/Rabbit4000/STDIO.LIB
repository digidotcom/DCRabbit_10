/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader  ********************************************/
#ifndef __STDIO_LIB
#define __STDIO_LIB

#include <stdio.h>

#define __STDIO_LIB_VERSION	2

/*** EndHeader ***********************************************/

/* START LIBRARY DESCRIPTION *********************************************
STDIO.LIB

DESCRIPTION:
	Standard I/O (with Dynamic C terminal window) functions

SUPPORT LIB'S:
END DESCRIPTION **********************************************************/

/*** Beginheader  */
#define DEFDECDIGITS 6

// Template for calling "putc" function pointer.
// Maintainer note: assembler functions outchrs and outstr call this via assembler,
// so be careful if changing the prototype of the putc functions.
// WARNING: All putc functions passed to doprnt must preserve IX!  The plhex,
// plint, phex, pint, pfloat functions are all written as "useix".
#define _CALL_PUTC_FUNC(f, a, b, c, d) f((int)(a), (char __far *)(b), (int *)(c), (void *)(d))

// Function pointer prototype for putc functions, with parameters
typedef void (*putc_func_t)(int, char __far *, int *, void *);
/*** endheader */

/*** Beginheader getsn */

char *getsn( char *input, int length);

/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
getsn                                                          <STDIO.LIB>

SYNTAX: char *getsn( char *input, int length);

KEYWORDS: keyboard, input, stdio window

DESCRIPTION:	This function communicates through the stdio window to wait for
					a string terminated by a return.  It does not return until a
					return is typed in the stdio window.

					The string returned is null-terminated without the return.

					This function requires Dynamic C's stdio window to be open, and
					the stdio window must have the focus for keybaord hits on the PC
					to be detected. Any call to printf in debug mode opens the stdio
					window.

PARAMETER 1:	Buffer to store the user-entered string.

PARAMETER 2:	Size of buffer to recieve the string.

RETURN VALUE:	NULL if length is less than 1, otherwise returns parameter 1,
					the pointer to the user-entered string.

SEE ALSO:	gets, getswf

END DESCRIPTION **********************************************************/
__nodebug
char *getsn( char *input, int length)
{
	auto int c;
	auto int curpos;

	if (length < 1)
	{
		return NULL;
	}

	curpos = 0;
	for (;;)
	{
		if (kbhit())
		{
			c = getchar();
			switch (c)
			{
				case '\b':		// backspace
					if (curpos)
					{
						// if input not empty, delete last char and erase from screen
						--curpos;
						fputs( "\b \b", stdout);
					}
               else
               {
                  putchar( '\x07');     // error beep -- nothing to delete
               }
					break;

				case '\r':		// return/enter
					putchar( '\n');			// go to a new line on screen
               input[curpos] = '\0';	// add null-terminator to input
               fflush( stdout);
					return input;

				default:
					if (isprint( c) && curpos < (length - 1))
               {
                  input[curpos++] = c;
                  putchar( c);
               }
               else
               {
                  putchar( '\x07');     // error beep -- bad char or line full
               }
			}
			fflush( stdout);
		}
	}
}

/*** Beginheader getswf */

int getswf(char *);

/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
getswf                         <STDIO.LIB>

SYNTAX: int getswf(char *s);

KEYWORDS: keyboard, input, stdio window

DESCRIPTION: This function is a non-blocking version of gets().

It communicates through the stdio window to wait for a string terminated by
a return.  It should be called repeatedly, until it returns 1.  The input
string, stored at <s> is null-terminated without the return.

The caller is responsible to make sure the location pointed to by <s> is big
enough for the string.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

The user should make sure only one process calls this function at a time.

PARAMETER1: Buffer to store string from user.

RETURN VALUE:	Returns 1 when the user ends the input with a linefeed,
otherwise returns 0, indicating the user is not done yet.

SEE ALSO: gets, getsn

END DESCRIPTION **********************************************************/
__nodebug __useix
int getswf(char *s)
{
	auto res;
	static char *p, c;

	res = 0;
	__costate
	{
		p = s;
		*s = '\0';	// reset string
		do {
			__waitfor(kbhit());
			c = getchar();
			switch (c)
			{
				case '\b':
					if (s != p)
					{
						fputs("\b \b", stdout);		// back up, erase last character
						p--;
					}
					break;
				case '\r':
					putchar('\n');
					c = 0;
					break;
				default:
					if (isprint( c))
					{
						*p++= c;
						putchar(c);
					}
               else
               {
                  putchar( '\x07');     // error beep -- bad char
               }
					break;
			}
			fflush( stdout);
			*p = 0;		// keep string null-terminated
		} while (c);
		res = 1;
	}
	return res;
}


/*** BeginHeader getsn_tick */
int getsn_tick( char *buffer, int length);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
getsn_tick                         <STDIO.LIB>

SYNTAX: int getsn_tick( char *buffer, int length);

KEYWORDS: keyboard, input, stdio window

DESCRIPTION: This function is a non-blocking version of getsn().

It communicates through the stdio window to wait for a string terminated by
a return.  It should be called repeatedly, until it returns 1.  The input
string, stored at <buffer> is null-terminated without the return.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

The user should make sure only one process calls this function at a time.

PARAMETER1: Buffer to store string from user.
PARAMETER1: Length of buffer.

RETURN VALUE:	-EINVAL: bad parameters
					-EAGAIN: string not yet complete
               0 or positive: string completed with this length

SEE ALSO: gets, getsn

END DESCRIPTION **********************************************************/
__nodebug __useix
int getsn_tick( char *buffer, int length)
{
	auto res;
	static char *cursor, c;

	if (buffer == NULL || length < 1)
	{
		return -EINVAL;
	}

	res = -EAGAIN;
	__costate
	{
		cursor = buffer;
		*buffer = '\0';   // reset string
		do {
			__waitfor(kbhit());
			c = getchar();
			switch (c)
			{
				case '\b':
					if (buffer != cursor)
					{
						fputs( "\b \b", stdout);		// back up, erase last character
						cursor--;
					}
					break;

				case '\r':
					putchar( '\n');
					c = 0;
					res = cursor - buffer;
					break;

				default:
					if (isprint( c) && (cursor - buffer < length - 1))
					{
						*cursor++= c;
						putchar( c);
					}
               else
               {
                  putchar( '\x07');     // error beep -- bad char
               }
					break;
			}
			fflush( stdout);
			*cursor = 0;		// keep string null-terminated
		} while (c);
	}

	return res;
}


/*=========================================================================*\
	Wait for Keyboard Input
\*=========================================================================*/

/*** BeginHeader selectkey */

int selectkey(const char *selection);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
selectkey                         <STDIO.LIB>

SYNTAX: int selectkey(const char *selection);

KEYWORDS: string, output, display, stdio window

DESCRIPTION: This function waits for the user to enter a key (character),
then match the character to a given selection.  This function is not
task reentrant.

This function requires Dynamic C's stdio window to be open, and the
stdio window must have the focus for keybaord hits on the PC to be
detected. Any call to printf in debug mode opens the stdio window.

PARAMETER1:	This string lists all the valid choices the user can make.

RETURN VALUE: If the operator enters a valid choice, the index to the
character in the "selection" argument + 1 is returned. Otherwise, 0 is
returned to indicate no valid choices has been made.

END DESCRIPTION **********************************************************/

__nodebug
int selectkey(const char *selection) {
	auto int retval;
	auto const char *p;

	retval = 0;
	if (kbhit()) {
		p = _n_strchr(selection,getchar());
		if (p) { putchar(*p); putchar('\n'); }
		return p ? p-selection+1 : 0;
	} else {
		return 0;
	}
}


/*** BeginHeader _doprnt_atoi */
int _doprnt_atoi( const char __far *start, const char __far * __far *end);
/*** EndHeader */
// Dedicated atoi for use by doprnt(), doesn't check for overflow, negative
// values, or NULL <end> parameter; always does base 10.
// Takes 5% as long as calling _f_strtol.
__nodebug
int _doprnt_atoi( const char __far *start, const char __far * __far *end)
{
	#asm
		clr	hl
		ld		b, 0

.again:
		ld		a, (px)
		sub	a, '0'
		jr		c, .done
		cp		10
		jr		nc, .done

		; HL *= 10 (10 clocks)
		add	hl, hl		; HL = retval * 2
		ld		de, hl		; DE = retval * 2
		add	hl, hl		; HL = retval * 4
		add	hl, hl		; HL = retval * 8
		add	hl, de		; HL = retval * 10

		; add A to HL via BC (4 clocks)
		ld		c, a
		add	hl, bc

		ld		px, px + 1
		jr		.again

.done:
		; copy end
		ld		py, (sp+@SP+end)
		ld		(py), px
		; result is in hl
	#endasm
}

/*** BeginHeader doprnt */
__xmem
void doprnt(putc_func_t putc, const char __far *fmt, va_list arg1,
						void *instanceParam, char __far *buf, int *cnt);

// Flag values from parsed format specifier, passed to sub functions.
#define _DOPRNT_FLAG_LEFT_JUSTIFY	0x0001		// '-'
#define _DOPRNT_FLAG_SIGN_ALWAYS		0x0002		// '+'
#define _DOPRNT_FLAG_SIGN_SPACE		0x0004		// ' '
#define _DOPRNT_FLAG_ALTERNATE		0x0008		// '#'
#define _DOPRNT_FLAG_LEADING_ZEROS	0x0010		// '0'

#define _DOPRNT_FLAG_INT				0x0000		// default
#define _DOPRNT_FLAG_CHAR				0x0100		// hh			8-bit
#define _DOPRNT_FLAG_SHORT				0x0200		// h			16-bit
#define _DOPRNT_FLAG_LONG				0x0400		// l, L		32-bit
#define _DOPRNT_FLAG_LONGLONG			0x0800		// ll			64-bit
#define _DOPRNT_FLAG_ANYLONG			(_DOPRNT_FLAG_LONG | _DOPRNT_FLAG_LONGLONG)
#define _DOPRNT_FLAG_FAR				0x4000		// F			far pointer

#define _DOPRNT_FLAG_PARSED			0x8000		// done parsing flags
/*** EndHeader  */

/***************************************************************************\
   DOPRNT - Formatted Output Routine
\***************************************************************************/

/* START FUNCTION DESCRIPTION *********************************************
doprnt                       <STDIO.LIB>

SYNTAX:
   void doprnt(putc_func_t putc, const char far *fmt, va_list arg1,
               void *instanceParam, char far *buf, int *count);

KEYWORDS:

DESCRIPTION:	Formatted output routine.  This is the support routine behind
					all ...printf routines.

PARAMETER 1:	A function that outputs one byte, it is called by doprnt
					to output a character.

			void (*putc_func_t)(int c, char far *buf, int *count, void *instance)

					 c - Character to print.
				  buf - Buffer passed to doprnt.
				count - Address of variable with current count of characters
							written. Your putc function should increment this count
							if the character is written.
			instance - The instanceParam passed to doprnt.

		IMPORTANT: Your putc function must not modify register IX.  If it needs
						to use IX, or a subfunction might modify IX, then you must
						preserve and restore it.  The easiest way is as follows:

			root nodebug nouseix
			void my_putc( int c, char far *buf, int *count, void *instance)
			{
				int saveix;

				asm ld (sp+@SP+saveix), ix

				// do whatever it takes to put the character here

				asm ld ix, (sp+@SP+saveix)
			}

PARAMETER 2:	The format string that specifies the output.

PARAMETER 3:	The address of the first parameter to be used by the formatted
					string.  The interpretation of the parameters depends on the
					format fields in the format string.

PARAMETER 4:	A parameter that will be passed on to the putc function.

PARAMETER 5:	A buffer that will be passed on to the putc function.

PARAMETER 6:	Address of a counter that will be passed on to the putc function.

This routine brings in many math functions.

This routine can be called from processes of different priorities.

The macro STDIO_DISABLE_FLOATS can be defined if it is not necessary to format
floating point numbers.  If this macro is defined, %e, %f and %g will not
be recognized. This can save thousands of bytes of code space.

RETURN VALUE: none.
END DESCRIPTION **********************************************************/

// Define STDIO_DISABLE_FLOATS to remove floating-point conversion from
// printf.  This macro can be defined locally within a user program, or globally
// here.

//#define STDIO_DISABLE_FLOATS

#include <stdarg.h>

__nouseix __nodebug __xmem
void doprnt(putc_func_t putc, const char __far *fptr, va_list ap,
						void *instanceParam, char __far *buf, int *cnt)
{
	long longarg;
	unsigned long ulongarg;

	int width, prec, temp, j, length, code;
	word flags;			// see _DOPRNT_FLAG_* defined in BeginHeader/EndHeader
   char __far *farstrptr;
   void __far *dest;

__DC_loop:
	while((temp = *fptr++) != '%' && temp != 0)
	{
		_CALL_PUTC_FUNC(putc, temp, buf, cnt, instanceParam);
	}

	if (! temp)
	{
		return;
	}

	if (*fptr == '%')
	{
		// '%' is only valid immediately after '%' -- no flags before
		_CALL_PUTC_FUNC(putc, '%', buf, cnt, instanceParam);
		++fptr;
		goto __DC_loop;
	}

	// process flags
	flags = 0;
	for (;;)
	{
		switch (*fptr)
		{
			case '-':	flags |= _DOPRNT_FLAG_LEFT_JUSTIFY;		break;
			case '+':	flags |= _DOPRNT_FLAG_SIGN_ALWAYS;		break;
			case ' ':	flags |= _DOPRNT_FLAG_SIGN_SPACE;		break;
			case '#':	flags |= _DOPRNT_FLAG_ALTERNATE;			break;
			case '0':	flags |= _DOPRNT_FLAG_LEADING_ZEROS;	break;

			default:
				flags |= _DOPRNT_FLAG_PARSED;
		}
		if (flags & _DOPRNT_FLAG_PARSED)
		{
			break;
		}
		++fptr;
	}

	// convert width
	if (*fptr == '*')
	{
		++fptr;
		width = va_arg( ap, int);
		if (width < 0)
		{
			// "A negative field width argument is taken as a - flag followed by
			// a positive field width."
			width = abs( width);
			flags |= _DOPRNT_FLAG_LEFT_JUSTIFY;
		}
	}
	else
	{
		width = _doprnt_atoi( fptr, &fptr);		//	total length
	}

	// convert precision
	// "A negative precision argument is taken as if the precision were omitted."
	prec = -1;
	if (*fptr == '.')
	{
		++fptr;
		if (*fptr == '*')
		{
			++fptr;
			prec = va_arg( ap, int);
		}
		else
		{
			if (*fptr == '-')
			{
				// ignore negative precision
				_doprnt_atoi( fptr + 1, &fptr);
			}
			else
			{
				// "if only the period is specified, the precision is taken as zero"
				prec = _doprnt_atoi( fptr, &fptr);
			}
		}
	}

	// "If the 0 and - flags both appear, the 0 flag will be ignored."
	if (flags & _DOPRNT_FLAG_LEFT_JUSTIFY)
	{
		flags &= ~_DOPRNT_FLAG_LEADING_ZEROS;
	}

	// "If the space and + flags both appear, the space flag will be ignored."
	if (flags & _DOPRNT_FLAG_SIGN_ALWAYS)
	{
		flags &= ~_DOPRNT_FLAG_SIGN_SPACE;
	}

	code = *fptr++;

	// optional 'F' after width/precision and before variable size for "far *"
	if (code == 'F')		// far pointer (used for s, p and n)
	{
		code = *fptr++;
		flags |= _DOPRNT_FLAG_FAR;
	}

	// convert variable size (8/16/32 bit)
	switch (code)
	{
		case 'l':
			code = *fptr++;
			if (code == 'l')
			{
				code = *fptr++;
				flags |= _DOPRNT_FLAG_LONGLONG;
			}
			else
			{
				flags |= _DOPRNT_FLAG_LONG;
			}
			break;

		case 'L':			// long double; should only apply to e, E, f, g or G
		case 'q':			// long double (extension, not ANSI)
			code = *fptr++;
			flags |= _DOPRNT_FLAG_LONGLONG;
			break;

		case 'h':
			code = *fptr++;
			if (code == 'h')
			{
				code = *fptr++;
				flags |= _DOPRNT_FLAG_CHAR;
			}
			else
			{
				flags |= _DOPRNT_FLAG_SHORT;
			}
			break;

		case 'j':		// intmax_t or uintmax_t
		case 't':		// ptrdiff_t
			code = *fptr++;
			flags |= _DOPRNT_FLAG_LONG;
			break;

		case 'z':		// size_t (same as default size, int)
			code = *fptr++;
			break;
	}

	// process actual conversion specifier
	switch (code)
	{
		case 'n':
			dest = (flags & _DOPRNT_FLAG_FAR)
				? va_arg( ap, void __far *) : va_arg( ap, void *);
			if (flags & _DOPRNT_FLAG_ANYLONG)
			{
				*(long __far *)dest = *cnt;
			}
			else if (flags & _DOPRNT_FLAG_CHAR)
			{
				*(signed char __far *)dest = (signed char) *cnt;
			}
			else
			{
				*(int __far *)dest = *cnt;
			}
			break;

		case 's':
         farstrptr = flags & (_DOPRNT_FLAG_ANYLONG | _DOPRNT_FLAG_FAR)
         	? va_arg( ap, char __far *) : va_arg( ap, char *);
         if (!farstrptr)
         {
         	farstrptr = "(null)";		// match gcc behavior
         }
			length = strlen( farstrptr );

			if ((prec>=0) && (length > prec))
				 length = prec;
			if (width > length)
				 temp = width - length;
			else
				temp = 0;
			if (! (flags & _DOPRNT_FLAG_LEFT_JUSTIFY) && temp > 0)
				outchrs(' ', temp, putc, instanceParam, buf, cnt);

         for (j = length; j; --j)
         {
            _CALL_PUTC_FUNC(putc, *farstrptr++, buf, cnt, instanceParam);
         }

			if (flags & _DOPRNT_FLAG_LEFT_JUSTIFY && temp > 0)
				outchrs(' ', temp, putc, instanceParam, buf, cnt);
			goto __DC_loop;

#ifndef STDIO_DISABLE_FLOATS
		case 'F':
		case 'f':
		case 'G':
		case 'g':
		case 'E':
		case 'e':
			// Better to round in function after ftoa conversion (i.e. round the
			//  long) because floating point operations lose precision.
			pflt( flags, code, width, prec, putc, va_arg( ap, double),
			     instanceParam, buf, cnt);
			goto __DC_loop;
#endif

		case 'd':
		case 'i':
			if (flags & _DOPRNT_FLAG_ANYLONG)
			{
				longarg = va_arg( ap, long);
			}
			else if (flags & _DOPRNT_FLAG_CHAR)
			{
				// signed char passed as signed int, cast back to signed char
				// and then up to signed long
				longarg = (signed char) va_arg( ap, int);
			}
			else
			{
				// sign-extend 16-bit value
				longarg = va_arg( ap, int);
			}
			doprnt_integral( flags, width, prec, code, longarg,
				putc, instanceParam, buf, cnt);
			goto __DC_loop;

      case 'p': 				// %p is 16-bit pointer, %lp and %Fp are 32-bit.
      	code = 'X';			// use upper-case hex chars for address.
      	if (prec < 0)
      	{
				// set precision
				prec = (flags & (_DOPRNT_FLAG_ANYLONG | _DOPRNT_FLAG_FAR)) ? 6 : 4;
      	}
      	if (flags & _DOPRNT_FLAG_FAR)
      	{
				flags |= _DOPRNT_FLAG_LONG;
      	}
      	// fall through to hex/octal/unsigned code
		case 'X':
		case 'x':
		case 'o':
		case 'u':
			if (flags & (_DOPRNT_FLAG_LONG | _DOPRNT_FLAG_LONGLONG))
			{
				ulongarg = va_arg( ap, unsigned long);
			}
			else
			{
				ulongarg = va_arg( ap, unsigned int);
				if (flags & _DOPRNT_FLAG_CHAR)
				{
					// clear high bits -- we just want the lower byte
					ulongarg &= 0x000000FF;
				}
			}
			doprnt_integral( flags, width, prec, code, ulongarg,
				putc, instanceParam, buf, cnt);
			goto __DC_loop;

		case 'c':
			_CALL_PUTC_FUNC(putc, va_arg( ap, int), buf, cnt, instanceParam);
			goto __DC_loop;

		default:
			// invalid format specifier -- just print the specifier
			_CALL_PUTC_FUNC(putc, code, buf, cnt, instanceParam);
			goto __DC_loop;
	}
}

/*** BeginHeader _ultostr */
char *_ultostr( const char *buffer, unsigned long n);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
_ultostr                                                       <STDIO.LIB>

SYNTAX:	char *_ultostr( const char *buffer, unsigned long n)

DESCRIPTION:	Support function for formatted printing.

					Converts an unsigned long value to a series of characters,
					in reverse order and returns a pointer to the first position
					after the characters.

PARAMETER 1:	Buffer to write characters ('0' - '9') to.  Must be at least 10
					bytes long to hold maximum values.

PARAMETER 2:	Value to convert.  If value is 0, no bytes are written to the
					buffer (to support ANSI standard of, "The result of converting
					a zero value with a precision of zero is no characters."

RETURN VALUE:	Pointer to first character AFTER characters written.  Note that
					this function does NOT write a NULL terminator.

END DESCRIPTION **********************************************************/
__nodebug
char *_ultostr( const char *buffer, unsigned long n)
{
	#asm
		; hl holds address of buffer
		ld		bcde, (sp+@SP+n)
		push	ix				; preserve ix
		ld		ix, hl

		test	bcde
		jr		z, .done
	.loop:
		push	bcde			; put numerator on stack
		ld		bcde, 10		; pass denominator in bcde
		call	G_div			; returns quotient in BCDE, modulus in HL'HL
								; Note that L_div also removes numerator from stack
		ld		a, '0'
		add	a, l
		ld		(ix), a
		inc	ix
		test	bcde
		jr		nz, .loop
	.done:
		; return value in hl
		ld		hl, ix
		pop	ix
	#endasm
}


/*** BeginHeader doprnt_integral */
void doprnt_integral( word flags, int width, int precision, int code,
	unsigned long value, putc_func_t putc, void *instanceParam,
	char __far *buffer, int *count);
/*** EndHeader */
// Single function for printing unsigned int/long as octal or hex.
/* START _FUNCTION DESCRIPTION ********************************************
doprnt_integral                                                <STDIO.LIB>

SYNTAX:	void doprnt_integral( word flags, int width, int precision, int code,
						unsigned long value, putc_func_t putc, void *instanceParam,
						char far *buffer, int *count)

DESCRIPTION:	Support function for formatted printing.  Handles integral
					values (signed and unsigned, int and long).

					Should only be called by doprnt().

PARAMETER 1:	Flags as parsed by doprnt().

PARAMETER 2:	Field width.

PARAMETER 3:	Field precision.

PARAMETER 4:	Format code used.

PARAMETER 5:	Value to print.  For 'd' and 'i' specifiers, this will actually
					be a signed value cast to an unsigned long.

PARAMETER 6:	"putc" function to use for printing characters.

PARAMETER 7:	Instance/cookie to pass to putc() function.

PARAMETER 8:	Buffer to pass to putc() function.

PARAMETER 9:	Count pointer to pass to putc() function.

RETURN VALUE:	None

END DESCRIPTION **********************************************************/
__nodebug
void doprnt_integral( word flags, int width, int precision, int code,
	unsigned long value, putc_func_t putc, void *instanceParam,
	char __far *buffer, int *count)
{
	char dumpbuf[12];			// big enough for 037777777777; no null terminator
	char *p;						// position in dumpbuf[]
	const char *hexits;		// upper or lowercase hex characters
	int chars;					// number of chars copied to dumpbuf
	char sign = 0;				// if non-null, sign character to use (+, -, space)
	int prefix = 0;			// whether to prefix with 0x, 0X or a sign
	int spaces;					// padding for left or right justify

	// use default precision if not specified by user
	if (precision < 0)
	{
		precision = 1;
	}
	else
	{
		// "If the precision is specified, the 0 flag will be ignored."
		flags &= ~_DOPRNT_FLAG_LEADING_ZEROS;
	}

	#if ! (defined __ANSI_STRICT__ || defined __ANSI_PRINTF__)
		// This is necessary for legacy reasons, to prevent writing asterisks
		// when a value can't fit within the specified field width (but can
		// fit within the specified precision).
		if (width && (width < precision))
		{
			// if width was specified, it must be at least as big as the precision
			width = precision;
		}
	#endif

	// reverse-print characters into dumpbuf
	p = dumpbuf;

	// Since "The result of converting a zero value with a precision of zero is
	// no characters.", the cases below won't populate the buffer with
	// characters if value is zero (other than the "%#o" case which "increases
	// the precision to force the first digit of the result to be a zero.")
	switch (code)
	{
		case 'd':
		case 'i':
			// value is negative
			if (value & 0x80000000)
			{
				sign = '-';
				value = 0 - value;
			}
			else if (flags & _DOPRNT_FLAG_SIGN_ALWAYS)
			{
				// "If the space and + flags both appear, the space flag
				// will be ignored."
				sign = '+';
			}
			else if (flags & _DOPRNT_FLAG_SIGN_SPACE)
			{
				sign = ' ';
			}

			if (sign)
			{
				prefix = 1;
			}
			// fall through to code that converts integral value to a string
		case 'u':
			p = _ultostr( p, value);
			break;

		case 'o':
			while (value)
			{
				*p++ = '0' + ((unsigned)value & 0x07);
				value >>= 3;
			}
			if (flags & _DOPRNT_FLAG_ALTERNATE)
			{
				*p++ = '0';
			}
			break;

		case 'X':
		case 'x':
			if (value && (flags & _DOPRNT_FLAG_ALTERNATE))
			{
				prefix = 2;
			}
			hexits = (code == 'X') ? _hexits_upper : _hexits_lower;
			while (value)
			{
				*p++ = hexits[(unsigned)value & 0x0F];
				value >>= 4;
			}
			break;
	}

	precision += prefix;
	chars = (int) (p - dumpbuf) + prefix;
	if (precision < chars)
	{
		precision = chars;
	}

	// If printing leading zeros, we can force the precision to match the width
	// in order to get the correct number of zeros in front of the value.
	if (flags & _DOPRNT_FLAG_LEADING_ZEROS && width > precision)
	{
		precision = width;
	}

	// ANSI spec says width is a minimum and the field should grow as necessary
	// to display the value.  Dynamic C legacy is to replace the field with
	// asterisks (*) if it isn't large enough to display the value.

	#if ! (defined __ANSI_STRICT__ || defined __ANSI_PRINTF__)
		if (width && (precision > width))
		{
			// can't fit within specified width, dump asterisks and return
			outchrs( '*', width, putc, instanceParam, buffer, count);
			return;
		}
	#endif

	// Calculate number of spaces to add before or after the field.
	spaces = width - precision;
	if (spaces < 0)
	{
		spaces = 0;
	}

	// leading spaces for right justified
	if (spaces && ! (flags & _DOPRNT_FLAG_LEFT_JUSTIFY))
	{
		outchrs( ' ', spaces, putc, instanceParam, buffer, count);
		spaces = 0;
	}

	if (sign)
	{
		_CALL_PUTC_FUNC( putc, sign, buffer, count, instanceParam);
	}
	else if (prefix == 2)			// leading 0x or 0X
	{
		_CALL_PUTC_FUNC( putc, '0', buffer, count, instanceParam);
		_CALL_PUTC_FUNC( putc, code, buffer, count, instanceParam);
	}

	// leading zeros
	while (precision > chars)
	{
		_CALL_PUTC_FUNC( putc, '0', buffer, count, instanceParam);
		--precision;
	}

	// unwind characters stored in dumpbuf
	while (p > dumpbuf)
	{
		_CALL_PUTC_FUNC( putc, *--p, buffer, count, instanceParam);
	}

	// Add trailing spaces if left justified.  If right justified, <spaces>
	// should have been decremented to zero.
	if (spaces)
	{
		outchrs( ' ', spaces, putc, instanceParam, buffer, count);
	}

}


/*** BeginHeader _gltoa */
__xmem char *_gltoa(unsigned long int num, char *ibuf, char neg);
/*** EndHeader */

/*=========================================================================*\
 Convert (un)signed long to ascii. Pass long and pointer to 12 byte field.
 Returns count of digits generated including minus sign if any.
 For example: -500 generates "-500" and returned value of 4.
 Returned string terminated by null. Provide 12 bytes in buf
 for longest possible number.  330 bytes 1.1 millisecond 9mhz 64180.

 *** performance not checked under new version
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
_gltoa                       <STDIO.LIB>

SYNTAX: char *_gltoa(unsigned long int num, char *ibuf, char is_signed);

KEYWORDS:

DESCRIPTION: Converts (un)signed long to ascii. Passes long and pointer
to 12 byte field. "num" is the unsigned long int to be converted to a
string, "ibuf" is a pointer to the array that will hold the ASCII string
representing "num", and "is_signed" indicates whether or not "num"
is a signed long.  The user should make sure the string
pointed to by "ibuf" is large enough to hold the string.

RETURN VALUE: Pointer to string.
END DESCRIPTION **********************************************************/
__nouseix __nodebug
__xmem char *_gltoa(unsigned long int num, char *ibuf, char is_signed)
{
	char temp[10];			// room for 10 digits, no null terminator or sign
	char *rev;
	char *dest;

	if (num)
	{
		dest = ibuf;
		if (is_signed && (num & 0x80000000))
		{
			*dest++ = '-';
			rev = _ultostr( temp, labs( num));
		}
		else
		{
			rev = _ultostr( temp, num);
		}

		// unroll characters stored in temp by _ultostr
		while (rev > temp)
		{
			*dest++ = *--rev;
		}
		*dest = '\0';			// add null terminator
	}
	else
	{
		memcpy( ibuf, "0", 2);
	}

	return ibuf;
}

/*** BeginHeader _gltoan */
__xmem int _gltoan(unsigned long num, int signed_flag);
/*** EndHeader */

/* returns number of digits needed in field 1-11 for (un)signed long int */

/* START_FUNCTION DESCRIPTION *********************************************
_gltoan                       <STDIO.LIB>

SYNTAX:
   int _gltoan(unsigned long num, int signed);

KEYWORDS:

DESCRIPTION:
   This function determines how many characters (possible sign character
   plus digits) are required for decimal display of the supplied (un)signed
   long integer given the specified signed or unsigned type.

PARAMETER1:
   The possibly signed integer whose decimal display length is to be
   returned.

PARAMETER2:
   1 to specify that the supplied integer's type is signed, or 0 to specify
   unsigned type.

RETURN VALUE:
   The number of characters needed for decimal display of the supplied
   (un)signed long integer, always in the range [1,11].
END DESCRIPTION **********************************************************/

__xmem __nodebug
int _gltoan(unsigned long num, int signed_flag)
{
	auto int j, len;
	static const unsigned long __ltens[] = { 1000000000ul, 100000000ul,
	                                         10000000ul, 1000000ul, 100000ul,
	                                         10000ul, 1000ul, 100ul, 10ul, 1ul };

	// Initially ignoring the possible sign character, 32-bit (un)signed long
	//  type display may require as many as 10 or as few as 1 decimal digit
	//  characters.
	len = sizeof __ltens / sizeof __ltens[0];
	if (signed_flag && ((long) num < 0L))
	{
		num = labs(num);
		++len;	// add one for the required sign character
	}
	// The j count maximum allows for the minimum 1 digit character required for
	//  decimal display.
	for (j = 0; j < sizeof __ltens / sizeof __ltens[0] - 1; ++j)
	{
		if (__ltens[j] <= num)
		{
			break;
		}
		--len;
	}
	return len;
}

/*** BeginHeader gtoa */
char *gtoa(unsigned long num, char *ibuf);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
gtoa                         <STDIO.LIB>

SYNTAX: char *gtoa(unsigned long num, char *ibuf);

KEYWORDS:

DESCRIPTION:

RETURN VALUE:
END DESCRIPTION **********************************************************/
__nodebug char *gtoa(unsigned long num, char *ibuf)
{
	return _gltoa(num, ibuf, 0);
}

/*** BeginHeader ltoa */
char *ltoa(long num, char *ibuf);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
ltoa                         <STDIO.LIB>

SYNTAX: char *ltoa(long num, char *ibuf)

KEYWORDS:

DESCRIPTION:  This function uses _gltoa to output a signed long int "num"
to the character array pointed to by "ibuf".

RETURN VALUE: Pointer to the same array passed in to hold the result.
END DESCRIPTION **********************************************************/
__nodebug char *ltoa(long num, char *ibuf)
{
	return _gltoa((unsigned long) num, ibuf, 1);
}

/*** BeginHeader gtoan */
int gtoan(unsigned long num);
/*** EndHeader */
/* returns number of digits needed in field 1-11 for unsigned long int */

/* START _FUNCTION DESCRIPTION ********************************************
gtoan                        <STDIO.LIB>

SYNTAX: int gtoan(unsigned long num);

KEYWORDS:

DESCRIPTION:  This function uses _gltoa to output an unsigned long int
"num" to the character array pointed to by "ibuf"

RETURN VALUE: Pointer to the same array passed in to hold the result.
END DESCRIPTION **********************************************************/
__nodebug int gtoan(unsigned long num)
{
	return _gltoan(num, 0);
}

/*** BeginHeader ltoan */
int ltoan(long num);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
ltoan                        <STDIO.LIB>

SYNTAX: int ltoan(long num)

KEYWORDS:

DESCRIPTION:  This function returns the number of characters required to
display a signed long int "num".

RETURN VALUE: The number of characters to display "num".
END DESCRIPTION **********************************************************/
__nodebug int ltoan(long num)
{
	return _gltoan((unsigned long) num, 1);
}

/* START_FUNCTION DESCRIPTION *********************************************
__ftoa                        <STDIO.LIB>

SYNTAX: int __ftoa(float f, long *rlng);

KEYWORDS: convert

DESCRIPTION:  Converts the floating pointer number "f" to a long
for use by the ftoa function.  This was code was separated out
from ftoa so that pflt can handle mantissa rounding at the integer (long)
level without performing additional string conversions.
This function acts the same as ftoa except that it returns the decimal
exponent of the converted long instead of a pointer to the string.

RETURN VALUE: the decimal exponent of the number.
END DESCRIPTION **********************************************************/

/*** BeginHeader __ftoa */

__xmem int __ftoa(float f, long* rlng);

/*** EndHeader */

__nodebug
__xmem int __ftoa(float f, long* rlng)
{
/* index on upper 4 bits of exponent */
	auto float tmp;
	auto float mant;

/* adjustment to 10's exponent for each */

	/* log base 2 of 10 to find magnitude of 10's exponent */
	const static float lg_2_10 = 3.321928094887;

	auto int sgn, texp;
	auto int exp,exp2,exp10,i;
	auto unsigned long int lng,chg;
	auto long int slng; //signed long to pass value to _gltoa

	exp10 = sgn = 0;
	if (f < 0.0)
	{
		f = - f;
		sgn = 1;
	}
	// 0 is special case handle separately
	if (f == 0.0)
	{
		exp10 = 0;
		sgn = 0;
		lng = 0;
		goto __DC_loop2;
	}
#asm xmemok
c		f;
	   rl       c
	   rl       b              ; shift to get exp to b
		ld      hl, exp2+@SP    ; 8-18-94, aoc changed slightly eff
		add     hl, sp          ; 8-18-94, aoc
		ld      (hl), b         ; 8-18-94, aoc
		inc     hl              ; 8-18-94, aoc
		ld      (hl), 0         ; 8-18-94, aoc
#endasm
	exp2 = exp2-127-28;
	exp10 = (int)(((float)exp2)/lg_2_10);

// normalize the mantissa to the 2^28
	mant = f;
#asm xmemok
c	mant;
	set   7, c				;set bit high (implicit) bit
	ld		hl, mant+@SP+3	;start at MSB
	add	hl, SP
	ld		(hl), 0x4B		;make exponent 24 and ignore sign
	dec	hl
	ld		(hl), c
#endasm

	lng = (unsigned long) mant;
	lng <<= 4;
	chg=0;  // extra precision bits
	if(exp2 > 0) {
		texp = exp10;
		for(i = 0; i < exp2; i++) {
			while(lng > 214748364)  {
				texp--;
				chg /=10;
				chg += lng % 10 * 1000000;
				lng /= 10; // code in assembly later to optimize
			}
			lng <<= 1;
			chg <<= 1;
			if(chg > 10000000) {
				lng++;
				chg-=10000000;
			}
		}
		while(texp > 0) {
			texp--;
			lng+=5;
			lng /= 10;
		}
		// add any difference of 10s exponent to exp10; for some numbers texp will be neg
		exp10 -= texp;
	}
	else {
		f;
		texp=exp2;
		for(i = exp10;  i < 0; i++) {
			while(lng > 42949672 && texp < 0) {
				texp++;
				chg >>= 1;
				if(lng&1) {
					chg += 5000000;
				}
				lng >>= 1;
			}
			lng*=10;
			chg*=10;
			lng += chg/10000000;
			chg %= 10000000;
		}
		while(texp < 0) {
			texp++;
			lng >>= 1;
		}
	}
	if (0x80000000 & lng) {
		lng/=10;
		exp10++;
	}
	__DC_loop2:
	if(rlng != NULL) {
		if (sgn)
			*rlng = - lng;
		else
			*rlng = lng;
	}
	else // abort?? null pointer passed
		*rlng;
	return (exp10);

}


/*** BeginHeader ftoa */

int ftoa(float f, char *buf);

/*** EndHeader */

/*=========================================================================*\
 convert a floating number to character string
 places signed string in buf no more than 12 chars long
 and returns exponent as for 10**n
\*=========================================================================*/

/* START _FUNCTION DESCRIPTION ********************************************
ftoa                         <STDIO.LIB>

SYNTAX: int ftoa(float f, char *buf);

KEYWORDS: convert

DESCRIPTION:  Converts the floating pointer number "f" to a character
string into "buf".  The string is no longer than 12 characters long.
The character string only displays the mantissa up to 12 digits, no
decimal points.  The function returns the exponent (of 10) that should
be used to compensate for the string.  I.e., ftoa(1.0,buf) yields
buf="1000000000", and returns -10.

RETURN VALUE: the exponent of the number.
END DESCRIPTION **********************************************************/

__nodebug
int ftoa(float f, char *buf){
	auto long slng;
	auto int e;
	e = __ftoa(f,&slng);
	_gltoa((unsigned long)slng, buf, 1);
	return e;
}


/*** BeginHeader outpad */
void outpad(char left, int count, putc_func_t putc, void *instanceParam,
																		char __far *buf, int *cnt);
/*** EndHeader outpad */

__nodebug
void outpad(char left, int count, putc_func_t putc, void *instanceParam,
																		char __far *buf, int *cnt)
{
	outchrs( left == '0' ? '0' : ' ', count, putc, instanceParam, buf, cnt);
}


/*** BeginHeader pflt */

__xmem void pflt(word flags, int fmtS, int lenTotal, int precision,
               putc_func_t putc, float f, void *instanceParam,
               char __far *buffer, int *cnt);

/*** EndHeader   pflt */

/*=========================================================================*\
   PFLT - Formatted Output of Floating Point Numbers
\*=========================================================================*/

/* START_FUNCTION DESCRIPTION *********************************************
pflt                          <STDIO.LIB>

SYNTAX:
   void pflt(word flags, int fmtSpec, int lenTotal, int precision,
             putc_func_t putc, float f, void *instanceParam,
             char far *buffer, int *cnt);

KEYWORDS:

DESCRIPTION:
   This function outputs the ASCII decimal representation of a floating
   point number using the passed in function pointer, "putc".

PARAMETER1:
   "flags" are the flags for the format specifier.

PARAMETER2:
   "fmtSpec" specifies how the floating point number should be printed.

PARAMETER3:
   "lenTotal" when non-zero is the maximum total length of the output.
   (the width from the format)

PARAMETER4:
   "precision" optionally specifies the output precision, as the number
   of digits following the decimal point.  (the precision from the format)

PARAMETER5:
   "putc" is the single character output function pointer.

PARAMETER6:
   "f" is the floating point value to be output in ASCII decimal
   representation.

PARAMETER7:
   "instanceParam" when non-NULL is a pointer to an object, such as a data
   structure or a buffer limit down counter, that the particular instance
   of the putc function requires as a parameter. Note that "instanceParam"
   is used only as a parameter that is passed either directly or indirectly
   to putc.

PARAMETER8:
   "buffer" is a pointer to the output buffer. Note that "buffer" is used
   only as a parameter that is passed either directly or indirectly to
   putc.

PARAMETER9:
   "cnt" is a pointer to the count of output characters. Note that "cnt" is
   used only as a parameter that is passed either directly or indirectly to
   putc.

RETURN VALUE:
   None.
END DESCRIPTION **********************************************************/

#define DEFMANTISSA 12
#define _LENOUT_FOR_E_FORMAT_SPECIFIER_ \
        ((sgnM > 0) + digPreDecPt + (precision > 0) + precision + 2 + \
         ((2 > lenE) ? 2 : lenE))
#define _LENOUT_FOR_F_FORMAT_SPECIFIER_ \
        ((sgnM > 0) + digPreDecPt + (precision > 0) + precision)

__nouseix __nodebug
__xmem void pflt(word flags, int fmtSpec, int lenTotal, int precision,
               putc_func_t putc, float f, void *instanceParam,
               char __far *buffer, int *cnt)
{
	auto char buf[DEFMANTISSA + 30], padC;
	auto int expD, lenE, lenM, lenOut, lenPad, nPow, sgnE, sgnM, temp, xFmtS;
	auto int digIndex, digPreDecPt;
	auto int firstDigitIsZero, maxCalcRecalcCnt, okToRound, omitTrailingZeros;
	auto long sLng;
	const static long round[] = { 500000000L, 50000000L, 5000000L, 500000L,
	                              50000L, 5000L, 500L, 50L, 5L };

	// set the post decimal point precision (initial value, may change later)
	if (precision < 0)
	{
		precision = DEFDECDIGITS;
	}

	// get the decimal exponent of sLng (which is converted from f's mantissa)
	nPow = __ftoa(f, &sLng);
	// an initial calculation followed by a recalculation is the maximum allowed
	maxCalcRecalcCnt = 2;
	// only on the first time through is it OK to round the converted sLng value
	okToRound = 1;
	while (0 < maxCalcRecalcCnt)
	{
		// reset or set the mantissa's sign flag as appropriate to sLng (and to f)
		if (sLng < 0)
		{
			sgnM = '-';
		}
		else if (flags & _DOPRNT_FLAG_SIGN_ALWAYS)
		{
			sgnM = '+';
		}
		else if (flags & _DOPRNT_FLAG_SIGN_SPACE)
		{
			sgnM = ' ';
		}
		else
		{
			sgnM = 0;
		}
		// get the output length of sLng's (i.e. f's mantissa's) absolute value
		lenM = _gltoan((unsigned long) labs(sLng), 0);
		// calculate f's actual (i.e. "x.y * 10^^z" format) decimal exponent
		expD = nPow + lenM - 1;
		// reset or set the exponents's sign flag as appropriate to f
		sgnE = expD < 0;
		// get the output length of f's decimal exponent's absolute value
		lenE = _gltoan((unsigned long) abs(expD), 0);

		xFmtS = fmtSpec;
		if (tolower(xFmtS) == 'g')
		{	// 'G' and 'g' always omit trailing zeros following the decimal point,
			//  and will also omit the decimal point on whole numbers.
			omitTrailingZeros = 1;
			// 'G' or 'g': Use 'E' or 'e' (respectively) if decimal exponent < -4
			//  or if decimal exponent >= output precision.
			if (-4 > expD || expD >= precision)
			{	// convert 'G' to 'E' or 'g' to 'e'
				//  (assumes ASCII-like ordering of upper and lower case letters)
				xFmtS -= 'g' - 'e';
			}
			else
			{	// convert 'G' to 'F' or 'g' to 'f'
				//  (assumes ASCII-like ordering of upper and lower case letters)
				xFmtS -= 'g' - 'f';
			}
		}
		else
		{	// 'E' or 'e' or 'F' or 'f' never omit trailing zeros following the
			//  decimal point.
			omitTrailingZeros = 0;
		}
		switch (xFmtS)
		{
		case 'E':	// [-]d[.dd*]E(+-)dd[d*]
		case 'e':	// [-]d[.dd*]e(+-)dd[d*]
			// 'E' and 'e' format specifiers have exactly 1 non-zero decimal digit
			//  to the left of the decimal point.
			firstDigitIsZero = 0;
			digPreDecPt = 1;
			// maximum output length is [-]d[.dd*]E(+-)dd[d*] or [-]de(+-)dd[d*]
			lenOut = _LENOUT_FOR_E_FORMAT_SPECIFIER_;
			if (0 < lenTotal && lenTotal < lenOut)
			{	// 'E' or 'e' output must be truncated to fit the specified field
				//  width and the mantissa is the only possibility for truncation.
				precision -= lenOut - lenTotal;
				precision = (precision < 0) ? 0 : precision;
				// recalculate the output length
				lenOut = _LENOUT_FOR_E_FORMAT_SPECIFIER_;
			}
			break;
		case 'F':	// [-]dd*[.dd*]
		case 'f':	// [-]dd*[.dd*]
			// 'F' and 'f' format specifiers have at least 1 decimal digit to the
			//  left of the decimal point.
			firstDigitIsZero = 0 > expD;
			digPreDecPt = firstDigitIsZero ? 1 : 1 + expD;
			// maximum output length is [-]dd*[.dd*]
			lenOut = _LENOUT_FOR_F_FORMAT_SPECIFIER_;
			if (0 < lenTotal && lenTotal < lenOut)
			{	// 'F' or 'f' output must be truncated to fit the specified field
				//  width and the mantissa is the only possibility for truncation.
				precision -= lenOut - lenTotal;
				precision = (precision < 0) ? 0 : precision;
				// recalculate the output length
				lenOut = _LENOUT_FOR_F_FORMAT_SPECIFIER_;
			}
			break;
		default:
#ifdef STDIO_VERBOSE
			printf("\npflt() format specifier error! (How is this possible?)\n");
#endif
			//break;
		}

		// Was sLng already rounded on a previous pass through this part of pflt?
		if (okToRound)
		{	// No, but we must prevent re-rounding in case there's another pass.
			okToRound = 0;
			// Calculate the index into the rounding array.
			temp = (firstDigitIsZero ? 0 : digPreDecPt) + precision +
			       (sizeof round / sizeof round[0] - lenM);
			// Is the output precision within range of a long round value?
			if (0 <= temp && sizeof round / sizeof round[0] > temp)
			{	// Within range, so round sLng to suit the output precision.
				if (sgnM == '-')
				{	// f is a negative number
					sLng -= round[temp];
				}
				else
				{	// f is a non-negative number
					sLng += round[temp];
				}
				// Did rounding change the mantissa length?
				if (_gltoan((unsigned long) labs(sLng), 0) == lenM)
				{	// No, we're done with output precision calculations.
					break;
				}
			}
		}
		// If we get here  at all (see the "rounding" break immediately above)
		//  then we've got one less calculation / recalculation pass to go.
		--maxCalcRecalcCnt;
	}

	// Convert the long mantissa's absolute value to a string mantissa.
	_gltoa((unsigned long) labs(sLng), buf, 0);

	// May trailing zeros to the right of the decimal point, if any, be omitted?
	if (omitTrailingZeros && 0 < precision)
	{	// Yes, omit trailing zeros (if any) by adjusting both precision and
		//  lenOut to suit.
		// First, calculate the difference between the total output digits length
		//  and the buffered mantissa length (and accounting for a possible
		//  significant leading zero digit that is not in the mantissa buffer).
		temp = digPreDecPt + precision - firstDigitIsZero - lenM;
		// Is the mantissa length shorter than the total output digits length?
		if (0 < temp)
		{	// Yes, immediately truncate the excess trailing zero digits. (At most,
			//  we truncate all of the digits after the decimal point.)
			temp = (temp < precision) ? temp : precision;
			precision -= temp;
			lenOut -= temp;
		}
		// Now calculate the zero-based index of the remaining least significant
		//  buffered mantissa digit.
		temp = digPreDecPt + precision - firstDigitIsZero - 1;
		// Now truncate buffered trailing zero digits, if any, one at a time from
		//  right to left.
		while (0 < precision && 0 <= temp && ('0' == buf[temp]))
		{
			--precision;
			--lenOut;
			--temp;
		}
		// Have we omitted all digits after the decimal point?
		if (!precision)
		{	// Yes, so omit the decimal point, too.
			--lenOut;
		}
	}

	// Is there a specified field width?
	if (0 < lenTotal)
	{	// Yes, field width is specified. Will the output length fit?
		if (lenTotal < lenOut)
		{
			#if ! (defined __ANSI_STRICT__ || defined __ANSI_PRINTF__)
				// Won't fit, output the field width as '*' characters, then return.
				outchrs('*', lenTotal, putc, instanceParam, buffer, cnt);
				return;
			#endif
		}
		else
		{
			// Calculate the (left or right) padding length.
			lenPad = lenTotal - lenOut;
			// Is padding required?
			if (lenPad > 0)
			{	// Is this field right justified?
				if (! (flags & _DOPRNT_FLAG_LEFT_JUSTIFY))
				{	// Is it zero-padded on the left?
					if (flags & _DOPRNT_FLAG_LEADING_ZEROS)
					{	// Is there a sign character to display?
						if (sgnM)
						{
							_CALL_PUTC_FUNC(putc, sgnM, buffer, cnt, instanceParam);
							// Prevent unwanted subsequent sign character output.
							sgnM = 0;
						}
						padC = '0';
					}
					else
					{
						padC = ' ';
					}
					// Left pad with one or more (zero or space) characters.
					outchrs(padC, lenPad, putc, instanceParam, buffer, cnt);
				}
			}
		}
	}

	// Is there a leading sign character to output?
	if (sgnM)
	{
		_CALL_PUTC_FUNC(putc, sgnM, buffer, cnt, instanceParam);
	}

	// Is the first decimal digit a zero, separate from the digits buffer?
	if (firstDigitIsZero)
	{	// Yes, output the zero character now and decrement the 'before' count.
		_CALL_PUTC_FUNC(putc, '0', buffer, cnt, instanceParam);
		--digPreDecPt;
	}

	// initialize the decimal digits buffer index
	digIndex = 0;
	while (0 < digPreDecPt)
	{	// Output any / all remaining digits before the decimal point.
		// Do any buffered decimal digits remain?
		if (0 < lenM)
		{	// Yes, output from the decimal digits buffer.
			_CALL_PUTC_FUNC(putc, buf[digIndex], buffer, cnt, instanceParam);
			--digPreDecPt;
			++digIndex;
			--lenM;
		}
		else
		{	// No decimal digits remain, output the trailing zero characters.
			outchrs('0', digPreDecPt, putc, instanceParam, buffer, cnt);
			digPreDecPt = 0;
		}
	}
	// Any digits following the decimal point?
	if (0 < precision)
	{	// Yes, output the decimal point now.
		_CALL_PUTC_FUNC(putc, '.', buffer, cnt, instanceParam);
		// Is the decimal exponent < -1 and is this 'F' or 'f' format?
		if (-1 > expD && 'f' == tolower(xFmtS))
		{	// Yes, output the significant leading zero characters, the count of
			//  which is one less than the absolute value of the decimal exponent.
			//  (E.g. 1e-2 == 0.01 where there is one significant leading zero to
			//  the right of the decimal point.)
			temp = abs(expD) - 1;
			temp = (temp < precision) ? temp : precision;
			outchrs('0', temp, putc, instanceParam, buffer, cnt);
			precision -= temp;
		}
		while (0 < precision)
		{	// Output any / all remaining digits after the decimal point.
			// Do any buffered decimal digits remain?
			if (0 < lenM)
			{	// Yes, output from the decimal digits buffer.
				_CALL_PUTC_FUNC(putc, buf[digIndex], buffer, cnt, instanceParam);
				--precision;
				++digIndex;
				--lenM;
			}
			else
			{	// No decimal digits remain, output the trailing zero characters.
				outchrs('0', precision, putc, instanceParam, buffer, cnt);
				precision = 0;
			}
		}
	}

	// Is this an 'E' or 'e' format specification?
	if ('e' == tolower(xFmtS))
	{	// Yes, output the exponent part now.
		// convert the int exponent's absolute value to a string exponent
		_gltoa((unsigned long) abs(expD), buf, 0);
		// output the 'E' or 'e' exponent character
		_CALL_PUTC_FUNC(putc, (char) xFmtS, buffer, cnt, instanceParam);
		// re-use padC as the exponent's sign character and output it
		padC = sgnE ? '-' : '+';
		_CALL_PUTC_FUNC(putc, padC, buffer, cnt, instanceParam);
		// Is the exponent length less than 2?
		if (2 > lenE)
		{	// Yes, left pad the exponent with a single zero character.
			_CALL_PUTC_FUNC(putc, '0', buffer, cnt, instanceParam);
		}
		// output the remainder of the string exponent
		outstr(buf, putc, instanceParam, buffer, cnt);
	}

	// Is a field width specified and padding required for left justified output?
	if (0 < lenTotal && 0 < lenPad && (flags & _DOPRNT_FLAG_LEFT_JUSTIFY))
	{	// Yes, output the right-side padding space characters.
		outchrs(' ', lenPad, putc, instanceParam, buffer, cnt);
	}
}

/*** BeginHeader itoa */

__root char *itoa(int value, char *buf);

/*** EndHeader   itoa */

/* START FUNCTION DESCRIPTION ********************************************
itoa                         <STDIO.LIB>

SYNTAX: char *itoa(int value, char *buf);

KEYWORDS: string

DESCRIPTION: Places up to 5 digit character string at *buf, representing
value of signed number, with minus sign in first place, when appropriate.
Supresses leading zeros, but leaves one zero digit for value = 0. Max =
65535. 73 program bytes. Executes in about 200us on 9 mhz hd64180.

RETURN VALUE: pointer to the end (null terminator) of the string in buf.
END DESCRIPTION **********************************************************/
#asm __nodebug

; 153 bytes, 3 routines
;
; char *itoa(int value, char *buf)
; same as utoa below, but places minus sign first in buffer if neg

itoa::
	   pop      bc                ; ret
	   pop      de                ; value
	   pop      hl                ; pointer
	   ld       a,d
	   or       a
	   jp       p,.itoa2           ; not neg
	   res      7,a
	   or       e
	   jp       z,.itoa2           ; max neg int
	   ld       a,e
	   cpl
	   ld       e,a
	   ld       a,d
	   cpl
	   ld       d,a
	   inc      de                ; de neg value
	   ld       (hl),'-'          ; minus to buffer
	   inc      hl
.itoa2:
	   push     hl
	   push     de
	   push     bc
	   jp       utoa              ; continue as unsigned

#endasm

/*** BeginHeader utoa, utoan, itoan */

__root char *utoa(unsigned value, char *buf);
__root int utoan(int num);
__root int itoan(int num);

/*** EndHeader   utoa */

/* START _FUNCTION DESCRIPTION ********************************************
utoa                         <STDIO.LIB>

SYNTAX: char *utoa(unsigned value, char *buf);

KEYWORDS: string

DESCRIPTION: Places up to 5 digit character string at *buf representing
value of unsigned number.  Supresses leading zeros, but leaves one zero
digit for value = 0. Max = 65535. 73 program bytes. Executes in about
200us on 9 mhz hd64180.

RETURN VALUE: Pointer to null at end of string.
END DESCRIPTION **********************************************************/

const unsigned short _tens[] = {10000,1000,100,10,1};

#asm __nodebug

; char *utoa(unsigned int value, char *buf )
; places up to 5 digit character string at *buf representing
; value of unsigned number. returns pointer to null at end of string.
; supresses leading zeros. places one zero digit for zero. max 65535.
; 73 program bytes. Exectes in about 200us on 9 mhz hd64180.

utoa::
	  pop      bc                ; return
	  pop      hl                ; value
	  exx
	  pop      hl                ; pointer to buf
	  ld       de,_tens         ; pointer to power of tens
	  ld       c,0               ; c' is first non zero flag
	  exx
	  push     hl
	  push     hl
	  push     bc                ; return
; hl value, hl' pointer to buf, de' pointer to tens, c' nozero flag
	  ld       b,5               ; number of steps
__DC_loop:  exx
	  ld       a,(de)            ; get power of ten
	  inc      de
	  exx
	  ld       e,a               ; to de
	  exx
	  ld       a,(de)
	  inc      de
	  exx
	  ld       d,a             ; de is power of 10
	  or       a                 ; clc
	  ld       c,-1              ; digit
.loopi:
	  inc      c                 ; digit
	  sbc      hl,de             ; sub a power of ten
	  jp       nc,.loopi          ; carry means done
	  add      hl,de             ; restore value
; c has digit
	  ld       a,c
	  exx
	  or       c                 ; first nonzero flag
	  ld       c,a               ; save
	  exx
	  jr       z,__DC_loop2           ; if digit not encountered yet
	  ld       a,c               ; digit
	  add      a,'0'             ; to ascii
	  exx
	  ld       (hl),a            ; to *buf++
	  inc      hl
	  exx
__DC_loop2:
	  djnz     __DC_loop              ; do 5 times b=b-1
	  exx
	  ld       a,c
	  or       c                 ; any digits in entire process
	  jr       nz,.loop3          ; yes
	  ld       a,'0'
	  ld       (hl),a            ; put one zero if none at all
	  inc      hl
.loop3:
	  xor      a
	  ld       (hl),a            ; term null
	  ret                        ; pass pointer back in hl

; returns number of digits needed to express unsigned int
; never less than 1
; int utoan(int num)

utoan::
	  ld       b,5               ; max possible
	  ld       iy,_tens         ; pointer to array
.utoan1:
	  ld       e,(iy)
	  inc      iy
	  ld       d,(iy)
	  inc      iy
	  push     hl
	  or       a
	  sbc      hl,de
	  pop      hl
	  jr       nc,.utoan3         ; if hl>= tenpower, need this many digs
	  djnz     .utoan1            ; loop
	  inc      b                 ; at least 1 digit
.utoan3:
	  ld       l,b               ; count
	  ld       h,0               ; return in hl
	  ret

; routine to return number of digits in signed integer
; same as utoan, but one more for sign

itoan::
	  bit      7,h
	  jr       z,utoan           ; unsigned
	  neg      hl                ; negate
	  call     utoan
	  inc      hl                ; 1 more for sign
	  ret

#endasm

/*** BeginHeader htoa, hltoa */

__root char *htoa(int value, char *buf);
__root char *hltoa(long int value, char *buf);
/*** EndHeader   htoa */

/* START _FUNCTION DESCRIPTION ********************************************
htoa                         <STDIO.LIB>

SYNTAX: char *htoa(int value, char *buf);

KEYWORDS: math

DESCRIPTION: Converts integer "value" to hex number and put result into
"buf".

RETURN VALUE: Pointer to end (null terminator) of string in buf.
END DESCRIPTION **********************************************************/
#asm __nodebug

; convert integer to hex number
; char * htoa(int value, char *buf)

._ls4:
		ld		b,4
._lsloop:
		or		a
		rl		e
		rl		d
		djnz	._lsloop
		ret

htoa::
	   ex       de,hl
	   ld       hl,4
	   add      hl,sp
	   ld       a,(hl)
	   inc      hl
	   ld       h,(hl)
	   ld       l,a               ; pointer to output buf
.htoa0:
	   ld			a,d
	   cp			010h
	   jr			c,._3orLess
	   ld			c,4
	   jr			.htoa1

._3orLess:
		call		._ls4
		ld			a,d
		cp			010h
		jr			c,._2orLess
		ld			c,3
		jr			.htoa1

._2orLess:
		call		._ls4
		ld			a,d
		cp			010h
		jr			c,._1
		ld			c,2
		jr			.htoa1
._1:
		call		._ls4
		ld			c,1
.htoa1:
	   ld       b,4               ; shift count
	   ld       a,0
.htoa2:
	   rl       e
	   rl       d
	   rla
	   djnz     .htoa2
	   cp       10
	   jr       c,.htoa3           ; 0-9
	   add      a,'A'-10
	   jr       .htoa4
.htoa3:
	   add      a,'0'
.htoa4:
	   ld       (hl),a
	   inc      hl
	   dec      c
	   jr       nz,.htoa1          ; 4 hex digits
	   ld       (hl),0            ; terminal null
	   ret

; char * hltoa(long int value, char *buf)
; convert long to hex

hltoa::
	   ld       hl,6
	   add      hl,sp
	   ld       a,(hl)
	   inc      hl
	   ld       h,(hl)
	   ld       l,a               ; pointer to buffer now in hl
	   push     de                ; save least
	   push     hl                ; pointer
	   ld       d,b
	   ld			a,d
	   ld       e,c               ; arg must be in hl too
	   or			e
	   jr			z,.lobyteonly
	   call     .htoa0          ; 4 digits, hl returns pointer
	   pop      bc                ; clean stack
	   pop      de                ; next 16 bits
		ld			c,4
	   call     .htoa1
	   ret

.lobyteonly:
		pop		bc
		pop		de
		call		.htoa0
		ret
#endasm

/*** BeginHeader outchrs */
__root char outchrs(char, int, putc_func_t, void *, char __far *, int *);
/*** EndHeader */

/* START_FUNCTION DESCRIPTION *********************************************
outchrs                      <STDIO.LIB>

SYNTAX:
   char outchrs(char c, int n, putc_func_t putc, void *instanceParam,
                char far *buf, int *cnt);

KEYWORDS:

DESCRIPTION:  Use "putc" to output "n" times the character "c".  The
function pointed to by "putc" should take a character parameter.

RETURN VALUE: The character in parameter "c".
END DESCRIPTION **********************************************************/

__nodebug
__root char outchrs(char c, int n, putc_func_t putc, void *instanceParam,
                  char __far *buf, int *cnt)
{
#asm
.repeatOut:
	ld		hl,(sp+@sp+n)
	test	hl
	jp		m, .endFunc				; negative count, nothing to do!
	jr		z, .endFunc				; zero count, nothing to do!
	dec	hl
	ld		(sp+@sp+n),hl
	ld		hl,(sp+@sp+instanceParam)
	push	hl
	ld		hl,(sp+@sp+cnt+2)
	push	hl
	ld		px,(sp+@sp+buf+4)
	push	px
	ld		hl,(sp+@sp+c+8)
	push	hl
	ld		iy,(sp+@sp+putc+10)
	call	(iy)
.retAddr:
	add	sp,10
	jr		.repeatOut
.endFunc:
#endasm
	return c;
}

/*** BeginHeader outstr */
void outstr(char __far *, putc_func_t, void *, char __far *, int *);
/*** EndHeader */

/* START_FUNCTION DESCRIPTION *********************************************
outstr                       <STDIO.LIB>

SYNTAX:
   void outstr(char *string, putc_func_t putc, void *instanceParam,
               char far *buf, int *cnt);

KEYWORDS:

DESCRIPTION: Output the string pointed to by "string" via calls to "putc".
"putc" should take one character parameter.
END DESCRIPTION **********************************************************/

__nodebug
void outstr(char __far *string, putc_func_t putc, void *instanceParam,
				char __far *buf, int *cnt)
{
#asm
.repeatOut:
	ld		px,(sp+@sp+string)
	ld		a,(px)
	or		a
	jr		z,.endFunc
	ld		px,px+1
	ld		(sp+@sp+string),px
	ld		hl,(sp+@sp+instanceParam)
	push	hl
	ld		hl,(sp+@sp+cnt+2)
	push	hl
	ld		px,(sp+@sp+buf+4)
	push	px
	clr	hl
	ld		L,a
	push	hl					; push the current string character
	ld		iy,(sp+@sp+putc+10)
	call	(iy)
.retAddr:
	add	sp,10
	jr		.repeatOut
.endFunc:
#endasm
}


/*** BeginHeader _tmtoa */

char * _tmtoa(long t, char *str);

/*** EndHeader */

__nodebug
char * _tmtoa(long t, char *str) {
	auto struct tm ts;
	sprintf(str,"%2d:%02d:%02d",
		(int)(t/3600),
		(int)((t%3600)/60),
		(int)(t%60));
	return str;
}

/*** BeginHeader _dtmonname */

extern char * const _dtmonname[13];

/*** EndHeader */

char * const _dtmonname[13] = {
	"???","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};

/*** BeginHeader _dttoa */

char * _dttoa(int t, char *str);

/*** EndHeader */

__nodebug
char * _dttoa(int d, char *str) {
	auto struct tm ts;
	_mktm_date(&ts,d);
	sprintf(str,"%d/%d/%02d",
							tm_mon2month(ts.tm_mon), ts.tm_mday, ts.tm_year % 100);
	return str;
}

/*** BeginHeader _atotm */

long _atotm(const char __far*str);

/*** EndHeader */

__nodebug
long _atotm(const char __far*str) {
	auto long time;
	auto int i;
	auto char __far*tail;

	i = (int)_f_strtol(str, &tail, 10);
	if (i >= 0 && i < 24) {
		time = i * 3600L;
	} else {
		return -1;
	}

	if (*tail != ':') return -1;
	++tail;
	i = (int)_f_strtol(tail, &tail, 10);
	if (i >= 0 && i < 60) {
		time += i * 60L;
	} else {
		return -1;
	}

	if (*tail != ':') return -1;
	++tail;
	i = (int)_f_strtol(tail, &tail, 10);
	if (i >= 0 && i < 60) {
		return time + i;
	} else {
		return -1;
	}
}

/*** BeginHeader _atodt */

int _atodt(const char __far*str);

/*** EndHeader */

__nodebug
int _atodt(const char __far*str) {
	auto int date;
	auto char __far*tail;
	auto int i;
	auto struct tm t;

	static const int __dom[2][12] =
		{
		{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
		{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
		};

	i = (int)_f_strtol(str, &tail, 10);
	if (i >= 1 && i < 13) {
		t.tm_mon = month2tm_mon(i);
	} else {
		return -1;
	}

	if (*tail != '/') return -1;
	++tail;

	i = (int)_f_strtol(tail, &tail, 10);
	if (i >= 1) {
		t.tm_mday = i;
	} else {
		return -1;
	}

	if (*tail != '/') return -1;
	++tail;

	i = (int)_f_strtol(tail, &tail, 10);
	if (	(i >= 1980 && i <= 2079) || (i >= 0 && i <= 99)) {
		t.tm_year = i % 100;
		if (t.tm_year < 80) t.tm_year += 100;
	} else {
		return -1;
	}

	if (t.tm_mday < __dom[!(t.tm_year % 4)][t.tm_mon-1]+1) {
		return (int)(mktime(&t)/86400);
	} else {
		return -1;
	}
}

/*** BeginHeader mem_dump */
void mem_dump(const void __far * pblock, word len);
// Macro for backwards compatibility with 'xalloc' style pointers...
#define xmem_dump(addr, len) mem_dump((void __far *)(addr), len)
/*** EndHeader */

__nodebug void mem_dump(const void __far * pblock, word len)
{
	auto char buf[67];
   auto word i, j, k, l, m;
   auto const char __far * block;

   block = (const char __far *)pblock;
   i = 0;
   for (j = 0; j < len; j += 16) {
	   memset(buf, ' ', sizeof(buf)-1);
	   buf[sizeof(buf)-1] = 0;
		k = len - j;
      if (k > 16)
      	k = 16;
	   for(i = j, l = 0, m = 0; l < k; ++i, ++l, m += 3) {
	      sprintf(buf+m,"%02X", block[i]);
         buf[m+2] = ' ';
         if (block[i] >= ' ' && block[i] < 0x7F)
         	buf[50+l] = block[i];
	      if((i & 15) == 15) {
	         printf("%s\n", buf);
	      }
	   }
   }
   if (i & 15)
   	printf("%s\n", buf);
}


/*** BeginHeader  ********************************************/
#endif
/*** EndHeader ***********************************************/