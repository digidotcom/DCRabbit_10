/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
AES_CRYPT.LIB

DESCRIPTION:
   Implementation of the Rijndael AES cipher.

END DESCRIPTION *********************************************************/


/*** BeginHeader */
#ifndef __AES_CRYPT_LIB
#define __AES_CRYPT_LIB


#ifndef __AES_CORE_LIB
	#use "aes_core.lib"
#endif

#if CC_VER < 0xA20
#fatal "This AES Encryption module must be used with Dynamic C version 10.20 or later."
#endif

#define _AES_VERS 0x0107


//#define AES_ONLY		// App may define this to delete code for non-standard Rijndael
								// i.e. blocks != 4 or key sizes not 4,6 or 8 longwords.
                        // Define this to save space if using only AES.



#ifdef AES_STATS
	#define AES_S(addr) push hl $ ld hl,(addr) $ inc hl $ ld (addr),hl $ pop hl
	word aes_s_sbox;
	word aes_s_rowshift;
	word aes_s_colmix;
	word aes_s_addkey;
#else
	#define AES_S(addr)
#endif

// Block size for AES-CBC mode
#define _AES_CBC_BLK_SZ_ 16

/*** EndHeader */

/*** BeginHeader _AESinitStream */
int _AESinitStream(AESstreamState __far *state, const char __far *key,
                   int key_size, const char __far *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
_AESinitStream                 <AES_CRYPT.LIB>

SYNTAX:		   int _AESinitStream(AESstreamState far *state,
											 const char far *key,
                                  int nk,
											 const char far *init_vector);

DESCRIPTION:   Sets up a stream state structure to begin encrypting or
					decrypting a stream. A particular stream state can only be
					used for one direction.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 16, 24 or 32-byte cipher key, using a NULL pointer
 						will prevent an existing key from being recalculated.
PARAMETER3:		nk - key size, in 32-bit words (either 4, 6, or 8)
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

RETURNS:			0: success
					-EINVAL: invalid parameter
END DESCRIPTION *********************************************************/

_aes_debug int _AESinitStream(AESstreamState __far *state,
                              const char __far *key,
                              int key_size,
                              const char __far *init_vector)
{
	if (state == NULL || init_vector == NULL
   	|| (key_size != 4 && key_size != 6 && key_size != 8)) {
      return -EINVAL;
   }
   
	_f_memcpy(state->feedback_register, init_vector, 16);
	if (key) {
		state->nk = key_size;
		AESexpandKey(state->expanded_key, key, 4, key_size);
   }
	state->feedback_index = 0;
   
   return 0;
}


/*** BeginHeader AESinitStream */
void AESinitStream(AESstreamState *state, const char *key,
											 const char *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESinitStream                 <AES_CRYPT.LIB>

SYNTAX:		   void AESinitStream(AESstreamState *state,
											 const char *key,
											 const char *init_vector);

DESCRIPTION:   Sets up a stream state structure to begin encrypting or
					decrypting a stream. A particular stream state can only be
					used for one direction.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 16-byte cipher key, using a NULL pointer will prevent
 						an existing key from being recalculated.
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

END DESCRIPTION *********************************************************/

_aes_debug void AESinitStream(AESstreamState *state, const char *key,
																		const char *init_vector)
{
	_AESinitStream(state, key, 4, init_vector);
}

/*** BeginHeader AESinitStream192 */
void AESinitStream192(AESstreamState *state, const char *key,
																	const char *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESinitStream192              <AES_CRYPT.LIB>

SYNTAX:		   void AESinitStream192(AESstreamState *state,
											 const char *key,
											 const char *init_vector);

DESCRIPTION:   See AESinitStream().  This version assumes a 192 bit key
               (24 bytes).  Everything else is the same.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 24-byte cipher key, using a NULL pointer will prevent
 						an existing key from being recalculated.
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

END DESCRIPTION *********************************************************/

_aes_debug void AESinitStream192(AESstreamState *state, const char *key,
																		const char *init_vector)
{
	_AESinitStream(state, key, 6, init_vector);
}

/*** BeginHeader AESinitStream256 */
void AESinitStream256(AESstreamState *state, const char *key,
																	const char *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESinitStream256              <AES_CRYPT.LIB>

SYNTAX:		   void AESinitStream256(AESstreamState *state,
											 const char *key,
											 const char *init_vector);

DESCRIPTION:   See AESinitStream().  This version assumes a 256 bit key
               (32 bytes).  Everything else is the same.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 32-byte cipher key, using a NULL pointer will prevent
 						an existing key from being recalculated.
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

END DESCRIPTION *********************************************************/

_aes_debug void AESinitStream256(AESstreamState *state, const char *key,
																		const char *init_vector)
{
	_AESinitStream(state, key, 8, init_vector);
}

/*** BeginHeader AESencryptStream */
void AESencryptStream(AESstreamState *state, char *data, int count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencryptStream              <AES_CRYPT.LIB>

SYNTAX:		   void AESencryptStream(AESstreamState *state,
											    char *data,
											    int count);

DESCRIPTION:   Encrypts an array of bytes

PARAMETER1:		state - The AESstreamState structure
PARAMETER2:		data - an array of bytes that will be encrypted in place.
PARAMETER3:		count - size of data array

END DESCRIPTION *********************************************************/

_aes_debug void AESencryptStream(AESstreamState *state, char *data, int count)
{
#asm _aes_debug
	push	ix
	push	pw
	ld		ix,hl
	ld		de,[AESstreamState]+feedback_index
	add	hl,de
	ldl	pw,hl			; Use pw to point to feedback_index and following fields
	ld		hl,(sp+@sp+6+count)
	ld		bc,hl
	bool	hl
	jr		z,.aes_enc_exit
	ld		hl,(sp+@sp+6+data)
	ex		de,hl
	; DE = data, IX = state, BC = count
.aes_enc_loop:
	ld		hl,(pw)	; feedback_index followed by nk field
   ld		a,h
   ld		h,0	; Now A is NK, HL is fb_index
	bool	hl
	jr		nz,.aes_enc_1	; Not 0 (mod 16), so continue with current feedback
	push	bc
	push	de

	ld		l,a	; Get NK (H is 0)
	push	hl
	; following commented out, expanded_key offset is 0
	;ld		hl,ix
	;ld		de,[AESstreamState]+expanded_key	; Offset to expanded key
	;add	hl,de
	;push	hl
	push	ix
	ld		hl,ix
	ld		de,[AESstreamState]+feedback_register
	add	hl,de	; feedback, block to be re-encrypted
	push	hl
	call	AESencrypt4
	add	sp,6

	pop	de
	pop	bc
.aes_enc_1:
	exx
   ld		a,(pw)	; Get feedback index
	ld		de,[AESstreamState]+feedback_register
	ld		hl,ix
   add	hl,de			; HL points to feedback
	ex		de,hl			; DE points to feedb reg.
   ld		l,a
	inc	a
	and	0x0F
	ld		(pw),a	; add 1 to offset, modulo 16
   ld		h,0
	add	hl,de			; hl points to feedback_register[feedabck_index]
	ld		h',h
	ld		l',L
	exx
	ld		a,(de)
	xor	(hl)
	ld		(de),a
	ld		(hl),a
	inc	de
	dwjnz	.aes_enc_loop
.aes_enc_exit:
	pop	pw
	pop	ix
#endasm
}

/*** BeginHeader AESdecryptStream */
void AESdecryptStream(AESstreamState *state, char *data, int count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecryptStream                   <AES_CRYPT.LIB>

SYNTAX:		   void AESdecryptStream(AESstreamState *state,
											    char *data,
											    int count);

DESCRIPTION:   Decrypts an array of bytes

PARAMETER1:		state - The AESstreamState structure
PARAMETER2:		data - an array of bytes that will be decrypted in place.
PARAMETER3:		count - size of data array

END DESCRIPTION *********************************************************/

_aes_debug void AESdecryptStream(AESstreamState *state, char *data, int count)
{
	/*
	int i;
	char ct_byte;

	for(i = 0;i < count;i++)
	{
		if(state->feedback_index == 0)
		{
			//new register block
			AESencrypt4(state->feedback_register,
							state->expanded_key,
							state->nk);
		}
		ct_byte = data[i]; //temp store for the current ciphertext
		data[i] ^= state->feedback_register[state->feedback_index];
		state->feedback_register[state->feedback_index] = ct_byte;
		state->feedback_index = (state->feedback_index + 1) & 0x0f;
	}
	*/
#asm _aes_debug
	push	ix
	push	pw
	ld		ix,hl
	ld		de,[AESstreamState]+feedback_index
	add	hl,de
	ldl	pw,hl			; Use pw to point to feedback_index and following fields
	ld		hl,(sp+@sp+6+count)
	ld		bc,hl
	bool	hl
	jr		z,.aes_enc_exit
	ld		hl,(sp+@sp+6+data)
	ex		de,hl
	; DE = data, IX = state, BC = count
.aes_enc_loop:
	ld		hl,(pw)
   ld		a,h
   ld		h,0
	bool	hl
	jr		nz,.aes_enc_1
	push	bc
	push	de

	ld		l,a
	push	hl
	; following commented out, expanded_key offset is 0
	;ld		hl,ix
	;ld		de,[AESstreamState]+expanded_key	; Offset to expanded key
	;add	hl,de
	;push	hl
	push	ix
	ld		hl,ix
	ld		de,[AESstreamState]+feedback_register
	add	hl,de	; feedback, block to be re-encrypted
	push	hl
	call	AESencrypt4
	add	sp,6

	pop	de
	pop	bc
.aes_enc_1:
	exx
   ld		a,(pw)
	ld		de,[AESstreamState]+feedback_register
	ld		hl,ix
   add	hl,de		; HL points to feedback
	ex		de,hl		; DE points to feedb reg.
	ld		l,a
	inc	a
	and	0x0F
	ld		(pw),a	; add 1 to offset, modulo 16
   ld		h,0
	add	hl,de
	ld		h',h
	ld		l',L
	exx
	ld		a,(de)
	ld		a',a
	xor	(hl)
	ld		(de),a
	ex		af,af'
	ld		(hl),a
	inc	de
	dwjnz	.aes_enc_loop
.aes_enc_exit:
	pop	pw
	pop	ix
#endasm
}


/*** Beginheader AESsubBytes */
//assume count < 256
__root void AESsubBytes(const char *table, char *bytes, int count);
/*** EndHeader */

#asm __root

AESsubBytes::
	AES_S(aes_s_sbox)
	 ex	 de, hl 		 ; 2 DE = table base
	 ld	 hl, (sp+6)	; 9
	 ld	 b, L			; 2  B holds byte count
	 ld	 hl, (sp+4) ; 9 Data to transform
subloop:
	 ld	a,(hl)
	 ex	de',hl
	 bool	hl
	 ld	l,a
	 add	hl,de
	 ld	a,(hl)
	 ex	de',hl
	 ld	(hl),a
	 inc	hl
	 djnz	 subloop		; 33*16 + 22 + 8 = 558 clocks
	 ret

#endasm


/*** Beginheader AESshiftRows */
// takes pointer to data block and size of data block in columns (4,6, or 8)
void AESshiftRows(char *block, int nb);
/*** EndHeader */

#asm

;hl is starting point, b is column counter, assumes start point is also on stack
aes_shiftone:
	 ld	 e, (hl)
	 ld	 (hl), a
	 ld	 a, e
	 dec	 b
	 jr	 z, aes_shiftone_end
	 ld	 de, 4
	 or	 a		;clear carry
	 sbc	 hl, de		;subtract 4 from pointer
	 jr	 aes_shiftone

aes_shiftone_end:
	 ld	 hl, (sp+2)	;reload start point, on stack right after return address
	 ld	 (hl), e		;store last shift
	 ret


AESshiftRows::
	 ld	 hl, (sp+4)
	 ld	 c, L		;c holds block size

	 ;row 2
	 ld	 b, c		;set counter
	 ld	 d, 0x00
	 ld	 e, c
	 dec	 e
	 sla	 e
	 sla	 e			;offset for first row is Nb*4 -4
	 inc	 e			;offset for second row
	 ld	 hl, (sp+2)	;hl holds block pointer
	 add	 hl, de		;start point of shift
	 push	 hl			;store start point
	 call  aes_shiftone		;hl is start of shift, b is counter
aes_row3:
	 ld	 b, c					;reset counter
	 pop	 hl				;reload start point
	 inc	 hl					;set for row 3
	 push	 hl
	 call	 aes_shiftone
	 ld	 b, c					;reset counter
	 ld	 hl, (sp)			;reload start point
	 call	 aes_shiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_row4		;no extra shift for Nb=4,6
	 ld	 b, c
	 ld	 hl, (sp)			;grab start point
	 call	 aes_shiftone
aes_row4:
	 ld	 b, c					;reset counter
	 pop	 hl
	 inc	 hl					;set for row 4
	 push	 hl
	 call	 aes_shiftone
	 ld	 b, c
	 ld	 hl, (sp)
	 call	 aes_shiftone
	 ld	 b, c					;reset counter
	 ld	 hl, (sp)
	 call	 aes_shiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_shiftexit 	;no extra shift for Nb=4,6
	 ld	 b, c
	 ld	 hl, (sp)
	 call	 aes_shiftone
aes_shiftexit:
	 pop	 hl						;restore stack
	 ret

#endasm

/*** Beginheader AESinvShiftRows */
// takes pointer to data block and size of data block in columns (4,6, or 8)
void AESinvShiftRows(char *block, int nb);
/*** EndHeader */

#asm

;iy is starting point, b is column counter, preserves hl
aes_ishiftone:
	 push	 hl				;save start point
aes_ishift_loop:
	 ld	 e, (hl)
	 ld	 (hl), a
	 ld	 a, e
	 dec	 b
	 jr	 z, aes_ishiftone_end
	 ld	 de, 0x04		;for incrementing pointer
	 add	 hl, de
	 jr	 aes_ishift_loop

aes_ishiftone_end:
	 pop	 hl			;restore start point
	 ld	 (hl), e		;store last shift
	 ret


AESinvShiftRows::
	 ld	 hl, (sp+4)
	 ld	 c, L		;c holds block size

	 ;row 2
	 ld	 b, c		;set counter
	 ld	 d, 0x00
	 ld	 hl, (sp+2)	;hl holds block pointer
	 inc	 hl			;start at row 2
	 call  aes_ishiftone		;iy is start point, b is counter
aes_irow3:
	 ld	 b, c					;reset counter
	 inc	 hl					;set for row 3
	 call	 aes_ishiftone
	 ld	 b, c					;reset counter
	 call	 aes_ishiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_irow4		;no extra shift for Nb=4,6
	 ld	 b, c
	 call	 aes_ishiftone
aes_irow4:
	 ld	 b, c					;reset counter
	 inc	 hl					;set for row 4
	 call	 aes_ishiftone
	 ld	 b, c
	 call	 aes_ishiftone
	 ld	 b, c					;reset counter
	 call	 aes_ishiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_ishiftexit 	;no extra shift for Nb=4,6
	 ld	 b, c
	 call	 aes_ishiftone
aes_ishiftexit:

	 ret

#endasm

/*** Beginheader AESmixColumns */
void AESmixColumns(char *data, int nb);
/*** EndHeader */

#asm

AESmixColumns::
	AES_S(aes_s_colmix)
	push 	ix			; 12
	 ;using 8-bit algorithm in Rijndael spec
	 ; b = a[0], c = a[1], d=a[2], e=a[3], L = Tmp
	 ld	 ix, hl		; 4 start of block
	 ld	 hl, (sp+6)	; 9
	 ex	 de', hl		; 2  de' holds nb (loop counter)  : 27 clocks
aes_mixloop:
	ld		hl,(ix)		; 9
	ld		c,h			; 2
	ld		b,L			; 2
	ld		hl,(ix+2)	; 9
	ld		e,h			; 2
	ld		d,L			; 2
	 ld	 a, b			; 2
	 xor	 c				; 2
	 xor	 d				; 2
	 xor	 e				; 2
	 ld	 L, a			; 2  calculate Tmp
	 ld	h,0x1B		; 4

	 ld	 a, b			; 2
	 xor	 c				; 2
	 rla					; 2 do xtime on a[0] ^ a[1]
	 jr	 nc, continue_0 ; 5
	 xor	 h				; 2
continue_0:
	 xor	 L				; 2
	 xor	 b				; 2
	 ld	 (ix), a		; 10  load new value into column

	 ld	 a, c			; 2
	 xor	 d				; 2
	 rla					; 2 do xtime on a[1] ^ a[2]
	 jr	 nc, continue_1	; 5
	 xor	 h				; 2
continue_1:
	 xor	 L				; 2
	 xor	 c				; 2
	 ld	 (ix+1), a	; 10  load new value into column

	 ld	 a, d			; 2
	 xor	 e				; 2
	 rla					; 2  do xtime on a[2] ^ a[3]
	 jr	 nc, continue_2	; 5
	 xor	 h				; 2
continue_2:
	 xor	 L				; 2
	 xor	 d				; 2
	 ld	 (ix+2), a	; 10  load new value into column

	 ld	 a, e			; 2
	 xor	 b				; 2
	 rla					; 2  do xtime on a[3] ^ a[0]
	 jr	 nc, continue_3	; 5
	 xor	 h				; 2
continue_3:
	 xor	 L				; 2
	 xor	 e				; 2
	 ld	 (ix+3), a	; 10  load new value into column

	 ex	 de', hl			; 2  get countdown
	 dec	 L					; 2  assumes nb is less than 256
	 jr	 z, aes_mixexit  ; 5		: 157 per loop

	 ex	 de', hl			; 2  put countdown back into de'
	 ld	 de, 4			; 6
	 add	 ix, de			; 4  point to next column
	 jr	 aes_mixloop	; 5	: 174 per loop, *3 = 522

aes_mixexit:
	pop	ix				; 9
	 ret					; 8 : total = 27 + 174*3 + 157 + 17 = 723 clocks

#endasm


/*** BeginHeader AESinvMixColumns */
void AESinvMixColumns(char *data, int columns);
/*** EndHeader */

#asm

AESinvMixColumns::
	 ; b = a[0], c = a[1], d=a[2], e=a[3], L = Tmp
	 ld	 iy, hl
	 ld	 hl, (sp+4)		;hl holds column counter
	 push	 ix			;this may be necessary
	 add	 sp, -12		;reserve 12 bytes on the stack
	 ld	 ix, 0x00
	 add	 ix, sp		;ix now points to new 12 bytes
aes_invmixloop:
	 ld	 b, (iy)
	 ld	 c, (iy+1)
	 ld	 d, (iy+2)
	 ld	 e, (iy+3)

	 ;calculate the mult table
	 ;for a[0]
	 ld	 a, b
	 sla	 a
	 jr	 nc, continue_a0x2
	 xor	 0x1B
continue_a0x2:
	 ld	 (ix), a
	 sla	 a
	 jr	 nc, continue_a0x4
	 xor	 0x1B
continue_a0x4:
	 ld	 (ix+1), a
	 sla	 a
	 jr	 nc, continue_a0x8
	 xor	 0x1B
continue_a0x8:
	 ld	 (ix+2), a

	 ;for a[1]
	 ld	 a, c
	 sla	 a
	 jr	 nc, continue_a1x2
	 xor	 0x1B
continue_a1x2:
	 ld	 (ix+3), a
	 sla	 a
	 jr	 nc, continue_a1x4
	 xor	 0x1B
continue_a1x4:
	 ld	 (ix+4), a
	 sla	 a
	 jr	 nc, continue_a1x8
	 xor	 0x1B
continue_a1x8:
	 ld	 (ix+5), a

	 ;for a[2]
	 ld	 a, d
	 sla	 a
	 jr	 nc, continue_a2x2
	 xor	 0x1B
continue_a2x2:
	 ld	 (ix+6), a
	 sla	 a
	 jr	 nc, continue_a2x4
	 xor	 0x1B
continue_a2x4:
	 ld	 (ix+7), a
	 sla	 a
	 jr	 nc, continue_a2x8
	 xor	 0x1B
continue_a2x8:
	 ld	 (ix+8), a

	 ;for a[3]
	 ld	 a, e
	 sla	 a
	 jr	 nc, continue_a3x2
	 xor	 0x1B
continue_a3x2:
	 ld	 (ix+9), a
	 sla	 a
	 jr	 nc, continue_a3x4
	 xor	 0x1B
continue_a3x4:
	 ld	 (ix+10), a
	 sla	 a
	 jr	 nc, continue_a3x8
	 xor	 0x1B
continue_a3x8:
	 ld	 (ix+11), a

	 ;do matrix multiply
	 ;for a[0]
	 ld	 a, (ix)	;0x0e x a[0]
	 xor	 (ix+1)
	 xor   (ix+2)
	 xor	 c			; x (0x0b x a[1])
	 xor	 (ix+3)
	 xor	 (ix+5)
	 xor	 d			; x (0x0d X a[2])
	 xor	 (ix+7)
	 xor	 (ix+8)
	 xor	 e			; x (0x09 x a[3])
	 xor	 (ix+11)
	 ld	 (iy), a		;load mixed a[0]

	 ;for a[1]
	 ld	 a, b		;0x09 x a[0]
	 xor   (ix+2)
	 xor	 (ix+3)	; x (0x0e x a[1])
	 xor	 (ix+4)
	 xor	 (ix+5)
	 xor	 d			; x (0x0b X a[2])
	 xor	 (ix+6)
	 xor	 (ix+8)
	 xor	 e			; x (0x0d x a[3])
	 xor	 (ix+10)
	 xor	 (ix+11)
	 ld	 (iy+1), a		;load mixed a[1]

	 ;for a[2]
	 ld	 a, b		;0x0d x a[0]
	 xor	 (ix+1)
	 xor   (ix+2)
	 xor	 c			; x (0x09 x a[1])
	 xor	 (ix+5)
	 xor	 (ix+6)	; x (0x0e X a[2])
	 xor	 (ix+7)
	 xor	 (ix+8)
	 xor	 e			; x (0x0b x a[3])
	 xor	 (ix+9)
	 xor	 (ix+11)
	 ld	 (iy+2), a		;load mixed a[2]

	 ;for a[3]
	 ld	 a, b		;0x0b x a[0]
	 xor	 (ix)
	 xor   (ix+2)
	 xor	 c			; x (0x0d x a[1])
	 xor	 (ix+4)
	 xor	 (ix+5)
	 xor	 d			; x (0x09 X a[2])
	 xor	 (ix+8)
	 xor	 (ix+9)	; x (0x0e x a[3])
	 xor	 (ix+10)
	 xor	 (ix+11)
	 ld	 (iy+3), a		;load mixed a[3]

	 dec	 L					;assume columns < 256
	 jr	 z, aes_invmixexit
	 ld	 de, 4
	 add	 iy, de
	 jp	 aes_invmixloop

aes_invmixexit:
	 ;restore stack
	 add	 sp, 12
	 pop	 ix

	 ret


#endasm

/*** Beginheader AESaddKey4, AESinvAddKey4 */
// takes pointer to data block, round key, and size of data block in assumed to be 4 (16bytes)
__root void AESaddKey4(char *block, char *key);
__root void AESinvAddKey4(char *block, char *key);
/*** EndHeader */

#asm __root


AESaddKey4::
	; IY points to expanded key
	ld		bcde, pw
   ld		jkhl, (iy+0)
   xor	jkhl, bcde
   ld		pw, jkhl

	ld		bcde, px
   ld		jkhl, (iy+4)
   xor	jkhl, bcde
   ld		px, jkhl

	ld		bcde, py
   ld		jkhl, (iy+8)
   xor	jkhl, bcde
   ld		py, jkhl

	ld		bcde, pz
   ld		jkhl, (iy+12)
   xor	jkhl, bcde
   ld		pz, jkhl
	ld		de,16
   add	iy,de
   ret

AESinvAddKey4::
	; IY points to expanded key.
   ; This is same as above except key pointer is decremented at end
	ld		bcde, pw
   ld		jkhl, (iy+0)
   xor	jkhl, bcde
   ld		pw, jkhl

	ld		bcde, px
   ld		jkhl, (iy+4)
   xor	jkhl, bcde
   ld		px, jkhl

	ld		bcde, py
   ld		jkhl, (iy+8)
   xor	jkhl, bcde
   ld		py, jkhl

	ld		bcde, pz
   ld		jkhl, (iy+12)
   xor	jkhl, bcde
   ld		pz, jkhl
	ld		de,-16
   add	iy,de
   ret


#endasm

/*** Beginheader AESaddKey */
// takes pointer to data block, round key, and size of data block in columns (4,6, or 8)
void AESaddKey(char *block, char *key, int nb);
/*** EndHeader */

#asm

AESaddKey::
	AES_S(aes_s_addkey)
	 ld	 hl, (sp+4)		; 9  de holds pointer to key
	 ex	de,hl				; 2
	 ld	 hl, (sp+6)		; 9
	 add	hl,hl				; 2
	 add	hl,hl				; 2
	 ld	 b, L				; 2  b holds column count
	 ld	 hl, (sp+2)		; 9  hl holds block pointer : 35
aes_addkey_loop:
	 ld	 a, (de)			; 6
	 xor	 (hl)				; 5
	 ld	 (hl), a			; 6  XOR block with key
	 inc	 hl				; 2
	 inc	 de				; 2
	 djnz	aes_addkey_loop	; 5  : 26
	 ret	 					; 8 : total = 35 + 26*16 + 8 = 459

#endasm



/*** Beginheader AESexpandKey */
// takes pointer to space for expanded key, pointer to cipher key, numbers for Nb, Nk
void AESexpandKey(char __far *expanded, const char __far *key, int nb, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESexpandKey                  <AES_CRYPT.LIB>

SYNTAX:		   void AESexpandKey(char far *expanded,
											 const char far *key,
											 int nb,
											 int nk);

DESCRIPTION:   Prepares a key for use by expanding it into a set of round
					keys.

               Note: previous versions required the number of rounds
               to be specified.  This is now calculated automatically.

PARAMETER1:		expanded - A buffer for storing the expanded key. The size of
						the expanded key is 4*nb*(rounds+1)
                  where rounds is according to following table:
                  nk      rounds    AES usage
                  -----   --------  ----------
                  4       10        AES-128
                  6       12        AES-192
                  8       14        AES-256
               Other key sizes are not supported.
PARAMETER2:		key - the cipher key, the size in bytes should be 4*nk
PARAMETER3:		nb - the block size to use; must be '4' for AES.
PARAMETER4:		nk - the key size to use; must be 4,6 or 8 for AES.

END DESCRIPTION *********************************************************/

_aes_debug void AESexpandKey(char __far *expanded, const char __far *key,
																					int nb, int nk)
{
	auto int i, j, columns;
	auto char temp[4];
	auto char other_temp[4];
	auto char temp_byte;
   auto int rounds;

   rounds = AEScalcRounds(nb, nk);

	//copy cipher key into beginning of expanded key
	_f_memcpy(expanded, key, 4*nk);

	columns = nb * (rounds + 1);
	_f_memcpy(temp, expanded + 4*(nk - 1), 4);	//get first temp column
	for(i = nk; i < columns;i++)
	{
		if (!(i % nk))
		{
			//rotate
			temp_byte = temp[0];
			temp[0] = temp[1];
			temp[1] = temp[2];
			temp[2] = temp[3];
			//memcpy(temp, temp+1, 3);
			temp[3] = temp_byte;
			//sub
			AESsubBytes(AESsbox, temp, 4);
			//add rcon
			temp[0] ^= AESrcon[i / nk - 1]; //AESrcon[0] is for second round
		}
		if(nk > 6 && i % nk == 4)
		{
			AESsubBytes(AESsbox, temp, 4);
		}
		_f_memcpy(other_temp, expanded+(4*(i-nk)), 4);
		temp[0] ^= other_temp[0];
		temp[1] ^= other_temp[1];
		temp[2] ^= other_temp[2];
		temp[3] ^= other_temp[3];
		_f_memcpy(expanded + (4*i), temp, 4);
	}
}

/*** Beginheader AESencrypt */
// takes data block, expanded key, Nb, and Nk
void AESencrypt(char *data, char *expandedkey, int nb, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencrypt                    <AES_CRYPT.LIB>

SYNTAX:		   void AESencrypt(char *data,
									 	 char *expandedkey,
										 int nb,
										 int nk );

DESCRIPTION:   Encrypts a block of data in place
               Note that AES (as such) uses only nb==4 and
               nk==4,6 or 8.  Rijndael allows different block and key
               sizes than AES, however performance will be slower if
               nb is not 4.

               You can #define AES_ONLY before #use AES_CRYPT.LIB if
               you are adhering to AES.  This saves some code space.

PARAMETER1:		data - A block of data to be encrypted; must be nb*4 bytes.
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey,
               with the same nb and nk parameters!)
PARAMETER3:		nb - the block size to use. Block is 4*nb bytes long.
               Must be '4' for AES.
PARAMETER4:		nk - the key size to use. Cipher key is 4*nk bytes long.
               Must be 4,6 or 8 for AES.

END DESCRIPTION *********************************************************/


_aes_debug void AESencrypt(char *data, char *expandedkey, int nb, int nk)
{
	int rounds, i, j;


#ifdef AES_ONLY
	AESencrypt4(data, expandedkey, nk);

#else

	if (nb == 4) {
		AESencrypt4(data, expandedkey, nk);
      return;
   }

	rounds = AEScalcRounds(nb, nk);
	//initial key addition
	AESaddKey(data, expandedkey, nb);
	//do rounds
	for(i = 1;i < rounds;i++)
	{
		AESsubBytes(AESsbox, data, 4*nb);
		AESshiftRows(data, nb);
		AESmixColumns(data, nb);
		AESaddKey(data, expandedkey + 4*nb*i, nb);
	}
	//final round
	AESsubBytes(AESsbox, data, 4*nb);
	AESshiftRows(data, nb);
	AESaddKey(data, expandedkey + 4*nb*rounds, nb);

#endif // AES_ONLY
}

/*** Beginheader AESencrypt4 */
// takes data block, expanded key.  Optimized for Nb=4.
void AESencrypt4(char *data, char *expandedkey, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencrypt4                   <AES_CRYPT.LIB>

SYNTAX:		   void AESencrypt4(char *data,
									 	 char *expandedkey,
                               int nk);

DESCRIPTION:   Encrypts a block of data in place.  Same as AESencrypt()
               except optimized for most common case of 16-byte block
               size (the only size supported for AES as such).

PARAMETER1:		data - A block of data to be encrypted
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey)
PARAMETER2:		nk - key size in longwords.  Must be 4,6 or 8 for AES.

SEE ALSO:      AESencrypt4x4, AESencrypt4xK
END DESCRIPTION *********************************************************/


_aes_debug void AESencrypt4(char *data, char *expandedkey, int nk)
{
	#if _RAB6K
	setEXPCanonical();
	#endif
#asm _aes_debug
	push	pw		; These regs must be preserved

   ldl	pz,(sp+@sp+data+4)	; Data block
   ld		hl,(sp+@sp+nk+4)
	exp
   ldl	py,(sp+@sp+expandedkey+4)
	exp

   lcall _AESencrypt4xK
   
   ld		bcde,pz
   ldl	pz,(sp+@sp+data+4)
   ld		(pz+0),pw
   ld		(pz+4),px
   ld		(pz+8),py
   ld		(pz+12),bcde

   pop	pw
#endasm
}

/*** Beginheader AESdecrypt */
// takes data block, expanded key, Nb, and Nk
void AESdecrypt(char *data, char *expandedkey, int nb, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecrypt                    <AES_CRYPT.LIB>

SYNTAX:		   void AESdecrypt(char *data,
									 	 char *expandedkey,
										 int nb,
										 int nk );

DESCRIPTION:   Decrypts a block of data in place

PARAMETER1:		data - A block of data to be decrypted
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey)
PARAMETER3:		nb - the block size to use. Block is 4*nb bytes long
PARAMETER4:		nk - the key size to use. Cipher key is 4*nk bytes long

END DESCRIPTION *********************************************************/


_aes_debug void AESdecrypt(char *data, char *expandedkey, int nb, int nk)
{
	int rounds, i, j;

#ifdef AES_ONLY
	AESdecrypt4(data, expandedkey, nk);

#else

	if (nb == 4) {
		AESdecrypt4(data, expandedkey, nk);
      return;
   }

	rounds = AEScalcRounds(nb, nk);

	//first round
	AESaddKey(data, expandedkey + 4*nb*rounds, nb);
	AESinvShiftRows(data, nb);
	AESsubBytes(AESsboxI, data, 4*nb);
	//do rounds
	for(i = rounds-1;i > 0;i--)
	{
		AESaddKey(data, expandedkey + 4*nb*i, nb);
		AESinvMixColumns(data, nb);
		AESinvShiftRows(data, nb);
		AESsubBytes(AESsboxI, data, 4*nb);
	}
	//last key addition
	AESaddKey(data, expandedkey, nb);
#endif
}

/*** Beginheader AESdecrypt4 */
// takes data block, expanded key, Nb=4, and Nk
void AESdecrypt4(char *data, char *expandedkey, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecrypt4                   <AES_CRYPT.LIB>

SYNTAX:		   void AESdecrypt4(char *data,
									 	 char *expandedkey,
										 int nk );

DESCRIPTION:   Decrypts a block of data in place.  This function assumes
               that the block size (Nb) is 4 words (i.e. 16 bytes).  This
               is always the case for AES, in which case this function is
               more efficient than the general purpose AESdecrypt().

PARAMETER1:		data - A block of data to be decrypted
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey)
PARAMETER3:		nk - the key size to use. Cipher key is 4*nk bytes long.
               This parameter should be 4,6 or 8 for AES-128, AES-192 or
               AES-256 respectively.

SEE ALSO:      AESdecrypt4x4, AESdecrypt4xK
END DESCRIPTION *********************************************************/


_aes_debug void AESdecrypt4(char *data, char *expandedkey, int nk)
{
	#if _RAB6K
	setEXPCanonical();
	#endif
#asm _aes_debug
	push	pw		; These regs must be preserved

   ldl	pz,(sp+@sp+data+4)	; Data block
   ld		hl,(sp+@sp+nk+4)
	exp
   ldl	py,(sp+@sp+expandedkey+4)
	exp

   lcall _AESdecrypt4xK
   
   ld		bcde,pz
   ldl	pz,(sp+@sp+data+4)
   ld		(pz+0),pw
   ld		(pz+4),px
   ld		(pz+8),py
   ld		(pz+12),bcde

   pop	pw
#endasm
}

/*** Beginheader AEScalcRounds */
// takes Nb and Nk, returns number of rounds to use
int AEScalcRounds(int nb, int nk);
/*** EndHeader */

_aes_debug int AEScalcRounds(int nb, int nk)
{
	if(nb == 4 && nk == 4)
	{
		return 10;
	}
	else if(nb == 8 || nk == 8)
	{
		return 14;
	}
	else
	{
		return 12;
	}
}

/*** BeginHeader AESencryptStream_CBC */
void AESencryptStream_CBC( AESstreamState * state, char * text, int count );
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
AESencryptStream_CBC          <AES_CRYPT.LIB>

SYNTAX:		   void AESencryptStream_CBC(AESstreamState *state,
											    char *data,
											    int count);

DESCRIPTION:   Encrypts an array of bytes, using cipher-block chaining

PARAMETER1:		state - The AESstreamState structure
PARAMETER2:		data - an array of bytes that will be encrypted in place.
               Must be padded to be an integer multiple of 16-byte blocks.
PARAMETER3:		count - size of data array.  Must a multiple of
               _AES_CBC_BLK_SZ_



END DESCRIPTION *********************************************************/
_aes_debug
void AESencryptStream_CBC( AESstreamState * state, char * text, int count )
{
   auto int i;
   auto char *ptext, // Pointer to text -- subexpression
        *fbreg; // Pointer to state->feedback_register -- subexpression

   #ifdef AES_CBC_BUFSIZE_ALERT
      // Count must be a multiple of _AES_CBC_BLK_SZ_
      assert (0 == (count % _AES_CBC_BLK_SZ_));
   #endif

   fbreg = state->feedback_register;
   // *text = iv ^ *text
   while (count >= _AES_CBC_BLK_SZ_) {
      for (i = 0; i < _AES_CBC_BLK_SZ_; i++) {
         ptext = text + i;
         *ptext = *ptext ^ fbreg[i];
      }
      AESencrypt(text, state->expanded_key, 4, state->nk);
      memcpy(fbreg, text, _AES_CBC_BLK_SZ_);
      text += _AES_CBC_BLK_SZ_;
      count -= _AES_CBC_BLK_SZ_;
   }
}

/*** BeginHeader AESdecryptStream_CBC */
void AESdecryptStream_CBC( AESstreamState * state, char * text, int count);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
AESdecryptStream_CBC          <AES_CRYPT.LIB>

SYNTAX:		   void AESdecryptStream_CBC(AESstreamState *state,
											    char *data,
											    int count);

DESCRIPTION:   Decrypts an array of bytes, using cipher-block chaining.

PARAMETER1:		state - The AESstreamState structure
PARAMETER2:		data - an array of bytes that will be decrypted in place.
               Must be padded to be an integer multiple of 16-byte blocks.
PARAMETER3:		count - size of data array.  Must a multiple of
               _AES_CBC_BLK_SZ_

END DESCRIPTION *********************************************************/
_aes_debug
void AESdecryptStream_CBC(
      AESstreamState * state,
      char * text,
      int count )
{
   auto int i;
   auto char buf[_AES_CBC_BLK_SZ_],   // temp storage for ciphertext
        *ptext, // Pointer to text -- subexpression
        *fbreg; // Pointer to state->feedback_register -- subexpression

   #ifdef AES_CBC_BUFSIZE_ALERT
      // Count must be a multiple of _AES_CBC_BLK_SZ_
      assert (0 == (count % _AES_CBC_BLK_SZ_));
   #endif

   fbreg = state->feedback_register;
   // *text = iv ^ *text
   while (count >= _AES_CBC_BLK_SZ_) {
      memcpy(buf, text, _AES_CBC_BLK_SZ_);
      AESdecrypt(text, state->expanded_key, 4, state->nk);
      for (i = 0; i < _AES_CBC_BLK_SZ_; i++) {
         ptext = text + i;
         *ptext = *ptext ^ fbreg[i];
      }
      memcpy(fbreg, buf, _AES_CBC_BLK_SZ_);
      text += _AES_CBC_BLK_SZ_;
      count -= _AES_CBC_BLK_SZ_;
   }
}


/*** BeginHeader AESencryptStream_CBC_XMEM */
int AESencryptStream_CBC_XMEM(AESstreamState* state, long message,
            long output, unsigned int count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencryptStream_CBC_XMEM     <AES_CRYPT.LIB>

SYNTAX: int AESencryptStream_CBC_XMEM(AESstreamState* state, long message,
                     					  long output, unsigned int count);

DESCRIPTION: Perform an AES-CBC encryption operation on XMEM data.
				 Encryption is not "in-place."

PARAMETER 1: An AES stream state structure, initialized
PARAMETER 2: The message in plaintext (an xmem buffer)
PARAMETER 3: The output buffer, for return of encrypted text (in xmem), must
				 be as large as the plaintext buffer, and may be the same as the
				 plaintext buffer.
PARAMETER 4: The length of the message.  Must a multiple of
               _AES_CBC_BLK_SZ_

RETURN VALUE: 0 on success, non-zero on failure

END DESCRIPTION *********************************************************/

_aes_debug
int AESencryptStream_CBC_XMEM(AESstreamState* state, long text,
            						long output, unsigned int count)
{
   auto int i;
   auto char *ptext;  // Pointer to text in xmem
   auto char *fbreg; // Pointer to state->feedback_register -- subexpression
   auto char temp[_AES_CBC_BLK_SZ_];  // temp storage for text

   #ifdef AES_CBC_BUFSIZE_ALERT
      // Count must be a multiple of _AES_CBC_BLK_SZ_
      assert (0 == (count % _AES_CBC_BLK_SZ_));
   #endif
   if (0 != (count % _AES_CBC_BLK_SZ_)) {
      return 1;
   }

   fbreg = state->feedback_register;
   // *text = iv ^ *text
   while (count >= _AES_CBC_BLK_SZ_) {
	   xmem2root(temp, text, _AES_CBC_BLK_SZ_);
      for (i = 0; i < _AES_CBC_BLK_SZ_; i++) {
         ptext = temp + i;
         *ptext = *ptext ^ fbreg[i];
      }
      // Encrypt text and update fbreg
      AESencrypt(temp, state->expanded_key, 4, 4);
      root2xmem(output, temp, _AES_CBC_BLK_SZ_);
      memcpy(fbreg, temp, _AES_CBC_BLK_SZ_);

      text += _AES_CBC_BLK_SZ_;
      output += _AES_CBC_BLK_SZ_;
      count -= _AES_CBC_BLK_SZ_;
   }
   return 0;
}

/*** BeginHeader AESdecryptStream_CBC_XMEM */
int AESdecryptStream_CBC_XMEM(AESstreamState* state, long message,
            long output, unsigned int count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecryptStream_CBC_XMEM     <AES_CRYPT.LIB>

SYNTAX: int AESdecryptStream_CBC_XMEM(AESstreamState* state, long message,
                     					  long output, unsigned int count);

DESCRIPTION: Perform an AES-CBC decryption operation.

PARAMETER 1: An AES stream state structure, initialized
PARAMETER 2: The cipher-text message (an xmem buffer)
PARAMETER 3: The output buffer, for return of decrypted text (in xmem).  Must
				 be as large as the cipher-text buffer.  May be the same as the
				 cipher-text buffer.
PARAMETER 4: The length of the message.  Must a multiple of
               _AES_CBC_BLK_SZ_

RETURN VALUE: 0 on success, non-zero on failure

END DESCRIPTION *********************************************************/

_aes_debug
int AESdecryptStream_CBC_XMEM(AESstreamState* state, long text,
            long output, unsigned int count)
{
   auto int i;
   auto char buf[_AES_CBC_BLK_SZ_],   // temp storage for ciphertext
   	  temp[_AES_CBC_BLK_SZ_],  // temp storage for ciphertext
        *fbreg, // Pointer to state->feedback_register -- subexpression
        *ptext; // Pointer to text


   #ifdef AES_CBC_BUFSIZE_ALERT
      // Count must be a multiple of _AES_CBC_BLK_SZ_
      assert (0 == (count % _AES_CBC_BLK_SZ_));
   #endif
   if (0 != (count % _AES_CBC_BLK_SZ_)) {
      return 1;
   }

   fbreg = state->feedback_register;
   // *text = iv ^ *text
   while (count >= _AES_CBC_BLK_SZ_) {
      // get ciphertext from xmem buffer
      xmem2root(buf, text, _AES_CBC_BLK_SZ_);

      // use temp storage in root for decryption
		memcpy(temp, buf, _AES_CBC_BLK_SZ_);
      AESdecrypt(temp, state->expanded_key, 4, 4);

      for (i = 0; i < _AES_CBC_BLK_SZ_; i++) {
         ptext = temp + i;
         *ptext = *ptext ^ fbreg[i];
      }
      // Put plaintext into xmem buffer
      root2xmem(output, temp, _AES_CBC_BLK_SZ_);
      memcpy(fbreg, buf, _AES_CBC_BLK_SZ_);
      text += _AES_CBC_BLK_SZ_;
      output += _AES_CBC_BLK_SZ_;
      count -= _AES_CBC_BLK_SZ_;
   }
   return 0;
}

//tables
/*** BeginHeader AESsbox */
extern const char AESsbox[256];
/*** Endheader */

const char AESsbox[256] = {
 99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 118,
202, 130, 201, 125, 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 114, 192,
183, 253, 147,  38,  54,  63, 247, 204,  52, 165, 229, 241, 113, 216,  49,  21,
  4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 235,  39, 178, 117,
  9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 179,  41, 227,  47, 132,
 83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 190,  57,  74,  76,  88, 207,
208, 239, 170, 251,  67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 159, 168,
 81, 163,  64, 143, 146, 157,  56, 245, 188, 182, 218,  33,  16, 255, 243, 210,
205,  12,  19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 100,  93,  25, 115,
 96, 129,  79, 220,  34,  42, 144, 136,  70, 238, 184,  20, 222,  94,  11, 219,
224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121,
231, 200,  55, 109, 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8,
186, 120,  37,  46,  28, 166, 180, 198, 232, 221, 116,  31,  75, 189, 139, 138,
112,  62, 181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 134, 193,  29, 158,
225, 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223,
140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  22,
};

/*** BeginHeader AESsboxI */
extern const char AESsboxI[256];
/*** Endheader */

const char AESsboxI[256] = {
 82,   9, 106, 213,  48,  54, 165,  56, 191,  64, 163, 158, 129, 243, 215, 251,
124, 227,  57, 130, 155,  47, 255, 135,  52, 142,  67,  68, 196, 222, 233, 203,
 84, 123, 148,  50, 166, 194,  35,  61, 238,  76, 149,  11,  66, 250, 195,  78,
  8,  46, 161, 102,  40, 217,  36, 178, 118,  91, 162,  73, 109, 139, 209,  37,
114, 248, 246, 100, 134, 104, 152,  22, 212, 164,  92, 204,  93, 101, 182, 146,
108, 112,  72,  80, 253, 237, 185, 218,  94,  21,  70,  87, 167, 141, 157, 132,
144, 216, 171,   0, 140, 188, 211,  10, 247, 228,  88,   5, 184, 179,  69,   6,
208,  44,  30, 143, 202,  63,  15,   2, 193, 175, 189,   3,   1,  19, 138, 107,
 58, 145,  17,  65,  79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115,
150, 172, 116,  34, 231, 173,  53, 133, 226, 249,  55, 232,  28, 117, 223, 110,
 71, 241,  26, 113,  29,  41, 197, 137, 111, 183,  98,  14, 170,  24, 190,  27,
252,  86,  62,  75, 198, 210, 121,  32, 154, 219, 192, 254, 120, 205,  90, 244,
 31, 221, 168,  51, 136,   7, 199,  49, 177,  18,  16,  89,  39, 128, 236,  95,
 96,  81, 127, 169,  25, 181,  74,  13,  45, 229, 122, 159, 147, 201, 156, 239,
160, 224,  59,  77, 174,  42, 245, 176, 200, 235, 187,  60, 131,  83, 153,  97,
 23,  43,   4, 126, 186, 119, 214,  38, 225, 105,  20,  99,  85,  33,  12, 125,
};



/*** BeginHeader _f_AESencrypt4 */
void _f_AESencrypt4(AESstreamState __far * rk, char __far *data_in, char __far * data_out);
/*** EndHeader */

_aes_debug
void _f_AESencrypt4(AESstreamState __far * rk, char __far *data_in, char __far * data_out)
{
#asm
	push	pw		; These regs must be preserved
	exp
	ld		pz,(sp+@sp+rk+4)
	ld		py,pz+[AESstreamState]+expanded_key
	exp

   ld		pz,(sp+@sp+data_in+4)	; Data block
   ld		pw,(pz+0)
   ld		px,(pz+4)
   ld		py,(pz+8)
   ld		pz,(pz+12)

	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4

	exp
	ld		hl,[AESstreamState]+nk
   ld		a,(pz+hl)
   exp
   cp		4
   jr		z,.rounds_10
   cp		6
   jr		z,.rounds_12

.rounds_14:
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
.rounds_12:
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
.rounds_10:
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4pyp

	call	AESsubBytes4					; last round
	call	AESshiftRows4
	call	AESaddKey4pyp

   ld		bcde,pz
   ld		pz,(sp+@sp+data_out+4)
   ld		(pz+0),pw
   ld		(pz+4),px
   ld		(pz+8),py
   ld		(pz+12),bcde

   pop	pw
#endasm
}


/*** BeginHeader _f_AESdecrypt4 */
void _f_AESdecrypt4(AESstreamState __far * rk, char __far *data_in, char __far * data_out);
/*** EndHeader */

_aes_debug
void _f_AESdecrypt4(AESstreamState __far * rk, char __far *data_in, char __far * data_out)
{
	auto word rounds;
	auto char __far * ek;

	rounds = rk->nk + 6;
	ek = rk->expanded_key + (rounds<<4);

#asm
	push	pw		; These regs must be preserved

   ld		pz,(sp+@sp+data_in+4)	; Data block
   ld		pw,(pz+0)
   ld		px,(pz+4)
   ld		py,(pz+8)
   ld		pz,(pz+12)

	exp
   ld		py,(sp+@sp+ek+4)
   exp

   call  AESinvAddKey4pyp
   call	AESinvShiftRows4
   call	AESinvSubBytes4

   ld		hl,(sp+@sp+rounds+4)
   ld		a,L
   cp		10
   jr		z,.rounds_10
   cp		12
   jr		z,.rounds_12

.rounds_14:
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
.rounds_12:
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
.rounds_10:
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4pyp
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4

   call	AESinvAddKey4pyp

   ld		bcde,pz
   ldl	pz,(sp+@sp+data_out+4)
   ld		(pz+0),pw
   ld		(pz+4),px
   ld		(pz+8),py
   ld		(pz+12),bcde

   pop	pw
#endasm
}






/*** BeginHeader */
#endif
/*** EndHeader */

