/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader */
#ifndef mem_debug
	#ifdef MEM_DEBUG
	#define mem_debug __debug
	#else
	#define mem_debug __nodebug
	#endif
#endif
/*** EndHeader */

/*** BeginHeader **************************************************************/
// 'type' parameter for _xalloc():
#define XALLOC_ANY	0		// Return any type of RAM
#define XALLOC_BB		1		// Return only battery-backed (2nd RAM)
#define XALLOC_NOTBB	2		// Return only non-BB RAM.
#define XALLOC_MAYBBB 3		// Return non-BB RAM first, and only return BB RAM if no non-BB RAM remains.

typedef struct {
	void *sbreak;  // points to pointer of the top of system heap (allocates down)
	void *limit;  	// points to the line past which ubreak cannot grow
   void *next;    // points to the next root allocation region.
   char flags;		// marks memory as BB or not BB, possibly also user or system?
	char chksum;  	// simple checksum of the two above to check heap integrity
}	rbreak_t;

typedef struct {
	long sbreak;  	// points to pointer of the top of system heap (allocates down)
	long limit;  	// points to the line past which ubreak cannot grow
   long next;    	// points to the next region
   char flags;		// marks memory as BB or not BB, possibly also user or system?
	char chksum;  	// simple checksum of the two above to check heap integrity
}	xbreak_t;

/*** EndHeader */

/*** BeginHeader ubreak,  alloc_calc_chksum ***************/


__xmem char alloc_calc_chksum(void __far *, int num);
extern rbreak_t *ubreak;

/*** EndHeader ****************************************************************/

rbreak_t *ubreak;

mem_debug
__xmem char alloc_calc_chksum(void __far *p, int num) {
#asm
	ld hl, (sp+@sp+num)
   ld b, l
   dec b ;; don't include checksum in calc
   xor a
   ld	c,a
	ld px, (sp+@sp+p)
.loop:
   ld a, (px)
   add a,c
   ld	c,a
   ld	px,px+1
   djnz .loop
   ld	a,c
   cpl
   clr hl
   ld l, a
#endasm


}

/*** BeginHeader xalloc_init */
void xalloc_init(_sys_mem_origin_t *orgtbl, uint16 orgtblsize);
#if defined RAM2_START && defined RAM2_SIZE
	#define USER_XALLOC_END (RAM2_START*0x1000L+RAM2_SIZE*0x1000L)
#else
	#define USER_XALLOC_END (RAM_START*0x1000L+_RAM_SIZE_*0x1000L)
#endif
#define USER_XALLOC_START (RAM_START*0x1000L)
#define SYSTEM_XALLOC_END (USER_XALLOC_START-2L)	// must be even
/*** EndHeader */

mem_debug
void xalloc_init(_sys_mem_origin_t *orgtbl, uint16 orgtblsize) {
   auto long tmp;
   auto long prior_tmp;
   auto long prev_xsbreak;
   auto int i;
   auto xbreak_t xsbreak;
   auto long available;
   _sys_mem_origin_t *porgtbl;
	// Ensure that the allocations are aligned on an even boundary.
	#define XBREAK_T_ADJ ((sizeof(xbreak_t)-1|1)+1)

   // skip origin table entries that are not in RAM
   // Ensure user is always initialized to zero.
   xubreak = prev_xsbreak = 0L;
   prior_tmp = 0;
   i = orgtblsize-1;

	do {
	  porgtbl = &orgtbl[i];
      // Note tmp is used below in root2xmem and is used to update
      // the next pointer.
      if (porgtbl->type == RVARORG) {
      	continue;
      }
      available = porgtbl->totalbytes - porgtbl->usedbytes - 2;
      if (XBREAK_T_ADJ >= available) {
      	continue;
      }
      if (porgtbl->type == XVARORG) {
         tmp = porgtbl->paddr - available;
      }
      else {
		   tmp = porgtbl->paddr + porgtbl->usedbytes;
      }
      if(tmp <= USER_XALLOC_START) {
         break;
      }
		xsbreak.limit = tmp + XBREAK_T_ADJ;
      xsbreak.sbreak = tmp + available;
      xsbreak.next = prev_xsbreak;
      prev_xsbreak = tmp;
      xsbreak.flags = porgtbl->flags;
      xsbreak.chksum = alloc_calc_chksum(&xsbreak, sizeof(xbreak_t));
      root2xmem(tmp, &xsbreak, sizeof(xbreak_t));
      prior_tmp = tmp;
   } while(--i);
   xubreak = prior_tmp;

}

/*** BeginHeader alloc_init ***********************/
extern int alloc_init();
extern void* ulimit;
/*** EndHeader ****************************************************************/


/* START_FUNCTION DESCRIPTION ********************************************
alloc_init                <MEM.LIB>

SYNTAX:		int alloc_init(_sys_mem_origin_t*)


DESCRIPTION:	This function is called by the system start-up code to
determine system root memory allocation for ralloc and _sys_ralloc.
The _sys_mem_origin_t is a table generated by the compiler

PARAMETER1: orgtbl - Pointer to compiler generated origin table.

ALSO SEE: ralloc

RETURN VALUE:  0 - success.
					-ENOMEM - if no memory is available.

END DESCRIPTION *********************************************************/
mem_debug
int alloc_init(_sys_mem_origin_t *orgtbl, uint16 orgtblsize) {
   auto unsigned i, msize, bsize;
   auto rbreak_t *mbreak;
	auto _sys_mem_origin_t *pe;

	ubreak = NULL;
   bsize = 0;
   i = orgtblsize;
   pe = orgtbl;
	do {
   	if(pe->type == RVARORG) {
			msize = (int)(pe->totalbytes - pe->usedbytes);
         if(msize > sizeof(rbreak_t)) {
	      	mbreak = (rbreak_t*)(pe->laddr - msize);
	      	mbreak->sbreak = (void *)(pe->laddr - 1);
	         mbreak->limit = mbreak + 1;
            mbreak->flags = pe->flags;
            // Keep largest allocation at the front of list (others don't matter so much).
	         if(bsize == 0 || (msize > bsize && mbreak->flags & XALLOC_NOTBB)) {
		         bsize = msize;
               mbreak->next = ubreak;
	            ubreak = mbreak;
            }
            else {
            	mbreak->next = ubreak->next;
               ubreak->next = mbreak;
               // SJH - fix checksum, since altered by the above
					ubreak->chksum = alloc_calc_chksum(ubreak, sizeof(rbreak_t));
            }
			   mbreak->chksum = alloc_calc_chksum(mbreak, sizeof(rbreak_t));
         }
      }
      pe++;
   } while(--i);

	if(ubreak) {
   	return 0;
   }
   return -ENOMEM;		// allocation failed, no RVARORG regions found
}


/*** BeginHeader ralloc ***************************************************/
extern void *ralloc(unsigned sz);
/*** EndHeader ****************************************************************/

/* START_FUNCTION DESCRIPTION ********************************************
alloc_init                <MEM.LIB>

SYNTAX:		 void *ralloc(unsigned sz)

DESCRIPTION:	This function allocates memory from the system root memory
"heap". Memory returned is not intended to be deallocated (there is no free).

PARAMETER1: sz - The amount of root memory to allocate.

ALSO SEE: alloc_init, ravail

RETURN VALUE:  Pointer to allocated memory.
					NULL pointer on failure.

END DESCRIPTION *********************************************************/

mem_debug
void *ralloc(unsigned sz) {
   auto rbreak_t *mbreak, *next;

  	mbreak = ubreak;

   while((unsigned)(mbreak->sbreak) - (unsigned)(mbreak->limit) < sz) {
	   if(mbreak->chksum != alloc_calc_chksum(mbreak, sizeof(rbreak_t))) {
      	goto _fail;
      }
   	mbreak = mbreak->next;
      if(!mbreak) return mbreak;
   }
	mbreak->sbreak = (void*)((unsigned)(mbreak->sbreak) - sz);
   mbreak->chksum = alloc_calc_chksum(mbreak, sizeof(rbreak_t));
   return mbreak->sbreak;
// Something has gone horribly wrong with the allocation. Structure doesn't
// checksum.
_fail:
	exception(-ERR_BADXALLOC);
	exit(-ERR_BADXALLOC);
}

/*** BeginHeader ravail ***************************************************/
extern unsigned ravail(void);
/*** EndHeader ****************************************************************/

/* START_FUNCTION DESCRIPTION ********************************************
ravail                <MEM.LIB>

SYNTAX:		 unsigned ravail(void)

DESCRIPTION:	This function returns the size of the largest contiguous
             memory area which could be successfully allocated by ralloc().


ALSO SEE: alloc_init, ralloc

RETURN VALUE:  Number of bytes available.  0 if no available root memory.

END DESCRIPTION *********************************************************/

mem_debug
unsigned ravail(void) {
   auto rbreak_t *mbreak, *next;
   auto unsigned largest, chunk;

	largest = 0;

  	mbreak = ubreak;

	for (;mbreak;mbreak = mbreak->next) {
   	chunk = (unsigned)(mbreak->sbreak) - (unsigned)(mbreak->limit);
      if (chunk > largest)
      	largest = chunk;
   }
   return largest;
}

/*** BeginHeader _xalloc, xubreak *************************/
extern long _xalloc(long *, word, word);

extern long xubreak;

/*** EndHeader ****************************************************************/

/* START FUNCTION DESCRIPTION ********************************************
_xalloc                       <MEM.LIB>
SYNTAX:
   long _xalloc(long * sz, word align, word type);

DESCRIPTION:
   Allocates memory in extended memory.  If _xalloc() fails, a runtime
   error will occur.

PARAMETER1:
   sz - On entry, pointer to the number of bytes to allocate.  On return,
        the pointed-to value will be updated with the actual number of
        bytes allocated.  This may be larger than requested if an odd
        number of bytes was requested, or if some space was wasted at the
        end because of alignment restrictions.

PARAMETER2:
   align - Storage alignment as the log (base 2) of the desired returned
           memory starting address.  For example, if this parameter is
           "8," then the returned address will align on a 256-byte
           boundary.  Values between 0 and 16 inclusive are allowed.  Any
           other value is treated as zero, i.e., no required alignment.

PARAMETER3:
   type - This parameter is only meaningful on boards with more than one
          type of RAM.  For example, boards with a fast RAM and a slower
          battery-backed RAM.  Use one of the following values, any other
          value will have undefined results:
            XALLOC_ANY (0) - any type of SRAM storage allowed;
            XALLOC_BB (1) - must be battery-backed (slow) SRAM;
            XALLOC_NOTBB (2) - return non-battery-backed (fast) SRAM only;
            XALLOC_MAYBBB (3) - return non-battery-backed SRAM in
                                preference to battery-backed SRAM.
				XALLOC_URAM (4) - Rabbit 6000 only: return internal RAM only.
RETURN VALUE:
   On success, the physical address of the allocated data.
   NOTE:  This return value cannot be used directly with pointer arithmetic,
   however it can be cast to a far pointer type if required.
   On error, a runtime exception (ERR_BADXALLOC) occurs, as when _xalloc
   can not allocate requested storage or if negative size is requested.
END DESCRIPTION *********************************************************/

long xubreak;

mem_debug
long _xalloc(long * szp, word alignm, word type)
{
	auto int i;
   auto long mask, next;
   auto long sz, base;
   auto xbreak_t xsbreak;
#if _RAB6K
	char __far * uram;

	if (type & XALLOC_URAM) {
		// For now, force other bits as well.
		type = XALLOC_URAM | XALLOC_MAYBBB;
	   if ((RdPortI(MB0CR) & 15) == 3)
	      uram = (char __far *)0;
	   else if ((RdPortI(MB1CR) & 15) == 3)
	      uram = (char __far *)_QUADRANT_SIZE;
	   else if ((RdPortI(MB2CR) & 15) == 3)
	      uram = (char __far *)(_QUADRANT_SIZE*2);
	   else if ((RdPortI(MB3CR) & 15) == 3)
	      uram = (char __far *)(_QUADRANT_SIZE*3);
	   else
	      goto _fail;
	}
#endif

   sz = *szp;

   #ifdef _XALLOC_DEBUG
   	printf("B %X\n", *szp);
   #endif
   if (!alignm) {
   	alignm = 1;
   }
  	mask = ~0L << alignm;

	if (sz < 0)		// this value should fail (rounds up to 0x0000)
   	goto _fail;
   if (sz == 0)
   	return 0L;	// Allocating zero always works, and returns addres zero.
   if(!type) type = XALLOC_MAYBBB;
  	i = XALLOC_NOTBB;
	do {
	   base = 0L;
	   xsbreak.next = xubreak;
	   do {
      	next = xsbreak.next;
	      xmem2root(&xsbreak, xsbreak.next, sizeof(xbreak_t));

	      if(xsbreak.chksum != alloc_calc_chksum(&xsbreak, sizeof(xbreak_t)))
	         goto _fail;
	      //      xsbreak.flags
	      base = xsbreak.sbreak - sz & mask;
	   #if _RAB6K
	   	if (type & XALLOC_URAM) {
	   		if ((char __far *)base <= uram || (char __far *)base > uram+(1u<<20))
	   			continue;
	   	}
	   #endif
			if(xsbreak.flags & i & type && base >= xsbreak.limit) {
            *szp = xsbreak.sbreak - base;
				xsbreak.sbreak = base;
				xsbreak.chksum = alloc_calc_chksum(&xsbreak, sizeof(xbreak_t));
			   root2xmem(next, &xsbreak, sizeof(xbreak_t));
			   #ifdef _XALLOC_DEBUG
			   	printf("E %X %X\n", base, *szp);
			   #endif
			   return base;
         }
	   } while(xsbreak.next);
	} while(--i);
_fail:
	exception(-ERR_BADXALLOC);
	exit(-ERR_BADXALLOC);
}


/*** BeginHeader xrelease */
extern void xrelease(long addr, long sz);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
xrelease                      <MEM.LIB>

SYNTAX: void xrelease(long addr, long sz);

DESCRIPTION: Release a block of memory previously obtained by xalloc() or
by xavail() with a non-null parameter.  xrelease() may only be called to
free the most recent block obtained.  It is NOT a general-purpose
malloc/free type dynamic memory allocator.  Calls to xalloc()/xrelease()
must be nested in first-allocated/last-released order, similar to the
execution stack.  The addr parameter must be the return value from
xalloc().  If not, then a runtime exception will occur.  The sz parameter
must also be equal to the actual allocated size, however this is not
checked.  The actual allocated size may be larger than the requested
size (because of alignment overhead).  The actual size may be obtained by
calling _xalloc() rather than xalloc().  For this reason, it is recommended
that your application consistently uses _xalloc() rather than xalloc()
if you intend to use this function.

PARAMETER1: addr: Address of storage previously obtained by _xalloc().
PARAMETER2: sz: Size of storage previously returned by _xalloc().  Size must
be even or the function will cause an exception.

KEYWORDS: xalloc

SEE ALSO: xalloc, _xalloc, xavail, _xavail, xalloc_stats
END DESCRIPTION *********************************************************/

mem_debug
void xrelease(long addr, long sz)
{
  	auto int i;
   auto long next;
   auto xbreak_t xsbreak;

	if(sz & 1) goto _fail;

   xsbreak.next = xubreak;

	while(xsbreak.next) {
   	next = xsbreak.next;
      xmem2root(&xsbreak, xsbreak.next, sizeof(xbreak_t));
		if(xsbreak.sbreak == addr) {
      	xsbreak.sbreak += sz;
		   xsbreak.chksum = alloc_calc_chksum(&xsbreak, sizeof(xbreak_t));
	      root2xmem(next, &xsbreak, sizeof(xbreak_t));
			return;
      }
	}
_fail:
	exception(-ERR_BADXALLOC);
	exit(-ERR_BADXALLOC);
}


/* START FUNCTION DESCRIPTION ********************************************
_xavail                       <MEM.LIB>

SYNTAX: long _xavail(long * addr_ptr, word align, word type);

DESCRIPTION: Returns the maximum length of memory that may be successfully
obtained by an immediate call to _xalloc(), and optionally allocates that
amount.  The 'align' and 'type' parameters are the same as would be
presented to _xalloc().

PARAMETER1: addr_ptr: Address of a longword, in root data memory, to store
the address of the block.  If this pointer is NULL, then the block is not
allocated.  Otherwise, the block is allocated as if by a call to _xalloc().
PARAMETER2: align: alignment of returned block, as per _xalloc().
PARAMETER3: type: type of memory, as per _xalloc().

RETURN VALUE: The size of the largest free block available.  If this is zero,
then *addr_ptr will not be changed.

KEYWORDS: xalloc

SEE ALSO: xalloc, _xalloc, xavail, xrelease, xalloc_stats
END DESCRIPTION *********************************************************/

/*** BeginHeader _xavail **************************************************/
extern long _xavail(long * addr_ptr, word alignm, word type);
/*** EndHeader ***************************************************************/

mem_debug
long _xavail(long * addr_ptr, word alignm, word type)
{
  	auto int i;
   auto long mask;
   auto long sz, maxsz;
   auto xbreak_t xsbreak;

   sz = maxsz = 0;

   if (!alignm) {
   	alignm = 1;
   }
  	mask = ~0L << alignm;

   if(!type) type = XALLOC_MAYBBB;

  	i = XALLOC_NOTBB;
	do {
	   xsbreak.next = xubreak;
	   do {
	      xmem2root(&xsbreak, xsbreak.next, sizeof(xbreak_t));
         // Check integrity of structure
	      if(xsbreak.chksum != alloc_calc_chksum(&xsbreak, sizeof(xbreak_t)))
	         goto _fail;
	      //      xsbreak.flags
	      sz = xsbreak.sbreak - (xsbreak.limit + ~mask & mask);
			if(xsbreak.flags & i & type && sz > maxsz) {
         	maxsz = sz;
         }
	   } while(xsbreak.next);
	} while(--i);

	if (addr_ptr && maxsz > 0)
		*addr_ptr = _xalloc(&maxsz, alignm, type);
	return maxsz;
_fail:
	exception(-ERR_BADXALLOC);
	exit(-ERR_BADXALLOC);
}


/*** BeginHeader _ralloc_stats ************************************************/
void _ralloc_stats(rbreak_t *_rkbreak);
/*** EndHeader ****************************************************************/


void _ralloc_stats(rbreak_t *_rkbreak) {

   printf("Available ralloc() regions for _rkbreak = 0x%04x:\n\n", _rkbreak);

   printf("limit=%u=0x%04x  _r+1=0x%04x  sbreak=%u=0x%04x\n",
			  	 _rkbreak->limit, _rkbreak->limit,
				 (unsigned)_rkbreak + sizeof(_rkbreak),
			  	 _rkbreak->sbreak,_rkbreak->sbreak
	         );
   printf("Data struct Limit(Low)  Current(Hi) Avail       \n");
   printf("----------  ----------  ----------  ----------  \n");

	while(_rkbreak) {
		if(_rkbreak->chksum != alloc_calc_chksum(_rkbreak, sizeof(rbreak_t))) {
			printf("*** CHECKSUM ERROR AT 0x%04X ***\n", _rkbreak);
			break;
		}
	   printf("    0x%04x      0x%04x      0x%04x      0x%04x      %s\n\n",
	             _rkbreak,
	             (unsigned)_rkbreak->limit,
	             _rkbreak->sbreak,
	             (unsigned)_rkbreak->sbreak - (unsigned)_rkbreak->limit,
	             _rkbreak->flags & XALLOC_BB ? "BB RAM" : "normal"
	            );
	   _rkbreak = _rkbreak->next;
   }
}


//#undef _xxalloc
//xbreak_t xsbreak;

/******************************************************************************
// IDEA: Write algorithm that initializes on start-up
******************************************************************************/


/* START_FUNCTION DESCRIPTION ********************************************
_init_xalloc                  <MEM.LIB>

SYNTAX: void _init_xalloc();

DESCRIPTION: Initializes data structure with physical addresses that
xalloc() may use to allocate memory.  _init_alloc() is normally called
by premain and must be called before calling xalloc(), _Init_Stack(), and
_Alloc_Stack().

_init_xalloc() uses the _orgtable structure generated by the compiler
to calculate what regions of physical memory are free for xalloc use.
The Dynamic C compiler creates entries in the _orgtable for each
origin directive that uses memory.  Note that the compiler merges some
regions into one when they are contiguous.

WARNING: This function is normally called from premain.
Do not call this function from main because it will clobber
data allocated by stack allocation in premain!

RETURN VALUE: None.

KEYWORDS: xalloc, _Init_Stack, _Alloc_Stack, premain
END DESCRIPTION *********************************************************/

/*** BeginHeader _init_xalloc */
void _init_xalloc();
/*** EndHeader */

mem_debug
void _init_xalloc()
{
	char *p;
   #ifdef MEM_DEBUG
   	long msize;
	#endif

   if (alloc_init(_orgtable, _orgtablesize) == -ENOMEM)
   {
      exception(-ENOMEM);
      exit(-ENOMEM);
   }

   xalloc_init(_orgtable, _orgtablesize);
   #ifdef MEM_DEBUG
   msize= 0x1000;
   //xalloc_stats(xubreak);
   msize = _xalloc(&msize, 1, XALLOC_MAYBBB);
   #endif
}



/*** BeginHeader xalloc_stats */
__xmem void xalloc_stats(long xpointer);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
xalloc_stats                  <MEM.LIB>

SYNTAX: void xalloc_stats(long xpointer)

DESCRIPTION:   Prints a table of available xalloc() regions to the
               stdout window.  This function is for debugging and
               educational purposes.  It should not be called in a
               production program.

PARAMETER1:    address of the data structure xbreak_t.  Must not be 0.

SEE ALSO:		xalloc, _xalloc, xavail, _xavail, xrelease

END DESCRIPTION *********************************************************/
mem_debug
__xmem void xalloc_stats(long xpointer)
{
	auto long next;
   auto xbreak_t xsbreak;

	if(0 == xpointer) {
		printf("Error - must pass location of xbreak_t data structure.\n");
		return;
	}

   printf("Available xalloc() regions:\n\n");

   printf("Low addr    High addr   Current     Avail       Type\n");
   printf("----------  ----------  ----------  ----------  -------\n");
   next = xpointer;
   while(next) {
      xmem2root(&xsbreak, next, sizeof(xbreak_t));
		if(xsbreak.chksum != alloc_calc_chksum(&xsbreak, sizeof(xbreak_t))) {
			printf("*** CHECKSUM ERROR AT 0x%06lX ***\n", next);
			break;
		}

		//               1         2         3         4         5         6
		//      12345678901234567890123456789012345678901234567890123456789012345
			//      Low addr    High addr   Current     Size        Avail       Type
		//      ----------  ----------  ----------  ----------  ----------  -------
      printf("%10lX  %10lX  %10lX  %10lX  %s\n",
             next + sizeof(xbreak_t),
             xsbreak.sbreak,
             xsbreak.sbreak,
             xsbreak.sbreak - xsbreak.limit,
             xsbreak.flags & XALLOC_BB ? "BB RAM" : "normal"
            );
      next = xsbreak.next;
   }
}

/*** BeginHeader basic_program_stats */
__xmem void basic_program_stats(void);
/*** EndHeader */
mem_debug
void _bpstats_print(char * label, ADDR24 x[2], long tot, int rt)
{
	unsigned long mb,mt,ms;
   mb = 0x0ffffful &
        ((unsigned long)x[0].aaa.a.addr +
         ((unsigned long)x[0].aaa.a.base << 12));
   mt = 0x0ffffful &
      ((unsigned long)x[1].aaa.a.addr +
      ((unsigned long)x[1].aaa.a.base << 12));
   ms = mt-mb;
	if (rt)
		// Whacky, but compiler sometimes stores begin/end reversed.
		ms = -ms;
	if (tot)
		printf("%.29s\t%lu\t/%lu\n", label, ms, tot);
	else
		printf("%.29s\t%lu\n", label, ms);
}

mem_debug
__xmem void basic_program_stats(void)
{
	_sys_mem_origin_t * o;
	int i;
	unsigned long lo, hi, xd;
	xbreak_t __far * xsbreak;

	// This uses the BIOS "prog_param" variable to print actual code and data
	// usage in a running program.  These are static values.
	// Doesn't count BB data.
	#ifndef ___RCODESIZE
		#orgmac ___RCODESIZE = rootcode size
	#endif
	_bpstats_print("Root code+BIOS", &prog_param.RCB,  ___RCODESIZE,  0);
	#ifndef ___XCODE_SIZE
		#orgmac ___XCODE_SIZE = xmemcode size
	#endif
	_bpstats_print("XMEM code",      &prog_param.XCB,  ___XCODE_SIZE, 0);
#if __SEPARATE_INST_DATA__
	#ifndef ___CONST_SIZE
		#orgmac ___CONST_SIZE = rootconst size
	#endif
	_bpstats_print("Root constants", &prog_param.RCDB, ___CONST_SIZE, 0);
#endif
	#ifndef ___RDATA_SIZE
		#orgmac ___RDATA_SIZE = rootdata size
	#endif
	_bpstats_print("Root variables", &prog_param.RDB,  ___RDATA_SIZE, 1);

	// Unfortunately, compiler doesn't set up this field correctly.  Can guess
	// by looking at XVARORGs in org table, and seeing what's *not* devoted
	// to xalloc.
	//_bpstats_print("XMEM variables", &prog_param.XDB, 0, 0);
	xd = 0;
	for (i = 0, o = _orgtable; i < _orgtablesize; ++i, ++o) {
		if (o->type != XVARORG)
			continue;
      // allocates down
      lo = o->paddr + o->usedbytes - o->totalbytes;
      hi = o->paddr + o->usedbytes;
      // find xbreak inside this range, and add any unused to total xd
      for (xsbreak = (xbreak_t __far *)xubreak; xsbreak;
      			xsbreak = (xbreak_t __far *)xsbreak->next) {
	      if(xsbreak->chksum != alloc_calc_chksum(xsbreak, sizeof(xbreak_t))) {
	         break;
	      }
			if ((unsigned long)xsbreak >= lo && (unsigned long)xsbreak < hi) {
				xd += (hi-lo) - (xsbreak->sbreak - xsbreak->limit + sizeof(xbreak_t));
				break;
			}
      }

	}
	printf("%.29s\t%lu\n", "XMEM variables", xd);
}

/*** BeginHeader orgtable_stats */
__xmem void orgtable_stats(_sys_mem_origin_t * orgtable, int orgtablesize);
/*** EndHeader */

void _printorgtype(char type);

mem_debug
void _get_xalloc_range(char * xas, long lo, long hi, long xpointer)
{
   auto xbreak_t __far * xsbreak = (xbreak_t __far *)xpointer;

	*xas = 0;
   while(xsbreak) {
		if(xsbreak->chksum != alloc_calc_chksum(xsbreak, sizeof(xbreak_t))) {
			break;
		}
		if ((long)xsbreak >= lo && (long)xsbreak <= hi) {
			sprintf(xas, "%lX..%lX (%lX)", xsbreak + 1, xsbreak->sbreak,
				xsbreak->sbreak - xsbreak->limit);
			break;
		}
      xsbreak = (xbreak_t __far *)xsbreak->next;
   }
}
mem_debug
void _get_ralloc_range(char * xas, long lo, long hi, void * xpointer)
{
   auto rbreak_t * xsbreak = (rbreak_t *)xpointer;

	*xas = 0;
   while(xsbreak) {
		if(xsbreak->chksum != alloc_calc_chksum(xsbreak, sizeof(rbreak_t))) {
			break;
		}
		if ((long)xsbreak >= lo && (long)xsbreak <= hi) {
			sprintf(xas, "%X..%X (%X) [R]", xsbreak + 1, xsbreak->sbreak,
				(char *)xsbreak->sbreak - (char *)xsbreak->limit);
			break;
		}
      xsbreak = (rbreak_t *)xsbreak->next;
   }
}
mem_debug
void orgtable_stats(_sys_mem_origin_t * orgtable, int orgtablesize) {
	int i;
	long lo, hi;
	char xas[32];

	if (!orgtable) {
		orgtable = _orgtable;
		orgtablesize = _orgtablesize;
	}

	printf("ROOT_SIZE_4K = %d (=%u bytes)\n", ROOT_SIZE_4K, ROOT_SIZE_4K*4096);
   #ifdef XMEMCODE_SIZE
		printf("XMEMCODE_SIZE = 0x%lX (=%lu)\n", (long)XMEMCODE_SIZE,
      		(long)XMEMCODE_SIZE);
   #else
      #if FLASH_COMPILE
      	#define FLASH_COMPILE_WARNING " in flash compile mode"
      #else
      	#define FLASH_COMPILE_WARNING ""
      #endif
   	printf("XMEMCODE_SIZE: not available" FLASH_COMPILE_WARNING "\n");
      #undef FLASH_COMPILE_WARNING
   #endif
	//      123456789012345678901234567890
	printf("#\tType\tPhys\t\tUsed\tTotal\tQuad\txalloc\n");
	for(i = 0; i < orgtablesize; ++i, ++orgtable) {
		printf("%2d\t", i);
	   _printorgtype(orgtable->type);
	   if (orgtable->type == RVARORG || orgtable->type == XVARORG ||
	       orgtable->type == WVARORG) {
	   	// allocates down
	   	lo = orgtable->paddr + orgtable->usedbytes - orgtable->totalbytes;
	   	hi = orgtable->paddr + orgtable->usedbytes - 1;
	   }
	   else {
	   	// allocates up
	   	lo = orgtable->paddr;
	   	hi = orgtable->paddr + orgtable->totalbytes - 1;
	   }
	   _get_xalloc_range(xas, lo, hi, xubreak);
	   if (!xas[0])
	   	_get_ralloc_range(xas, lo, hi, ubreak);
      printf("%6lX - %6lX\t%6lX\t%6lX\t%d-%d\t%s\n",
      	lo,
      	hi,
      	orgtable->usedbytes,
      	orgtable->totalbytes,
      	xGetQuadrant(lo), xGetQuadrant(hi),
      	xas
      	);
   }
}

mem_debug
void _printorgtype(char type) {
	char *s;
	switch(type) {
   case UNKNOWN_ORG:
   	s = "UNKNOWN_ORG";
   	break;
   case RCODORG:
      s = "RCODORG";
   	break;
   case XCODORG:
      s = "XCODORG";
   	break;
   case WCODORG:
      s = "WCODORG";
   	break;
   case RVARORG:
      s = "RVARORG";
   	break;
   case XVARORG:
      s = "XVARORG";
   	break;
	case WVARORG:
      s = "WVARORG";
   	break;
   case RCONORG:
      s = "RCONORG";
   	break;
   case RESVORG:
      s = "RESVORG";
   	break;
   }
	printf("%s\t",s);
}


/*** BeginHeader print_mmu_regs */
__xmem void print_mmu_regs(void);
/*** EndHeader */
__nodebug __xmem void print_mmu_regs(void)
{
	auto word i;
	printf("\n============= MMU registers =============\n");
	printf("Reg\tVal\tShadowVal\n");
	printf("ACS0CR\t%02X\t--\n", RdPortI(ACS0CR));
	printf("ACS1CR\t%02X\t--\n", RdPortI(ACS1CR));
	#if _RAB6K
		printf("ACS2CR\t%02X\t--\n", RdPortI(ACS2CR));
	#endif
	printf("MACR\t%02X\t--\n", RdPortI(MACR));
	printf("MB0CR\t%02X\t%02X\n", RdPortI(MB0CR), MB0CRShadow);
	printf("MB1CR\t%02X\t%02X\n", RdPortI(MB1CR), MB1CRShadow);
	printf("MB2CR\t%02X\t%02X\n", RdPortI(MB2CR), MB2CRShadow);
	printf("MB3CR\t%02X\t%02X\n", RdPortI(MB3CR), MB3CRShadow);
	printf("MECR\t%02X\t--\n", RdPortI(MECR));
	printf("DATASEG\t%02X\t--\n", RdPortI(DATASEG));
	printf("STKSEG\t%02X\t--\n", RdPortI(STACKSEG));
	printf("SEGSIZE\t%02X\t--\n", RdPortI(SEGSIZE));
	printf("MMIDR\t%02X\t%02X\n", RdPortI(MMIDR), MMIDRShadow);
	printf("RAMSR\t%02X\t--\n", RdPortI(RAMSR));
	printf("DTASEGX\t%04X\t----\n", RdPortI(DATASEGH)<<8 | RdPortI(DATASEGL));
	printf("STKSEGX\t%04X\t----\n", RdPortI(STACKSEGH)<<8 | RdPortI(STACKSEGL));
	printf("\n");
   for (i = 0; i < 0xF000; i += 0x1000)
   	printf("paddr(%04X)=%08lX\n", i, paddr((void *)i));
	printf("=========================================\n\n");
}

/*** BeginHeader _print_stacks */
__xmem void _print_stacks(void);
/*** EndHeader */

__nodebug __xmem void _print_stacks(void)
{
	auto word alloc, i, ssize;
	auto long seg;

	printf("\n%12s%12s%12s%12s%12s\n",
	       "Stack #", "Allocated", "Size", "paddr", "segaddr");
	for (i = 0; i < TOTAL_STACK_CNT; ++i)
	{
		alloc = (word) (freeStacks[i] >> 31 & 0x1);
		ssize = stackSizes[(int) (freeStacks[i] >> 24 & 0x7FuL)];
		seg = freeStacks[i] & 0xFFFFFFuL;
 		_gen_lin2seg(&seg, 0xd);
		printf("%12u%12u%12u    %08lX    %08lX\n",
		       i, alloc, ssize, freeStacks[i] & 0xFFFFFFuL, seg);
	}
	printf("%s%s%s%s%s\n", "    ========", "    ========", "    ========",
	       "    ========", "    ========");
}

/*** BeginHeader memory_usage_table */
void _mut_separator(void);
void _mut_entry(unsigned logaddr, long physaddr, long Size, char *use);
void memory_usage_table(void);
/*** EndHeader */

mem_debug
void _mut_separator(void)
{
	printf(" \xC3--------------------------------------------------------------"\
	       "--------------\xB4\n");
}

mem_debug
void _mut_entry(unsigned logaddr, long physaddr, long Size, char *use)
{
	auto unsigned xAddr;
	auto unsigned long addr32, xBase;

	// *** base seg entry ***
	if (logaddr < ROOTDATAORG) {
		printf(" \xB3 %06lx  %03x:%04x  %06lx  %8ld  %-38.38s \xB3\n",
		       physaddr, 0, logaddr, Size, Size, use);
	}
	// *** data seg entry ***
	else if (logaddr < STACKORG) {
		printf(" \xB3 %06lx  %03x:%04x  %06lx  %8ld  %-38.38s \xB3\n",
		       physaddr, RdPortI16(DATASEGL), logaddr, Size, Size, use);
	}
	// *** stack seg entry ***
	else if (logaddr < 0xE000u) {
		printf(" \xB3 %06lx  %03x:%04x  %06lx  %8ld  %-38.38s \xB3\n",
		       physaddr, RdPortI16(STACKSEGL), logaddr, Size, Size, use);
	}
	// *** xmem seg entry ***
	// if log address is in E000-FFFF range ignore logical entry parameter
	// and convert physical address to a an E000-FFFF logical address
	else {
		addr32 = physaddr - 0xe000ul;
		xBase = (addr32 & 0x00fff000) >> 12;
		xAddr = (unsigned) ((addr32 & 0x00000fff) | 0xe000);
		printf(" \xB3 %06lx  %03lx:%04x  %06lx  %8ld  %-38.38s \xB3\n",
		       physaddr, xBase, xAddr, Size, Size, use);
	}
}

__debug
void memory_usage_table(void)
{
	int i;
	long next;
	unsigned long mb, mt, ms, rcon;
	xbreak_t xsbreak;
	const _sys_mem_origin_t * org_entry;

	printf(" \xda--------------------------------------------------------------"\
	       "--------------\xbf\n");
	printf(" \xB3 PHYSADR LOGADR    SIZE    SIZE(Dec) USAGE                    "\
	       "              \xB3\n");

	_mut_separator();
#ifdef _FLASH_
	printf(" \xB3 FLASH                                                        "\
	       "              \xB3\n");
#else
	printf(" \xB3 RAM                                                          "\
	       "              \xB3\n");
#endif
	_mut_separator();

	//********** Root Code  ***************
	#ifndef ___RCODESIZE
		#orgmac ___RCODESIZE = rootcode size
	#endif
	_mut_entry(0, 0, ___RCODESIZE, "Reserved by Compiler for Root Code");
	_mut_entry(0, 0, (long) StartUserCode - 1, "Used by BIOS");
	_mut_entry((unsigned) StartUserCode, (long) StartUserCode,
	            prog_param.RCE.aaa.a.addr - (long) StartUserCode,
	            "Used by this program for root code");

#if __SEPARATE_INST_DATA__
	#orgmac ___CONST_START = rootconst physical start
	#ifndef ___CONST_SIZE
		#orgmac ___CONST_SIZE = rootconst size
	#endif
	_mut_entry(0, ___CONST_START, ___CONST_SIZE, "Reserved for Root Constants");
#endif
	rcon = 0x0ffffful &
	     ((unsigned long)prog_param.RCDB.aaa.a.addr +
	      ((unsigned long)prog_param.RCDB.aaa.a.base << 12));
	_mut_entry(prog_param.RCDB.aaa.a.addr,
					rcon,
	            prog_param.RCDE.aaa.a.addr - prog_param.RCDB.aaa.a.addr,
	            "Used by this program for root constants");

	_mut_separator();

	//********** XMem Code  ***************
	#orgmac ___XMEMCODE_START = xmemcode physical start
	#ifndef ___XCODE_SIZE
		#orgmac ___XCODE_SIZE = xmemcode size
	#endif
	_mut_entry(0xffff, ___XMEMCODE_START, ___XCODE_SIZE,
	            "Reserved for Xmem Code");

	mb = 0x0ffffful &
	     ((unsigned long)prog_param.XCB.aaa.a.addr +
	      ((unsigned long)prog_param.XCB.aaa.a.base << 12));
	mt = 0x0ffffful &
		((unsigned long)prog_param.XCE.aaa.a.addr +
		((unsigned long)prog_param.XCE.aaa.a.base << 12));
	ms = mt-mb;

	_mut_entry(0xffff, mb, ms, "Used by this program for xmem code");

	_mut_separator();

#ifdef _FLASH_
	printf(" \xB3 RAM                                                          "\
	       "              \xB3\n");
#else
	printf(" \xB3 MORE RAM (Code and BIOS in RAM option set in compiler options"\
	       ")             \xB3\n");
#endif
	_mut_separator();

	//********** Root RAM ***************

	#orgmac ___DATA_START = rootdata physical start
	#ifndef ___RDATA_SIZE
		#orgmac ___RDATA_SIZE = rootdata size
	#endif
	_mut_entry(ROOTDATA_LOGICAL_START, ___DATA_START, ___RDATA_SIZE,
	            "Reserved for Root Data");

#if defined BBROOTDATA_SIZE && BBROOTDATA_SIZE > 0
	#orgmac ___BBDATA_START = bbrootdata physical start
	_mut_entry(BBROOTDATA_LOGICAL_START, ___BBDATA_START, BBROOTDATA_SIZE,
	            "Reserved for Battery Backed Root Data");
#endif

	_mut_entry(prog_param.RDE.aaa.a.addr,
	            paddr((void *) prog_param.RDE.aaa.a.addr),
	            (long) prog_param.RDB.aaa.a.addr - prog_param.RDE.aaa.a.addr + 1,
	            "Used by this program for root data");

	_mut_entry(INTVEC_BASE, paddr((void *) (INTVEC_BASE)), INTVEC_TABLE_SIZE,
	            "Internal interrupts vector table");

	_mut_entry(XINTVEC_BASE, paddr((void *) (XINTVEC_BASE)), XINTVEC_TABLE_SIZE,
	            "External interrupts vector table");

	_mut_separator();

	//********** Display xalloc used areas ***************
	// includes RAM space reserved for items already listed
	for (i = 0; i < _orgtablesize; ++i) {
		org_entry = &_orgtable[i];
		if (org_entry->type == RESVORG) {
			_mut_entry(org_entry->laddr, org_entry->paddr, org_entry->totalbytes,
			            "Reserved RAM space");
		}
	}

	_mut_separator();

	//********** Stacks ***************
	_mut_entry(0xffff, BaseOfStacks1, SizeOfStacks1, "Stack space");

	_mut_separator();

	//********** Display xalloc free areas ***************
	next = xubreak;
	while (next) {
		xmem2root(&xsbreak, next, sizeof (xbreak_t));
		_mut_entry(0xe000, next + sizeof (xbreak_t),
		            xsbreak.sbreak - xsbreak.limit, "Free XRAM space for xalloc");
		next = xsbreak.next;
	}

#if !_SERIAL_BOOT_FLASH_ && (FAST_RAM_COMPILE || RAM_COMPILE)
	_mut_separator();

	#orgmac ___MB3_FLASH_START = flash physical start
	#orgmac ___MB3_FLASH_SIZE = flash size
	//********** flash in the MB3CR quadrant ***************
	_mut_entry(0xffff, ___MB3_FLASH_START, ___MB3_FLASH_SIZE,
	            "Reserved for ID / User blocks access");
#endif

	// bottom of table
	printf(" \xC0--------------------------------------------------------------"\
	       "--------------\xd9\n\n");

}

/*** BeginHeader mmu_miu_regs */
void mmu_miu_regs(void);
/*** EndHeader */

__debug
void mmu_miu_regs(void)
{
	printf("MMU Registers:\n");
	printf("   SEGSIZE  =  %02x\n", RdPortI(SEGSIZE));
	printf("   DATASEG  = %03x\n", RdPortI16(DATASEGL));
	printf("   STACKSEG = %03x\n", RdPortI16(STACKSEGL));
#orgmac ___XMEMCODE_SEGMENT = xmemcode segment start
	printf("   XPC      = %03x\n\n", 0xfff & (___XMEMCODE_SEGMENT));
	printf("MIU Registers:\n");
	printf("   MB0CR    =  %02x\n", RdPortI(MB0CR));
	printf("   MB1CR    =  %02x\n", RdPortI(MB1CR));
	printf("   MB2CR    =  %02x\n", RdPortI(MB2CR));
	printf("   MB3CR    =  %02x\n", RdPortI(MB3CR));
	printf("   MECR     =  %02x\n\n", RdPortI(MECR));
}

