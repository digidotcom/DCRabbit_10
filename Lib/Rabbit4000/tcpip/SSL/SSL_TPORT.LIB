/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
SSL_TPORT.LIB

DESCRIPTION:

  This library defines an interface to the TLS/SSL library.  It allows TLS to
  be used over any reliable transport layer, not just TCP sockets.

  The API is designed to satisfy the expectations of the
  WPA supplicant library, however it is also used as the core of
  a transport-agnostic TLS API.  If you wish to use TLS over TCP/IP
  sockets, then #use SSL_SOCK.LIB instead.

  This library supports:
    - Server-side
    - Client-side
    - Far pointers throughout
    - Arbitrary number of sessions (limited by _sys_malloc() memory)
    - Session resumption for both client and server sides
    - "non-blocking" RSA private key operations.
    - Use of X509 certificates
    - Verification of certificates against a list of trusted CAs
    - MD5, SHA-1 or SHA-256 message authentication
    - RC4 or AES bulk encryption
    - RSA key exchange and authentication

  Based on...
    - WPA Supplicant / TLS interface definition
    - Original Rabbit SSL module
  ...but with many enhancements.

  The following features are not implemented, but reserved for a future
  release:
    - Inner authentication protocols, TLS/IA
    - Tickets and client hello extensions
    - Key exchange and authentication other than RSA-based (such
      as Diffie-Hellman or DSS).

END DESCRIPTION **********************************************************/
/*** BeginHeader */

#ifndef _SSL_TPORT_H
#define _SSL_TPORT_H

#ifndef __SSL_DEFS_LIB__
	#use "ssl_defs.lib"
#endif

#ifdef SSL_TPORT_DEBUG
	#define _ssl_tport_debug __debug
#else
	#define _ssl_tport_debug __nodebug
#endif



// This structure used by tls_connection_get_keys()
struct tls_keys {
	char __far *master_key;		/* TLS master secret */
	size_t master_key_len;
	char __far *client_random;
	size_t client_random_len;
	char __far *server_random;
	size_t server_random_len;
	char __far *inner_secret;		/* TLS/IA inner secret */
	size_t inner_secret_len;
};

// This structure is for compatibility with wpa supplicant, however
// this library does not make any use of it.
struct tls_config {
	char __far *opensc_engine_path;
	char __far *pkcs11_engine_path;
	char __far *pkcs11_module_path;
};

/**
 * struct tls_connection_params - Parameters for TLS connection
 * @ca_cert: File or reference name for CA X.509 certificate in PEM or DER
 * format
 * @ca_cert_blob: ca_cert as inlined data or %NULL if not used
 * @ca_cert_blob_len: ca_cert_blob length
 * @ca_path: Path to CA certificates (OpenSSL specific)
 * @subject_match: String to match in the subject of the peer certificate or
 * %NULL to allow all subjects
 * @altsubject_match: String to match in the alternative subject of the peer
 * certificate or %NULL to allow all alternative subjects
 * @client_cert: File or reference name for client X.509 certificate in PEM or
 * DER format
 * @client_cert_blob: client_cert as inlined data or %NULL if not used
 * @client_cert_blob_len: client_cert_blob length
 * @private_key: File or reference name for client private key in PEM or DER
 * format (traditional format (RSA PRIVATE KEY) or PKCS#8 (PRIVATE KEY)
 * @private_key_blob: private_key as inlined data or %NULL if not used
 * @private_key_blob_len: private_key_blob length
 * @private_key_passwd: Passphrase for decrypted private key, %NULL if no
 * passphrase is used.
 * @dh_file: File name for DH/DSA data in PEM format, or %NULL if not used
 * @dh_blob: dh_file as inlined data or %NULL if not used
 * @dh_blob_len: dh_blob length
 * @engine: 1 = use engine (e.g., a smartcard) for private key operations
 * (this is OpenSSL specific for now)
 * @engine_id: engine id string (this is OpenSSL specific for now)
 * @ppin: pointer to the pin variable in the configuration
 * (this is OpenSSL specific for now)
 * @key_id: the private key's key id (this is OpenSSL specific for now)
 * @tls_ia: Whether to enable TLS/IA (for EAP-TTLSv1)
 *
 * TLS connection parameters to be configured with tls_connection_set_params()
 * and tls_global_set_params().
 *
 * Certificates and private key can be configured either as a reference name
 * (file path or reference to certificate store) or by providing the same data
 * as a pointer to the data in memory. Only one option will be used for each
 * field.
 */
struct tls_connection_params {
#if _SSL_USE_RSA_
	char __far *ca_cert;
	SSL_Cert_t __far *ca_cert_blob;
	size_t ca_cert_blob_len;
	char __far *ca_path;
	char __far *subject_match;
	char __far *altsubject_match;
	char __far *client_cert;
	SSL_Cert_t __far *client_cert_blob;
	size_t client_cert_blob_len;
	char __far *private_key;
	char __far *private_key_blob;
	size_t private_key_blob_len;
	char __far *private_key_passwd;
	char __far *dh_file;
	char __far *dh_blob;
	size_t dh_blob_len;
	int tls_ia;
#else
	int dummy;
#endif
	/* OpenSSL specific variables */
	//int engine;
	// char *engine_id;
	// char *pin;
	// char *key_id;
};
/*** EndHeader */


/*** BeginHeader ulton24 */
// Convert unsigned long to 24-bit format used by TLS handshake messages
void ulton24(char __far * dst, long src);
/*** EndHeader */
__nodebug
void ulton24(char __far * dst, long src)
{
	#asm
	ld bcde,(sp+@sp+src)
	ld	a,c
	ld (px),a
	ld	h,e
	ld l,d
	ld (px+1),hl
	#endasm
}


/*** BeginHeader n24toul */
// Convert 24-bit format used by TLS handshake messages to unsigned long
long n24toul(char __far * src);
/*** EndHeader */
__nodebug
long n24toul(char __far * src)
{
	#asm
	ld jkhl,(px-1)	; result in jkh (L is rubbish, j is LSB, h is MSB)
	ld b,0
	ld c,h
	ex	jk,hl
	ld d,L
	ld e,h
	#endasm
}



////////////////////////////////////////////////////////////////////////////////
// SSL Initialization
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader ssl_init */
int ssl_init(ssl_Socket __far* state);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_init                               <SSL_TPORT.LIB>

SYNTAX: int ssl_init(ssl_Socket* state);

DESCRIPTION: Initialize an SSL socket for use. This function should be
             called to initialize an ssl_Socket before its first use
             only.  Thereafter, it can be opened and closed as many times
             as required.

PARAMETER 1: Pointer to SSL socket structure

RETURN VALUE: 0 if OK.  Currently, there are no possible error conditions,
              except a run-time exit is possible if the CPU does not support
              cryptography.

END DESCRIPTION **********************************************************/

#ifdef __ZSERVER_LIB
const ServerContext _ssl_init_server_context =
	{
		-1,		// userid
		0xFFFF,	// server (all are applicable)
		"/",		// rootdir
		"/",		// cwd
		""			// dfltname
	};
#endif

// Set up one-time (per program run) data structures
_ssl_tport_debug
int ssl_init(ssl_Socket __far* state) {
	auto int i;
	auto void __far * p;
	#GLOBAL_INIT {
      // At program startup, initialize the random number generator
      seed_init((char*)0);

      // Initialize globals and X509 stuff
      memset(&_ssl_globals, 0, sizeof(_ssl_globals));
#ifdef __ZSERVER_LIB
		_ssl_globals.context = &_ssl_init_server_context;
#endif

#if _SSL_USE_RSA_
		__x509_initStatics();
#endif
		// Init resource pool.  Use a linked pool to make it easier to iterate
		// through each active connection.
		_f_memset(ssl_ResourcePool, 0, sizeof(ssl_ResourcePool));
		memset(ssl_NResourcePool, 0, sizeof(ssl_NResourcePool));
		pool_xinit(&_ssl_globals.pool, (long)ssl_ResourcePool, SSL_MAX_CONNECTIONS, _SSL_RP_ELEMSIZE);
		pool_link(&_ssl_globals.pool, POOL_LINKED_AUTO);
		pool_init(&_ssl_globals.npool, ssl_NResourcePool, SSL_MAX_CONNECTIONS, _SSL_NRP_ELEMSIZE);
		pool_link(&_ssl_globals.npool, POOL_LINKED_AUTO);

   } // End #GLOBAL_INIT section

	if (!_ssl_globals.done_init) {
	   // Rehash the random seed at initialization time
	   seed_hash_secret((char*)0);

		_ssl_globals.done_init = 1;

		// Set the magic number which allows us to convert "far" socket pointers to
		// root.  This is temporary until TCP/IP supports far pointers throughout.
		//_ssl_globals.rootable = (long)ssl_ResourcePool - paddr(ssl_ResourcePool);
	}

   // Clear out the state
   if (state)
   	_f_memset(state, 0, sizeof(ssl_Socket));

	return 0;
}



/*** BeginHeader tls_init */

/**
 * tls_init - Initialize TLS library
 * @conf: Configuration data for TLS library
 * Returns: Context data to be used as tls_ctx in calls to other functions,
 * or %NULL on failure.
 *
 * Called once during program startup and once for each RSN pre-authentication
 * session. In other words, there can be two concurrent TLS contexts. If global
 * library initialization is needed (i.e., one that is shared between both
 * authentication types), the TLS library wrapper should maintain a reference
 * counter and do global initialization only when moving from 0 to 1 reference.
 *
 * We don't use multiple contexts, thus return a single (global) object.
 */
void __far * tls_init( struct tls_config __far *conf);
/*** EndHeader */
_ssl_tport_debug
void __far * tls_init( struct tls_config __far *conf)
{
	ssl_init(NULL);
	return &_ssl_globals;
}

/*** BeginHeader tls_deinit */
/**
 * tls_deinit - Deinitialize TLS library
 * @tls_ctx: TLS context data from tls_init()
 *
 * Called once during program shutdown and once for each RSN pre-authentication
 * session. If global library deinitialization is needed (i.e., one that is
 * shared between both authentication types), the TLS library wrapper should
 * maintain a reference counter and do global deinitialization only when moving
 * from 1 to 0 references.
 *
 * Dummy function for Rabbit.
 */
void tls_deinit(void __far *tls_ctx);
/*** EndHeader */
_ssl_tport_debug
void tls_deinit(void __far *tls_ctx)
{
}



/*** BeginHeader tls_get_errors */
/**
 * tls_get_errors - Process pending errors
 * @tls_ctx: TLS context data from tls_init()
 * Returns: Number of found error, 0 if no errors detected.
 *
 * Process all pending TLS errors.
 *
 * We have no global errors, so return 0.
 */
int tls_get_errors(void __far *tls_ctx);
/*** EndHeader */
_ssl_tport_debug
int tls_get_errors(void __far *tls_ctx)
{
	return 0;
}



/*** BeginHeader tls_connection_init, tls_connection_init_state */
/**
 * tls_connection_init - Initialize a new TLS connection
 * @tls_ctx: TLS context data from tls_init()
 * Returns: Connection context data, conn for other function calls
 */
ssl_Socket __far * tls_connection_init(void __far *tls_ctx);
ssl_Socket __far * tls_connection_init_state(void __far *tls_ctx, ssl_Socket __far* state);
/*** EndHeader */
_ssl_tport_debug
ssl_Socket __far * tls_connection_init(void __far *tls_ctx)
{
	return tls_connection_init_state(tls_ctx, NULL);
}

// This is extension of wpa_supplicant-defined API, to allow caller to provide
// ssl_Socket.
_ssl_tport_debug
ssl_Socket __far * tls_connection_init_state(void __far *tls_ctx, ssl_Socket __far* state)
{
   auto ssl_ResourcePool_t __far* rp;
   auto ssl_NResourcePool_t * nrp;
   auto char __far* p;

 	// Get an index from the alloc pool
   rp = pfcalloc(&_ssl_globals.pool);
#if _SSL_PRINTF_DEBUG
   printf("SSL allocated at %08lX\n", rp);
#endif

   // See if we are trying to make too many SSL connections
   if (!rp) {
	   _ssl_globals.last_error = SSL_INIT_ALLOC_FAIL;
	   return NULL;
	}
	// Parallel pool, so following guaranteed to work...
	nrp = rp->nrp = (ssl_NResourcePool_t *)pcalloc(&_ssl_globals.npool);

	// Provide a default state instance if called with null
	if (!state)
		state = &nrp->sock_inst;

	rp->ssl_sock = state;

   // Clear out the structure
   _f_memset(state, 0, sizeof(ssl_Socket));

	// Our current state is 'listening' (we assume server unless tls_sm() is
	// called with NULL input data, in which case the connection is changed to
	// client).
	state->cur_state = SSL_STATE_HS_LISTEN;

	state->cn_timeout = 6000;	// Default 6 second timeout for full close

   // Allocate resources to state structure
	state->resource_index = rp;
	state->cipher_state = &rp->cipher;
   state->cipher_state->suite = &rp->suite;
   state->cipher_state->key_exch = &rp->key_exch;
   state->cipher_state->bulk_cipher = &rp->bulk_cipher;
   state->cipher_state->digest = &rp->digest;

   // Secret and message digest information
   state->master_secret = &rp->master_secret;
	state->fin_hash = &rp->fin_hash;

   // Clear out old secret (if any)
   _f_memset(state->master_secret, 0, sizeof(SSL_Secret));

   // Finish hash initialization
   sha256_init(state->fin_hash);

#if _SSL_USE_RSA_
	state->cert = &rp->cert;
	state->peer_cert = &rp->peer_cert;
	// By default, library manages the connection's certificate
	state->cert_flags = SSL_CF_OWN_CERT | SSL_CF_OWN_PEER_CERT;
#endif
#if _SSL_USE_PSK_
#endif
#ifndef TLS_OLDBUF
	state->indata_remain = 0;
#endif
#if SSL_NO_SESSION_RENEGOTIATION
	state->flags = SSL_F_NO_RESUME;
#endif

	tls_set_default_ciphersuites(state);

	return state;

}



/*** BeginHeader tls_connection_deinit */
/**
 * tls_connection_deinit - Free TLS connection data
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 *
 * Release all resources allocated for TLS connection.
 */
void tls_connection_deinit(void __far *tls_ctx, ssl_Socket __far *state);
/*** EndHeader */
_ssl_tport_debug
void tls_connection_deinit(void __far *tls_ctx, ssl_Socket __far *state)
{
	auto ssl_ResourcePool_t __far * rp;
	auto ssl_NResourcePool_t * nrp;
	auto SSL_CipherState __far* cipher;

	// Allow state to be null (since it sometimes is when called from
	// WPA supplicant)
	if (!state)
		return;

	// Allow the resources to go back to the pool
	rp = state->resource_index;
	nrp = rp->nrp;

	if (state->client_hello_ext_len) {
	   _sys_free(state->client_hello_ext);
	   state->client_hello_ext = NULL;
	   state->client_hello_ext_len = 0;
	}

#if _SSL_USE_RSA_
	if (state->cert) {
		if (state->cert_flags & SSL_CF_OWN_CERT)
			SSL_free_cert(state->cert);
		state->cert_flags &= ~SSL_CF_OWN_CERT;
	}
	if (state->peer_cert) {
		if (state->cert_flags & SSL_CF_OWN_PEER_CERT)
			SSL_free_cert(state->peer_cert);
		state->cert_flags &= ~SSL_CF_OWN_PEER_CERT;
	}
	if (state->trusted) {
		if (state->cert_flags & SSL_CF_OWN_TRUST)
			SSL_free_cert(state->trusted);
		state->trusted = NULL;
		state->cert_flags &= ~SSL_CF_OWN_TRUST;
	}
#endif
   cipher = state->cipher_state;

   // Clear the state structure
	state->resource_index = NULL; // NULL indicates uninitialized
  	cipher->key_exch = NULL;
	cipher->auth = NULL;
   cipher->bulk_cipher = NULL;
   cipher->digest = NULL;
	state->cipher_state = NULL;
   state->ip_type = 0;


   // Clear the resources, now that we saved the session,
   // for security reasons (clears secret key data).
   _f_memset(rp, 0, sizeof(*rp));
#if _SSL_USE_RSA_
   memset(&nrp->modexp_work, 0, sizeof(nrp->modexp_work));
#endif
   // Don't clear sock_inst

#if _SSL_PRINTF_DEBUG
	printf("SSL freed %08lX\n", rp);
#endif
   pffree(&_ssl_globals.pool, rp);
   pfree(&_ssl_globals.npool, nrp);
}



/*** BeginHeader tls_established */
int tls_established(ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_established(ssl_Socket __far *conn)
{
	return 0 != (conn->cur_state & SSL_ESTABLISHED_STATES);
}


/*** BeginHeader tls_connection_established */
/**
 * tls_connection_established - Has the TLS connection been completed?
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: 1 if TLS connection has been completed, 0 if not.
 */
int tls_connection_established(void __far *tls_ctx, ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_established(void __far *tls_ctx, ssl_Socket __far *conn)
{
	return tls_established(conn);
}


/*** BeginHeader tls_readable */
int tls_readable(ssl_Socket __far * state);
/*** EndHeader */
_ssl_tport_debug
int tls_readable(ssl_Socket __far * state)
{
	// Returns 0 if not readable, else 1 if
	// able to read more data from peer.  This means state must be established
	// and not have received close notify.
	return state->cur_state & SSL_ESTABLISHED_STATES &&
	       !(state->flags & SSL_F_CLOSE_NOTIFY);
}


/*** BeginHeader tls_writable */
int tls_writable(ssl_Socket __far * state);
/*** EndHeader */
_ssl_tport_debug
int tls_writable(ssl_Socket __far * state)
{
	// Returns 0 if not writable, else 1 or -1 if able to write more data to peer.
	// This means state must be in app data state.  1 is returned if have not
	// received close notify from peer.  -1 is returned if have received CN.
	// In practice, since we don't truly support half close, -1 will never
	// be returned, since receipt of CN always transitions us to the DONE state,
	// in which case we would return 0.
	if (SSL_STATE_APP_DATA != state->cur_state)
		return 0;
	return state->flags & SSL_F_CLOSE_NOTIFY ? -1 : 1;
}


/*** BeginHeader tls_set_done */
int tls_set_done(ssl_Socket __far * state);
/*** EndHeader */
_ssl_tport_debug
int tls_set_done(ssl_Socket __far * state)
{
	state->cur_state = SSL_STATE_DONE;
	state->flags &= ~(SSL_F_REQUESTED_CERT | SSL_F_SEND_CERT | SSL_F_PEER_CERT_OK |
	                  SSL_F_TRIED_RESUME | SSL_F_RESUMED | SSL_F_USED_TICKET_KEY |
	                  SSL_F_TICKET_KEY | SSL_F_CLOSE_NOTIFY | SSL_F_ENCRYPT |
	                  SSL_F_DECRYPT);
#if !SSL_NO_SESSION_RENEGOTIATION
   // Save the state for possible resumption.  We can save now since the
   // connection is correctly terminated.
   // Only do this for servers.  Clients save the session ID in their own state
   // (not in a common cache), whereas servers pool IDs in a cache.
   if (!state->is_client &&
       !(state->flags & SSL_F_NO_RESUME) &&
       state->session_id_length) {
      _ssl_session_save(state);
   }
#endif
	if (state->flags & SSL_F_NO_RESUME) {
	   state->session_id_length = 0;
#if _SSL_USE_RSA_
	   if (state->peer_cert && (state->cert_flags & SSL_CF_OWN_PEER_CERT)) {
	      SSL_free_cert(state->peer_cert);
			//state->peer_cert = NULL;
		}
#endif
	}

	state->tport && state->tport(state, TPORT_EVENT_DONE, 0);
	state->is_client = 0;
	state->is_psk = 0;
}


/*** BeginHeader tls_shutdown */
int tls_shutdown(ssl_Socket __far * state, SSL_shutdown_type how, _tbuf __far * tport_out);
/*** EndHeader */
_ssl_tport_debug
int tls_shutdown(ssl_Socket __far * state, SSL_shutdown_type how, _tbuf __far * tport_out)
{
	auto int rc;

#if _SSL_PRINTF_DEBUG
   printf("tls_shutdown: how=%s\n",
   	how == SHUTDOWN_HALF ? "half" :
   	how == SHUTDOWN_FULL ? "full" :
   	how == SHUTDOWN_PURGE ? "purge" :
   	how == SHUTDOWN_ABORT ? "app abort" :
   	"tport fail"
   	);
#endif

	switch (how) {
	case SHUTDOWN_HALF:
		// This is rather feeble: "half close" is simply the application declaring it's
		// not going to write any more data.  Nothing actually happens "on the wire".
		// We defer sending close notify (even though we would do that if the spec actually
		// supported half-close properly).
		if (state->cur_state == SSL_STATE_APP_DATA) {
			state->tport && state->tport(state, TPORT_EVENT_APP_HALF_CLOSE, 0);
			state->cur_state = SSL_STATE_HALF_CLOSED;
		}
		break;
	case SHUTDOWN_ABORT:
		// Always abort the transport in this case.  Session resume is allowed
		// unless specifically disallowed.
		state->tport && state->tport(state, TPORT_EVENT_APP_ABORT, 0);
		// fall thru...
	case SHUTDOWN_TPORT_FAIL:
		// Transport layer failed unexpectedly.  Simply move to done state.
		tls_set_done(state);
		break;
	case SHUTDOWN_PURGE:
		// Explicitly disallow session resume
		state->flags |= SSL_F_NO_RESUME;
	   // fall through
	case SHUTDOWN_FULL:
		if (state->cur_state == SSL_STATE_APP_DATA ||
		    state->cur_state == SSL_STATE_HALF_CLOSED ||
		    SSL_STATE_DRAINING == state->cur_state) {
			state->tport && state->tport(state, TPORT_EVENT_APP_FULL_CLOSE, 0);
	      rc = tls_send_alert(state, TLS_ALRT_close_notify, tport_out, TLS_warning);
	      if (rc < 0)
	         return rc;
		}
		else if (state->cur_state != SSL_STATE_DONE)
			tls_set_done(state);
		break;
	}
	return 0;
}


/*** BeginHeader tls_connection_shutdown */
/**
 * tls_connection_shutdown - Shutdown TLS connection
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: 0 on success, -1 on failure
 *
 * Shutdown current TLS connection without releasing all resources. New
 * connection can be started by using the same conn without having to call
 * tls_connection_init() or setting certificates etc. again. The new
 * connection should try to use session resumption.
 *
 * NOTE: tls_shutdown() should be used instead of this function,
 * since this function does not issue close notify alert to other side,
 * since there is no tbuf parameter.
 */
int tls_connection_shutdown(void __far *tls_ctx, ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_shutdown(void __far *tls_ctx, ssl_Socket __far *conn)
{
	tls_set_done(conn);
	return 0;
}

/*** BeginHeader tls_set_trusted */
// This sets the list of trusted (CA) certs.  These are read-only to the
// library.  Caller is responsible for their management.  Typically, all
// instances will refer to the same set of trusted certs.
#if _SSL_USE_RSA_
SSL_Cert_t __far * tls_set_trusted(ssl_Socket __far * state, SSL_Cert_t __far * trusted);
#endif
/*** EndHeader */
#if _SSL_USE_RSA_
_ssl_tport_debug
SSL_Cert_t __far * tls_set_trusted(ssl_Socket __far * state, SSL_Cert_t __far * trusted)
{
	SSL_Cert_t __far * old;
	if (state->cert_flags & SSL_CF_OWN_TRUST)
		SSL_free_cert(state->trusted);
	state->cert_flags &= ~SSL_CF_OWN_TRUST;	// caller manages list
	old = state->trusted;
	state->trusted = trusted;
	return old;
}
#endif

/*** BeginHeader tls_set_cert */
// Set the certificate belonging to this state.  Interface to SSL_new_cert() and
// SSL_set_private_key().  Previous cert (if any) is freed.  New cert is
// managed by library.
// NOTE: my_cert, if not NULL, is used in place of the other parameters, and
// signifies the library does *not* manage (i.e. alloc/free) the data structs.
// DO NOT mix use of my_cert (binary struct) and imported certs (e.g. by appending
// an imported cert to an existing list established by my_cert), otherwise
// memory management errors may occur.
#if _SSL_USE_RSA_
int tls_set_cert(ssl_Socket __far * state,
                  long addr,
						SSL_Cert_Import_t import_type,
						int append,
                  long priv_addr,
						SSL_Cert_Import_t priv_import_type,
					 	SSL_Cert_t __far * my_cert
						);
#endif
/*** EndHeader */
#if _SSL_USE_RSA_
_ssl_tport_debug
int tls_set_cert(ssl_Socket __far * state,
                  long addr,			// 0 if no cert
						SSL_Cert_Import_t import_type,
						int append,			// 1 to append above cert to list (should be a cert which
													// validates the previously added one)
                  long priv_addr,	// 0 if no private key
						SSL_Cert_Import_t priv_import_type,
					 	SSL_Cert_t __far * my_cert
						)
{
	auto int rc;
	if (state->cert_flags & SSL_CF_OWN_CERT)
		SSL_free_cert(state->cert);
	rc = 0;
	if (my_cert) {
		state->cert_flags &= ~SSL_CF_OWN_CERT;
		_f_memcpy(state->cert, my_cert, sizeof(SSL_Cert_t));
	}
	else {
		state->cert_flags |= SSL_CF_OWN_CERT;
	   if (addr) {
	      rc = SSL_new_cert(state->cert, addr, import_type, append);
	      if (rc < 0)
	         return rc;
	   }
	   if (priv_addr)
	      rc = SSL_set_private_key(state->cert, priv_addr, priv_import_type);
	}
	return rc;
}
#endif

/*** BeginHeader tls_set_flags */
// This sets certain boolean flags (bitwise OR of flags) in the "flags" and
// "suite_flags" fields of the state structure.
// Allowable flags are documented in SSL_DEFS.LIB.
// Returns new flags.
// Only flags with bit set in mask are actioned.  If mask 0, then this is query only.
// Change only accepted in HS_LISTEN or DONE states.  Caller should verify
// against retcode if uncertain.
word tls_set_flags(ssl_Socket __far * state, word flags, word mask);
/*** EndHeader */
_ssl_tport_debug
word tls_set_flags(ssl_Socket __far * state, word flags, word mask)
{
	auto word f_mask, s_mask;
	f_mask = mask & SSL_F_OPTIONS;
	s_mask = mask & SSL_S_OPTIONS;
	if (f_mask | s_mask) {
		if (state->cur_state & (SSL_STATE_HS_LISTEN | SSL_STATE_DONE)) {
		   state->flags &= ~f_mask;
		   state->flags |= flags & f_mask;
		   state->suite_flags &= ~s_mask;
		   state->suite_flags |= flags & s_mask;
		}
	}
	return state->flags & SSL_F_OPTIONS | state->suite_flags & SSL_S_OPTIONS;
}


/*** BeginHeader tls_set_tport_flags */
// Similar to tls_set_flags(), except these flags are for use by transport layer
// and not otherwise used by TLS/SSL libraries.
word tls_set_tport_flags(ssl_Socket __far * state, word flags, word mask);
#define tls_get_tport_flags(state) ((state)->tport_flags)
/*** EndHeader */
_ssl_tport_debug
word tls_set_tport_flags(ssl_Socket __far * state, word flags, word mask)
{
	if (mask) {
	   state->tport_flags &= ~mask;
	   state->tport_flags |= flags & mask;
	}
	return state->tport_flags;
}




/*** BeginHeader tls_set_cn_timeout */
// This sets the full-close timeout in ms
int tls_set_cn_timeout(ssl_Socket __far * state, unsigned long timeout_ms);
/*** EndHeader */
_ssl_tport_debug
int tls_set_cn_timeout(ssl_Socket __far * state, unsigned long timeout_ms)
{
	if (state->cur_state != SSL_STATE_WAIT_CLOSE) {
		state->cn_timeout = timeout_ms;
		return 0;
	}
	return -1;
}


/*** BeginHeader tls_connection_set_params */

// Following enum is only for compat with wpa_supplicant.  We don't
// support external PKCS#11 "engines".
enum {
	TLS_SET_PARAMS_ENGINE_PRV_VERIFY_FAILED = -3,
	TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED = -2
};

/**
 * tls_connection_set_params - Set TLS connection parameters
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @params: Connection parameters
 * Returns: 0 on success, -1 on failure,
 * TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED (-2) on possible PIN error causing
 * PKCS#11 engine failure, or
 * TLS_SET_PARAMS_ENGINE_PRV_VERIFY_FAILED (-3) on failure to verify the
 * PKCS#11 engine private key.
 */
int tls_connection_set_params(void __far *tls_ctx, ssl_Socket __far *state,
			       struct tls_connection_params __far *params);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_set_params(void __far *tls_ctx, ssl_Socket __far *state,
			       struct tls_connection_params __far *params)
{
	// This routine is mainly for compat with wpa_supplicant.  We support
	// setting of the trusted cert list, and the client cert.
	// Only 'blob' (binary) form certificates are supported.  Such certs must be
	// managed by the caller using SSL_new_cert() etc.
	// The client cert blob must be already set up with the private key

	if (params->ca_cert_blob) {
		if (state->cert_flags & SSL_CF_OWN_TRUST)
			SSL_free_cert(state->trusted);
		state->cert_flags &= ~SSL_CF_OWN_TRUST;
	}

	if (params->client_cert_blob) {
		if (state->cert_flags & SSL_CF_OWN_CERT)
			SSL_free_cert(state->cert);
		state->cert_flags &= ~SSL_CF_OWN_CERT;
	}


	tls_set_trusted(state, params->ca_cert_blob);

	tls_set_cert(state, 0, 0, 0, 0, 0, params->client_cert_blob);

	return 0;
}



/*** BeginHeader tls_global_set_params */
// We don't support global parameters.  Each connection needs to have its
// own parameters set.

/**
 * tls_global_set_params - Set TLS parameters for all TLS connection
 * @tls_ctx: TLS context data from tls_init()
 * @params: Global TLS parameters
 * Returns: 0 on success, -1 on failure,
 * TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED (-2) on possible PIN error causing
 * PKCS#11 engine failure, or
 * TLS_SET_PARAMS_ENGINE_PRV_VERIFY_FAILED (-3) on failure to verify the
 * PKCS#11 engine private key.
 */
int tls_global_set_params(void __far *tls_ctx,
			  struct tls_connection_params __far *params);
/*** EndHeader */
_ssl_tport_debug
int tls_global_set_params(void __far *tls_ctx,
			  struct tls_connection_params __far *params)
{
	return -1;
}



/*** BeginHeader tls_global_set_verify */
/**
 * tls_global_set_verify - Set global certificate verification options
 * @tls_ctx: TLS context data from tls_init()
 * @check_crl: 0 = do not verify CRLs, 1 = verify CRL for the user certificate,
 * 2 = verify CRL for all certificates
 * Returns: 0 on success, -1 on failure
 */
int tls_global_set_verify(void __far *tls_ctx, int check_crl);
/*** EndHeader */
_ssl_tport_debug
int tls_global_set_verify(void __far *tls_ctx, int check_crl)
{
	return -1;
}



/*** BeginHeader tls_connection_set_verify */
/**
 * tls_connection_set_verify - Set certificate verification options
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @verify_peer: 1 = verify peer certificate
 * Returns: 0 on success, -1 on failure
 */
int tls_connection_set_verify(void __far *tls_ctx, ssl_Socket __far *conn,
			      int verify_peer);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_set_verify(void __far *tls_ctx, ssl_Socket __far *conn,
			      int verify_peer)
{
	return -1;
}



/*** BeginHeader tls_connection_set_ia */
/**
 * tls_connection_set_ia - Set TLS/IA parameters
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @tls_ia: 1 = enable TLS/IA
 * Returns: 0 on success, -1 on failure
 *
 * This function is used to configure TLS/IA in server mode where
 * tls_connection_set_params() is not used.
 */
int tls_connection_set_ia(void __far *tls_ctx, ssl_Socket __far *conn,
			  int tls_ia);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_set_ia(void __far *tls_ctx, ssl_Socket __far *conn,
			  int tls_ia)
{
	return -1;
}



/*** BeginHeader tls_connection_get_keys */
/**
 * tls_connection_get_keys - Get master key and random data from TLS connection
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @keys: Structure of key/random data (filled on success)
 * Returns: 0 on success, -1 on failure
 */
int tls_connection_get_keys(void __far *tls_ctx, ssl_Socket __far *conn,
			    struct tls_keys __far *keys);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_get_keys(void __far *tls_ctx, ssl_Socket __far *conn,
			    struct tls_keys __far *keys)
{
	keys->master_key = conn->master_secret->data;
	keys->master_key_len = conn->master_secret->length;
	keys->client_random = (char __far *)&conn->cipher_state->client_random;
	keys->client_random_len = sizeof(conn->cipher_state->client_random);
	keys->server_random = (char __far *)&conn->cipher_state->server_random;
	keys->server_random_len = sizeof(conn->cipher_state->server_random);
	keys->inner_secret_len = 0;	//DEVIDEA: implement this
	return 0;
}



/*** BeginHeader tls_connection_prf */
/**
 * tls_connection_prf - Use TLS-PRF to derive keying material
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @label: Label (e.g., description of the key) for PRF
 * @server_random_first: seed is 0 = client_random|server_random,
 * 1 = server_random|client_random
 * @out: Buffer for output data from TLS-PRF
 * @out_len: Length of the output buffer
 * Returns: 0 on success, -1 on failure
 *
 * This function is optional to implement if tls_connection_get_keys() provides
 * access to master secret and server/client random values. If these values are
 * not exported from the TLS library, tls_connection_prf() is required so that
 * further keying material can be derived from the master secret. If not
 * implemented, the function will still need to be defined, but it can just
 * return -1.
 */
int tls_connection_prf(void __far *tls_ctx, ssl_Socket __far *conn,
		       char __far *label, int server_random_first,
		       char __far *out, size_t out_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_prf(void __far *tls_ctx, ssl_Socket __far *conn,
		       char __far *label, int server_random_first,
		       char __far *out, size_t out_len)
{
	auto char seed[256+ 2 * sizeof(SSL_Random)];
	auto word lablen;

	lablen = _f_strlen(label);

	if (!tls_connection_established(tls_ctx, conn) || lablen > 256)
		return -1;

	_f_memcpy(seed, label, lablen);
	if (server_random_first) {
		_f_memcpy(seed + lablen, (char __far *)&conn->cipher_state->server_random, sizeof(SSL_Random));
		_f_memcpy(seed + lablen + sizeof(SSL_Random), (char __far *)&conn->cipher_state->client_random,
			  sizeof(SSL_Random));
	} else {
		_f_memcpy(seed + lablen, (char __far *)&conn->cipher_state->client_random, sizeof(SSL_Random));
		_f_memcpy(seed + lablen + sizeof(SSL_Random), (char __far *)&conn->cipher_state->server_random,
			  sizeof(SSL_Random));
	}

	_SHA256_PRF(conn->master_secret, seed, lablen + 2*sizeof(SSL_Random), out,
            out_len);

	return 0;
}


/*** BeginHeader tls_digest_hs_message, tls_finished_mac */
int tls_digest_hs_message(ssl_Socket __far* state, ll_Gather * g);
int tls_finished_mac(ssl_Socket __far* state, char __far * buf, int verify);
/*** EndHeader */
_ssl_tport_debug
int tls_digest_hs_message(ssl_Socket __far* state, ll_Gather * g)
{
   _ssl_assert(state != NULL);
#if _SSL_PRINTF_DEBUG > 3
   printf("\n\n%u bytes digested\n", g->len2 + g->len3);
	mem_dump(g->data2, g->len2);
	if (g->len3)
		mem_dump(g->data3, g->len3);
#endif

	// Digest 1st part
   sha256_add(state->fin_hash, g->data2, g->len2);

	// ...and 2nd if any
	if (g->len3) {
	   sha256_add(state->fin_hash, g->data3, g->len3);
   }

   // Success
   return 0;
}

_ssl_tport_debug
int tls_finished_mac(ssl_Socket __far* state, char __far * buf, int verify)
{
	auto SSL_byte_t mac[TLS_VERIFY_DATA_SIZE];
   auto SSL_byte_t ret_val;
   auto SSL_Finish_Hash_t fh;
   auto _ssl_MAC_sender_t sender;

	// Copy state, since we still need to keep hashing HS mesages in fin_hash.
   _f_memcpy(&fh, state->fin_hash, sizeof(fh));

   sender = (!state->is_client ^ !verify) ? SSL_FMAC_CLIENT : SSL_FMAC_SERVER;
	ret_val = 0;
	// Generate the mac
	_tls_1_generate_finish_mac(state, &fh, sender, mac);
	if (verify)
   	ret_val = _f_memcmp(mac, buf, TLS_VERIFY_DATA_SIZE);
   else
   	_f_memcpy(buf, mac, ret_val = TLS_VERIFY_DATA_SIZE);

	return ret_val;
}


/*** BeginHeader tls_send_alert */
int tls_send_alert(ssl_Socket __far*, TLS_AlertDescription_t, _tbuf __far *, TLS_AlertLevel_t);
/*** EndHeader */


// No error propagation, we want to ignore further errors when
// we are sending an alert
_ssl_tport_debug
int tls_send_alert(ssl_Socket __far* state, TLS_AlertDescription_t desc, _tbuf __far * out, TLS_AlertLevel_t level) {

	auto TLS_Alert alert;
   auto int bytes_written;
   auto _tbuf t;

   _ssl_assert(state != NULL);

	if (level == TLS_auto_level)
		level =
					desc == TLS_ALRT_close_notify ||
					desc == TLS_ALRT_no_renegotiation ||
					desc == TLS_ALRT_user_cancelled ?
						TLS_warning :
						TLS_fatal;

   // Setup the alert
	alert.level = level;
   alert.description = desc;

   // use tbuf to contain record
   t.buf = (char __far *)&alert;
   t.begin = 0;
   t.len = t.maxlen = sizeof(alert);
   if (tls_write_record(state, SSL_REC_alert, &t, t.len, out) < 0)
      return -state->ssl_errno;

   // Set the state back to normal error state (SSL_STATE_ENC_ALERT is
   // only for sending encrypted alerts)
   if (TLS_fatal == level) {
   	// We are not sending a close_notify alert, so this is an error state
#if _SSL_PRINTF_DEBUG
      printf("\n^^^Sending fatal alert: %d^^^\n", desc);
#endif
	   state->cur_state = SSL_STATE_ERROR;
	   ++state->alerts_sent;
		state->tport && state->tport(state, TPORT_EVENT_SENT_FATAL_ALERT, alert.description);
	   return -1;
   }

   if (TLS_ALRT_close_notify == desc) {
	#if _SSL_PRINTF_DEBUG
	   printf("\n^^^Sending close_notify^^^\n");
	#endif
		state->tport && state->tport(state, TPORT_EVENT_SENT_CLOSE_NOTIFY, 0);
		if (state->flags & SSL_F_CLOSE_NOTIFY)
			// Fully closed now
			tls_set_done(state);
		else {
	      // Wait for close, and save session
	      state->cur_state = SSL_STATE_DRAINING;
#if !SSL_NO_SESSION_RENEGOTIATION
	      // Save the state for possible resumption.  Since we sent CN first,
	      // assume that it is safe to save the session info at this point.
	      // Some clients (such as Mozilla/Firefox) do not respond with CN
	      // but simply close the transport.  In this case, the TLS state
	      // machine does not get to invoke the tls_set_done() processing,
	      // which means the session ID is lost.  Thus, we save it here.
	      if (!state->is_client && !(state->flags & SSL_F_NO_RESUME)) {
	         _ssl_session_save(state);
			   state->session_id_length = 0;	// Don't save it again if get CN response
	      }
#endif

	   }
	}
   return 0;
}

/*** BeginHeader tls_query_unsent */
// This is a wrapper for the transport "query unsent" callback
int tls_query_unsent(ssl_Socket __far * state);
/*** EndHeader */

_ssl_tport_debug
int tls_query_unsent(ssl_Socket __far * state)
{
	return state->tport ? state->tport(state, TPORT_QUERY_UNSENT, 0) : 0;
}


/*** BeginHeader tls_sm */
/*
 * Main TLS state machine processing.  Record data, of any content type, is
 * extracted from 'tport_in', and any resulting handshake or alert messages are
 * appended to 'tport_out', and decrypted application data is appended to
 * 'app_in'.  The caller should send the data in tport_out to the transport
 * (e.g. TCP socket), and send the data in app_in to the application for
 * reading.
 *
 * This works for both client and server.  A client-side connection is
 * established if the first call passes a NULL tport_in.  This signifies
 * that a client_hello message is to be formatted and returned.
 *
 * tport_out will be used to contain handshake and/or alert mesages which are
 * generated by this state machine.  During the actual handshake phase, this
 * buffer must be big enough to contain the required data, otherwise a
 * 'record write overflow' error will be generated and the connection will
 * fail.  Currently, the implementation does not fragment outgoing HS messages.
 * For best chance of success, the caller should ensure tport_out is empty
 * before calling this function.
 *
 * Not all the input data may be processed, since there may not be enough
 * output buffer space.  This function can be called again once some of the
 * output data has been written to the transport layer.  If the ctrl buffer
 * is empty, and yet a handshake record could not be written to it, then
 * an alert will be written and an error condition set.  This should only
 * occur with a small buffer and large certificates.  Application data also
 * has this error possibility, since the peer can end records up to 16k.
 *
 * Any partial record at the end of tport_in will be left for next call.  Only
 * whole records are processed and drive the state machine.  If the last
 * (partial) record has a complete header, and the header indicates the
 * following record length would exceed the carrying capacity of tport_in,
 * then an error will be generated.
 *
 * The return value indicates the minimum amount of data which needs to be
 * added to tport_in in order to obtain a complete record or header (depending
 * on final state).  If tport_in contained an exact number of whole records,
 * then the return value will be zero, in which case the caller should add
 * at least 5 bytes (size of TLS/SSLv3 record header) before calling again.
 *
 * If the return code is -EAGAIN, then application data was available which
 * could not fit in the given app_in buffer.  The caller should remove as
 * much data as possible from app_in then call again.  state->buf_extra
 * will be set to indicate the minimum amount of space to free.
 *
 * If the return value is -ve, other than the above listed, then an error occurred.
 * In this case, the caller should send the contents of tport_out (if any)
 * since there may be an alert message to send.
 *
*/
int tls_sm(ssl_Socket __far * state,
           _tbuf __far * tport_in,		// Incoming (encrypted) data stream from transport layer
           _tbuf __far * tport_out,	// Outgoing (encrypted) data stream to transport layer
           _tbuf __far * hs_in,			// Temporary incoming handshake stream
           _tbuf __far * app_in,		// Received plaintext application data (read by app)
           _tbuf __far * app_out);		// Plaintext application data to send out (written by app)
/*** EndHeader */

_ssl_tport_debug
int tls_sm(ssl_Socket __far * state,
           _tbuf __far * tport_in,
           _tbuf __far * tport_out,
           _tbuf __far * hs_in,
           _tbuf __far * app_in,
           _tbuf __far * app_out)
{
	auto SSL_byte_t cert_verf_hashes[36];	// MD5 plus SHA hash
	auto SSL_byte_t recvd_mac[TLS_VERIFY_DATA_SIZE];
	auto SSL_Handshake_Hdr_t hh;
	auto _tbuf t;			// HS message data only (not header), overlays hs_in.
	auto ll_Gather g;		// complete HS message buffer (ref to hs_in data)
	auto long hs_len;		// length of HS message (incl its header)
	auto int rc;
	auto word in_hs, out_hs;
	auto size_t app_get, hs_get;
	auto size_t nag_curr, nag_extra, nag_avail, nag_len;
#ifndef TLS_OLDBUF
	auto word app_remain;
	auto _tbuf _hs_in;
	hs_in = &_hs_in;	// Ignore provided parm, no need for it
#endif

	if (!tport_in) {
		// If called with NULL input data, then we are a client, and should now
		// generate the initial client_hello.  If in DONE state, this is an
		// attempted session resumption.  Caller can also set a ticket key
		// and/or client hello extension data which will be used if provided.
		if (state->cur_state != SSL_STATE_HS_LISTEN &&
		    state->cur_state != SSL_STATE_DONE) {
#if _SSL_PRINTF_DEBUG
    		printf("*** NULL tport_in in forbidden state ***\n");
#endif
			return tls_error(state, SSL_BAD_STATE_CLI_HELLO, NULL);
		}
		state->is_client = 1;
		rc = tls_send_client_hello(state, tport_out);
		state->hs_timeout = _SET_SHORT_TIMEOUT(SSL_HANDSHAKE_TIMEOUT);
		if (!rc)
			state->cur_state = SSL_STATE_SENT_CLI_HELLO;
		return rc;
	}

#if _SSL_USE_RSA_
	switch (state->wait_rsa) {
	case SSL_WAIT_RSA_PCKE:
		// server processing client key exchange
      rc = tls_do_client_key_exchange(state, &t, tport_out, 1);
      if (rc == -EAGAIN)
         // non-blocking RSA operation not yet complete
         return 0;
      // else continue with next message
      state->wait_rsa = SSL_WAIT_RSA_NONE;
      break;
   case SSL_WAIT_RSA_CCV:
   	// client constructing certificate verify
		rc = tls_do_server_hello_done(state, &t, tport_out, 1);
      if (rc == -EAGAIN)
         // non-blocking RSA operation not yet complete
         return 0;
      // else continue with next message
      state->wait_rsa = SSL_WAIT_RSA_NONE;
   default:
   	break;
	}
#endif

	in_hs = state->cur_state & SSL_HANDSHAKE_STATES;


#ifndef TLS_OLDBUF
	if (state->indata_remain) {
      app_remain = _tbuf_remain(app_in);
      if (state->indata_remain <= app_remain) {
#if _SSL_PRINTF_DEBUG
    		printf("tls_sm: completed long rec, app_remain=%u, indata=%u, footer=%u\n",
    				app_remain, state->indata_remain, state->footer_remain);
#endif
         _tbuf_move(app_in, tport_in, state->indata_remain, 1, 0);
         _tbuf_delete(tport_in, state->indata_remain + state->footer_remain);
         state->indata_remain = 0;
         // Done, can continue normally now.
      }
      else {
         // Need to move in smaller chunks (requires more sm calls
         // to drain down the tport buffer).
#if _SSL_PRINTF_DEBUG
    		printf("tls_sm: incomplete read of long rec, app_remain=%u, indata=%u\n",
    				app_remain, state->indata_remain);
#endif
         _tbuf_move(app_in, tport_in, app_remain, 1, 0);
         _tbuf_delete(tport_in, app_remain);
         state->indata_remain -= app_remain;
			// Can't do following input operation until all data from previous
			// decrypted app record has been drained to app buffer.
			goto _do_output;
      }
	}
#endif

	while (tport_in->len
#ifndef TLS_OLDBUF
			// Need to break from this loop if only partial app data moved to app_in
			&& !state->indata_remain
#endif
			) {

	   rc = tls_proc_record(state, tport_in, tport_out, hs_in, &hs_get, app_in, &app_get);

	   if (rc) {
	   	if (rc == -EAGAIN) {
	   		if (app_get)
	            // App data, but too much for given buffer
	            state->buf_extra = app_get;
	         else {
	         	// HS data, but too much for buffer.  This should not happen
	         	// unless peer sends huge record, since we process data ASAP.
#if _SSL_PRINTF_DEBUG
    				printf("*** Too much HS data ***\n");
#endif
	   			return tls_error(state, SSL_READ_REC_OVERFLOW, tport_out);
	   		}
			}
   		return rc;
	   }

		// These message types handled in proc_record.
	   if (state->hdr.rec_type != SSL_REC_application_data &&
			 state->hdr.rec_type != SSL_REC_handshake)
			continue;

		// This loop processes all handshake mesages in one record (if HS record
		// content, otherwise it will only iterate once for app data).
		do {
	      // Assemble fragmented handshake messages
	      if (state->hdr.rec_type == SSL_REC_handshake) {
	         if (hs_in->len >= sizeof(hh)) {
	            _tbuf_xread(&hh, hs_in, 0, sizeof(hh));
	            hs_len = n24toul(hh.length) + sizeof(hh);
#if _SSL_PRINTF_DEBUG > 2
    				printf("  [TLS HS] got type %u, length %lu\n", hh.msg_type, hs_len);
    				if (hh.msg_type == certificate_request)
    					;
#endif
	            if (hs_len > (unsigned long)hs_in->maxlen) {
#if _SSL_PRINTF_DEBUG
    					printf("*** Oversize HS record (%lu, max allowed %u) ***\n",
    						hs_len, hs_in->maxlen);
#endif
	               return tls_error(state, SSL_READ_REC_OVERFLOW, tport_out);
	            }
	            if ((unsigned long)hs_in->len < hs_len) {
#if _SSL_PRINTF_DEBUG > 2
    					printf("  [TLS HS] ...but only %u\n", hs_in->len);
#endif
	               break;   // Full HS message not yet available, process next record
	            }
	            // Have at least one complete HS message.  Get reference to it and
	            // continue after deleting the HS message (deletion does not yet trash
	            // any data, but we must use the data completely before continuing).
	            _tbuf_ref(hs_in, &g, 0, (word)hs_len);

	            // t is set up to map the HS data only
	            _f_memcpy(&t, hs_in, sizeof(t));
	            t.len = (word)hs_len;
	            _tbuf_delete(&t, sizeof(hh));

	         _hs_proc:
					// Since we're here, may as well check and/or add HS message digest
					if (hh.msg_type == finished) {
						_tbuf_xread(recvd_mac, hs_in, sizeof(hh), sizeof(recvd_mac));
						if (tls_finished_mac(state, recvd_mac, 1)) {
#if _SSL_PRINTF_DEBUG
							printf("*** Finish Verification Error ***\n");
#endif
							return tls_error(state, SSL_FINISH_VERIFY_FAIL, tport_out);
						}
					}
					if (hh.msg_type != hello_request) {
						if (hh.msg_type == certificate_verify) {
							// Take snapshot of hashes so far, since this is the data
							// which was signed by the client.
                     /* TODO: update Certificate Request code to handle new
                     	message structure, recording the requested
                        SignatureAndHashAlgorithm, and use that to create
                        cert_verf_hashes.
	                  md5_sofar(&state->fin_hash->md5_hash, cert_verf_hashes);
	                  sha_sofar(&state->fin_hash->sha_hash, cert_verf_hashes+16);
                     */
						}
						tls_digest_hs_message(state, &g);
					}

	            _tbuf_delete(hs_in, (word)hs_len);

	            if (hh.msg_type == hello_request) {
	            	continue;
	            }
	         }
	         else
	            break;   // Incomplete HS message, process next record.  This
	            			// break actually continues the outermost loop.
	      }


	      // A complete record was processed, run state machine.  Note that
	      // state->hdr.rec_type indicates the record type just processed.

	      // If we got a complete handshake message, 'g' is a reference to the
	      // handshake message data, and hs_len is the total length of the
	      // message.  hh.msg_type will contain the handshake type.
	      // For convenience, 't' is a temporary tbuf which contains just
	      // the message data (not the header).  It can be read without
	      // affecting the original buffer.

	      // If we got app data, then that data will have been appended to the
	      // given buffer.  ** Note that tls_proc_record makes sure we don't get
	      // application data other than in APP_DATA or WAIT_CLOSE states. **

	      switch (state->cur_state) {
	      default:
	         // not a state in which we process records
	         break;
	      case SSL_STATE_DONE:
	      	// Automatically transition to appropriate state and continue (must be server;
	      	// to be client must call this with null tport_in which will transition to
	      	// state SENT_CLI_HELLO).
	      	state->is_client = 0;
	      	state->cur_state = SSL_STATE_HS_LISTEN;
	      	goto _listen;
	      case SSL_STATE_WAIT_CLOSE:
	      case SSL_STATE_HALF_CLOSED:
	      case SSL_STATE_DRAINING:
	      case SSL_STATE_APP_DATA:
	         // Check for handshake messages in APP_DATA mode
            if (state->hdr.rec_type == SSL_REC_handshake) {
            	// If it is a client or server hello message, send a no_renegotiation
            	// (warning) alert since we don't support renegotiation.
            	if (hh.msg_type == hello_request
            		|| state->is_client && hh.msg_type == server_hello
            		|| !state->is_client && hh.msg_type == client_hello) {
	            #if _SSL_PRINTF_DEBUG
	                printf("*** Got renegotiation in app data state ***\n");
	            #endif
   					tls_send_alert(state, TLS_ALRT_no_renegotiation, tport_out, TLS_auto_level);

            	}
            	else {
	         	#if _SSL_PRINTF_DEBUG
	               printf("*** Got handshake message in app data state ***\n");
	         	#endif
	               goto _unexpected;
               }
            }
            // At this point, received app data have been moved to the appropriate
            // buffer, so we are done for this record.
            break;
         case SSL_STATE_SENT_CLI_HELLO:
	      	if (hh.msg_type != server_hello)
	            goto _unexpected;
	         rc = tls_do_server_hello(state, &t, tport_out);
	         break;
#if _SSL_USE_RSA_
         case SSL_STATE_WAIT_CERT:
	      	if (hh.msg_type != certificate)
	            goto _unexpected;
	         rc = tls_do_certificate(state, &t, tport_out);
	         break;
#endif
         case SSL_STATE_WAIT_SHD:
#if _SSL_USE_PSK_
	      	if (hh.msg_type == server_key_exchange && state->is_psk) {
            	rc = tls_do_server_key_exchange(state, &t, tport_out);
            }
            else
#endif
	      	if (hh.msg_type == server_hello_done) {
#if _SSL_USE_RSA_
	#ifdef SSL_BLOCKING_RSA
		 			rc = tls_do_server_hello_done(state, &t, tport_out, 0);
					while (rc == -EAGAIN)
						rc = tls_do_server_hello_done(state, &t, tport_out, 1);
	#else
					rc = tls_do_server_hello_done(state, &t, tport_out, 0);
	            if (rc == -EAGAIN) {
	               // non-blocking RSA operation not yet complete
	               state->wait_rsa = SSL_WAIT_RSA_CCV;
	               return 0;
	            }
	#endif
#else
					// No -EAGAIN possible if not doing RSA
		 			rc = tls_do_server_hello_done(state, &t, tport_out, 0);
#endif
				}
#if _SSL_USE_RSA_
	      	else if (hh.msg_type == certificate_request && !state->is_psk)
					rc = tls_do_certificate_request(state, &t, tport_out);
					// this remains in WAIT_SHD state
#endif
				else
	            goto _unexpected;
	         break;
         case SSL_STATE_WAIT_CCS:
         case SSL_STATE_WAIT_CCS_RESUME:
         	// We should never be in these states at this point, since CCS
         	// is a content type which is processed by tls_proc_record.  When
         	// CCS is seen, the state is automatically advanced to WAIT_FIN.
	      	goto _unexpected;
         case SSL_STATE_WAIT_FIN:
         case SSL_STATE_WAIT_FIN_RESUME:
	      	if (hh.msg_type != finished)
	            goto _unexpected;
	         // Note the 'logical xor' following...
	         if ((state->cur_state == SSL_STATE_WAIT_FIN_RESUME) ^ !state->is_client) {
	            if (rc = tls_send_chg_cipher_spec(state, tport_out))
	               break;
	            if (rc = tls_send_finished(state, tport_out))
	               break;
	         }
            // The finished message was verified above.  If we get to this
            // point, it is OK to change to app data state
            state->cur_state = SSL_STATE_APP_DATA;
				state->tport && state->tport(state, TPORT_EVENT_HS_COMPLETE, 0);
            rc = 0;
	         break;
	      case SSL_STATE_HS_LISTEN:
	      _listen:
	      	if (hh.msg_type != client_hello)
	            goto _unexpected;
				rc = tls_do_client_hello(state, &t, tport_out);
	      	break;
	      case SSL_STATE_WAIT_CKE:
	         if (hh.msg_type != client_key_exchange)
	            goto _unexpected;
#if _SSL_USE_RSA_
	#ifdef SSL_BLOCKING_RSA
				rc = tls_do_client_key_exchange(state, &t, tport_out, 0);
				while (rc == -EAGAIN)
	            rc = tls_do_client_key_exchange(state, &t, tport_out, 1);
	#else
	         rc = tls_do_client_key_exchange(state, &t, tport_out, 0);
	         if (rc == -EAGAIN) {
	         	// non-blocking RSA operation not yet complete
	         	state->wait_rsa = SSL_WAIT_RSA_PCKE;
	         	return 0;
	         }
	#endif
#else
				// No -EAGAIN possible if not doing RSA
				rc = tls_do_client_key_exchange(state, &t, tport_out, 0);
#endif
	         break;
#if _SSL_USE_RSA_
	      case SSL_STATE_WAIT_CERT_VERIFY:
	         if (hh.msg_type != certificate_verify)
	            goto _unexpected;
	         rc = tls_do_certificate_verify(state, &t, tport_out, cert_verf_hashes);
	         break;
#endif
	      } // sw

			if (rc < 0)
				// Something went wrong
				return rc;

      } while (state->hdr.rec_type == SSL_REC_handshake);

	}	// while()

_do_output:

	if (state->cur_state == SSL_STATE_DRAINING &&
		 !(state->tport ? state->tport(state, TPORT_QUERY_UNSENT, 0) : 0)) {
		state->cur_state = SSL_STATE_WAIT_CLOSE;
		state->cn_timeout = _SET_TIMEOUT(state->cn_timeout);
	}
	else if (state->cur_state == SSL_STATE_WAIT_CLOSE &&
	    _CHK_TIMEOUT(state->cn_timeout)) {
		// Timed out waiting for peer CN after we sent CN.  Set done.
		state->tport && state->tport(state, TPORT_EVENT_CLOSE_NOTIFY_TIMEOUT, 0);
		tls_set_done(state);
	}

	// Now try to move application data.  Caller can put a hold on this by
	// providing null app_out, and also we will not generate a new record
	// if the remaining space in tport_out is less than SSL_OUT_BUF_RESERVE
	// bytes.
	if (app_out && app_out->len &&
	    state->cur_state == SSL_STATE_APP_DATA &&
	    (nag_avail = _tbuf_remain(tport_out)) >= SSL_OUT_BUF_RESERVE) {
		// OK to send application data.  nag_curr is size of record
		// we would create at this point.
      nag_curr = state->cipher_state->bulk_cipher->block_size;
      // If we're using a block cipher, leave room for the explicit IV.
      if (nag_curr) {
         nag_curr += SSL_EXPLICIT_IV_SIZE;
		}
		nag_curr += (nag_len = app_out->len) + sizeof(SSL_Record_Hdr) +
		           state->cipher_state->digest->hash_size;
		if (nag_curr > nag_avail) {
			nag_len -= (nag_curr - nag_avail);
			nag_curr = nag_avail;
		}
		if (state->nagle)
			nag_extra = state->nagle(state, nag_curr);
		else
			nag_extra = 0;
		if (!nag_extra)
			// Time to flush out.   We know there is sufficient space
			return tls_write_record(state, SSL_REC_application_data, app_out, nag_len, tport_out);
	}

	out_hs = state->cur_state & SSL_HANDSHAKE_STATES;
	if (out_hs) {
		// In handshake state on exit.  If different from entry state, then start timer.
		// Otherwise, see if timer expired.
		if (out_hs != in_hs)
			state->hs_timeout = _SET_SHORT_TIMEOUT(SSL_HANDSHAKE_TIMEOUT);
		else if (_CHK_SHORT_TIMEOUT(state->hs_timeout)) {
	#if _SSL_PRINTF_DEBUG
			printf("!!! Timed out waiting for handshake progress !!!\n");
	#endif
			tls_shutdown(state, SHUTDOWN_ABORT, tport_out);
		}
	}

	return 0;

_unexpected:
#if _SSL_PRINTF_DEBUG
	printf("*** Unexpected message ***\n");
#endif
 	return tls_error(state, SSL_READ_UNEXPECTED_MSG, tport_out);

}

/*** BeginHeader tls_do_server_hello */
int tls_do_server_hello(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_do_server_hello(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out)
{
   auto SSL_byte_t sess_id[SSL_MAX_SESSION_ID];
	auto SSL_ServerHello srv;
	auto size_t i;
	auto int rc;

   // Parse the handshake message
   _tbuf_extract(&srv.server_version, t, sizeof(SSL_ProtocolVersion) + sizeof(SSL_Random));

   // Extract length and session id and check for illegal length
   _tbuf_extract(&srv.session_id_length, t, 1);
   if(srv.session_id_length > SSL_MAX_SESSION_ID) {
#if _SSL_PRINTF_DEBUG
    	printf("*** Session ID too long (%u, max %u) ***\n",
    		srv.session_id_length, SSL_MAX_SESSION_ID);
#endif
      return tls_error(state, SSL_HS_SESSION_ID_TOO_LONG, out);
   }

   // Get session ID
   _tbuf_extract(sess_id, t, srv.session_id_length);
   srv.session_id = srv.session_id_length > 0 ? sess_id : NULL;
   if (state->flags & SSL_F_TRIED_RESUME) {
   	// Does response match our session ID?
   	if (srv.session_id_length == state->session_id_length &&
   	    !_f_memcmp(srv.session_id, state->session_id, srv.session_id_length))
   		state->flags |= SSL_F_RESUMED;
   }
   // Copy this session ID to state
	state->session_id_length = srv.session_id_length;
	_f_memcpy(state->session_id, srv.session_id,srv.session_id_length);

   // Extract selected ciphersuite
   _tbuf_extract(&srv.cipher_suite, t, 2);

   // Initialize cipher state based on the selection
	for (i = 0; i < state->n_accept_suites; ++i)
		if (srv.cipher_suite == state->accept_suites[i])
			break;
	if (i >= state->n_accept_suites) {
#if _SSL_PRINTF_DEBUG
    	printf("*** No suitable cipher suite ***\n");
#endif
		return tls_error(state, SSL_CIPHER_CHOICE_ERROR, out);
	}

	// Copy server random (we already generated client random back when sending client hello)
	_f_memcpy(&state->cipher_state->server_random, &srv.random, sizeof(SSL_Random));

	// Init cipher suite
	_ssl_cipher_init(state, ntohs(srv.cipher_suite));

   // Null compression must be specified, so assume it's there.  We currently don't
   // support any others.
   srv.compression_method = SSL_CM_null;

	#if _SSL_PRINTF_DEBUG > 2
	   printf("\n\nServer Random:\n");
	   mem_dump((SSL_byte_t*)&srv.random, sizeof(SSL_Random));
	#endif

   // Check Protcol Version
   if(!(srv.server_version.major == TLS1_VER_MAJ &&
        srv.server_version.minor == TLS1_VER_MIN))
   {
#if _SSL_PRINTF_DEBUG
    	printf("*** Bad TLS version ***\n");
#endif
      return tls_error(state, SSL_HS_CLI_PROTOCOL_ERROR, out);
   }

	rc = 0;

	if (state->flags & SSL_F_RESUMED) {
		state->cur_state = SSL_STATE_WAIT_CCS_RESUME;

      // Derive keys from state using TLSv1 algorithms
      rc = _tls_1_derive_keys(state);

      if(!rc) {
	      // Now that we have keys, we can initialize our bulk cipher
		   _ssl_bulk_cipher_init(state);
      }
	}
	else {
   	if (state->is_psk)
      	// can also get ServerKeyExchange
			state->cur_state = SSL_STATE_WAIT_SHD;
      else
			// Assume server must not be anonymous (and thus has to send its cert)
			state->cur_state = SSL_STATE_WAIT_CERT;
   }

	return rc;
}


/*** BeginHeader tls_do_certificate */
int tls_do_certificate(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_do_certificate(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out)
{
#if _SSL_USE_RSA_

	// Receive and parse certificate(s) from peer.
	// The first certificate is retained.  The others (if any) are used to verify their predecessor.
	auto SSL_Cert_t cert;
	auto _tbuf ct;
	auto char lenbuf[3];
	auto long oal;			// overall length
	auto long cert_len;	// certificate length
	auto size_t i;
	auto int rc;
	auto int rsn;

	memset(&cert, 0, sizeof(cert));
	if (t->len < 3)
		goto _len_error;
	_tbuf_extract(lenbuf, t, sizeof(lenbuf));
	oal = n24toul(lenbuf);
	if (oal != t->len)
		goto _len_error;

	for (i = 0; t->len >= 3; ++i) {
	   _tbuf_extract(lenbuf, t, sizeof(lenbuf));
	   cert_len = n24toul(lenbuf);
		if (t->len < cert_len)
			goto _len_error;
		_tbuf_overlay(&ct, t, 0, (word)cert_len);
		rc = SSL_new_cert(&cert, (long)(void __far *)&ct, SSL_DCERT_TBUF, i != 0);
		if (rc) {
			SSL_free_cert(&cert);
#if _SSL_PRINTF_DEBUG
    		printf("*** Bad certificate received, or processing error (rc=%d) ***\n", rc);
#endif
			return tls_error(state, SSL_BAD_CERT, out);
		}
		_tbuf_delete(t, (word)cert_len);
	}

	if (!t->len) {
		// Certs parsed OK, now verify chain if we have a trusted CA list
		// Only verify if application is not already giving a pass.
		if (state->trusted && !(state->flags & SSL_F_PEER_CERT_OK)) {
			rc = x509_certificate_chain_validate(
						state->trusted->u.x509_cert,
						cert.u.x509_cert,		// this will "work" even if NULL (but give validation error)
						&rsn,
						state->flags & SSL_F_COP_YIELD);
			if (rc) {
				// Validation failed.
#if _SSL_PRINTF_DEBUG
    			printf("*** Certificate verification failed (rc=%d) ***\n", rc);
#endif
				SSL_free_cert(&cert);
				return tls_error(state, SSL_CERT_CODE_BASE + rsn, out);
			}
		}

		if (state->policy && state->flags & SSL_F_REQUIRE_CERT) {
			rc = state->policy(state, state->trusted ? 1 : 0, cert.u.x509_cert,
										state->policy_data);
			if (rc) {
#if _SSL_PRINTF_DEBUG
    			printf("*** Certificate rejected by local policy (rc=%d) ***\n", rc);
#endif
				SSL_free_cert(&cert);
				return tls_error(state, EACCES, out);
			}
		}

		// else all OK; free all but first of chain (not needed any more)
		if (cert.u.x509_cert) {
			x509_certificate_chain_free(cert.u.x509_cert->next);
			cert.u.x509_cert->next = NULL;
		}
		// Free old cert if any.
		if (state->cert_flags & SSL_CF_OWN_PEER_CERT)
			SSL_free_cert(state->peer_cert);
		// Copy temp cert struct to peer_cert.
		_f_memcpy(state->peer_cert, &cert, sizeof(cert));
		state->flags |= SSL_F_PEER_CERT_OK | SSL_CF_OWN_PEER_CERT;

		if (state->is_client)
			state->cur_state = SSL_STATE_WAIT_SHD;
		else
			state->cur_state = SSL_STATE_WAIT_CKE;

		return 0;
	}
_len_error:
	SSL_free_cert(&cert);
#if _SSL_PRINTF_DEBUG
	printf("*** Certificate length error ***\n");
#endif
	return tls_error(state, SSL_READ_WRONG_LENGTH, out);
#else
	// Not using RSA.  Should not get a cert from peer, but if we do
   // then just ignore it.
	return 0;
#endif //#if _SSL_USE_RSA_

}


/*** BeginHeader tls_do_certificate_request */
int tls_do_certificate_request(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_do_certificate_request(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out)
{
	// We only support RSA signing.
	// DEVIDEA: save list of acceptable DNs for the client.  Currently, client would
	// have no clue as to which (if any) CAs would be acceptable to this server.
	state->flags |= SSL_F_SEND_CERT;
	return 0;
}



/*** BeginHeader tls_send_certificate_verify */
int tls_send_certificate_verify(ssl_Socket __far* state, _tbuf __far * out, int phase);
/*** EndHeader */
_ssl_tport_debug
int tls_send_certificate_verify(ssl_Socket __far* state, _tbuf __far * out, int phase)
{
	auto char hashes[RSA_KEY_LENGTH];
	auto _tbuf __far * t;
	auto int rc;
   auto RSA_key __far * key;
#ifndef RSA_DISABLE_CRT
   auto mp_modexpCRT_state * mms;
#else
   auto mp_modexp_state * mms;
#endif

	// Set up work area pointers for non-blocking RSA operation
	mms = &state->resource_index->nrp->modexp_work;
   key = state->cert->rsa_key;

	switch (phase) {
	case 0:
		// first phase: fire off modular exp.
	   if (!state->cert || TLS_SIGN_RSA != state->cipher_state->suite->signature_alg) {
	#if _SSL_PRINTF_DEBUG
	      printf("*** Cert verify signature algo not supported (not RSA) ***\n");
	#endif
	      return tls_error(state, SSL_PRIV_KEY_ENCRYPTION_FAIL, out);
	   }

	   // Digitally sign (rsa encrypt with our private key) the result of
	   // the handshake message hashes to this point.
      /* TODO: update Certificate Request code to handle new
         message structure, recording the requested
         SignatureAndHashAlgorithm, and use that to create
         cert_verf_hashes.
	   md5_sofar(&state->fin_hash->md5_hash, hashes);
	   sha_sofar(&state->fin_hash->sha_hash, hashes+16);
		*/

	   rc = RSA_PKCS1v1_5_Encrypt(key,
	                              hashes,
	                              36,	// MD5 plus SHA1 size
	                              NULL,
	                              1,    // signature
	                              0,    // first phase
	                              mms);
	#ifdef _COPROCESS_H
		if (rc == -EAGAIN)
				if (state->flags & SSL_F_COP_YIELD)
					cop_yield(state);
	#endif

	   break;

	case 1:

		// 2nd phase: chug through modular exponentiation.  When finished,
		// do final processing (key gen etc.) and return 0.  Else, return -EAGAIN
		// to keep chugging, or other -ve if error.
	   rc = RSA_PKCS1v1_5_Encrypt(key,
	                              NULL,
	                              0,
	                              hashes,	// takes output on last iteration
	                              1,    // signature
	                              1,    // subsequent phase
	                              mms);
		if (rc < 0) {
	#ifdef _COPROCESS_H
			if (rc == -EAGAIN)
				if (state->flags & SSL_F_COP_YIELD)
					cop_yield(state);
	#endif
			break;
		}

	   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, certificate_verify);
	   if (!t)
	      return tls_error(state, SSL_ALLOC_FAIL, out);

		_f_memcpy(t->buf + (t->len + 2), hashes, rc);
      *(size_t __far *)(t->buf + t->len) = htons(rc);

	   t->len += rc + 2;
	   rc = _tls_finalize_hs_msg(state, t, out);
	   break;
	}
	return rc;
}


/*** BeginHeader tls_do_server_hello_done */
int tls_do_server_hello_done(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out, int phase);
/*** EndHeader */
_ssl_tport_debug
int tls_do_server_hello_done(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out, int phase)
{
	auto int rc;
	// On receipt of server_hello_done, we
	//  - optionally send our certificate(s) (if server sent certificate request).  If necessary,
	//     send an empty cert list and let the server deal with it.
	//  - send client key exchange
	//  - optionally send certificate verify (if server sent certificate request)
	//     This proves to the server that we posess the private key for our cert.
	//  - send change cipher spec
	//  - send finished message

	// Client (active open) may specify zero or more certificates in a verification chain.
	// This is stored in the state->cert struct.  If state->cert has zero certs, then we send
	// an empty list.

	switch (phase) {
	case 0:
	   if (state->flags & SSL_F_SEND_CERT) {
	      if (rc = tls_send_certificate(state, out))
	         return rc;
	   }
	   if (rc = tls_send_client_key_exchange(state, out))
	      return rc;
	   // fall through
	case 1:
#if _SSL_USE_RSA_
	   if (state->flags & SSL_F_SEND_CERT && state->cert && state->cert->rsa_key) {
	      if (rc = tls_send_certificate_verify(state, out, phase))
	         return rc;	// may be -EAGAIN, or error
	   }
#endif
	   if (rc = tls_send_chg_cipher_spec(state, out))
	      return rc;
	   if (rc = tls_send_finished(state, out))
	      return rc;
	   state->cur_state = SSL_STATE_WAIT_CCS;
	}
	return 0;
}


/*** BeginHeader tls_do_server_key_exchange */
int tls_do_server_key_exchange(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_do_server_key_exchange(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out)
{
	// Only called when PSK negotiated.  Server sends this to client to provide a
   // 'key identity hint'.
   auto size_t hint_len;

   _tbuf_delete(t, 2);  // Remove redundant TLS length field
   state->psk_hint = &state->resource_index->psk_hint;
   // Quietly truncate hint to max size we can accept
   hint_len = u_min(t->len, sizeof(state->psk_hint->data));
   _tbuf_extract(state->psk_hint->data, t, hint_len);
	state->psk_hint->length = hint_len;
   #if _SSL_PRINTF_DEBUG > 2
   printf("\n--->PSK identity hint (%d) <---\n", hint_len);
   mem_dump(state->psk_hint->data, hint_len);
   #endif

	return 0;
}


/*** BeginHeader tls_do_client_key_exchange */
#define SSL_UNKNOWN_IDENTITY 961
int tls_do_client_key_exchange(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out, int phase);
/*** EndHeader */
_ssl_tport_debug
int tls_do_client_key_exchange(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out, int phase)
{
	// We are server, compute pre-master key.
   auto union {
#if _SSL_USE_RSA_
		struct {
	      char output[MP_SIZE];
	      char input[MP_SIZE];
      } rsa;
#endif
#if _SSL_USE_PSK_
		struct {
	      char input[SSL_MAX_PSK_IDENTITY];
      } psk;
#endif

   } buf;
#if _SSL_USE_RSA_
   auto RSA_key __far * key;
	#ifndef RSA_DISABLE_CRT
   auto mp_modexpCRT_state * mms;
	#else
   auto mp_modexp_state * mms;
	#endif
#endif
   auto int msg_len;
   auto size_t psk_id_len;
   auto size_t rsa_key_len;
	auto SSL_ClientKeyExchange cli_key_exch;
   auto int rc;


	switch (state->cipher_state->suite->key_exchange_alg) {

   default:
	#if _SSL_PRINTF_DEBUG
	   printf("***Key exchange algorithm choice invalid***\n");
	#endif
      return tls_error(state, SSL_PRIV_KEY_DECRYPTION_FAIL, out);

#if _SSL_USE_PSK_
	case TLS_KX_PSK:
		// Client provides key identifier (2 byte length followed by 0-2**16-1
      // bytes.  The identifier is used to find the appropriate key.
      // We use a callback for this.  The key is subsequently turned into
      // the pre-master secret.
      if (!state->getPSK) {
	   #if _SSL_PRINTF_DEBUG
	      printf("*** do-CKE: no getPSK ***\n");
	   #endif
	      return tls_error(state, SSL_PRIV_KEY_DECRYPTION_FAIL, out);
      }
      _tbuf_delete(t, 2);  // Remove redundant TLS length field
      psk_id_len = u_min(t->len, sizeof(buf.psk.input));
      _tbuf_extract(buf.psk.input, t, psk_id_len);
	   #if _SSL_PRINTF_DEBUG > 2
	   printf("\n--->PSK identity (%d) <---\n", psk_id_len);
	   mem_dump(buf.psk.input, psk_id_len);
	   #endif
      rc = state->getPSK(state,
      			NULL, 0,	// <- we are server, have no hint
      			buf.psk.input, &psk_id_len,
               cli_key_exch.by_kx_algo.psk.data,
               	&cli_key_exch.by_kx_algo.psk.length);
		if (rc) {
	   #if _SSL_PRINTF_DEBUG
	      printf("***Unknown identity***\n");
	   #endif
	      return tls_error(state, SSL_UNKNOWN_IDENTITY, out);
      }
	   #if _SSL_PRINTF_DEBUG > 2
	   printf("\n---> PSK (%u) <---\n", cli_key_exch.by_kx_algo.psk.length);
	   mem_dump(cli_key_exch.by_kx_algo.psk.data, cli_key_exch.by_kx_algo.psk.length);
	   #endif
		break;
#endif

#if _SSL_USE_RSA_
	case TLS_KX_RSA:
	   // Set up work area pointers for non-blocking RSA operation
	   mms = &state->resource_index->nrp->modexp_work;
	   key = state->cert->rsa_key;

	   switch (phase) {
	   case 0:
	      // first phase: fire off modular exp.
         // Get the encrypted message
         _tbuf_delete(t, 2);  // Remove redundant TLS length field

         rsa_key_len = state->cipher_state->key_exch->key_size >> 3;
         if (rsa_key_len != t->len || rsa_key_len > MP_SIZE-2 ||
             state->cert->rsa_key->public.n.length-2 != rsa_key_len) {
   #if _SSL_PRINTF_DEBUG
            printf("*** Private key decryption failed ***\n");
   #endif
            return tls_error(state, SSL_PRIV_KEY_DECRYPTION_FAIL, out);
         }
         _tbuf_extract(buf.rsa.input, t, rsa_key_len);

   #if _SSL_PRINTF_DEBUG > 2
         printf("\n--->Encrypted Pre-Master Secret<---\n");
         mem_dump(buf.rsa.input, rsa_key_len);
         printf("\nDoing RSA Decrypt...\n");
   #endif

         // Start the decryption
         msg_len = RSA_PKCS1v1_5_Decrypt(key,
                                         buf.rsa.input,
                                         buf.rsa.output,
                                         0,  // not a signature
                                         0,  // 1st phase
                                         mms);

         if (msg_len < 0) {
   #ifdef _COPROCESS_H
            if (state->flags & SSL_F_COP_YIELD)
               cop_yield(state);
   #endif
            return msg_len;
         }
	      // fall through (PKCS operation completed in blocking mode)
	   case 1:
	      // 2nd phase: chug through modular exponentiation.  When finished,
	      // do final processing (key gen etc.) and return 0.  Else, return -EAGAIN
	      // to keep chugging, or other -ve if error.
	      msg_len = RSA_PKCS1v1_5_Decrypt(key,
	                                      buf.rsa.input,
	                                      buf.rsa.output,
	                                      0,  // not a signature
	                                      1,  // 2nd phase
	                                      mms);
	      if (msg_len < 0) {
	   #ifdef _COPROCESS_H
	         if (state->flags & SSL_F_COP_YIELD)
	            cop_yield(state);
	   #endif
	         return msg_len;
	      }

	      rsa_key_len = state->cipher_state->key_exch->key_size >> 3;
	      // Check decrytped message length
	      if(msg_len != sizeof(SSL_PreMasterSecret)) {
	   #if _SSL_PRINTF_DEBUG
	         printf("***Key exchange decryption failure***\n");
	   #endif
	         // Error, unexpected message, handshake failure
	         return tls_error(state, msg_len > 0 ? SSL_PRIV_KEY_DECRYPTION_FAIL : SSL_PUB_KEY_INT_ERROR, out);
	      }

	   #if _SSL_PRINTF_DEBUG > 2
	      printf("\n--->Decrypted Pre-Master Secret (%u) <---\n", msg_len);
	      mem_dump(buf.rsa.output, msg_len);
	   #endif

	      // Copy message to our PreMasterSecret
	      _f_memcpy(&cli_key_exch.by_kx_algo.exchange_keys, buf.rsa.output, sizeof(SSL_PreMasterSecret));
	      break;
      }	// phase switch
      break;
#endif // _SSL_USE_RSA_
	}	// key exchange algo switch

   // Derive keys from message
   if(rc = _ssl_cli_key_exch(state, &cli_key_exch, out)) {
#if _SSL_PRINTF_DEBUG
      printf("***Key derivation failure***\n");
#endif
      return rc;
   }

   // Now we can initialize our bulk cipher
   // (there is no return value from this function)
   _ssl_bulk_cipher_init(state);

#if _SSL_PRINTF_DEBUG > 1
         printf("--->Bulk Cipher initialized<---\n");
#endif

   if (state->flags & SSL_F_REQUESTED_CERT)
      state->cur_state = SSL_STATE_WAIT_CERT_VERIFY;
   else
      state->cur_state = SSL_STATE_WAIT_CCS;

	return 0;
}


/*** BeginHeader tls_do_certificate_verify */
int tls_do_certificate_verify(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out, char * cert_verf_hashes);
/*** EndHeader */
_ssl_tport_debug
int tls_do_certificate_verify(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out, char * cert_verf_hashes)
{
#if _SSL_USE_RSA_
	auto char verf[MP_SIZE];
	auto char verf_plain[MP_SIZE];
   auto size_t plain_len, rsa_key_len;
   auto int rc;

#if _SSL_PRINTF_DEBUG > 1
	printf("--->Verifying client certificate...<---\n");
#endif
	_tbuf_delete(t, 2);	// Delete TLS redundant length field

   if (state->peer_cert && TLS_SIGN_RSA == state->cipher_state->suite->signature_alg) {
      rsa_key_len = state->cipher_state->key_exch->key_size >> 3;
      if (rsa_key_len != t->len || rsa_key_len > MP_SIZE-2) {
#if _SSL_PRINTF_DEBUG
    		printf("*** Public key decryption failed basic sanity ***\n");
#endif
      	return tls_error(state, SSL_PUB_KEY_DECRYPTION_FAIL, out);
      }
		_tbuf_extract(verf, t, rsa_key_len);
		if (crypto_public_key_decrypt_pkcs1(state->peer_cert->rsa_key, verf, rsa_key_len, verf_plain, &plain_len) ||
		    plain_len != 36 ||
		    _f_memcmp(cert_verf_hashes, verf_plain, 36)) {
#if _SSL_PRINTF_DEBUG
    		printf("*** Public key decryption failed ***\n");
#endif
      	return tls_error(state, SSL_PUB_KEY_DECRYPTION_FAIL, out);
      }
#if _SSL_PRINTF_DEBUG > 1
		printf("--->Client verified OK!<---\n");
#endif
	}
	else {
		// Unsupported signature algo.
#if _SSL_PRINTF_DEBUG
    	printf("*** Unsupported signature algorithm ***\n");
#endif
		return tls_error(state, SSL_PUB_KEY_DECRYPTION_FAIL, out);
	}

	state->cur_state = SSL_STATE_WAIT_CCS;
#endif
	return 0;
}


/*** BeginHeader tls_set_session */
int tls_set_session(ssl_Socket __far * state, SSL_Session_Resume_t __far * sess);
/*** EndHeader */
_ssl_tport_debug
int tls_set_session(ssl_Socket __far * state, SSL_Session_Resume_t __far * sess)
{
	auto SSL_CipherState __far* cipher;

   cipher = state->cipher_state;

   // Index now points into the cache, copy our data over to our state
   cipher->suite->suite_number = sess->suite_number;
   _f_memcpy(state->master_secret, &sess->master_secret, sizeof(SSL_Secret));
   state->session_id_length = sess->session_id_length;
   _f_memcpy(state->session_id, sess->session_id, state->session_id_length);

	return 0;
}

/*** BeginHeader tls_get_session */
int tls_get_session(ssl_Socket __far * state, SSL_Session_Resume_t __far * sess);
/*** EndHeader */
_ssl_tport_debug
int tls_get_session(ssl_Socket __far * state, SSL_Session_Resume_t __far * sess)
{
	auto SSL_CipherState __far* cipher;

   cipher = state->cipher_state;

   sess->suite_number = cipher->suite->suite_number;
   _f_memcpy(&sess->master_secret, state->master_secret, sizeof(SSL_Secret));
   sess->session_id_length = state->session_id_length;
   _f_memcpy(sess->session_id, &state->session_id, state->session_id_length);

   return 0;
}

/*** BeginHeader _ssl_session_save, _ssl_session_resume */
#if !SSL_NO_SESSION_RENEGOTIATION
int _ssl_session_save(ssl_Socket __far*);
int _ssl_session_resume(ssl_Socket __far*, SSL_byte_t __far *, SSL_uint16_t);
#endif
/*** EndHeader */

#if !SSL_NO_SESSION_RENEGOTIATION

// Our session cache
static __far int SSL_SESSION_RESUME_INDEX;
__far SSL_Session_Resume_t SSL_session_cache[SSL_MAX_SESS_RESUMES];

// Save a TLS session for later renegotiation
// Return 0 on success
_ssl_tport_debug
int _ssl_session_save(ssl_Socket __far* state) {
	auto int index;
	auto SSL_CipherState __far* cipher;
   #GLOBAL_INIT {
   	// Clear our table
		_f_memset(SSL_session_cache, 0, sizeof(SSL_session_cache));
      SSL_SESSION_RESUME_INDEX = 0; // Reset the index into the table
   } // End #GLOBAL_INIT section

   cipher = state->cipher_state;

   // LOCK(SSL_SESSION_RESUME_INDEX)
   //	Get access index into session resume cache
	// First, check for existing session ID, so we can update it, rather
   // than adding a second copy
   for(index = 0; index < SSL_MAX_SESS_RESUMES; index++) {
    	if(!_f_memcmp(state->session_id, SSL_session_cache[index].session_id,
                 state->session_id_length))
      {
       	break;
      }
   }

   // See if we got a match
   if(SSL_MAX_SESS_RESUMES == index) {
    	// we got a new session ID
	   index = SSL_SESSION_RESUME_INDEX;
   	SSL_SESSION_RESUME_INDEX++;
	   if(SSL_SESSION_RESUME_INDEX >= SSL_MAX_SESS_RESUMES) {
   		// Round-robin removal of old session resume items
	      SSL_SESSION_RESUME_INDEX = 0;
   	}
   }
#if _SSL_PRINTF_DEBUG > 1
	else {
		printf("\n***Updating existing Session ID***\n");
   }
#endif

   // UNLOCK(SSL_SESSION_RESUME_INDEX)

#if _SSL_PRINTF_DEBUG > 1
	printf("Session ID being saved for later resume:\n");
   mem_dump(state->session_id, state->session_id_length);
#endif

	return tls_get_session(state, SSL_session_cache + index);

} // end TLS_session_save

// Resume a TLS session based upon a specific session ID receieved
// from the client
_ssl_tport_debug
int _ssl_session_resume(ssl_Socket __far* state, SSL_byte_t __far * sess_id_xmem,
                       SSL_uint16_t sess_id_len)
{
	auto int index;
	auto SSL_CipherState __far* cipher;

   // We want to lock the cache through this entire function, so it
   // cannot be modified before we get a chance to copy over our data
   // This should not be too much of a problem, unless a lot of connections
   // want to resume all at once, then they will have to wait!
   // LOCK(SSL_session_cache)
   // Search the SSL_session_cache for a matching session ID
   for(index = 0; index < SSL_MAX_SESS_RESUMES; index++) {
    	if(!_f_memcmp(sess_id_xmem, SSL_session_cache[index].session_id, sess_id_len)) {
       	break;
      }
   }

   // Make sure we got a match
   if(index == SSL_MAX_SESS_RESUMES) {
    	// Error, we got an invalid session ID
      return 1;
   }

   return tls_set_session(state, SSL_session_cache + index);

}
#else
// Trying to use this function without first enabling session renegotiation
#fatal "INTERNAL LIBRARY ERROR: referencing _ssl_session_save or " \
       "_ssl_session_resume with SSL_NO_SESSION_RENEGOTIATION set to 1"
#endif

/*** BeginHeader _ssl_get_session_ID_seed */
void _ssl_get_session_ID_seed(SSL_byte_t __far seed[HMAC_MD5_HASH_SIZE],
                              SSL_byte_t __far *in_seed);
/*** EndHeader */

// Build the Session ID seed, used for indexing the Session renegotiation
// cache
_ssl_tport_debug
void _ssl_get_session_ID_seed(SSL_byte_t __far seed[HMAC_MD5_HASH_SIZE],
                              SSL_byte_t __far in_seed[SESS_ID_SEED_SIZE])
{
	// Seed is an MD5 hash
   auto md5_state_t md5;
   auto SSL_byte_t buf[SESS_ID_SEED_SIZE];
   auto int i;

   // Copy the seed into the buffer
   memcpy(buf, SESSION_ID_SEED_1, SESS_ID_SEED_SIZE);

   // First, XOR the input seed and the base seed
   for(i = 0; i < SESS_ID_SEED_SIZE; i++)
   {
    	buf[i] = buf[i] ^ in_seed[i];
   }

   // Build the final seed
   md5_init(&md5);
   md5_append(&md5, buf, SESS_ID_SEED_SIZE);
	md5_finish(&md5, seed);
}

/*** BeginHeader _ssl_big_rand */
void _ssl_big_rand(SSL_byte_t __far*, unsigned int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_ssl_big_rand                          <SSL_TPORT.LIB>

SYNTAX: void _ssl_big_rand(SSL_byte_t* value, unsigned int length);

DESCRIPTION: Cryptographic pseudo-random number generator that returns
             large (>32bit) numbers for use with TLS/SSL

				 NOTE: this needs to be able to interface with an external
                   RNG if one ever exists, for now, use RAND.LIB

PARAMETER 1: Return value, a pointer to an array of "digits" (chars)
PARAMETER 2: The number of digits (bytes) in value

RETURN VALUE: None

END DESCRIPTION **********************************************************/

_ssl_tport_debug
void _ssl_big_rand(SSL_byte_t __far* value, unsigned int length) {
	auto unsigned int i;

   for (i=0; i < length; ++i) {
#ifdef _SSL_DETERMINISTIC_TEST
		*value++ = 0x33;
#else
		*value++ = (char)seed_getbits(8);
#endif
   }
}

/*** BeginHeader ssl_aes_cbc_init ***/
#if _SSL_USE_AES_
int ssl_aes_cbc_init(void __far * state, int direction, char __far * key,
					  int key_length, char __far * iv);
#endif
/*** EndHeader ***/

/* START _FUNCTION DESCRIPTION ********************************************
ssl_aes_cbc_init                               <SSL_TPORT.LIB>

SYNTAX: int ssl_aes_cbc_init(AESstreamState* state, int direction, char* key,
					  int key_length, char* iv);

DESCRIPTION: Initialize the AES-CBC stream cipher. This function is a wrapper
             that implements the expected SSL API.

PARAMETER 1: An AES stream state structure
PARAMETER 2: Direction (ignored)
PARAMETER 3: The key, stored as a an array of bytes
PARAMETER 4: The length of the key (ignored, always 128 bits)
PARAMETER 5: Initialization vector

RETURN VALUE: 0 on success, non-zero on failure

END DESCRIPTION **********************************************************/

_ssl_tport_debug
int ssl_aes_cbc_init(void __far * state, int direction, char __far * key,
					  int key_length, char __far * iv)
{
	AESinitStream4x4((AESstreamState __far *)state, key, iv);
   return 0;
}

/*** BeginHeader _ssl_get_suite_str */
char* _ssl_get_suite_str(SSL_uint16_t);
/*** EndHeader */

_ssl_tport_debug
char* _ssl_get_suite_str(SSL_uint16_t suite)
{
	switch (suite) {
	case TLS_NULL_WITH_NULL_NULL: return "TLS_NULL_WITH_NULL_NULL";
#if _SSL_USE_PSK_
	case TLS_PSK_WITH_RC4_128_SHA: return "TLS_PSK_WITH_RC4_128_SHA";
   case TLS_PSK_WITH_AES_128_CBC_SHA: return "TLS_PSK_WITH_AES_128_CBC_SHA";
   case TLS_PSK_WITH_NULL_SHA: return "TLS_PSK_WITH_NULL_SHA";
#endif
	case TLS_RSA_WITH_NULL_MD5: return "TLS_RSA_WITH_NULL_MD5";
	case TLS_RSA_WITH_NULL_SHA: return "TLS_RSA_WITH_NULL_SHA";
	case TLS_RSA_WITH_NULL_SHA256: return "TLS_RSA_WITH_NULL_SHA256";
	case TLS_RSA_WITH_RC4_128_MD5: return "TLS_RSA_WITH_RC4_128_MD5";
	case TLS_RSA_WITH_RC4_128_SHA: return "TLS_RSA_WITH_RC4_128_SHA";
	/*
	case TLS_RSA_WITH_3DES_EDE_CBC_SHA: return "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
	case TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA: return "TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA";
	case TLS_DH_anon_WITH_3DES_EDE_CBC_SHA: return "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA";
	*/
	case TLS_RSA_WITH_AES_128_CBC_SHA: return "TLS_RSA_WITH_AES_128_CBC_SHA";
	case TLS_RSA_WITH_AES_128_CBC_SHA256: return "TLS_RSA_WITH_AES_128_CBC_SHA256";
	/*
	case TLS_DH_anon_WITH_AES_128_CBC_SHA: return "TLS_DH_anon_WITH_AES_128_CBC_SHA";
	case TLS_RSA_WITH_DES_CBC_SHA: return "TLS_RSA_WITH_DES_CBC_SHA";
	*/
	default: return "Unknown ciphersuite";
	}
}


/*** BeginHeader _ssl_choose_suite */
SSL_uint16_t _ssl_choose_suite(ssl_Socket __far* state, SSL_uint16_t __far *, SSL_uint16_t);
/*** EndHeader */

// Selection uses pre-defined constant priorities for each suite.
// Priorities are in increasing order, with 0 being the lowest
// priority (which is also the error condition)
// The length parameter is the number of elements in suites
// which is a pointer to an xmem buffer
_ssl_tport_debug
SSL_uint16_t _ssl_choose_suite(ssl_Socket __far* state, SSL_uint16_t __far * suites, SSL_uint16_t length) {
   auto int i;
   auto int priority;	// Priority level of the current suite
   auto SSL_uint16_t cur_suite, temp; // Currently selected suite

   priority = 0;
   cur_suite = TLS_NULL_WITH_NULL_NULL; // If we return this, error
   for(i = 0; i < length; i++) {
   	// the suite number is still in network short form, so convert
      temp = ntohs(suites[i]);

   	// See what we have
		switch(temp) {
#if _SSL_USE_RSA_
      case TLS_RSA_WITH_NULL_MD5:
	      if (!(state->suite_flags & SSL_S_ALLOW_NULL) ||
	          (state->suite_flags & SSL_S_FORBID_MD5))
	         break;
	      if(TLS_RSA_NULL_MD5_PRI > priority) {
	         priority =  TLS_RSA_NULL_MD5_PRI;
	         cur_suite = TLS_RSA_WITH_NULL_MD5;
	      }
	      break;
      case TLS_RSA_WITH_NULL_SHA:
      	if (!(state->suite_flags & SSL_S_ALLOW_NULL))
      		break;
	      if(TLS_RSA_NULL_SHA_PRI > priority) {
	         priority =  TLS_RSA_NULL_SHA_PRI;
	         cur_suite = TLS_RSA_WITH_NULL_SHA;
	      }
	      break;
      case TLS_RSA_WITH_NULL_SHA256:
      	if (!(state->suite_flags & SSL_S_ALLOW_NULL))
      		break;
	      if(TLS_RSA_NULL_SHA256_PRI > priority) {
	         priority =  TLS_RSA_NULL_SHA256_PRI;
	         cur_suite = TLS_RSA_WITH_NULL_SHA256;
	      }
	      break;
	#if _SSL_USE_RC4_
		case TLS_RSA_WITH_RC4_128_MD5:
	      if (state->suite_flags & (SSL_S_FORBID_RC4 | SSL_S_FORBID_MD5))
	         break;
	      if(TLS_RSA_RC4_128_MD5_PRI > priority) {
	         priority =  TLS_RSA_RC4_128_MD5_PRI;
	         cur_suite = TLS_RSA_WITH_RC4_128_MD5;
	      }
	      break;
		case TLS_RSA_WITH_RC4_128_SHA:
	      if (state->suite_flags & SSL_S_FORBID_RC4)
	         break;
	      if(TLS_RSA_RC4_128_SHA_PRI > priority) {
	         priority =  TLS_RSA_RC4_128_SHA_PRI;
	         cur_suite = TLS_RSA_WITH_RC4_128_SHA;
	      }
	      break;
	#endif
	#if _SSL_USE_AES_
		case TLS_RSA_WITH_AES_128_CBC_SHA:
	      if(TLS_RSA_AES_128_CBC_SHA_PRI > priority) {
	         priority =  TLS_RSA_AES_128_CBC_SHA_PRI;
	         cur_suite = TLS_RSA_WITH_AES_128_CBC_SHA;
	      }
	      break;
		case TLS_RSA_WITH_AES_128_CBC_SHA256:
	      if(TLS_RSA_AES_128_CBC_SHA256_PRI > priority) {
	         priority =  TLS_RSA_AES_128_CBC_SHA256_PRI;
	         cur_suite = TLS_RSA_WITH_AES_128_CBC_SHA256;
	      }
	      break;
	#endif
#endif
#if _SSL_USE_PSK_
		case TLS_PSK_WITH_NULL_SHA:
      	if (!(state->suite_flags & SSL_S_ALLOW_NULL) ||
         	 !(state->suite_flags & SSL_S_ALLOW_PSK))
      		break;
	      if (TLS_PSK_NULL_SHA_PRI > priority) {
	         priority =  TLS_PSK_NULL_SHA_PRI;
	         cur_suite = TLS_PSK_WITH_NULL_SHA;
	      }
			break;
	#if _SSL_USE_RC4_
		case TLS_PSK_WITH_RC4_128_SHA:
	      if (state->suite_flags & SSL_S_FORBID_RC4 ||
         	 !(state->suite_flags & SSL_S_ALLOW_PSK))
	         break;
	      if (TLS_PSK_RC4_128_SHA_PRI > priority) {
	         priority =  TLS_PSK_RC4_128_SHA_PRI;
	         cur_suite = TLS_PSK_WITH_RC4_128_SHA;
	      }
      	break;
   #endif
	#if _SSL_USE_AES_
		case TLS_PSK_WITH_AES_128_CBC_SHA:
      	if (!(state->suite_flags & SSL_S_ALLOW_PSK))
         	break;
	      if (TLS_PSK_AES_128_CBC_SHA_PRI > priority) {
	         priority =  TLS_PSK_AES_128_CBC_SHA_PRI;
	         cur_suite = TLS_PSK_WITH_AES_128_CBC_SHA;
	      }
      	break;
   #endif
#endif
      // Currently unsupported suites
      default:
	      break;  // Do nothing
      }
   }

   // Finally, return the suite we selected
   return cur_suite;
}


/*** BeginHeader _ssl_server_cipher_init */
int _ssl_server_cipher_init(ssl_Socket __far*, SSL_ClientHello __far*, _tbuf __far *);
/*** EndHeader */

// Initialize the ciphersuire state from a client_hello message
// This should only be called during the INITIAL handshake, NOT
// during a RESUME
// Return 0 on success, Non-zero on failure (set TLS_errno)
_ssl_tport_debug
int _ssl_server_cipher_init(ssl_Socket __far* state, SSL_ClientHello __far* cli_hello_ptr, _tbuf __far * out)
{
	auto SSL_CipherState __far* cipher;
   auto SSL_SuiteConfig __far* suite;
   auto SSL_uint16_t suite_number;
   auto SSL_byte_t rand_buf[SSL_MAX_SESSION_ID - HMAC_MD5_HASH_SIZE];
   auto SSL_byte_t seed_buf[HMAC_MD5_HASH_SIZE];
	auto int i, ret_val;

   ret_val = 0;

#if _SSL_PRINTF_DEBUG > 2
	printf("Client supported suites:\n");

	// Process the ciphersuite choices
   for(i = 0; i < cli_hello_ptr->ciphersuite_length/2; i++) {
   	suite_number = ntohs(cli_hello_ptr->cipher_suites[i]);
		// Only print if a known suite
		if(strcmp(_ssl_get_suite_str(suite_number), "Unknown ciphersuite")) {
			printf("%s\n", _ssl_get_suite_str(suite_number));
      }
   }
#endif

	// Access to state members
   cipher = state->cipher_state;
   suite = cipher->suite;

   // Set up the cipher suite, based on the suite selection
   // from the client offer (ciphersuite_length is the number of BYTES
   // in the ciphersuite array, so we need to divide by the size of
   // the suite numbers)
	suite_number = _ssl_choose_suite(state, cli_hello_ptr->cipher_suites,
                                   cli_hello_ptr->ciphersuite_length /
                                   sizeof(SSL_uint16_t));

   // Check the suite choice
	if(TLS_NULL_WITH_NULL_NULL == suite_number) {
    	// Oops, did not find a compatible ciphersuite
#if _SSL_PRINTF_DEBUG
    	printf("*** No suitable cipher suite ***\n");
#endif
      tls_error(state, SSL_CIPHER_CHOICE_ERROR, out);
      return 1; // Return immediately
   }

   // Setup the server random for generating key material
   // The time stamp needs to be a UNIX time stamp, so
   // calculate the value from the SEC_TIMER
#ifdef _SSL_DETERMINISTIC_TEST
	cipher->server_random.gmt_unix_time = 0;
#else
   cipher->server_random.gmt_unix_time = htonl(SEC_TIMER + RTC_EPOCH_DIFF);
#endif
   _ssl_big_rand(cipher->server_random.random_bytes, SSL_RANDOM_SIZE);

   // Initialize the cipher, based upon our selection
   // Note: No error return from TLS_cipher_init
	_ssl_cipher_init(state, suite_number);

  	// Create a new session ID
   // DEVIDEA: In the future, we need to check for the existence of
   // this session ID accross all instances of TLS connections,
   // due to the random element

	// Get the random part of the Session ID
   state->session_id_length = SSL_MAX_SESSION_ID;
   _ssl_big_rand(rand_buf, sizeof(rand_buf));

   // Get the seed for the Session ID
	_ssl_get_session_ID_seed(seed_buf, SESSION_ID_SEED_2);

   for(i = 0; i < SSL_MAX_SESSION_ID; i++) {
   	// Build the session ID from the seed and the random data
	   state->session_id[i] = (i & 0x1)?
                               seed_buf[i >> 1] : rand_buf[i >> 1];
   }

#if _SSL_PRINTF_DEBUG > 2
	printf("Session ID:\n");
   mem_dump(state->session_id, state->session_id_length);
#endif

   // Copy the client random into our state
  	_f_memcpy(&cipher->client_random, &cli_hello_ptr->random, sizeof(SSL_Random));

   // Success
   return 0;
}

/*** BeginHeader _ssl_cipher_init */
void _ssl_cipher_init(ssl_Socket __far*, SSL_uint16_t);
/*** EndHeader */


_ssl_tport_debug
int _NullCipherInit(void __far * state, int direction,
	          char __far * key, int key_length,
             char __far * iv)
{
	return 0;
}

_ssl_tport_debug
int _NullCipherTransform(void __far * state, const char __far * message,
            char __far * output, unsigned int length)
{
	if (message != output)
		_f_memcpy(output, message, length);
	return 0;
}


// Set up cipher suite, based upon selected suite (which is selected
// by caller and stored in state->cipher_state)
// If suite_number is 0, we don't know yet (since this is client).
// DEVIDEA: Use constant structs for initialization?
_ssl_tport_debug
void _ssl_cipher_init(ssl_Socket __far* state, SSL_uint16_t suite_number) {
	auto SSL_CipherState __far* cipher;
   auto SSL_SuiteConfig __far* suite;
   auto SSL_uint32_t time_stamp;

   cipher = state->cipher_state;
   suite = cipher->suite;

   // Set up our number and text name
	suite->suite_number = suite_number;
	suite->fulltext_name = _ssl_get_suite_str(suite_number);

   // Clear sequence number
  	_f_memset(cipher->seq_number, 0, SSL_SEQ_NUM_SIZE);
  	_f_memset(cipher->rd_seq_number, 0, SSL_SEQ_NUM_SIZE);


#if _SSL_PRINTF_DEBUG > 1
    printf("\nUsing ciphersuite: %ls\n", (char __far *)suite->fulltext_name);
#endif

///////////////////////////////////////////////////////
	if (0) {}	// syntax to allow following to start with 'else'

#if _SSL_USE_RSA_

   else if (TLS_RSA_WITH_NULL_MD5 == suite_number ||
       TLS_RSA_WITH_NULL_SHA256 == suite_number ||
       TLS_RSA_WITH_NULL_SHA == suite_number) {
	  	suite->key_exchange_alg = TLS_KX_RSA;
	  	suite->signature_alg = TLS_SIGN_RSA;
		suite->bulk_cipher_alg = TLS_CIPHER_NULL;
   	suite->digest_alg =
   		TLS_RSA_WITH_NULL_MD5 == suite_number ? TLS_DIGEST_MD5 :
         TLS_RSA_WITH_NULL_SHA == suite_number ? TLS_DIGEST_SHA :
   															 TLS_DIGEST_SHA256;
   }

	#if _SSL_USE_RC4_
   // Set up ciphersuite
   else if (TLS_RSA_WITH_RC4_128_MD5 == suite_number||
		      TLS_RSA_WITH_RC4_128_SHA == suite_number) {
	  	suite->key_exchange_alg = TLS_KX_RSA;
	  	suite->signature_alg = TLS_SIGN_RSA;
// DEVIDEA: Certificate authentication is not yet supported
//		suite->authentication_alg = TLS_AUTH_RSA;
		suite->bulk_cipher_alg = TLS_CIPHER_RC4_128;
   	suite->digest_alg =
   		TLS_RSA_WITH_RC4_128_MD5 == suite_number ? TLS_DIGEST_MD5 :
   															 	 TLS_DIGEST_SHA;
   }
	#endif

	#if _SSL_USE_AES_
	else if (TLS_RSA_WITH_AES_128_CBC_SHA == suite_number ||
       TLS_RSA_WITH_AES_128_CBC_SHA256 == suite_number) {
	  	suite->key_exchange_alg = TLS_KX_RSA;
	  	suite->signature_alg = TLS_SIGN_RSA;
      suite->bulk_cipher_alg = TLS_CIPHER_AES_128_CBC;
   	suite->digest_alg =
   		TLS_RSA_WITH_AES_128_CBC_SHA == suite_number ? TLS_DIGEST_SHA :
   															 	     TLS_DIGEST_SHA256;
   }
	#endif

#endif

#if _SSL_USE_PSK_
	else if (TLS_PSK_WITH_NULL_SHA == suite_number) {
	  	suite->key_exchange_alg = TLS_KX_PSK;
	  	suite->signature_alg = TLS_SIGN_PSK;
		suite->digest_alg = TLS_DIGEST_SHA;
      suite->bulk_cipher_alg = TLS_CIPHER_NULL;
      state->is_psk = 1;
   }
	#if _SSL_USE_RC4_
	else if (TLS_PSK_WITH_RC4_128_SHA == suite_number) {
	  	suite->key_exchange_alg = TLS_KX_PSK;
	  	suite->signature_alg = TLS_SIGN_PSK;
		suite->digest_alg = TLS_DIGEST_SHA;
      suite->bulk_cipher_alg = TLS_CIPHER_RC4_128;
      state->is_psk = 1;
   }
	#endif
	#if _SSL_USE_AES_
	else if (TLS_PSK_WITH_AES_128_CBC_SHA == suite_number) {
	  	suite->key_exchange_alg = TLS_KX_PSK;
	  	suite->signature_alg = TLS_SIGN_PSK;
		suite->digest_alg = TLS_DIGEST_SHA;
      suite->bulk_cipher_alg = TLS_CIPHER_AES_128_CBC;
      state->is_psk = 1;
   }
	#endif
#endif
///////////////////////////////////////////////////////

#if _SSL_USE_RSA_
   // Set up key exchange algorithms
   if(TLS_KX_RSA == suite->key_exchange_alg) {
		cipher->key_exch->key_size = (state->cert->rsa_key->public.n.length - 2)<<3;
		cipher->key_exch->encrypt = RSA_op;
		cipher->key_exch->decrypt = RSA_op;
   }
#endif

///////////////////////////////////////////////////////
// DEVIDEA: Certificate authentication always RSA
   // Set up authentication
/*
	if(TLS_AUTH_RSA == suite->authentication_alg) {
      cipher->auth;
		SSL_uint16_t key_size;
		SSL_uint16_t (*sign)();
		SSL_uint16_t (*verify)();
   }
*/
///////////////////////////////////////////////////////
   // Set up bulk cipher
   if (TLS_CIPHER_NULL == suite->bulk_cipher_alg) {
		cipher->bulk_cipher->key_size = 0;
		cipher->bulk_cipher->block_size = 0;
		cipher->bulk_cipher->init = _NullCipherInit;
		cipher->bulk_cipher->encrypt = _NullCipherTransform;
		cipher->bulk_cipher->decrypt = _NullCipherTransform;
   }

#if _SSL_USE_RC4_
	else if (TLS_CIPHER_RC4_128 == suite->bulk_cipher_alg) {
		cipher->bulk_cipher->key_size = 16; // Bytes = 128/8
		cipher->bulk_cipher->block_size = 0;
		cipher->bulk_cipher->init = RC4Init;
		cipher->bulk_cipher->encrypt = RC4Transform;
		cipher->bulk_cipher->decrypt = RC4Transform;
   }
#endif

#if _SSL_USE_AES_
   else if (TLS_CIPHER_AES_128_CBC == suite->bulk_cipher_alg) {
		cipher->bulk_cipher->key_size = 16; // Bytes = 128/8
		cipher->bulk_cipher->block_size = _AES_CBC_BLK_SZ_;
		cipher->bulk_cipher->init = ssl_aes_cbc_init;
		cipher->bulk_cipher->encrypt = AESencryptStream4x4_CBC;
		cipher->bulk_cipher->decrypt = AESdecryptStream4x4_CBC;
   }
#endif

   // Be sure to update SSL_MAX_CIPHER_KEY and SSL_MAX_CIPHER_BLOCK when
   // adding bulk ciphers.
///////////////////////////////////////////////////////

   // Set up digest algorithm (TLS only uses HMAC)
   cipher->digest->init = HMAC_hash_init;
   cipher->digest->add = HMAC_hash_append;
   cipher->digest->finish = HMAC_hash_finish;

   if(TLS_DIGEST_MD5 == suite->digest_alg) {
      // TLS uses HMAC for digests
      HMAC_init(&cipher->digest->state, HMAC_USE_MD5);
      cipher->digest->hash_size = HMAC_MD5_HASH_SIZE;

		// Set these here for use later
      cipher->server_mac_sec_size = HMAC_MD5_HASH_SIZE;
      cipher->client_mac_sec_size = HMAC_MD5_HASH_SIZE;
   }

   if(TLS_DIGEST_SHA == suite->digest_alg) {
      // TLS uses HMAC for digests
      HMAC_init(&cipher->digest->state, HMAC_USE_SHA);
      cipher->digest->hash_size = HMAC_SHA_HASH_SIZE;

	   // Set these here for use later
      cipher->server_mac_sec_size = HMAC_SHA_HASH_SIZE;
      cipher->client_mac_sec_size = HMAC_SHA_HASH_SIZE;
   }

   if(TLS_DIGEST_SHA256 == suite->digest_alg) {
      // TLS uses HMAC for digests
      HMAC_init(&cipher->digest->state, HMAC_USE_SHA256);
      cipher->digest->hash_size = HMAC_SHA256_HASH_SIZE;

	   // Set these here for use later
      cipher->server_mac_sec_size = HMAC_SHA256_HASH_SIZE;
      cipher->client_mac_sec_size = HMAC_SHA256_HASH_SIZE;
   }

   // Be sure to update SSL_MAX_HASH_SIZE/HMAC_MAX_HASH_SIZE when adding hashes.
///////////////////////////////////////////////////////
}

/*** BeginHeader _ssl_bulk_cipher_init */
void _ssl_bulk_cipher_init(ssl_Socket __far*);
/*** EndHeader */

// Initialize the bulk cipher algorithms
_ssl_tport_debug
void _ssl_bulk_cipher_init(ssl_Socket __far* state) {
   auto SSL_BulkCipherConfig __far* bulk_cipher;

   bulk_cipher = state->cipher_state->bulk_cipher;

   // We can now initialize our bulk cipher
   if (state->is_client) {
      // Init read cipher
		bulk_cipher->init((void __far *)&bulk_cipher->read_state, bulk_cipher->direction,
   	                  (void __far *)bulk_cipher->server_key, bulk_cipher->key_size,
      	               (void __far *)bulk_cipher->server_iv);

	   // Init write cipher
		bulk_cipher->init((void __far *)&bulk_cipher->write_state, bulk_cipher->direction,
      	               (void __far *)bulk_cipher->client_key, bulk_cipher->key_size,
         	            (void __far *)bulk_cipher->client_iv);
   }
   else {
      // Init read cipher
		bulk_cipher->init((void __far *)&bulk_cipher->read_state, bulk_cipher->direction,
   	                  (void __far *)bulk_cipher->client_key, bulk_cipher->key_size,
      	               (void __far *)bulk_cipher->client_iv);

	   // Init write cipher
		bulk_cipher->init((void __far *)&bulk_cipher->write_state, bulk_cipher->direction,
      	               (void __far *)bulk_cipher->server_key, bulk_cipher->key_size,
         	            (void __far *)bulk_cipher->server_iv);
   }
}


/*** BeginHeader tls_do_client_hello */
int tls_do_client_hello(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_do_client_hello(ssl_Socket __far * state, _tbuf * t, _tbuf __far * out)
{
	// After parsing the message:
   // 1) send server hello message
   // 2) send certificate
   // 3) send server hello done message
   auto SSL_byte_t sess_id[SSL_MAX_SESSION_ID];
   auto SSL_uint16_t ciphers[SSL_MAX_CIPHER_LIST];
	auto SSL_ClientHello cli_hello;
   auto int ret_val, temp;
   auto long cc;
   auto word i, suites;

   ret_val = 0; // Assume success
   state->flags &= ~SSL_F_RESUMED;

#if _SSL_PRINTF_DEBUG > 1
   	  printf("--->Received Client Hello, begin Server Hello<---\n");
#endif

   // Parse the handshake message
   _tbuf_extract(&cli_hello.client_version, t, sizeof(SSL_ProtocolVersion) + sizeof(SSL_Random));

   // Extract length and session id and check for illegal length
   _tbuf_extract(&cli_hello.session_id_length, t, 1);
   if(cli_hello.session_id_length > SSL_MAX_SESSION_ID) {
#if _SSL_PRINTF_DEBUG
 		printf("*** Session ID too long in client hello ***\n");
#endif
      return tls_error(state, SSL_HS_SESSION_ID_TOO_LONG, out);
   }

   // Get session ID
   _tbuf_extract(sess_id, t, cli_hello.session_id_length);

   // Extract length and ciphersuites
   _tbuf_extract(&cli_hello.ciphersuite_length, t, 2);
	cli_hello.ciphersuite_length = ntohs(cli_hello.ciphersuite_length);
   if(cli_hello.ciphersuite_length > SSL_MAX_CIPHER_LIST*2) {
#if _SSL_PRINTF_DEBUG
		printf("*** Client hello ciphersuite list too long ***\n");
#endif
      return tls_error(state, SSL_CIPHER_CHOICE_ERROR, out);
   }
   _tbuf_extract(ciphers, t, cli_hello.ciphersuite_length);

   // Extract length and compression methods (ignore actual methods)
   _tbuf_extract(&cli_hello.compression_length, t, sizeof(cli_hello.compression_length));
   _tbuf_delete(t, cli_hello.compression_length);

   cli_hello.session_id = cli_hello.session_id_length > 0 ? sess_id : NULL;
   cli_hello.cipher_suites = cli_hello.ciphersuite_length > 0 ? ciphers : NULL;
   // Null compression must be specified, so assume it's there.  We currently don't
   // support any others.
   cli_hello.compression_methods = NULL;

	#if _SSL_PRINTF_DEBUG > 2
	   printf("\n\nClient Random:\n");
	   mem_dump((SSL_byte_t*)&cli_hello.random, sizeof(SSL_Random));
	#endif

   // Check Protcol Version
   if(!(cli_hello.client_version.major == TLS1_VER_MAJ &&
        cli_hello.client_version.minor == TLS1_VER_MIN))
   {
#if _SSL_PRINTF_DEBUG
      printf("*** Bad version in client hello 0x%02x 0x%02x***\n",
         cli_hello.client_version.major, cli_hello.client_version.minor);
#endif
      return tls_error(state, SSL_HS_CLI_PROTOCOL_ERROR, out);
   }

#if !SSL_NO_SESSION_RENEGOTIATION
   // Check session ID for resume
   if (cli_hello.session_id_length) {
		// Client is attempting to resume, try to find
      // matching session ID and use that state
#if _SSL_PRINTF_DEBUG > 2
      printf("--->Received resume session client hello.<---\n");
      printf("Session ID:\n");
      mem_dump(cli_hello.session_id, cli_hello.session_id_length);
#endif

		if (state->flags & SSL_F_NO_RESUME)
			goto _ssl_hs_new_session; // Start a new session

		// Session resumption is allowed, so do it (sets up state with
      // cached session information)
      if(_ssl_session_resume(state, cli_hello.session_id,
                         cli_hello.session_id_length))
			// We have an invalid Session ID
			goto _ssl_hs_new_session; // Start a new session

		state->cur_state = SSL_STATE_WAIT_CCS_RESUME;
      // Now our state is setup with a cached master secret, so
      // we can derive keys, etc as normal

      // first we need to save our new client random from the hello message
      _f_memcpy(&state->cipher_state->client_random, &cli_hello.random,
             sizeof(SSL_Random));

	   // Setup the server random for generating key material
	   // The time stamp needs to be a UNIX time stamp, so
	   // calculate the value from the SEC_TIMER
#ifdef _SSL_DETERMINISTIC_TEST
	   state->cipher_state->server_random.gmt_unix_time = 0;
#else
	   state->cipher_state->server_random.gmt_unix_time = htonl(SEC_TIMER + RTC_EPOCH_DIFF);
#endif
	   _ssl_big_rand(state->cipher_state->server_random.random_bytes, SSL_RANDOM_SIZE);

	   // Initialize the cipher suite
   	// Note: No error return from TLS_cipher_init
		_ssl_cipher_init(state, state->cipher_state->suite->suite_number);

      // Derive keys from state using TLSv1 algorithms
      ret_val = _tls_1_derive_keys(state);

      if(!ret_val) {
	      // Now that we have keys, we can initialize our bulk cipher
		   _ssl_bulk_cipher_init(state);
      }

		if(!ret_val) {
      	// Send the server hello
      	ret_val = tls_send_server_hello(state, out);
      }

	   if(!ret_val) {
		   // Send ChangeCipherSpec message.  This
		   // sets the 'encrypt' flag so server finish message is sent encrypted.
			ret_val = tls_send_chg_cipher_spec(state, out);
	   }

	   if(!ret_val) {

		   // Send encrypted handshake finished message
			ret_val = tls_send_finished(state, out);

         state->flags |= SSL_F_RESUMED;
	   }
   }
   else
#endif //#if !SSL_NO_SESSION_RENEGOTIATION
	{
_ssl_hs_new_session:
   	// We have a new session, so initialize the state
	   // Initialize the cipher suite from the client hello message
	   if(_ssl_server_cipher_init(state, &cli_hello, out))
	      return tls_error(state, TLS_ALRT_handshake_failure, out);

		// Send back server hello
   	ret_val = tls_send_server_hello(state, out);
		if(!ret_val && !state->is_psk) {
	   	ret_val = tls_send_certificate(state, out);
		}
   	if(!ret_val) {
   		if (state->flags & SSL_F_REQUIRE_CERT && !state->is_psk) {
   			tls_send_certificate_request(state, out);
   			state->flags |= SSL_F_REQUESTED_CERT;
   		}
   		// Following will set state to WAIT_CERT or WAIT_CKE as appropriate.
	   	ret_val = tls_send_server_hello_done(state, out);
	   }
	}

	return ret_val;
}

/*** BeginHeader tls_connection_handshake */
/**
 * tls_connection_handshake - Process TLS handshake (client side)
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @in_data: Input data from TLS peer
 * @in_len: Input data length
 * @out_len: Length of the output buffer.
 * @appl_data: Pointer to application data pointer, or %NULL if dropped
 * @appl_data_len: Pointer to variable that is set to appl_data length
 * Returns: Pointer to output data, %NULL on failure
 *
 * Caller is responsible for freeing returned output data. If the final
 * handshake message includes application data, this is decrypted and
 * appl_data (if not %NULL) is set to point this data. Caller is responsible
 * for freeing appl_data.
 *
 * This function is used during TLS handshake. If the first call (with initial
 * default state of SSL_STATE_HS_LISTEN) is done with
 * in_len == 0, the library is expected to return ClientHello packet.
 * This packet is then sent to the server and a response from server is given
 * to TLS library by calling this function again with in_data pointing to the
 * TLS message from the server.
 *
 * If the TLS handshake fails, this function may return %NULL. However, if the
 * TLS library has a TLS alert to send out, that should be returned as the
 * output data. In this case, tls_connection_get_failed() must return failure
 * (> 0).
 *
 * tls_connection_established() should return 1 once the TLS handshake has been
 * completed successfully.
 *
 * NOTE: this function works for both client and server.  A "client handshake"
 * is used if the first call for a connection passes NULL in_data.
 *
 * NOTE: this is a wrapper for tls_sm().  It is better to use tls_sm() directly
 * since it provides better efficiency and error handling.
 */
char __far * tls_connection_handshake(void __far *tls_ctx, ssl_Socket __far *state,
			       char __far *in_data, size_t in_len,
			      size_t __far *out_len, char __far * __far *appl_data,
			      size_t __far *appl_data_len);
/*** EndHeader */
_ssl_tport_debug
char __far * tls_connection_handshake(void __far *tls_ctx, ssl_Socket __far *state,
			       char __far *in_data, size_t in_len,
			      size_t __far *out_len, char __far * __far *appl_data,
			      size_t __far *appl_data_len)
{


	auto _tbuf tport_in, tport_out, hs_in, app_in, app_out;
	auto int rc;


	if (appl_data_len)
		*appl_data_len = 0;
	if (appl_data)
		*appl_data = NULL;
	*out_len = 0;

	tport_in.buf = in_data;	// May be NULL
	tport_in.begin = 0;
	tport_in.len = tport_in.maxlen = in_len;

	// This is about 8k.  Hopefully enough.
	tport_out.maxlen = SSL_WRITE_BUF_SIZE+sizeof(ssl_Header);
	// Another temporary 2k for handshake defragmentation
	hs_in.maxlen = tport_out.maxlen;
	tport_out.buf = _sys_malloc(tport_out.maxlen + hs_in.maxlen);
	if (!tport_out.buf)
		return /*-ENOMEM*/ NULL;
	tport_out.begin = 0;
	tport_out.len = 0;

	hs_in.buf = tport_out.buf + tport_out.maxlen;
	hs_in.begin = 0;
	hs_in.len = 0;

	// Possible application data is stored here.  Max possible length is in_len.
	app_in.maxlen = in_len;
	app_in.buf = _sys_malloc(app_in.maxlen);
	if (!app_in.buf) {
		_sys_free(tport_out.buf);
		return /*-ENOMEM*/ NULL;
	}
	app_in.begin = 0;
	app_in.len = 0;

	app_out.len = 0;	// No outgoing app data

	// We need to loop until complete, since caller is not expected to handle
	// the -EAGAIN return code.
	do {
	   rc = tls_sm(state, in_len || state->cur_state != SSL_STATE_HS_LISTEN ? &tport_in : NULL,
	               &tport_out, &hs_in, &app_in, &app_out);
	} while (!rc && state->wait_rsa);

	*out_len = tport_out.len;
	if (rc != 0) {
		// If rc > 0, there was an incomplete record, but this API requires
		// complete records, so we have to treat this as a hard error.
		if (rc < 0 && tport_out.len) {
			// Error, but have alert data.
			_sys_free(app_in.buf);
			return tport_out.buf;
		}
		_sys_free(tport_out.buf);
		_sys_free(app_in.buf);
		return NULL;
	}
	if (app_in.len && appl_data && appl_data_len) {
		*appl_data_len = 0;
		*appl_data = app_in.buf;
	}
	else
		_sys_free(app_in.buf);
	return tport_out.buf;
}



/*** BeginHeader tls_connection_server_handshake */
/**
 * tls_connection_server_handshake - Process TLS handshake (server side)
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @in_data: Input data from TLS peer: starts at start of record header.
 * @in_len: Input data length
 * @out_len: Length of the output buffer.
 * Returns: pointer to output data, %NULL on failure
 *
 * Caller is responsible for freeing returned output data.
 *
 * NOTE: this function is slightly misnamed, in that it is not specific
 * to servers.  (The name is required for compatibility with wpa_supplicant).
 * This is simply a wrapper around tls_connection_handshake() which does not
 * allow app data to be returned.
 *
 * NOTE: this is a wrapper for tls_sm().  It is better to use tls_sm() directly
 * since it provides better efficiency and error handling.
 */
char __far * tls_connection_server_handshake(void __far *tls_ctx,
				     ssl_Socket __far *conn,
				      char __far *in_data, size_t in_len,
				     size_t __far *out_len);
/*** EndHeader */
_ssl_tport_debug
char __far * tls_connection_server_handshake(void __far *tls_ctx,
				     ssl_Socket __far *conn,
				      char __far *in_data, size_t in_len,
				     size_t __far *out_len)
{
	return tls_connection_handshake(tls_ctx, conn, in_data, in_len, out_len, NULL, NULL);
}

/*** BeginHeader _ssl_increment_seq */
int _ssl_increment_seq(SSL_byte_t __far*);
/*** EndHeader */

// Increment a sequence number. Assumes sequence number is in
// network-endian order (no conversion needed).
// Returns 0 on success, non-zero on failure
_ssl_tport_debug
int _ssl_increment_seq(SSL_byte_t __far* seq_num) {
 	auto int i;

   _ssl_assert(seq_num != NULL);

   /*
      Since the sequence number is always used in network-endian order, we
      can avoid endianness conversions by incrementing in reverse, hence the
      reversed loop index.
      
   	The algorithm works by starting with the LSB, and incrementing
   	it. If the byte overflows to 0x00, the loop continues, and increments
   	the next (more significant) byte.
      
   	If the increment didn't overflow, the function returns successfully.
   	If it overflows the entire 64-bit number, the function return an error.
	*/
   
   for(i = SSL_SEQ_NUM_SIZE-1; i >= 0; --i) {
      if (++seq_num[i])
         return 0;
   }
   // Should only get here on a rollover of 0xFFFFFFFFFFFFFFFF to 0.
   // In practice, this is a 64-bit number which starts at 0, thus it is totally
   // infeasible for it to overflow, even at a billion records per sec for 100 years.
   return 1;
}



/*** BeginHeader tls_gen_mac */
int tls_gen_mac(ssl_Socket __far* state, void __far* mac,
                _tbuf __far * data, _ssl_MAC_mode_t mac_mode, size_t data_len);
/*** EndHeader */

// Generate a MAC for a message (either incoming or outgoing) using the
// appropriate digest.
// Note: The buffer mac (parameter 2) is assumed to be
// big enough to contain final MAC.
// Also increments the appropriate sequence number
// Ignores the explicit IV at the start of received messages.
// Appropriate record header (state->hdr or state->wr_hdr) must be set up with
// *final* record length (in local host order), and parameter data_len is
// length of actual data to hash (and does not include the explicit IV).

_ssl_tport_debug
int tls_gen_mac(ssl_Socket __far* state, void __far* mac,
                _tbuf __far * data, _ssl_MAC_mode_t mac_mode, size_t data_len)
{
   auto SSL_CipherState __far* cipher;
   auto SSL_DigestConfig __far* digest;
   auto char __far * secret;
   auto char __far * seqno;
   auto size_t buf_size, length, temp_len, sec_size;
   auto SSL_Record_Hdr __far * h;
	auto ll_Gather g;		// Used for referring to tbuf data

   // Extract digest and cipher from TLS state
   cipher = state->cipher_state;
   digest = cipher->digest;

   // Get appropriate MAC secrets and sequence numbers
	if(mac_mode == SSL_MAC_RECEIVE) {
		h = &state->hdr;
		secret = state->is_client ? cipher->server_mac_sec : cipher->client_mac_sec;
		sec_size = state->is_client ? cipher->server_mac_sec_size : cipher->client_mac_sec_size;
		seqno = cipher->rd_seq_number;
	}
	else {
		h = &state->wr_hdr;
		secret = state->is_client ? cipher->client_mac_sec : cipher->server_mac_sec;
		sec_size = state->is_client ? cipher->client_mac_sec_size : cipher->server_mac_sec_size;
		seqno = cipher->seq_number;
	}

  	length = h->length;

#if _SSL_PRINTF_DEBUG > 3
   /*
   printf("MAC secret:\n");
   mem_dump((SSL_byte_t far*)secret, sec_size);
   printf("Sequence:\n");
   mem_dump((SSL_byte_t far*)seqno, SSL_SEQ_NUM_SIZE);
   */
#endif


   // TLS record MAC = Digest(mac_secret, seq_num + type + version +
   //                         length + content)
   // The digest is HMAC
   // All this function does is add the seq_num through content into the hash
   // and finish the hash, the individual algorithms take care of the rest
   if(mac_mode == SSL_MAC_SEND) {
	   digest->init((void __far *)&digest->state, secret,
	                sec_size, (void __far *)seqno,
	                SSL_SEQ_NUM_SIZE);
   }
	else {
	   digest->init((void __far *)&digest->state, secret,
	                sec_size, (void __far *)seqno,
	                SSL_SEQ_NUM_SIZE);
   }

   if (_ssl_increment_seq(seqno)) {
      SSL_error(state, SSL_SEQ_NUM_OVERFLOW);
   }

   // Add record type
   digest->add((void __far *)&digest->state, (void __far *)&h->rec_type, sizeof(h->rec_type));

   // Add version
   digest->add((void __far *)&digest->state, (void __far *)&h->version, sizeof(h->version));

   // Add length.  The length used in MAC calculations is the data length i.e. NOT including
   // the MAC length and any padding.
   temp_len = htons(data_len);
   digest->add((void __far *)&digest->state, (void __far *)&temp_len, 2);

   // *** Digest Content ***
   // Finally, add the content (skipping over received IV)
   _tbuf_ref(data, &g, mac_mode == SSL_MAC_SEND ? 0 : SSL_EXPLICIT_IV_SIZE, data_len);
   
#if _SSL_PRINTF_DEBUG > 3
   printf("Generating %s MAC - record length: %u+%u(mac)\n",
      mac_mode == SSL_MAC_RECEIVE ? "receive" : "send", data_len, digest->hash_size);
   mem_dump(g.data2, g.len2);
   if (g.len3)
      mem_dump(g.data3, g.len3);
#endif

	digest->add((void __far *)&digest->state, (void __far *)g.data2, g.len2);
	if (g.len3)
		digest->add((void __far *)&digest->state, (void __far *)g.data3, g.len3);

   // Finally, calculate the final MAC
   digest->finish((void __far *)&digest->state, (void __far *)mac);

   return length;
}


/*** BeginHeader tls_decrypt_contig */
int tls_decrypt_contig(ssl_Socket __far* state, char __far * data, SSL_uint16_t len);
/*** EndHeader */
_ssl_tport_debug
int tls_decrypt_contig(ssl_Socket __far* state, char __far * data, SSL_uint16_t len)
{
	auto SSL_BulkCipherState __far * bcrs;
   auto SSL_BulkCipherConfig __far * bc;
   auto size_t lendown, rem, bs;

   // Pointer to our bulk cipher
   bc = state->cipher_state->bulk_cipher;
   bcrs = &bc->read_state;
	bs = bc->block_size;

	if (bs > 1) {
		// Block cipher
	   if (bc->partial_block_len) {
	   	// Previous partial block, see if completed
	   	rem = bs - bc->partial_block_len;
	   	if (len < rem) {
	   		// Not complete yet
	   		_f_memcpy(bc->partial_block + bc->partial_block_len, data, len);
				bc->partial_block_len += len;
				return 0;
			}
			// block completed
			_f_memcpy(bc->partial_block + bc->partial_block_len, data, rem);
   		bc->decrypt(bcrs, bc->partial_block, bc->partial_block, bs);
   		_f_memcpy(bc->partial_tbuf.buf, bc->partial_block, bc->partial_block_len);
			_f_memcpy(data, bc->partial_block + bc->partial_block_len, rem);
			data += rem;
			len -= rem;
			bc->partial_block_len = 0;
	   }
	   // now data starts on a block boundary
	   lendown = (len / bs) * bs;
	   rem = len - lendown;
   	bc->decrypt(bcrs, data, data, lendown);
   	if (rem) {
   		bc->partial_tbuf.buf = data + lendown;
   		bc->partial_block_len = rem;
   		_f_memcpy(bc->partial_block, bc->partial_tbuf.buf, rem);
   	}

	}
	else
   	bc->decrypt(bcrs, data, data, len);

   return 0;
}

/*** BeginHeader tls_decrypt */
// Internal function.  If necessary, decrypts and checks MAC.
// Returns length of decrypted data, or -1 if error.
// Decryption is done in-place in 'data' circular buffer.
// 'out_data' is only for alert messages.
int tls_decrypt(ssl_Socket __far * state, ssl_Header __far * hdr, _tbuf __far * data,
					 size_t rec_len, _tbuf __far * out_data);
/*** EndHeader */

_ssl_tport_debug
int tls_decrypt(ssl_Socket __far * state, ssl_Header __far * hdr, _tbuf __far * data,
					 size_t rec_len, _tbuf __far * out_data)
{
   auto SSL_byte_t calcd_mac[SSL_MAX_HASH_SIZE];
   auto SSL_byte_t recvd_mac[SSL_MAX_HASH_SIZE];
	auto ll_Gather g;		// Used for referring to tbuf data
	auto size_t bytes_decrypted;
	auto SSL_CipherState __far * cipher;
	auto SSL_BulkCipherConfig __far * bulk_cipher;
   auto SSL_byte_t padding_len;
   auto SSL_DigestConfig __far* digest;  	// Pointer to digest state

	if (!rec_len)
		return 0;

   if (state->flags & SSL_F_DECRYPT)
   {
	   cipher = state->cipher_state;
	   _ssl_assert(cipher->digest->hash_size <= SSL_MAX_HASH_SIZE);

	   bulk_cipher = cipher->bulk_cipher;

   	_tbuf_ref(data, &g, 0, rec_len);

#if _SSL_PRINTF_DEBUG > 3
      printf("\n-------------------------------------------------\n");
      printf("\nReceived Record (encrypted, len=%u=0x%X):\n", rec_len, rec_len);
      mem_dump(g.data2, g.len2);
      if (g.len3)
      	mem_dump(g.data3, g.len3);
#endif

      tls_decrypt_contig(state, (char __far *)g.data2, g.len2);
      if (g.len3)
      	tls_decrypt_contig(state, (char __far *)g.data3, g.len3);

#if _SSL_PRINTF_DEBUG > 2
      printf("Entering mac checking code\n");
#endif

      // Check for padding if using a block cipher
      if(bulk_cipher->block_size > 0) {
			// Check that we decrypted a multiple of the block size
	      if (bulk_cipher->partial_block_len) {
#if _SSL_PRINTF_DEBUG
    			printf("*** Not proper multiple of block size ***\n");
#endif
	         return tls_error(state, SSL_READ_BLOCK_CIPHER_ERROR, out_data);
	      }

	      // Padding length is *(last byte), plus 1.
	      _tbuf_xread(&padding_len, data, rec_len-1, 1);
	      ++padding_len;
      }
      else {
         padding_len = 0;
      }
      cipher->bulk_cipher->padding_len = padding_len;

	   digest = cipher->digest;

      // Subtract out mac length and padding length, to indicate length
      // up to the start of the mac.
      bytes_decrypted = rec_len - (digest->hash_size + padding_len);

      // Generate the appropriate MAC for this record
		tls_gen_mac(state, calcd_mac, data, SSL_MAC_RECEIVE,
      	bytes_decrypted - SSL_EXPLICIT_IV_SIZE);

		// Retrieve the actual mac
	   _tbuf_xread(recvd_mac, data, bytes_decrypted, digest->hash_size);

#if _SSL_PRINTF_DEBUG > 3
      printf("Compare MACs\n");
      printf("\n-------------------------------------------------\n");
      printf("\nReceived Record (plaintext):\n");
      mem_dump(g.data2, g.len2);
      if (g.len3)
      	mem_dump(g.data3, g.len3);

      printf("\nReceived Record MAC:\n");
      mem_dump(recvd_mac, digest->hash_size);
      printf("\nGenerated Record MAC:\n");
      mem_dump(calcd_mac, digest->hash_size);
      printf("\n-------------------------------------------------\n");
#endif

      // Compare the digest
      if(memcmp(recvd_mac, calcd_mac, digest->hash_size)) {
         // MAC compare failed
#if _SSL_PRINTF_DEBUG
      	printf("*** MAC compare failure in tls_decrypt ***\n");
#endif
         return tls_error(state, SSL_BAD_RECORD_MAC, out_data);

      }
      return bytes_decrypted;
   }
   // Else unencrypted
   return rec_len;

}



/*** BeginHeader tls_proc_record */
/**
 * This  accepts record header and data in a tbuf, which is a circular buffer.
 * If there is a complete record, it decrypts the record and returns 0.  It
 * returns negative if there is an error.
 * Otherwise, it returns a positive number R if the caller must read a further
 * R bytes (or more), then call back again.  Initially, with zero data in the buffer,
 * the return value R would be sizeof(ssl_Header), which is 5.  After the
 * complete header is read
 * then R may increase according to the number of bytes expected in the record data
 * which are not yet available.  Only when a complete record is available is any
 * state permanently updated (except in the case of errors).
 *
 * Note that data in the input tbuf may be altered (e.g. decrypted).
 *
 * If app_data is not NULL, then it is a buffer to which any application
 * data received will be appended.  If NULL, then the decrypted data will
 * be in the input tbuf and the caller must then extract it if required.
 *
 * Similarly, hs_data is used to store handshake messages.  Content type
 * other than app data or handshakes change the state machine state but do
 * not output to any buffer (except maybe output alerts).
 *
 * If there is not enough data in the input tbuf for the current record, but
 * the input tbuf could potentially hold the complete record data, then this
 * routine returns a non-zero value which represents the additional amount of
 * data to read (and append to the input tbuf) before attempting to call this
 * routine again.  Otherwise, if a complete record was processed, the return code
 * will be zero, in which case the data from the tbuf will have been deleted
 * up to the end of the current record.
 * A return code of -1 indicates some other error.
 *
 * If a complete record is processed, then:
 *   .  conn->hdr will be set to the TLS-equivalent record header
 *       (the length of decrypted data can be obtained directly from hdr.length
 *        since it is stored in host format, and has the footer subtracted out)
 *   .  some state chages may be made if e.g. change cipher
 *        spec or alerts encountered.
 *   .  if any application data is received (in a valid state for it) then
 *        the data is decrypted and appended to app_data.
 *   .  if any handshake data is received (in a valid state for it) then
 *        the data is decrypted and appended to hs_data.
 *   .  data is deleted from the input buffer.
 * If there are errors, then:
 *   .  out_data may have a TLS alert appended.  Caller should check for this
 *        if the return code is -ve.
 *   .  special return code -EAGAIN indicates that application or HS data was
 *        received, however the provided buffer did not have sufficient
 *        space to receive this record.  Call again later when there is more
 *        free buffer space.  In this case, the appropriate one of *app_data_len
 *        or *hs_data_len will be set to the additional amount of free space
 *        which is required in that buffer.
 */
int tls_proc_record(ssl_Socket __far *state,
				     _tbuf __far * data,		// Input data from transport
				     _tbuf __far * out_data,	// For possible alerts
				     _tbuf __far * hs_data, size_t * hs_data_len, // Decrytped HS
				     _tbuf __far * app_data, size_t * app_data_len	// Decr. app data
				     );
/*** EndHeader */
_ssl_tport_debug
int tls_proc_record(ssl_Socket __far *state,
				     _tbuf __far * data,		// Input data from transport
				     _tbuf __far * out_data,	// For possible alerts
				     _tbuf __far * hs_data, size_t * hs_data_len, // Decrytped HS
				     _tbuf __far * app_data, size_t * app_data_len	// Decr. app data
				     )
{
   auto TLS_Alert alert;		  	   // Used to extract an alert message
   auto ssl_Header h;
	auto size_t rec_len, start, dstart, foot;
	auto int bytes_decrypted;
	auto int rec_type;
#ifndef TLS_OLDBUF
	auto word app_remain;
#endif

	if (app_data_len)
		*app_data_len = 0;
	if (hs_data_len)
		*hs_data_len = 0;

	// Check have enough for full header
	if (sizeof(ssl_Header) > data->len)
		return sizeof(ssl_Header) - data->len;

	// peek at header
	_tbuf_xread(&h, data, 0, sizeof(h));

	if (h.v3.version.major == TLS1_VER_MAJ && h.v3.version.minor >= 1) { // TODO: check this == TLS1_VER_MIN) {
		rec_len = ntohs(h.v3.length);
      rec_type = h.v3.rec_type;
	}
   else {
#if _SSL_PRINTF_DEBUG
      printf("*** Got unsupported header version 0x%02x 0x%02x***\n",
         h.v3.version.major, h.v3.version.minor);
#endif
      return tls_error(state, SSL_READ_PROTOCOL_VER, out_data);
   }

	dstart = sizeof(ssl_Header);
   if ((unsigned long)rec_len + dstart > data->len) {
      if ((unsigned long)rec_len + dstart > data->maxlen) {
         // Could not possibly fit record in this buffer
#if _SSL_PRINTF_DEBUG
      	printf("*** Got input record too long (%u, but only allow %u) ***\n",
      		rec_len + dstart, data->maxlen);
#endif
         return tls_error(state, SSL_READ_REC_OVERFLOW, out_data);
      }
      // OK, but currently not enough data to complete processing.  Try again.
      // Tell caller how much *more* data to get.
#if _SSL_PRINTF_DEBUG > 2
    	printf("[TLS RECORD] incomplete record, need %u more to make %u\n",
    		rec_len + dstart - data->len, rec_len + dstart);
#endif
      return rec_len + dstart - data->len;
   }

   // OK, we have enough to completely process this record and commit state changes,
	// but before making any state changes check that app data could fit.
	if (rec_type == SSL_REC_application_data && app_data) {
		// Force error if getting app data in other than APP_DATA or WAIT_CLOSE state,
		// or peer already sent us a close notify.
		if ((state->cur_state != SSL_STATE_APP_DATA &&
		     state->cur_state != SSL_STATE_WAIT_CLOSE &&
		     state->cur_state != SSL_STATE_HALF_CLOSED &&
		     SSL_STATE_DRAINING != state->cur_state) ||
		     state->flags & SSL_F_CLOSE_NOTIFY) {
#if _SSL_PRINTF_DEBUG
    		printf("*** Got app data in forbidden state ***\n");
#endif
			return tls_error(state, SSL_READ_UNEXPECTED_MSG, out_data);
		}

#ifdef TLS_OLDBUF
		// Caller wants to get app data and this is an app data record.  Look
		// ahead to see if the given output buffer could contain the app data.
		// For this purpose (since we don't want to decrypt the data just yet)
		// we assume the decr. data length is the current record length minus the
		// MAC size.  This is the longest it could possibly be.
		bytes_decrypted = rec_len - state->cipher_state->digest->hash_size;
		if (bytes_decrypted > _tbuf_remain(app_data)) {
			if (bytes_decrypted > app_data->maxlen) {
	         // Could not possibly fit record in this app data buffer
#if _SSL_PRINTF_DEBUG
      		printf("*** Got app record too long (%u, but only allow %u) ***\n",
      			bytes_decrypted, app_data->maxlen);
#endif
	         return tls_error(state, SSL_READ_REC_OVERFLOW, out_data);
	      }

			if (app_data_len)
				*app_data_len = bytes_decrypted - _tbuf_remain(app_data);
			return -EAGAIN;
		}
#endif
	}

#ifdef TLS_OLDBUF
	if (rec_type == SSL_REC_handshake && hs_data) {
		// Caller wants to get handshake data and this is an HS record.
		// Do similar to previous block, except assume unencrypted.
		if (rec_len > _tbuf_remain(hs_data)) {
			if (rec_len > hs_data->maxlen) {
	         // Could not possibly fit record in this HS data buffer
#if _SSL_PRINTF_DEBUG
      		printf("*** Got HS record too long (%u, but only allow %u) ***\n",
      			rec_len, hs_data->maxlen);
#endif
	         return tls_error(state, SSL_READ_REC_OVERFLOW, out_data);
	      }

#if _SSL_PRINTF_DEBUG > 2
    		printf("[TLS RECORD] have %u hs data, waiting for hs buffer\n", rec_len);
#endif
			if (hs_data_len)
				*hs_data_len = rec_len - _tbuf_remain(hs_data);
			return -EAGAIN;
		}
	}
#endif

	// Now everything should fit in buffers.

	_f_memcpy(&state->hdr, &h.v3, sizeof(state->hdr));
   state->hdr.length = rec_len;	// assume unencrypted for now

	// Delete header from buffer
   _tbuf_delete(data, dstart);

   // Decrypt the record payload, if needed
   if ((bytes_decrypted = tls_decrypt(state, &h, data, rec_len, out_data)) < 0)
      return bytes_decrypted;

	if (bytes_decrypted < rec_len) {
		// strip the explicit IV from the start of the decrypted data
      _ssl_assert(bytes_decrypted > SSL_EXPLICIT_IV_SIZE);
		bytes_decrypted -= SSL_EXPLICIT_IV_SIZE;
		rec_len -= SSL_EXPLICIT_IV_SIZE;
		_tbuf_delete(data, SSL_EXPLICIT_IV_SIZE);
      
		// There was a non-zero footer (mac plus padding).
		state->hdr.length = bytes_decrypted;
	}
   
#if _SSL_PRINTF_DEBUG > 2
	if  (bytes_decrypted < rec_len)
   	printf("[TLS RECORD] have %u length record, decrypted to %u\n", rec_len, bytes_decrypted);
	else
   	printf("[TLS RECORD] have %u length record\n", rec_len);
#endif

	switch (rec_type) {
	default:
		// Unknown content type
#if _SSL_PRINTF_DEBUG
      printf("*** Got bad content type ***\n");
#endif
      return tls_error(state, SSL_READ_UNEXPECTED_MSG, out_data);

	case SSL_REC_handshake:
#ifdef TLS_OLDBUF
   	if (hs_data)
	      // Got handshake data, append to hs_data.  Note that
	      // we checked above that there was sufficient space in the
	      // dest buffer.
	      _tbuf_move(hs_data, data, bytes_decrypted, 1, 0);
#else
		// New buffering: hope that HS records are not fragmented,
		// since we now just alias hs_data to the part of the data
		// buffer containing the (hopefully complete) HS record.
		// This works because tls_sm() processes entire HS rec before
		// returning to caller.
		if (hs_data) {
			_f_memcpy(hs_data, data, sizeof(*hs_data));
			hs_data->len = bytes_decrypted;
		}
#endif
		break;

	case SSL_REC_application_data:
#ifdef TLS_OLDBUF
		if (app_data)
   		// Got legitimate app data, append to app_data.  Note that
   		// we checked above that there was sufficient space in the
   		// dest buffer.
   		_tbuf_move(app_data, data, bytes_decrypted, 1, 0);
#else
		// New buffering style, allows relatively small app data buffer.
		if (app_data) {
			app_remain = _tbuf_remain(app_data);
			if ((word)bytes_decrypted <= app_remain) {
   			_tbuf_move(app_data, data, bytes_decrypted, 1, 0);
   			state->indata_remain = 0;
   		}
			else {
				// Need to move in smaller chunks (requires more sm calls
				// to drain down the tport buffer).
   			_tbuf_move(app_data, data, app_remain, 1, 0);
   			_tbuf_delete(data, app_remain);
				state->indata_remain = bytes_decrypted - app_remain;
   			state->footer_remain = rec_len - bytes_decrypted;
#if _SSL_PRINTF_DEBUG
    			printf("tls_proc_record: long app rec, stored=%u, indata_remain=%u, footer=%u\n",
    				app_remain, state->indata_remain, state->footer_remain);
#endif
   			return 0;
			}
		}
#endif
		break;

   // See if we got an alert
   case SSL_REC_alert:
   	++state->alerts_recvd;
      if (bytes_decrypted < sizeof(TLS_Alert)) {
#if _SSL_PRINTF_DEBUG
         printf("*** Received alert, but data too short ***\n");
#endif
         return tls_error(state, SSL_READ_PROTOCOL_ERROR, out_data);
      }
      _tbuf_xread(&alert, data, 0, sizeof(TLS_Alert));
      if(TLS_ALRT_close_notify == alert.description &&
          (state->cur_state == SSL_STATE_APP_DATA ||
           state->cur_state == SSL_STATE_WAIT_CLOSE ||
           state->cur_state == SSL_STATE_HALF_CLOSED ||
           SSL_STATE_DRAINING == state->cur_state)) {
#if _SSL_PRINTF_DEBUG
         printf("^^^Received close_notify alert^^^\n");
#endif

         // In principle, we can still write data
         // to other side, but the spec (inflexibly, IMO) allows it to be discarded.
         // SSL does not support half close, so we send CN immediately on recipt
         state->flags |= SSL_F_CLOSE_NOTIFY;

			state->tport && state->tport(state, TPORT_EVENT_CLOSE_NOTIFY, 0);

			// Remove the following if want to implement true half-close
			// But then, you wouldn't be following the TLS spec...
			if (state->cur_state != SSL_STATE_WAIT_CLOSE)
				// Only send if not already sent CN!
         	tls_send_alert(state, TLS_ALRT_close_notify, out_data, TLS_warning);

         // If we sent CN, then fully closed now.
         if (state->cur_state == SSL_STATE_WAIT_CLOSE ||
             state->cur_state == SSL_STATE_DRAINING)
         	tls_set_done(state);

      }
      // Other alert handling, all other alerts are errors
      else {
#if _SSL_PRINTF_DEBUG
         printf("^^^Received alert. Description number: %d^^^\n",
                alert.description);
#endif
         state->TLS_alertno = alert.description;
			state->tport && state->tport(state, TPORT_EVENT_FATAL_ALERT, alert.description);
         return tls_error(state, SSL_READ_RECEIVED_ALERT, out_data);
      }
   	break;

   // Check for ChangeCipherSpec message
   case SSL_REC_change_cipher_spec:
	   #if _SSL_PRINTF_DEBUG
	         printf("--->Received ChangeCipherSpec Message<---\n");
	   #endif
      if (SSL_STATE_WAIT_CCS == state->cur_state)
         // Set state for handshake message handling
         state->cur_state = SSL_STATE_WAIT_FIN;
      else if (SSL_STATE_WAIT_CCS_RESUME == state->cur_state)
         // Set state for handshake message handling
         state->cur_state = SSL_STATE_WAIT_FIN_RESUME;
      else {
         // If we receive this message in any other state,
         // it is an error
#if _SSL_PRINTF_DEBUG
    		printf("*** Got CCS in forbidden state ***\n");
#endif
         return tls_error(state, SSL_READ_UNEXPECTED_MSG, out_data);
		}

      // Successful CCS means we go crypto (for receive)...
      state->flags |= SSL_F_DECRYPT;
      break;
   }

   // Finally, delete data from input buffer (already deleted header above)
   _tbuf_delete(data, rec_len);

	return 0;
}

/*** BeginHeader tls_encrypt */
int tls_encrypt(ssl_Socket __far * state, _tbuf __far * out, char __far * data, size_t len);
/*** EndHeader */
_ssl_tport_debug
int tls_encrypt(ssl_Socket __far * state, _tbuf __far * out, char __far * data, size_t len)
{
	// Encrypt given data and append to 'out'.
	// Note that encryption is always assumed to succeed.  This is because it always will
	// if the code is correct, and it is difficult to insert proper alert messages otherwise.
	// The only error can occur if the output buffer has insufficient space.  Caller must check.
	auto char buf[SSL_MAX_CIPHER_BLOCK];	// help split over output
   auto SSL_BulkCipherConfig __far* bc;
   auto int ret_val;
   auto char __far * p;
   auto ll_Gather g;
   auto void __far * bcws;
   auto size_t bs, rem, lendown, lenup, lendown2, rem2, rem3;
   auto int do_blocks;

   // Pointer to our bulk cipher, cache a few things
   bc = state->cipher_state->bulk_cipher;
	bcws = &bc->write_state;
   bs = bc->block_size;
   do_blocks = bs > 1;

	// If partial block from last time, try to complete it and add to the tail of the
	// previous output.
	if (bc->partial_block_len) {
		rem = bs - bc->partial_block_len;
		if (len >= rem) {
			// Yes, now complete.  Copy complete data, encrypt in-place, and move
			// to output (assumed to be same buffer as current output)
			_f_memcpy(bc->partial_block + bc->partial_block_len, data, rem);
			data += rem;
			len -= rem;
	      bc->encrypt(bcws, (char __far *)bc->partial_block, (char __far *)bc->partial_block, bs);
	      _tbuf_append(&bc->partial_tbuf, bc->partial_block, bs);
	      bc->partial_block_len = 0;
			// now proceed as normal
		}
		else {
			// still incomplete, copy source data and return
			_f_memcpy(bc->partial_block + bc->partial_block_len, data, len);
			bc->partial_block_len += len;
			return 0;
		}
	}

	if (!len)
		return 0;

	// At this point, we are starting a new block (i.e. partial_block_len is zero)
	// Set g to indicate output area(s) i.e. not already containing data
	_tbuf_writeref(out, &g);

	if (do_blocks) {
	   // Round down/up to next lower/higher block multiple from given data length.
	   // If length is an exact block multiple, both roundings are equal.
	   lendown = (len/bs) * bs;
	   if (lendown == len)
	      lenup = lendown;  // Exact multiple
	   else
	      lenup = lendown + bs;
	}
	else
		lenup = lendown = len;

	// Ensure data can fit.  Use the rounded-up figure, since eventually the partial
	// block will be finished and we'll need to fit it in as well.
	if (lenup > g.len2+g.len3)
   	return -1;

	if (do_blocks) {
	   bc->partial_block_len = rem = len - lendown; // partial block remainder at end
	   if (rem) {
	      // remember where encrypted block will go
	      _f_memcpy(&bc->partial_tbuf, out, sizeof(_tbuf));
	      bc->partial_tbuf.len += lendown;
	      // store tail data now
	      _f_memcpy(bc->partial_block, data + lendown, rem);
	   }
	}

	if (lendown > g.len2) {
		if (do_blocks) {
	      lendown2 = (g.len2 / bs) * bs;
	      rem2 = g.len2 - lendown2;
	      rem3 = bs - rem2;
	      bc->encrypt(bcws, data, g.data2, lendown2);
	      if (rem2) {
	         // block straddles output split point.
	         _f_memcpy(buf, data + lendown2, bs);
	         bc->encrypt(bcws, (char __far *)buf, (char __far *)buf, bs);
	         _f_memcpy((char __far *)g.data2 + lendown2, buf, rem2);
	         _f_memcpy((char __far *)g.data3, buf + rem2, rem3);
	         lendown2 += bs;   // length written so far (extra block for the overlapped bit)
	      }
         else
         	// Fits exactly at end
         	rem3 = 0;
	      bc->encrypt(bcws, data + lendown2, g.data3 + rem3, lendown - lendown2);
	   }
	   else {
	   	// not block cipher: easy!
	      bc->encrypt(bcws, data, g.data2, g.len2);
	      bc->encrypt(bcws, data + g.len2, g.data3, len - g.len2);
	   }
	}
	else {
   	bc->encrypt(bcws, data, g.data2, lendown);
   }

   // Adjust output tbuf, since we successfully wrote data.  We use the lenup
   // amount (even though that trailing data may not be written yet).
  	out->len += lenup;

   return 0;

}


/*** BeginHeader tls_write_record */
/*
   Create a TLS record with a given type, using data from 'data' for length 'len'.
   If necessary, the data has MAC and padding appended, and is encrypted.  Resulting
   record is appended to out.  On success, the input data is logically deleted from
   its tbuf.  On failure, out buffer may have an alert message instead of the input data.
*/
int tls_write_record(ssl_Socket __far * state, SSL_ContentType rec_type,
            _tbuf __far * data, size_t len, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_write_record(ssl_Socket __far * state, SSL_ContentType rec_type,
            _tbuf __far * data, size_t len, _tbuf __far * out)
{
   auto SSL_byte_t mac[HMAC_MAX_HASH_SIZE];
   auto SSL_byte_t pad[SSL_MAX_CIPHER_BLOCK];
   auto SSL_byte_t explicit_iv[SSL_EXPLICIT_IV_SIZE];
   auto long length;
   auto SSL_CipherState __far* cipher;
   auto SSL_DigestConfig __far* digest;
   auto int block_size;
   auto char padding_len;
   auto int encrypted;			// Encryption flag
	auto ll_Gather g;		// Used for referring to tbuf data
#if _SSL_PRINTF_DEBUG
	auto word out_offs;

	out_offs = out->len;	// Remember start point for debug output
#endif

   // Extract digest and cipher from TLS state
   cipher = state->cipher_state;
   digest = cipher->digest;

   encrypted = state->flags & SSL_F_ENCRYPT;

   state->wr_hdr.rec_type = rec_type;
	state->wr_hdr.version.major = TLS1_VER_MAJ;
	state->wr_hdr.version.minor = TLS1_VER_MIN;
   length = len;
   cipher->bulk_cipher->padding_len = padding_len = 0;
   if (encrypted) {
      // Account for the explicit IV before the cleartext payload
      length += SSL_EXPLICIT_IV_SIZE;
      
   	length += digest->hash_size;
      // Add padding for block ciphers according to RFC 2246 section 6.2.3.2
      block_size = cipher->bulk_cipher->block_size;
      _ssl_assert(block_size <= SSL_MAX_CIPHER_BLOCK);
      
      if (block_size) {
         // Fill up the remainder of last block (if length of data is not a
         // multiple of the block size) with bytes equal to the size of the
         // remainder (e.g. 6 bytes remain, padding = 06 06 06 06 06 06)
         // The SSL record uses the last byte to represent the length of
         // the padding - the padding value is actually 1 byte smaller than
         // the actual padding length, so 7 bytes padding equals 7 repetitions
         // of the byte 06.
         padding_len = (char)(block_size - (length % block_size));

         if (!padding_len)
            padding_len = block_size;

         // Subtract one to get padding byte
         memset(pad, padding_len-1, padding_len);
         length += padding_len;
      }
   }


   state->wr_hdr.length = (word)length;
   if (encrypted) {
   	// This expects header length to be in host order
		tls_gen_mac(state, mac, data, SSL_MAC_SEND, len);
      if (block_size) {
      	_ssl_big_rand(explicit_iv, sizeof explicit_iv);
      }
   }
	// Correct endianness
   state->wr_hdr.length = htons((word)length);

   _tbuf_ref(data, &g, 0, len);

#if _SSL_PRINTF_DEBUG > 3
		printf("------------------- S E N D ----------------------\n");
   	printf("Sending 5(hdr)+%u(iv)+%u+%u(mac)+%u(pad)\n",
   		encrypted && block_size ? SSL_EXPLICIT_IV_SIZE : 0, len,
         encrypted ? digest->hash_size : 0, encrypted ? padding_len : 0);
	#if _SSL_PRINTF_DEBUG > 4
  		printf("\nRecord header:\n");
   #endif
      mem_dump((SSL_byte_t __far*)&state->wr_hdr, sizeof(SSL_Record_Hdr));
      if (encrypted && block_size) {
	#if _SSL_PRINTF_DEBUG > 4
			printf("\nExplicit IV:\n");
   #endif
			mem_dump(explicit_iv, sizeof explicit_iv);
		}
	#if _SSL_PRINTF_DEBUG > 4
  		printf("\nRecord data (plaintext):\n");
	#endif
      mem_dump(g.data2, g.len2);
      if (g.len3)
      	mem_dump(g.data3, g.len3);
      if (encrypted) {
	#if _SSL_PRINTF_DEBUG > 4
			printf("Mac Secret (%s):\n", state->is_client ? "client" : "server");
	      mem_dump(state->is_client ? cipher->client_mac_sec : cipher->server_mac_sec,
	      				cipher->server_mac_sec_size);
			printf("\nSequence number:\n");
	#endif
      	mem_dump((SSL_byte_t __far*)&cipher->seq_number, SSL_SEQ_NUM_SIZE);
	#if _SSL_PRINTF_DEBUG > 4
	      printf("\nRecord MAC:\n");
	#endif
	      mem_dump(mac, digest->hash_size);
      }
		printf("\n-------------------------------------------------\n");
#endif

	// Check that final record can fit in output buffer
	if (length + sizeof(ssl_Header) > _tbuf_remain(out)) {
		// This will try to use 'out' to write an alert, however this is only done if
		// not currently trying to write an alert, to avoid infinite recursion.
      // TODO: need to pass state information through this calling chain and
      // down to tls_gen_mac() to have it NOT increment the sequence number
      // since we're not actually sending this record.
#if _SSL_PRINTF_DEBUG
    	printf("*** Could not send alert ***\n");
#endif
		return tls_error(state,
				rec_type == SSL_REC_alert ? SSL_COULD_NOT_SEND_ALERT : SSL_WRITE_REC_TOO_BIG,
				out);
	}
	// Move header to output buffer
	_tbuf_append(out, &state->wr_hdr, sizeof(state->wr_hdr));

   if(encrypted) {

#if _SSL_PRINTF_DEBUG > 3
      printf("\nBlock cipher Padding value:%d\n", padding_len-1);
      printf("Record Length after padding:%ld=0x%lX\n", length, length);
#endif
      if (block_size) {
         // encrypt explicit IV before cleartext payload
         tls_encrypt(state, out, explicit_iv, SSL_EXPLICIT_IV_SIZE);
      }
      tls_encrypt(state, out, (void __far *)g.data2, g.len2);
      if (g.len3)
      	tls_encrypt(state, out, (void __far *)g.data3, g.len3);
      tls_encrypt(state, out, (void __far *)mac, digest->hash_size);
      if (block_size) {
	      if (padding_len)
	         tls_encrypt(state, out, (void __far *)pad, padding_len);
	   }
#if _SSL_PRINTF_DEBUG > 4
   	_tbuf_ref(out, &g, out_offs, out->len - out_offs);
      printf("\n-------------------------------------------------\n");
      printf("\nSending Record (ciphertext):\n");
      mem_dump(g.data2, g.len2);
      if (g.len3)
      	mem_dump(g.data3, g.len3);
#endif
   }
   else {
   	// Not encrpyted, just move data
		_tbuf_append(out, (void __far *)g.data2, g.len2);
		if (g.len3)
			_tbuf_append(out, (void __far *)g.data3, g.len3);
	}

   // Sucess, we created a record.  Consume from input tbuf
	_tbuf_delete(data, len);

   return 0;
}

/*** BeginHeader _tls_init_hs_msg */
_tbuf __far * _tls_init_hs_msg(ssl_Socket __far* state, size_t maxlen, SSL_Handshake_t msg_type);
/*** EndHeader */
_ssl_tport_debug
_tbuf __far * _tls_init_hs_msg(ssl_Socket __far* state, size_t maxlen, SSL_Handshake_t msg_type)
{
	_tbuf __far * t;
	SSL_Handshake_Hdr_t __far * h;

	t = _sys_malloc(sizeof(_tbuf)+maxlen);
	if (!t) {
#if _SSL_PRINTF_DEBUG
    	printf("*** HS message allocation failure ***\n");
#endif
		return t;
	}
	h = (SSL_Handshake_Hdr_t __far *)(t + 1);
	t->buf = (char __far *)h;
	t->begin = 0;
	t->len = sizeof(SSL_Handshake_Hdr_t);	// Already space for header
	t->maxlen = maxlen;
	h->msg_type = msg_type;
	// ...length has to wait until end
	return t;
}

/*** BeginHeader _tls_finalize_hs_msg */
int _tls_finalize_hs_msg(ssl_Socket __far* state, _tbuf __far * t, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int _tls_finalize_hs_msg(ssl_Socket __far* state, _tbuf __far * t, _tbuf __far * out)
{
	auto ll_Gather g;
	SSL_Handshake_Hdr_t __far * h;
	auto int rc;

	h = (SSL_Handshake_Hdr_t __far *)(t + 1);
	// Set the message length (not including header)
   ulton24(h->length, t->len - sizeof(SSL_Handshake_Hdr_t));

   // Digest the message for the Finish MAC
   g.data2 = (char __far *)h;
   g.len2 = t->len;
   g.len3 = 0;
	tls_digest_hs_message(state, &g);

   rc = tls_write_record(state, SSL_REC_handshake, t, t->len, out);
   _sys_free(t);
   return rc;
}

/*** BeginHeader tls_send_client_hello */
int tls_send_client_hello(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_client_hello(ssl_Socket __far* state, _tbuf __far * out)
{
	auto _tbuf __far * t;
	auto SSL_CipherState __far* cipher;	 // Pointers to state internals
   auto SSL_SuiteConfig __far* suite;
   auto SSL_ProtocolVersion version;
   auto SSL_uint16_t temp;

   cipher = state->cipher_state;
   suite = cipher->suite;

   // Build the client hello message
   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, client_hello);
   if (!t)
   	return tls_error(state, SSL_ALLOC_FAIL, out);

	version.major = TLS1_VER_MAJ;
   version.minor = TLS1_VER_MIN;

	_tbuf_append(t, &version, sizeof(version));

   // Client random
#ifdef _SSL_DETERMINISTIC_TEST
	cipher->client_random.gmt_unix_time = 0;
#else
	cipher->client_random.gmt_unix_time = htonl(SEC_TIMER + RTC_EPOCH_DIFF);
#endif
	_ssl_big_rand(cipher->client_random.random_bytes, SSL_RANDOM_SIZE);
   _tbuf_append(t, &cipher->client_random, sizeof(SSL_Random));

   // Session ID
   if (!(state->flags & SSL_F_NO_RESUME) &&
       state->session_id_length) {
		state->flags |= SSL_F_TRIED_RESUME;
   }
   else {
   	state->flags &= ~SSL_F_TRIED_RESUME;
   	state->session_id_length = 0;
   }

	_tbuf_append(t, &state->session_id_length, 1);
	if (state->session_id_length)
		_tbuf_append(t, state->session_id, state->session_id_length);

	// Ciphersuite list
	temp = htons(state->n_accept_suites * 2);
	_tbuf_append(t, &temp, 2);
	_tbuf_append(t, state->accept_suites, state->n_accept_suites * 2);

	// Compression: only null supported.
	temp = 0x0001;		// length 1, null(0) compression
	_tbuf_append(t, &temp, 2);

	if (state->client_hello_ext_len)
		_tbuf_append(t, state->client_hello_ext, state->client_hello_ext_len);

   return _tls_finalize_hs_msg(state, t, out);
}


/*** BeginHeader tls_send_server_hello */
int tls_send_server_hello(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_server_hello(ssl_Socket __far* state, _tbuf __far * out)
{
	auto _tbuf __far * t;
   auto SSL_ProtocolVersion version;
   auto SSL_uint16_t suite_num;
	auto SSL_CipherState __far* cipher;	 // Pointers to state internals
   auto SSL_SuiteConfig __far* suite;

   cipher = state->cipher_state;
   suite = cipher->suite;

   // Build the ServerHello message
   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, server_hello);
   if (!t)
   	return tls_error(state, SSL_ALLOC_FAIL, out);

	// Server version
	version.major = TLS1_VER_MAJ;
   version.minor = TLS1_VER_MIN;
	_tbuf_append(t, &version, sizeof(version));

   // Server random
   _tbuf_append(t, &cipher->server_random, sizeof(SSL_Random));

   // Session ID
	_tbuf_append(t, &state->session_id_length, sizeof(SSL_byte_t));
   if (state->session_id_length > 0)
	   _tbuf_append(t, state->session_id, state->session_id_length);

   // The suite number must be switched to a network short to be processed
   // correctly (using htons)
   suite_num = htons(suite->suite_number);
   _tbuf_append(t, &suite_num, sizeof(SSL_uint16_t));

   // We always use compression method 'null'
   suite_num = SSL_CM_null;
   _tbuf_append(t, &suite_num, 1);

   return _tls_finalize_hs_msg(state, t, out);
}


/*** BeginHeader tls_send_certificate */
int tls_send_certificate(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_certificate(ssl_Socket __far* state, _tbuf __far * out)
{
#if _SSL_USE_RSA_
	auto _tbuf __far * t;
   auto SSL_byte_t tmp_len[3];
	auto size_t cert_len, ncerts, i;
	auto long oal;	// overall length of chain (all certs, no overhead)
	auto size_t maxlen;
	auto int rc;

   // Build the message.  Count certs in chain.
   ncerts = SSL_get_chain_size(state->cert, &oal);
   // add the 3-byte length field per cert to the overall length
	oal += ncerts * 3;

	if (oal > 32767) {
#if _SSL_PRINTF_DEBUG
    	printf("*** Cert chain too big to send (%lu) ***\n", oal);
#endif
   	return tls_error(state, SSL_ALLOC_FAIL, out);
   }

   maxlen = (size_t)(oal + sizeof(SSL_Handshake_Hdr_t) + 3);	// Total record data size

   t = _tls_init_hs_msg(state, maxlen, certificate);
   if (!t)
   	return tls_error(state, SSL_ALLOC_FAIL, out);


   ulton24(tmp_len, oal);
	_tbuf_append(t, tmp_len, 3);

	for (i = 0; i < ncerts; ++i) {
	   // Individual certificate length field
	   cert_len = SSL_get_cert_len(state->cert, i);
	   ulton24(tmp_len, cert_len);
	   _tbuf_append(t, tmp_len, 3);

	   // Get the cert
	   rc = SSL_extract_cert(state->cert, t->buf + t->len, i);
	   if (rc) {
#if _SSL_PRINTF_DEBUG
    		printf("*** Cannot extract cert #%d; chain of %d starting %08lX ***\n",
    					i, ncerts, state->cert);
#endif
			return tls_error(state, SSL_BAD_CERT, out);
		}
	   t->len += cert_len;
   }

   return _tls_finalize_hs_msg(state, t, out);
#else
	return 0;
#endif
}


/*** BeginHeader tls_send_server_hello_done */
int tls_send_server_hello_done(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_server_hello_done(ssl_Socket __far* state, _tbuf __far * out)
{
	auto _tbuf __far * t;

   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, server_hello_done);
   if (!t)
   	return tls_error(state, SSL_ALLOC_FAIL, out);

	// No content in this message; it represents itself.  Just change state now.
	if (state->flags & SSL_F_REQUESTED_CERT)
		state->cur_state = SSL_STATE_WAIT_CERT;
	else
		state->cur_state = SSL_STATE_WAIT_CKE;

   return _tls_finalize_hs_msg(state, t, out);
}


/*** BeginHeader tls_send_certificate_request */
int tls_send_certificate_request(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_certificate_request(ssl_Socket __far* state, _tbuf __far * out)
{
	auto _tbuf __far * t;
	auto word cert_type;
	auto SSL_uint16_t oal;

   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, certificate_request);
   if (!t)
   	return tls_error(state, SSL_ALLOC_FAIL, out);

	// Currently, we only support RSA signing
	cert_type = 0x0101; // (rsa_sign (MSB) = 1, length (LSB) = 1)
	_tbuf_append(t, &cert_type, sizeof(cert_type));

	// Add ASN.1 Distinguished Names of the certificate authorities we accept
	// as a server, for the peer client.
	// DEVIDEA: need to implement this if we wish our server to robustly
	// support client certificate verification.  This is not a serious
	// deficiency provided that we (the server) have a comprehensive list
	// of trusted CAs.
	oal = 0;
	_tbuf_append(t, &oal, sizeof(oal));


   return _tls_finalize_hs_msg(state, t, out);
}


/*** BeginHeader _ssl_cli_key_exch */
int _ssl_cli_key_exch(ssl_Socket __far*, SSL_ClientKeyExchange __far*, _tbuf __far *);
/*** EndHeader */

// Derive symmetric keys from a client key exchange message
// Return 0 on success, non-zero on fail (set TLS_errno)
_ssl_tport_debug
int _ssl_cli_key_exch(ssl_Socket __far* state, SSL_ClientKeyExchange __far* cli_key_exch, _tbuf __far * out) {
	auto SSL_Secret master_secret, pre_master_secret;
	auto SSL_CipherState __far* cipher;			// Pointers to state internals
   auto SSL_byte_t output[SSL_KEY_BLOCK_SIZE];
   auto SSL_byte_t seeded_label[SSL_SEEDED_LABEL_MAX];
   auto SSL_uint16_t psk_len;
   auto SSL_byte_t * p;
   auto unsigned int label_len;
   auto int i;

   // Access to state internals
   cipher = state->cipher_state;

   switch (cipher->suite->key_exchange_alg)
   {
   default:
   	// Should not get this far if unknown KX algo
   	break;

#if _SSL_USE_PSK_
	case TLS_KX_PSK:
   	psk_len = cli_key_exch->by_kx_algo.psk.length;
      *(SSL_uint16_t __far *)pre_master_secret.data = htons(psk_len);
      p = pre_master_secret.data + sizeof(SSL_uint16_t);
      memset(p, 0, psk_len);
      p += psk_len;
		*(SSL_uint16_t __far *)p = htons(psk_len);
      p += sizeof(SSL_uint16_t);
      _f_memcpy(p, cli_key_exch->by_kx_algo.psk.data, psk_len);
		pre_master_secret.length = (psk_len + sizeof(SSL_uint16_t))*2;
   	break;
#endif

#if _SSL_USE_RSA_
	case TLS_KX_RSA:
	   // Check Protcol Version
      if(!(cli_key_exch->by_kx_algo.exchange_keys.client_version.major == TLS1_VER_MAJ &&
           cli_key_exch->by_kx_algo.exchange_keys.client_version.minor == TLS1_VER_MIN)) {
	#if _SSL_PRINTF_DEBUG
         printf("*** Bad version in TLS CKE ***\n");
	#endif
         return tls_error(state, SSL_EXCH_KEYS_PROTOCOL_VER, out);
      }

	   // Fill our pre master secret data structure
	   _f_memcpy(&pre_master_secret.data, &cli_key_exch->by_kx_algo.exchange_keys,
	          sizeof(SSL_PreMasterSecret));
	   pre_master_secret.length = sizeof(SSL_PreMasterSecret);
		break;
#endif
	} // kx algo switch

#if _SSL_PRINTF_DEBUG > 2
   printf("\nClient Random:\n");
   mem_dump((SSL_byte_t __far*)&cipher->client_random, sizeof(SSL_Random));
   printf("\nServer Random:\n");
   mem_dump((SSL_byte_t __far*)&cipher->server_random, sizeof(SSL_Random));
   printf("\nPre Master Secret:\n");
   mem_dump(pre_master_secret.data, pre_master_secret.length);
#endif

   // ***Derive the Master Secret***
   memset(output, 0, SSL_KEY_BLOCK_SIZE);
   // Build the label to be used in the key derivation
   // Seeded label = MASTER_SEC_LABEL + client random + server random
   memcpy(seeded_label, TLS_MASTER_SEC_LABEL, strlen(TLS_MASTER_SEC_LABEL));
   label_len = strlen(TLS_MASTER_SEC_LABEL);
   _f_memcpy(seeded_label + label_len, &cipher->client_random,
          sizeof(SSL_Random));
   label_len += sizeof(SSL_Random);
   _f_memcpy(seeded_label + label_len, &cipher->server_random,
          sizeof(SSL_Random));
   label_len += sizeof(SSL_Random);

   // Derive the Master Secret using the TLS PRF
	_SHA256_PRF(&pre_master_secret, seeded_label, label_len, output,
  	         SSL_MASTER_SEC_SIZE);

   // Save our secret for use in key block derivation
   memcpy(&master_secret.data, output, sizeof(master_secret.data));
   master_secret.length = sizeof(master_secret.data);

#if _SSL_PRINTF_DEBUG > 2
   printf("\nMaster Secret:\n");
   mem_dump(master_secret.data, master_secret.length);
#endif

	// Save off our master secret for use in the Finished calculation
   _f_memcpy(state->master_secret, &master_secret, sizeof(*state->master_secret));

	// Derive our session keys from the master secret
	_tls_1_derive_keys(state);

   return 0;
}



/*** BeginHeader tls_send_client_key_exchange */
int tls_send_client_key_exchange(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_client_key_exchange(ssl_Socket __far* state, _tbuf __far * out)
{
#if _SSL_USE_RSA_
	auto char secret[48];
#endif
#if _SSL_USE_PSK_
	auto SSL_PSK_Identity id;
#endif
	auto SSL_ClientKeyExchange cke;
	auto _tbuf __far * t;
	size_t outlen;
	auto int rc;

	switch (state->cipher_state->suite->key_exchange_alg) {
   default:
#if _SSL_PRINTF_DEBUG
    	printf("*** CKE key exchange algo not supported ***\n");
#endif
   	return tls_error(state, SSL_CIPHER_CHOICE_ERROR, out);

#if _SSL_USE_PSK_
	case TLS_KX_PSK:
   	if (!state->getPSK) {
	#if _SSL_PRINTF_DEBUG
	      printf("*** send-CKE: no getPSK ***\n");
	#endif
	      return tls_error(state, SSL_UNKNOWN_IDENTITY, out);
	   }
      // Invoke callback to get appropriate key identity (and key).
      // Hint may have been provided by server.
      rc = state->getPSK(state,
      			state->psk_hint ? state->psk_hint->data : NULL,
               	state->psk_hint ? state->psk_hint->length : 0,
      			id.data, &id.length,
               cke.by_kx_algo.psk.data, &outlen);
		if (rc) {
	   #if _SSL_PRINTF_DEBUG
	      printf("***Unknown identity***\n");
	   #endif
	      return tls_error(state, SSL_UNKNOWN_IDENTITY, out);
      }
      cke.by_kx_algo.psk.length = outlen;
	   #if _SSL_PRINTF_DEBUG > 2
	   printf("\n---> PSK identity (%u), PSK (%u) <---\n", id.length, outlen);
	   mem_dump(id.data, id.length);
	   mem_dump(cke.by_kx_algo.psk.data, outlen);
	   #endif
	   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, client_key_exchange);
	   if (!t)
	      return tls_error(state, SSL_ALLOC_FAIL, out);
      *(SSL_uint16_t __far *)(t->buf + t->len) = htons(id.length);
      _f_memcpy(t->buf + t->len + 2, id.data, id.length);
      t->len += 2 + id.length;

   	break;
#endif //_SSL_USE_PSK_

#if _SSL_USE_RSA_
   case TLS_KX_RSA:
	   if (!state->peer_cert || !state->peer_cert->rsa_key) {
	#if _SSL_PRINTF_DEBUG
	      printf("*** CKE no peer cert or RSA key ***\n");
	#endif
	      return tls_error(state, SSL_PUB_KEY_ENCRYPTION_FAIL, out);
	   }

	   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, client_key_exchange);
	   if (!t)
	      return tls_error(state, SSL_ALLOC_FAIL, out);

	   // Since we only support RSA, this is the way to generate the pre-master secret
	   _ssl_big_rand(secret+2, sizeof(secret)-2);
	   secret[0] = TLS1_VER_MAJ;
	   secret[1] = TLS1_VER_MIN;
	    #ifdef _COPROCESS_H
	   if (state->flags & SSL_F_COP_YIELD)
	      state->peer_cert->rsa_key->flags |= RSA_KEY_PUB_COP_YIELD;
	    #endif
	   rc = crypto_public_key_encrypt_pkcs1_v15(state->peer_cert->rsa_key,
	         secret, sizeof(secret), t->buf + (t->len + 2), &outlen);
      *(SSL_uint16_t __far *)(t->buf + t->len) = htons(outlen);
	   t->len += outlen + 2;
	   if (rc < 0) {
	      _sys_free(t);
	#if _SSL_PRINTF_DEBUG
	      printf("*** CKE public key resource shortage ***\n");
	#endif
	      return tls_error(state, -rc, out);
	   }

	   // Now we need to do our own key derivation
	   memcpy(&cke, secret, sizeof(cke));
      break;
#endif //_SSL_USE_RSA_
	}

   _ssl_cli_key_exch(state, &cke, out);
   // Now that we have keys, we can initialize our bulk cipher
	_ssl_bulk_cipher_init(state);

   return _tls_finalize_hs_msg(state, t, out);
}


/*** BeginHeader tls_send_finished */
int tls_send_finished(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_finished(ssl_Socket __far* state, _tbuf __far * out)
{
	auto _tbuf __far * t;

   t = _tls_init_hs_msg(state, SSL_MAX_HANDSHAKE_SIZE, finished);
   if (!t)
   	return tls_error(state, SSL_ALLOC_FAIL, out);

	t->len += tls_finished_mac(state, t->buf + t->len, 0);

   return _tls_finalize_hs_msg(state, t, out);
}


/*** BeginHeader tls_send_chg_cipher_spec */
int tls_send_chg_cipher_spec(ssl_Socket __far* state, _tbuf __far * out);
/*** EndHeader */
_ssl_tport_debug
int tls_send_chg_cipher_spec(ssl_Socket __far* state, _tbuf __far * out)
{
	auto _tbuf t;
	auto char data;
	auto int rc;

	// This is the CCS message data
	data = 0x01;

	t.buf = &data;
	t.len = t.maxlen = 1;
	t.begin = 0;

   rc = tls_write_record(state, SSL_REC_change_cipher_spec, &t, 1, out);
	if (rc)
		return rc;

	// We sent CCS, so now go all cloak-and-dagger...
	state->flags |= SSL_F_ENCRYPT;
	return 0;
}


/*** BeginHeader tls_connection_encrypt */
/**
 * tls_connection_encrypt - Encrypt data into TLS tunnel
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @in_data: Pointer to plaintext data to be encrypted
 * @in_len: Input buffer length
 * @out_data: Pointer to output buffer (encrypted TLS data)
 * @out_len: Maximum out_data length
 * Returns: Number of bytes written to out_data, -1 on failure
 *
 * This function is used after TLS handshake has been completed successfully to
 * send data in the encrypted tunnel.
 *
 * NOTE: this is a wrapper for tls_sm().  It is better to use tls_sm() directly
 * since it provides better efficiency and error handling.
 */
int tls_connection_encrypt(void __far *tls_ctx, ssl_Socket __far *state,
			    char __far *in_data, size_t in_len,
			   char __far *out_data, size_t out_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_encrypt(void __far *tls_ctx, ssl_Socket __far *state,
			    char __far *in_data, size_t in_len,
			   char __far *out_data, size_t out_len)
{
	auto _tbuf tport_in, tport_out, hs_in, app_in, app_out;
	auto int rc;


	tport_in.len = 0;	// No input transport data

	tport_out.maxlen = out_len;
	tport_out.buf = out_data;
	tport_out.begin = 0;
	tport_out.len = 0;

	hs_in.len = 0;
	app_in.len = 0;	// No data for app

	app_out.buf = in_data;
	app_out.begin = 0;
	app_out.len = app_out.maxlen = in_len;
	// We need to loop until complete, since caller is not expected to handle
	// the -EAGAIN return code.
	do {
		rc = tls_sm(state, &tport_in, &tport_out, &hs_in, &app_in, &app_out);
	} while (!rc && state->wait_rsa);
	if (rc != 0)
		return -1;
	return tport_out.len;
}



/*** BeginHeader tls_connection_decrypt */
/**
 * tls_connection_decrypt - Decrypt data from TLS tunnel
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @in_data: Pointer to input buffer (encrypted TLS data)
 * @in_len: Input buffer length
 * @out_data: Pointer to output buffer (decrypted data from TLS tunnel)
 * @out_len: Maximum out_data length
 * Returns: Number of bytes written to out_data, -1 on failure
 *
 * This function is used after TLS handshake has been completed successfully to
 * receive data from the encrypted tunnel.
 *
 * NOTE: this is a wrapper for tls_sm().  It is better to use tls_sm() directly
 * since it provides better efficiency and error handling.
 */
int tls_connection_decrypt(void __far *tls_ctx, ssl_Socket __far *state,
			    char __far *in_data, size_t in_len,
			   char __far *out_data, size_t out_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_decrypt(void __far *tls_ctx, ssl_Socket __far *state,
			    char __far *in_data, size_t in_len,
			   char __far *out_data, size_t out_len)
{
	auto char buf1[100], buf2[100];
	auto _tbuf tport_in, tport_out, hs_in, app_in, app_out;
	auto int rc;


	tport_in.buf = in_data;
	tport_in.len = tport_in.maxlen = in_len;
	tport_in.begin = 0;

	// we should expect only alerts in this buffer.  Unfortunately, we cannot
	// send them (but tls_sm needs this anyway)
	tport_out.buf = buf1;
	tport_out.begin = 0;
	tport_out.maxlen = sizeof(buf1);
	tport_out.len = 0;
	hs_in.buf = buf2;
	hs_in.begin = 0;
	hs_in.maxlen = sizeof(buf2);
	hs_in.len = 0;

	app_in.maxlen = out_len;
	app_in.buf = out_data;
	app_in.begin = 0;
	app_in.len = 0;

	app_out.len = 0;	// no data from app

	// We need to loop until complete, since caller is not expected to handle
	// the -EAGAIN return code.
	do {
		rc = tls_sm(state, &tport_in, &tport_out, &hs_in, &app_in, &app_out);
	} while (!rc && state->wait_rsa);
	if (rc != 0)
		return -1;
	return app_in.len;
}



/*** BeginHeader tls_connection_resumed */
/**
 * tls_connection_resumed - Was session resumption used?
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: 1 if current session used session resumption, 0 if not
 */
int tls_connection_resumed(void __far *tls_ctx, ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_resumed(void __far *tls_ctx, ssl_Socket __far *conn)
{
	return (conn->flags & SSL_F_RESUMED) != 0;
}



/*** BeginHeader tls_connection_set_master_key */
/**
 * tls_connection_set_master_key - Configure master secret for TLS connection
 * This should be called before connection is established, otherwise the
 * finish calculation may be mucked up.
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @key: TLS pre-master-secret
 * @key_len: length of key in bytes
 * Returns: 0 on success, -1 on failure
 */
int tls_connection_set_master_key(void __far *tls_ctx, ssl_Socket __far *state,
				   char __far *key, size_t key_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_set_master_key(void __far *tls_ctx, ssl_Socket __far *state,
				   char __far *key, size_t key_len)
{

	// We store the PMS in the MS; it will be transformed at key derivation time.
	if (key_len > sizeof(state->master_secret->data))
		return -1;
	state->master_secret->length = key_len;
	_f_memcpy(state->master_secret->data, key, key_len);
	state->flags |= SSL_F_TICKET_KEY;
	return 0;
}


/*** BeginHeader tls_add_ciphersuite */
int tls_add_ciphersuite(ssl_Socket __far * state, SSL_uint16_t suite);
/*** EndHeader */
_ssl_tport_debug
int tls_add_ciphersuite(ssl_Socket __far * state, SSL_uint16_t suite)
{
	auto word i;

	if (   suite != TLS_RSA_WITH_RC4_128_MD5
	    && suite != TLS_RSA_WITH_RC4_128_SHA
	    && suite != TLS_RSA_WITH_AES_128_CBC_SHA
	    && suite != TLS_RSA_WITH_AES_128_CBC_SHA256
	    && suite != TLS_RSA_WITH_NULL_MD5
	    && suite != TLS_RSA_WITH_NULL_SHA
	    && suite != TLS_RSA_WITH_NULL_SHA256
	    && suite != TLS_PSK_WITH_RC4_128_SHA
	    && suite != TLS_PSK_WITH_AES_128_CBC_SHA
	    && suite != TLS_PSK_WITH_NULL_SHA
	   )
		return -1;	// not supported

	for (i = 0; i < state->n_accept_suites; ++i)
		if (state->accept_suites[i] == suite)
			return 0;	// already there
	if (state->n_accept_suites == SSL_MAX_CIPHER_LIST)
		return -1;	// cannot fit
	// These stored in network order
	state->accept_suites[i] = htons(suite);
	++state->n_accept_suites;
	return 0;
}

/*** BeginHeader tls_set_default_ciphersuites */
int tls_set_default_ciphersuites(ssl_Socket __far * state);
/*** EndHeader */
_ssl_tport_debug
int tls_set_default_ciphersuites(ssl_Socket __far * state)
{
	auto int ns;

	ns = 0;
#if _SSL_USE_RSA_
	#if _SSL_USE_AES_
	tls_add_ciphersuite(state, TLS_RSA_WITH_AES_128_CBC_SHA); ++ns;
	tls_add_ciphersuite(state, TLS_RSA_WITH_AES_128_CBC_SHA256); ++ns;
	#endif
	#if _SSL_USE_RC4_
	tls_add_ciphersuite(state, TLS_RSA_WITH_RC4_128_SHA); ++ns;
	tls_add_ciphersuite(state, TLS_RSA_WITH_RC4_128_MD5); ++ns;
	#endif
#endif
#if _SSL_USE_PSK_
	#if _SSL_USE_AES_
	tls_add_ciphersuite(state, TLS_PSK_WITH_AES_128_CBC_SHA); ++ns;
	#endif
	#if _SSL_USE_RC4_
	tls_add_ciphersuite(state, TLS_PSK_WITH_RC4_128_SHA); ++ns;
	#endif
#endif
	return ns > 0 ? 0 : -1;
}

/*** BeginHeader tls_connection_set_cipher_list */
// Following enum values are for compatibility with wpa_supplicant.
// Since our TLS does not yet support some of these ciphersuites, those
// are set to 0xFF so that we will expurgate them from the acceptable list.
enum {
	TLS_CIPHER_NONE = 0,
	TLS_CIPHER_RC4_SHA = TLS_RSA_WITH_RC4_128_SHA /* 0x0005 */,
	TLS_CIPHER_AES128_SHA = TLS_RSA_WITH_AES_128_CBC_SHA /* 0x002f */,
	TLS_CIPHER_AES128_SHA256 = TLS_RSA_WITH_AES_128_CBC_SHA256 /* 0x003c */,
	TLS_CIPHER_RSA_DHE_AES128_SHA = 0xFF /* 0x0031 */,
	TLS_CIPHER_ANON_DH_AES128_SHA = 0xFF /* 0x0034 */
};


/**
 * tls_connection_set_cipher_list - Configure acceptable cipher suites
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @ciphers: Zero (TLS_CIPHER_NONE) terminated list of allowed ciphers
 * (TLS_CIPHER_*).
 * Returns: 0 on success, -1 on failure
 *
 */
int tls_connection_set_cipher_list(void __far *tls_ctx, ssl_Socket __far *state,
				   char __far *ciphers);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_set_cipher_list(void __far *tls_ctx, ssl_Socket __far *state,
				   char __far *ciphers)
{
	state->n_accept_suites = 0;
	while (*ciphers) {
		if (*ciphers != 0xFF)
			if (tls_add_ciphersuite(state, *ciphers))
				return -1;
		++ciphers;
	}
	if (!state->n_accept_suites)
		return -1;
	return 0;
}



/*** BeginHeader tls_get_cipher */
/**
 * tls_get_cipher - Get current cipher name
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @buf: Buffer for the cipher name
 * @buflen: buf size
 * Returns: 0 on success, -1 on failure
 *
 * Get the name of the currently used cipher.
 */
int tls_get_cipher(void __far *tls_ctx, ssl_Socket __far *state,
		   char __far *buf, size_t buflen);
/*** EndHeader */
_ssl_tport_debug
int tls_get_cipher(void __far *tls_ctx, ssl_Socket __far *state,
		   char __far *buf, size_t buflen)
{
	if (!state)
		return -1;
	_f_strncpy(buf, state->cipher_state->suite->fulltext_name, buflen);
	return 0;
}



/*** BeginHeader tls_connection_enable_workaround */
/**
 * tls_connection_enable_workaround - Enable TLS workaround options
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: 0 on success, -1 on failure
 *
 * This function is used to enable connection-specific workaround options for
 * buffer SSL/TLS implementations.
 */
int tls_connection_enable_workaround(void __far *tls_ctx,
				     ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_enable_workaround(void __far *tls_ctx,
				     ssl_Socket __far *conn)
{
	return -1;
}



/*** BeginHeader tls_connection_client_hello_ext */
/**
 * tls_connection_client_hello_ext - Set TLS extension for ClientHello
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @ext_type: Extension type
 * @data: Extension payload (%NULL to remove extension)
 * @data_len: Extension payload length
 * Returns: 0 on success, -1 on failure
 */
/* TLS Extensions */
#define TLS_EXT_PAC_OPAQUE 35

int tls_connection_client_hello_ext(void __far *tls_ctx, ssl_Socket __far *state,
				    int ext_type,  char __far *data,
				    size_t data_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_client_hello_ext(void __far *tls_ctx, ssl_Socket __far *state,
				    int ext_type,  char __far *data,
				    size_t data_len)
{
	auto char __far * pos;

	state->flags &= ~SSL_F_TICKET;
	_sys_free(state->client_hello_ext);
	state->client_hello_ext = NULL;
	state->client_hello_ext_len = 0;

	if (data == NULL || data_len == 0)
		return 0;

	pos = state->client_hello_ext = _sys_malloc(6 + data_len);
	if (pos == NULL)
		return -1;

	*(SSL_uint16_t __far *)pos = htons(4 + data_len);
	pos += 2;
	*(SSL_uint16_t __far *)pos = htons(ext_type);
	pos += 2;
	*(SSL_uint16_t __far *)pos = htons(data_len);
	pos += 2;
	_f_memcpy(pos, data, data_len);
	state->client_hello_ext_len = 6 + data_len;

	if (ext_type == TLS_EXT_PAC_OPAQUE)
		state->flags |= SSL_F_TICKET;

	return 0;
}



/*** BeginHeader tls_connection_get_failed */
/**
 * tls_connection_get_failed - Get connection failure status
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 *
 * Returns >0 if connection has failed, 0 if not.
 */
int tls_connection_get_failed(void __far *tls_ctx, ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_get_failed(void __far *tls_ctx, ssl_Socket __far *conn)
{
	return conn->cur_state == SSL_STATE_ERROR;
}



/*** BeginHeader tls_connection_get_read_alerts */
/**
 * tls_connection_get_read_alerts - Get connection read alert status
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: Number of times a fatal read (remote end reported error) has
 * happened during this connection.
 */
int tls_connection_get_read_alerts(void __far *tls_ctx, ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_get_read_alerts(void __far *tls_ctx, ssl_Socket __far *conn)
{
	return conn->alerts_recvd;
}



/*** BeginHeader tls_connection_get_write_alerts */
/**
 * tls_connection_get_write_alerts - Get connection write alert status
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: Number of times a fatal write (locally detected error) has happened
 * during this connection.
 */
int tls_connection_get_write_alerts(void __far *tls_ctx,
				    ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_get_write_alerts(void __far *tls_ctx,
				    ssl_Socket __far *conn)
{
	return conn->alerts_sent;
}



/*** BeginHeader tls_connection_get_keyblock_size */
/**
 * tls_connection_get_keyblock_size - Get TLS key_block size
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: Size of the key_block for the negotiated cipher suite or -1 on
 * failure
 */
int tls_connection_get_keyblock_size(void __far *tls_ctx,
				     ssl_Socket __far *state);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_get_keyblock_size(void __far *tls_ctx,
				     ssl_Socket __far *state)
{
	SSL_CipherState __far* cipher;

	if (state->cur_state < SSL_STATE_WAIT_CCS ||
	    state->cur_state == SSL_STATE_ERROR)
		return -1;
	cipher = state->cipher_state;
	return 2 * (cipher->digest->hash_size + cipher->bulk_cipher->key_size +
	            cipher->bulk_cipher->block_size); // block size is IV size
}



/*** BeginHeader tls_capabilities */
#define TLS_CAPABILITY_IA 0x0001 /* TLS Inner Application (TLS/IA) */
/**
 * tls_capabilities - Get supported TLS capabilities
 * @tls_ctx: TLS context data from tls_init()
 * Returns: Bit field of supported TLS capabilities (TLS_CAPABILITY_*)
 */
unsigned int tls_capabilities(void __far *tls_ctx);
/*** EndHeader */
_ssl_tport_debug
unsigned int tls_capabilities(void __far *tls_ctx)
{
	return 0;
}



/*** BeginHeader tls_connection_ia_send_phase_finished */
/**
 * tls_connection_ia_send_phase_finished - Send a TLS/IA PhaseFinished message
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @final: 1 = FinalPhaseFinished, 0 = IntermediatePhaseFinished
 * @out_data: Pointer to output buffer (encrypted TLS/IA data)
 * @out_len: Maximum out_data length
 * Returns: Number of bytes written to out_data on success, -1 on failure
 *
 * This function is used to send the TLS/IA end phase message, e.g., when the
 * EAP server completes EAP-TTLSv1.
 */
int tls_connection_ia_send_phase_finished(void __far *tls_ctx,
					  ssl_Socket __far *conn,
					  int final,
					  char __far *out_data, size_t out_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_ia_send_phase_finished(void __far *tls_ctx,
					  ssl_Socket __far *conn,
					  int final,
					  char __far *out_data, size_t out_len)
{
	return -1;
}



/*** BeginHeader tls_connection_ia_final_phase_finished */
/**
 * tls_connection_ia_final_phase_finished - Has final phase been completed
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * Returns: 1 if valid FinalPhaseFinished has been received, 0 if not, or -1
 * on failure
 */
int tls_connection_ia_final_phase_finished(void __far *tls_ctx,
					   ssl_Socket __far *conn);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_ia_final_phase_finished(void __far *tls_ctx,
					   ssl_Socket __far *conn)
{
	return -1;
}



/*** BeginHeader tls_connection_ia_permute_inner_secret */
/**
 * tls_connection_ia_permute_inner_secret - Permute TLS/IA inner secret
 * @tls_ctx: TLS context data from tls_init()
 * @conn: Connection context data from tls_connection_init()
 * @key: Session key material (session_key vectors with 2-octet length), or
 * %NULL if no session key was generating in the current phase
 * @key_len: Length of session key material
 * Returns: 0 on success, -1 on failure
 */
int tls_connection_ia_permute_inner_secret(void __far *tls_ctx,
					   ssl_Socket __far *conn,
					    char __far *key, size_t key_len);
/*** EndHeader */
_ssl_tport_debug
int tls_connection_ia_permute_inner_secret(void __far *tls_ctx,
					   ssl_Socket __far *conn,
					    char __far *key, size_t key_len)
{
	return -1;
}



/*** BeginHeader */
#endif
/*** EndHeader */

