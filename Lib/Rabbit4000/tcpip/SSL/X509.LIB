/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
X509.LIB

Functions for processing X.509 (SSL/TLS) certificates.

Define the following macros to configure the library:

X509_VERBOSE: enable verbose debugging output

X509_DEBUG: enable function debugging including breakpoints and single-stepping

X509_ENABLE_SHA512: support certificates using sha384 or sha512 signatures

END DESCRIPTION **********************************************************/

/*** BeginHeader */
#ifndef _X509_H
#define _X509_H
/*******************************************************************
*  WARNING: this file was machine generated, but has since been edited manually
*******************************************************************/
#ifndef FUNCPTR
	#define FUNCPTR *
#endif
#ifdef X509_DEBUG
	#define _x509_debug __debug
#else
	#define _x509_debug __nodebug
#endif

#ifdef X509_VERBOSE
	#define _X509_PRINTF(x) _x509_printf x
	#define _X509_HEXDUMP(x) _x509_hexdump x
#else
	#define _X509_PRINTF(x)
	#define _X509_HEXDUMP(x)
#endif

#if defined X509_VERBOSE || defined X509_CHAIN_VERBOSE
	#define _X509_CHAIN_PRINTF(x) _x509_printf x
#else
	#define _X509_CHAIN_PRINTF(x)
#endif

#ifdef X509_ENABLE_SHA512
	#use "sha512.lib"
#endif
#use "sha2.lib"
#use "sha1.lib"

/* Need to include malloc support. We may remove this later */
#ifndef MALLOC_H_Incl
 #ifndef MSPACES
  #define MSPACES 1
 #endif
 #use MALLOC.LIB
#endif
#ifdef MSPACES
 #if !MSPACES
  #error "x509 library requires memory spaces to be enabled (#define MSPACES 1)"
 #endif
#endif
// Following provided by `network library`...
extern mspace _sys_mem_space;


typedef int _x509_ptrdiff_t;



/*** EndHeader */

// @ libraryPrefix[]  ; -- translator directive
// @ hdrStuff[]  ; -- translator directive
// @ parenthesizeArgs[_X509_PRINTF]  ; -- translator directive
// @ parenthesizeArgs[_X509_HEXDUMP]  ; -- translator directive
// @ pointerQualifier[]  ; -- translator directive
// @ ptrdiffType[]  ; -- translator directive
// @ switchType[]  ; -- translator directive
// @ printfFormat[_X509_PRINTF]  ; -- translator directive
// @ printfFormat[printf]  ; -- translator directive
// @ printfFormat[snprintf]  ; -- translator directive
// @ sizeOf[Char]  ; -- translator directive
// @ sizeOf[Short]  ; -- translator directive
// @ sizeOf[Int]  ; -- translator directive
// @ sizeOf[Enum]  ; -- translator directive
// @ sizeOf[Long]  ; -- translator directive
// @ sizeOf[Long_long]  ; -- translator directive
// @ sizeOf[Float]  ; -- translator directive
// @ sizeOf[Double]  ; -- translator directive
// @ sizeOf[Long_double]  ; -- translator directive
// @ sizeOf[Ptr]  ; -- translator directive
// @ sizeOf[Func_ptr]  ; -- translator directive
// @ typedefRename[u8]  ; -- translator directive
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

typedef long os_time_t;	// From "os.h":18

struct os_time {
	os_time_t sec;
	os_time_t usec;

} ;	// From "os.h":30
/*** EndHeader */

/*** BeginHeader os_mktime */
// From "x509_all.c":216
int os_mktime(int y, int mon, int d, int h, int m, int s, os_time_t __far * val);
/*** EndHeader */
_x509_debug
int os_mktime(int y, int mon, int d, int h, int m, int s, os_time_t __far * val) {
	struct tm t; 	// From "x509_all.c":218


	t.tm_sec = (char  )s;
	t.tm_min = (char  )m;
	t.tm_hour = (char  )h;
	t.tm_mday = (char  )d;
	t.tm_mon = (char  )mon;
	t.tm_year = (char  )(y - 1900);
	*val = mktime(&t);
	return 0;
}

/*** BeginHeader os_get_time */
// From "x509_all.c":231
int os_get_time(struct os_time __far * t);
/*** EndHeader */
_x509_debug
int os_get_time(struct os_time __far * t) {
	t->sec = SEC_TIMER;
	t->usec = 0;
	return 0;
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

#ifndef _MSG_ENUM_DEFINED
enum  {
	MSG_MSGDUMP,
	MSG_DEBUG,
	MSG_INFO,
	MSG_WARNING,
	MSG_ERROR
}  ;	// From "common.h":257
	#define _MSG_ENUM_DEFINED
#endif

struct asn1_hdr {
	char __far * payload;
	char identifier;
	char class;
		#define ASN1_CLASS_UNIVERSAL        0
		#define ASN1_CLASS_APPLICATION      1
		#define ASN1_CLASS_CONTEXT_SPECIFIC 2
		#define ASN1_CLASS_PRIVATE          3
	char constructed;
	unsigned int tag;
	unsigned int length;

} ;	// From "asn1.h":56

struct asn1_oid {
	unsigned long oid[20];
	size_t len;

} ;	// From "asn1.h":62
/*** EndHeader */

/*** BeginHeader asn1_get_next */
// From "asn1.c":23
int asn1_get_next(char __far * buf, size_t len, struct asn1_hdr __far * hdr);
/*** EndHeader */
_x509_debug
int asn1_get_next(char __far * buf, size_t len, struct asn1_hdr __far * hdr) {
	char __far * pos; 	// From "asn1.c":25
	char __far * end; 	// From "asn1.c":25
	char tmp; 	// From "asn1.c":26


	_f_memset(hdr, 0, sizeof (*hdr));
	pos = buf;
	end = buf+len;
	hdr->identifier = *pos++;
	hdr->class = hdr->identifier>>6;
	hdr->constructed = !!(hdr->identifier&(1<<5));
	if ((hdr->identifier&0x1f)==0x1f) {
		hdr->tag = 0;
		do {
			if (pos>=end) {
				_X509_PRINTF((MSG_DEBUG, "ASN.1: Identifier " \
				 "underflow" ));
				return  -1;
			}
			tmp = *pos++;
			_X509_PRINTF((MSG_MSGDUMP, "ASN.1: Extended tag data: " \
			 "0x%02x" , tmp));
			hdr->tag = (hdr->tag<<7)|(tmp&0x7f);
		} while (tmp&0x80);
	}
	else
		hdr->tag = hdr->identifier&0x1f;
	tmp = *pos++;
	if (tmp&0x80) {
		if (tmp==0xff) {
			_X509_PRINTF((MSG_DEBUG, "ASN.1: Reserved length " \
			 "value 0xff used" ));
			return  -1;
		}
		tmp &= 0x7f;
		hdr->length = 0;
		if (tmp > 4) {
			_X509_PRINTF((MSG_DEBUG, "ASN.1: Too long length field"));
			return -1;
		}
		while (tmp--) {
			if (pos>=end) {
				_X509_PRINTF((MSG_DEBUG, "ASN.1: Length " \
				 "underflow" ));
				return  -1;
			}
			hdr->length = (hdr->length<<8)|*pos++;
		}
	}
	else {
		hdr->length = tmp;
	}
	if (end < pos || hdr->length > (_x509_ptrdiff_t) (end - pos)) {
		_X509_PRINTF((MSG_DEBUG, "ASN.1: Contents underflow" ));
		return  -1;
	}
	hdr->payload = pos;
	return 0;
}

/*** BeginHeader asn1_get_oid */
// From "asn1.c":84
int asn1_get_oid(char __far * buf, size_t len, struct asn1_oid __far * oid, char __far * __far * next);
/*** EndHeader */
_x509_debug
int asn1_get_oid(char __far * buf, size_t len, struct asn1_oid __far * oid, char __far * __far * next) {
	struct asn1_hdr hdr; 	// From "asn1.c":87
	char __far * pos; 	// From "asn1.c":88
	char __far * end; 	// From "asn1.c":88
	unsigned long val; 	// From "asn1.c":89
	char tmp; 	// From "asn1.c":90


	_f_memset(oid, 0, sizeof (*oid));
	if (asn1_get_next(buf, len, &hdr)<0 ||
	hdr.length==0)
		return  -1;
	if (hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x06) {
		_X509_PRINTF((MSG_DEBUG, "ASN.1: Expected OID - found class %d " \
		 "tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	end = hdr.payload+hdr.length;
	*next = end;
	while (pos<end) {
		val = 0;
		do {
			if (pos>=end)
				return  -1;
			tmp = *pos++;
			val = (val<<7)|(tmp&0x7f);
		} while (tmp&0x80);
		if (oid->len>=20) {
			_X509_PRINTF((MSG_DEBUG, "ASN.1: Too long OID value" ));
			return  -1;
		}
		if (oid->len==0) {
			oid->oid[0] = val/40;
			if (oid->oid[0]>2)
				oid->oid[0] = 2;
			oid->oid[1] = val-oid->oid[0]*40;
			oid->len = 2;
		}
		else
			oid->oid[oid->len++] = val;
	}
	return 0;
}

/*** BeginHeader asn1_oid_to_str */
// From "asn1.c":140
void asn1_oid_to_str(struct asn1_oid __far * oid, char __far * buf, size_t len);
/*** EndHeader */
_x509_debug
void asn1_oid_to_str(struct asn1_oid __far * oid, char __far * buf, size_t len) {
	char __far * pos /* = buf */; 	// From "asn1.c":142
	size_t i; 	// From "asn1.c":143
	int ret; 	// From "asn1.c":144

	pos = buf;

	if (len==0)
		return /*void*/;
	buf[0] = '\0';
	for (i = 0; i<oid->len; i++) {
		ret = snprintf(pos, (_x509_ptrdiff_t)(buf+len-pos), "%ls%lu" , (char  __far * )(i
                                                                                   ==0 ?
		  ""  :
		  "." ), oid->oid[i]);
		if (ret<0 ||
		ret>=(_x509_ptrdiff_t)(buf+len-pos))
			break;
		pos += ret;
	}
	buf[len-1] = '\0';
}

/*** BeginHeader _x509_s2_rotate_bits */
// From "asn1.c":163
char _x509_s2_rotate_bits(char octet);
/*** EndHeader */
_x509_debug
char _x509_s2_rotate_bits(char octet) {
	int i; 	// From "asn1.c":165
	char res; 	// From "asn1.c":166


	res = 0;
	for (i = 0; i<8; i++) {
		res <<= 1;
		if (octet&1)
			res |= 1;
		octet >>= 1;
	}
	return res;
}

/*** BeginHeader asn1_bit_string_to_long */
// From "asn1.c":180
unsigned long asn1_bit_string_to_long(char __far * buf, size_t len);
/*** EndHeader */
_x509_debug
unsigned long asn1_bit_string_to_long(char __far * buf, size_t len) {
	unsigned long val /* = 0 */; 	// From "asn1.c":182
	char __far * pos /* = buf */; 	// From "asn1.c":183

	val = 0;
	pos = buf;

	pos++;
	if (len>=2)
		val |= _x509_s2_rotate_bits(*pos++);
	if (len>=3)
		val |= ((unsigned long  )_x509_s2_rotate_bits(*pos++))<<8;
	if (len>=4)
		val |= ((unsigned long  )_x509_s2_rotate_bits(*pos++))<<16;
	if (len>=5)
		val |= ((unsigned long  )_x509_s2_rotate_bits(*pos++))<<24;
	if (len>=6)
		_X509_PRINTF((MSG_DEBUG, "X509: %ls - some bits ignored (BIT STRING length %lu)" ,
                (char  __far * )("asn1_bit_string_to_long" ), (unsigned long  )len));
	return val;
}
// @ TUName[]  ; -- translator directive

/*** BeginHeader _x509_s3_x509_scan_decimal */
// From "x509_all.c":259
int _x509_s3_x509_scan_decimal(char __far * buf, size_t ndigits);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_scan_decimal(char __far * buf, size_t ndigits) {
	int retval /* = 0 */; 	// From "x509_all.c":261
	char c; 	// From "x509_all.c":262

	retval = 0;

	while (ndigits) {
		c = *buf++;
		if (c<'0' ||
		c>'9')
			return  -1;
		retval = retval*10+(c-'0');
		 --ndigits;
	}
	return retval;
}

/*** BeginHeader _x509_s3_x509_parse_time */
// From "x509_all.c":273
int _x509_s3_x509_parse_time(char __far * buf, size_t len, char asn1_tag, os_time_t __far * val);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_time(char __far * buf, size_t len, char asn1_tag, os_time_t __far * val) {
	char __far * pos; 	// From "x509_all.c":276
	int year; 	// From "x509_all.c":277
	int month; 	// From "x509_all.c":277
	int day; 	// From "x509_all.c":277
	int hour; 	// From "x509_all.c":277
	int min; 	// From "x509_all.c":277
	int sec; 	// From "x509_all.c":277


	pos = (char  __far * )buf;
	switch ((int)(asn1_tag)) {
		case 0x17:
		if (len!=13 ||
		buf[12]!='Z') {
			_X509_HEXDUMP((MSG_DEBUG, "X509: Unrecognized " \
			 "UTCTime format" , buf, len));
			return  -1;
		}
		year = _x509_s3_x509_scan_decimal(pos, 2);
		if (year<0) {
			_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse " \
			 "UTCTime year" , buf, len));
			return  -1;
		}
		if (year<50)
			year += 2000;
		else
			year += 1900;
		pos += 2;
		break;
		case 0x18:
		if (len!=15 ||
		buf[14]!='Z') {
			_X509_HEXDUMP((MSG_DEBUG, "X509: Unrecognized " \
			 "GeneralizedTime format" , buf, len));
			return  -1;
		}
		year = _x509_s3_x509_scan_decimal(pos, 4);
		if (year<0) {
			_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse " \
			 "GeneralizedTime year" , buf, len));
			return  -1;
		}
		pos += 4;
		break;
		default:
		_X509_PRINTF((MSG_DEBUG, "X509: Expected UTCTime or " \
		 "GeneralizedTime - found tag 0x%x" , asn1_tag));
		return  -1;
	}
	month = _x509_s3_x509_scan_decimal(pos, 2);
	if (month<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse Time " \
		 "(month)" , buf, len));
		return  -1;
	}
	pos += 2;
	day = _x509_s3_x509_scan_decimal(pos, 2);
	if (day<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse Time " \
		 "(day)" , buf, len));
		return  -1;
	}
	pos += 2;
	hour = _x509_s3_x509_scan_decimal(pos, 2);
	if (hour<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse Time " \
		 "(hour)" , buf, len));
		return  -1;
	}
	pos += 2;
	min = _x509_s3_x509_scan_decimal(pos, 2);
	if (min<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse Time " \
		 "(min)" , buf, len));
		return  -1;
	}
	pos += 2;
	sec = _x509_s3_x509_scan_decimal(pos, 2);
	if (sec<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse Time " \
		 "(sec)" , buf, len));
		return  -1;
	}
	if (os_mktime(year, month, day, hour, min, sec, val)<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to convert Time" , buf, len));
		return  -1;
	}
	return 0;
}
/*** BeginHeader */

struct x509_algorithm_identifier {
	struct asn1_oid oid;

} ;	// From "x509v3.h":22

struct x509_name {
	char __far * cn;
	char __far * c;
	char __far * l;
	char __far * st;
	char __far * o;
	char __far * ou;
	char __far * email;

} ;	// From "x509v3.h":32

struct x509_certificate {
	struct x509_certificate __far * next;

	enum  {
		X509_CERT_V1 = 0,
		X509_CERT_V2 = 1,
		X509_CERT_V3 = 2
	}  version;
	unsigned long serial_number;
	struct x509_algorithm_identifier signature;
	struct x509_name issuer;
	struct x509_name subject;
	os_time_t not_before;
	os_time_t not_after;
	struct x509_algorithm_identifier public_key_alg;
	char __far * public_key;
	size_t public_key_len;
	struct x509_algorithm_identifier signature_alg;
	char __far * sign_value;
	size_t sign_value_len;
	unsigned int extensions_present;
	int ca;
	unsigned long path_len_constraint;
	unsigned long key_usage;
	char __far * cert_start;
	size_t cert_len;
	const char __far * tbs_cert_start;
	size_t tbs_cert_len;
	char __far * subject_alt_name;

} ;	// From "x509v3.h":80

enum  {
	X509_VALIDATE_OK,
	X509_VALIDATE_BAD_CERTIFICATE,
	X509_VALIDATE_UNSUPPORTED_CERTIFICATE,
	X509_VALIDATE_CERTIFICATE_REVOKED,
	X509_VALIDATE_CERTIFICATE_EXPIRED,
	X509_VALIDATE_CERTIFICATE_UNKNOWN,
	X509_VALIDATE_UNKNOWN_CA
}  ;	// From "x509v3.h":90
/*** EndHeader */

/*** BeginHeader _x509_s3_x509_free_name */
// From "x509v3.c":26
void _x509_s3_x509_free_name(struct x509_name __far * name);
/*** EndHeader */
_x509_debug
void _x509_s3_x509_free_name(struct x509_name __far * name) {
	_sys_free(name->cn);
	_sys_free(name->c);
	_sys_free(name->l);
	_sys_free(name->st);
	_sys_free(name->o);
	_sys_free(name->ou);
	_sys_free(name->email);
	name->cn = name->c = name->l = name->st = name->o = name->ou = ((void  __far * )0);
	name->email = ((void  __far * )0);
}

/*** BeginHeader x509_certificate_free */
// From "x509v3.c":44
void x509_certificate_free(struct x509_certificate __far * cert);
/*** EndHeader */
_x509_debug
void x509_certificate_free(struct x509_certificate __far * cert) {
	if (cert==((void  __far * )0))
		return /*void*/;
	if (cert->next) {
		_X509_PRINTF((MSG_DEBUG, "X509: x509_certificate_free: cer=%lp was still on a list (next=%lp)\n" ,
                cert, cert->next));
	}
	_x509_s3_x509_free_name(&cert->issuer);
	_x509_s3_x509_free_name(&cert->subject);
	_sys_free(cert->public_key);
	_sys_free(cert->sign_value);
	_sys_free(cert->subject_alt_name);
	_sys_free(cert);
}

/*** BeginHeader x509_certificate_chain_free */
// From "x509v3.c":65
void x509_certificate_chain_free(struct x509_certificate __far * cert);
/*** EndHeader */
_x509_debug
void x509_certificate_chain_free(struct x509_certificate __far * cert) {
	struct x509_certificate __far * next; 	// From "x509v3.c":67


	while (cert) {
		next = cert->next;
		cert->next = ((void  __far * )0);
		x509_certificate_free(cert);
		cert = next;
	}
}

/*** BeginHeader _x509_s3_x509_str_compare */
// From "x509v3.c":78
int _x509_s3_x509_str_compare(char __far * a, char __far * b);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_str_compare(char __far * a, char __far * b) {
	if (!a)
		return b ? -1 : 0;
	if (!b)
		return 1;
	return strcmpi(a, b);
}

/*** BeginHeader x509_name_compare */
// From "x509v3.c":98
int x509_name_compare(struct x509_name __far * a, struct x509_name __far * b);
/*** EndHeader */
_x509_debug
int x509_name_compare(struct x509_name __far * a, struct x509_name __far * b) {
	int res; 	// From "x509v3.c":100

	if (!a)
		return b ? -1 : 0;
	if (!b)
		return 1;
	
	res = _x509_s3_x509_str_compare(a->cn, b->cn);
	if (res)
		return res;
	res = _x509_s3_x509_str_compare(a->c, b->c);
	if (res)
		return res;
	res = _x509_s3_x509_str_compare(a->l, b->l);
	if (res)
		return res;
	res = _x509_s3_x509_str_compare(a->st, b->st);
	if (res)
		return res;
	res = _x509_s3_x509_str_compare(a->o, b->o);
	if (res)
		return res;

	res = _x509_s3_x509_str_compare(a->ou, b->ou);
	return res ? res : _x509_s3_x509_str_compare(a->email, b->email);
}

/*** BeginHeader _x509_s3_x509_parse_algorithm_identifier */
// From "x509v3.c":135
int _x509_s3_x509_parse_algorithm_identifier(char __far * buf, size_t len, struct x509_algorithm_identifier __far * id,
                                             char __far * __far * next);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_algorithm_identifier(char __far * buf, size_t len, struct x509_algorithm_identifier __far * id,
                                             char __far * __far * next) {
	struct asn1_hdr hdr; 	// From "x509v3.c":139
	char __far * pos; 	// From "x509v3.c":140
	char __far * end; 	// From "x509v3.c":140


	if (asn1_get_next(buf, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
		 "(AlgorithmIdentifier) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	end = pos+hdr.length;
	if (end>buf+len)
		return  -1;
	*next = end;
	if (asn1_get_oid(pos, (_x509_ptrdiff_t)(end-pos), &id->oid, &pos))
		return  -1;
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_public_key */
// From "x509v3.c":174
int _x509_s3_x509_parse_public_key(char __far * buf, size_t len, struct x509_certificate __far * cert,
                                   char __far * __far * next);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_public_key(char __far * buf, size_t len, struct x509_certificate __far * cert,
                                   char __far * __far * next) {
	struct asn1_hdr hdr; 	// From "x509v3.c":178
	char __far * pos; 	// From "x509v3.c":179
	char __far * end; 	// From "x509v3.c":179


	pos = buf;
	end = buf+len;
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
		 "(SubjectPublicKeyInfo) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	if (pos+hdr.length>end)
		return  -1;
	end = pos+hdr.length;
	*next = end;
	if (_x509_s3_x509_parse_algorithm_identifier(pos, (_x509_ptrdiff_t)(end-pos), &cert->public_key_alg,
                                              &pos))
		return  -1;
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x03) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected BITSTRING " \
		 "(subjectPublicKey) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	if (hdr.length<1)
		return  -1;
	pos = hdr.payload;
	if (*pos) {
		_X509_PRINTF((MSG_DEBUG, "X509: BITSTRING - %d unused bits" , *pos));
	}
	_sys_free(cert->public_key);
	cert->public_key = _sys_malloc(hdr.length-1);
	if (cert->public_key==((void  __far * )0)) {
		_X509_PRINTF((MSG_DEBUG, "X509: Failed to allocate memory for " \
		 "public key" ));
		return  -1;
	}
	_f_memcpy(cert->public_key, pos+1, hdr.length-1);
	cert->public_key_len = hdr.length-1;
	_X509_HEXDUMP((MSG_MSGDUMP, "X509: subjectPublicKey" , cert->public_key, cert->public_key_len));
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_name */
// From "x509v3.c":247
int _x509_s3_x509_parse_name(char __far * buf, size_t len, struct x509_name __far * name,
                             char __far * __far * next);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_name(char __far * buf, size_t len, struct x509_name __far * name,
                             char __far * __far * next) {
	struct asn1_hdr hdr; 	// From "x509v3.c":250
	char __far * pos; 	// From "x509v3.c":251
	char __far * end; 	// From "x509v3.c":251
	char __far * set_pos; 	// From "x509v3.c":251
	char __far * set_end; 	// From "x509v3.c":251
	char __far * seq_pos; 	// From "x509v3.c":251
	char __far * seq_end; 	// From "x509v3.c":251
	struct asn1_oid oid; 	// From "x509v3.c":252
	char __far * __far * fieldp; 	// From "x509v3.c":253


	if (asn1_get_next(buf, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
		 "(Name / RDNSequencer) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	if (pos+hdr.length>buf+len)
		return  -1;
	end = *next = pos+hdr.length;
	while (pos<end) {
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
		hdr.class!=ASN1_CLASS_UNIVERSAL ||
		hdr.tag!=0x11) {
			_X509_PRINTF((MSG_DEBUG, "X509: Expected SET " \
			 "(RelativeDistinguishedName) - found class " \
			 "%d tag 0x%x" , hdr.class, hdr.tag));
			_x509_s3_x509_free_name(name);
			return  -1;
		}
		set_pos = hdr.payload;
		pos = set_end = hdr.payload+hdr.length;
		if (asn1_get_next(set_pos, (_x509_ptrdiff_t)(set_end-set_pos), &hdr)<0 ||
		hdr.class!=ASN1_CLASS_UNIVERSAL ||
		hdr.tag!=0x10) {
			_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
			 "(AttributeTypeAndValue) - found class %d " \
			 "tag 0x%x" , hdr.class, hdr.tag));
			_x509_s3_x509_free_name(name);
			return  -1;
		}
		seq_pos = hdr.payload;
		seq_end = hdr.payload+hdr.length;
		if (asn1_get_oid(seq_pos, (_x509_ptrdiff_t)(seq_end-seq_pos), &oid, &seq_pos)) {
			_x509_s3_x509_free_name(name);
			return  -1;
		}
		if (asn1_get_next(seq_pos, (_x509_ptrdiff_t)(seq_end-seq_pos), &hdr)<0 ||
		hdr.class!=ASN1_CLASS_UNIVERSAL) {
			_X509_PRINTF((MSG_DEBUG, "X509: Failed to parse " \
			 "AttributeValue" ));
			_x509_s3_x509_free_name(name);
			return  -1;
		}
		fieldp = ((void  __far * )0);
		if (oid.len==4 &&
		oid.oid[0]==2 &&
		oid.oid[1]==5 &&
		oid.oid[2]==4) {
			switch ((int)(oid.oid[3])) {
				case 3:
				fieldp = &name->cn;
				break;
				case 6:
				fieldp = &name->c;
				break;
				case 7:
				fieldp = &name->l;
				break;
				case 8:
				fieldp = &name->st;
				break;
				case 10:
				fieldp = &name->o;
				break;
				case 11:
				fieldp = &name->ou;
				break;
			}
		}
		else if (oid.len==7 &&
		oid.oid[0]==1 &&
		oid.oid[1]==2 &&
		oid.oid[2]==840 &&
		oid.oid[3]==113549 &&
		oid.oid[4]==1 &&
		oid.oid[5]==9 &&
		oid.oid[6]==1) {
			fieldp = &name->email;
		}
		if (fieldp==((void  __far * )0)) {
			_X509_HEXDUMP((MSG_DEBUG, "X509: Unrecognized OID" , (char  __far * )oid.oid, oid.len
                                                                               *sizeof (oid.oid[0])));
			_X509_HEXDUMP((MSG_MSGDUMP, "X509: Attribute Data" , hdr.payload, hdr.length));
			continue;
		}
		_sys_free(*fieldp);
		*fieldp = _sys_malloc(hdr.length+1);
		if (*fieldp==((void  __far * )0)) {
			_x509_s3_x509_free_name(name);
			return  -1;
		}
		_f_memcpy(*fieldp, hdr.payload, hdr.length);
		(*fieldp)[hdr.length] = '\0';
	}
	return 0;
}

/*** BeginHeader x509_name_string */
// From "x509v3.c":398
void x509_name_string(struct x509_name __far * name, char __far * buf, size_t len);
/*** EndHeader */
_x509_debug
void x509_name_string(struct x509_name __far * name, char __far * buf, size_t len) {
	char __far * pos; 	// From "x509v3.c":400
	char __far * end; 	// From "x509v3.c":400
	int ret; 	// From "x509v3.c":401
	char __far * name_str;
	char __far * format_str;
    _x509_ptrdiff_t diff;
    int iterator;

	if (len==0)
		return /*void*/;
		
	pos = buf;
    diff = len;
	end = len + buf;
    iterator = 0;

   while(iterator < 7) {
      switch(iterator)
         {
         case 0:
            if (name_str = name->c)
               format_str = "C=%ls, ";
            break;

         case 1:
            if (name_str = name->st)
               format_str = "ST=%ls, ";
            break;

         case 2:
            if (name_str = name->l)
               format_str = "L=%ls, ";
            break;

         case 3:
            if (name_str = name->o)
               format_str = "O=%ls, ";
            break;

         case 4:
            if (name_str = name->ou)
               format_str = "OU=%ls, ";
            break;

         case 5:
            if (name_str = name->cn)
               format_str = "CN=%ls, ";
            break;

         case 6:
            if (name_str = name->email)
               format_str = "/emailAddress=%ls";
            break;
	}

      if (name_str) {
         ret = snprintf(pos, diff, format_str , name_str);
         if ((ret < 0) || (ret >= diff))
            break;

		pos += ret;
         diff -= ret;
	}

      if((iterator == 5) && (pos > buf + 1) && (pos[-1] == ' ') && (pos[-2] == ',')) {
            --pos;
		*pos-- = '\0';
	}

      iterator++;
   };

	end[ -1] = '\0';
}

/*** BeginHeader _x509_s3_x509_parse_validity */
// From "x509v3.c":563
int _x509_s3_x509_parse_validity(char __far * buf, size_t len, struct x509_certificate __far * cert,
                                 char __far * __far * next);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_validity(char __far * buf, size_t len, struct x509_certificate __far * cert,
                                 char __far * __far * next) {
	struct asn1_hdr hdr; 	// From "x509v3.c":566
	char __far * pos; 	// From "x509v3.c":567
	size_t plen; 	// From "x509v3.c":568


	if (asn1_get_next(buf, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
		 "(Validity) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	plen = hdr.length;
	if (pos+plen>buf+len)
		return  -1;
	*next = pos+plen;
	if (asn1_get_next(pos, plen, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	_x509_s3_x509_parse_time(hdr.payload, hdr.length, hdr.tag, &cert->not_before)<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse notBefore " \
		 "Time" , hdr.payload, hdr.length));
		return  -1;
	}
	pos = hdr.payload+hdr.length;
	plen = (_x509_ptrdiff_t)(*next-pos);
	if (asn1_get_next(pos, plen, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	_x509_s3_x509_parse_time(hdr.payload, hdr.length, hdr.tag, &cert->not_after)<0) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Failed to parse notAfter " \
		 "Time" , hdr.payload, hdr.length));
		return  -1;
	}
	_X509_PRINTF((MSG_MSGDUMP, "X509: Validity: notBefore: %lu notAfter: %lu" , (unsigned long  )cert->not_before,
               (unsigned long  )cert->not_after));
	return 0;
}

/*** BeginHeader _x509_s3_x509_id_ce_oid */
// From "x509v3.c":627
int _x509_s3_x509_id_ce_oid(struct asn1_oid __far * oid);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_id_ce_oid(struct asn1_oid __far * oid) {
	return oid->len>=4 &&
	oid->oid[0]==2 &&
	oid->oid[1]==5 &&
	oid->oid[2]==29;
}

/*** BeginHeader _x509_s3_x509_parse_ext_key_usage */
// From "x509v3.c":637
int _x509_s3_x509_parse_ext_key_usage(struct x509_certificate __far * cert, char __far * pos,
                                      size_t len);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_ext_key_usage(struct x509_certificate __far * cert, char __far * pos,
                                      size_t len) {
	struct asn1_hdr hdr; 	// From "x509v3.c":640


	if (asn1_get_next(pos, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x03 ||
	hdr.length<1) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected BIT STRING in " \
		 "KeyUsage; found %d tag 0x%x len %d" , hdr.class, hdr.tag, hdr.length));
		return  -1;
	}
	cert->extensions_present |= (1<<2);
	cert->key_usage = asn1_bit_string_to_long(hdr.payload, hdr.length);
	_X509_PRINTF((MSG_DEBUG, "X509: KeyUsage 0x%lx" , cert->key_usage));
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_subj_alt_name */
int _x509_s3_x509_parse_subj_alt_name(struct x509_certificate __far * cert,
                                      char __far * pos, size_t len);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_subj_alt_name(struct x509_certificate __far * cert,
                                      char __far * pos, size_t len) {
	struct asn1_hdr hdr;
	char __far *end = pos + len;
	char __far *payload, *dest;
	int names_length;
	
	if (asn1_get_next(pos, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10 ||
	hdr.length>len-2) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected %s in %s; found %d tag 0x%x len %d",
			"SEQUENCE", "subjectAltName", hdr.class, hdr.tag, hdr.length));
		return  -1;
	}
	
	// Allocate space to hold a list of alternate names.  hdr.length will be
	// enough space, since each name has a two-byte prefix with the class/tag
	// and length.  We'll use one byte for a null between each entry, and
	// an extra null at the end to terminate the list.
	_sys_free(cert->subject_alt_name);
	cert->subject_alt_name = dest = _sys_malloc(hdr.length);
	if (cert->subject_alt_name == NULL) {
		_X509_PRINTF((MSG_DEBUG, "X509: Failed to allocate memory for %s",
		 "subjectAltName" ));
		return -1;
	}
	
	payload = hdr.payload;
	while (payload < end) {
		if (asn1_get_next(payload, (size_t)(end - payload), &hdr)<0 ||
		hdr.class!=ASN1_CLASS_CONTEXT_SPECIFIC) {
			_X509_PRINTF((MSG_DEBUG, "X509: Expected %s in %s; found %d tag 0x%x len %d",
				"Context-specific", "subjectAltName", hdr.class, hdr.tag, hdr.length));
			return  -1;
		}
		/*
		#   GeneralName ::= CHOICE {
		#        otherName                       [0]     OtherName,
		#        rfc822Name                      [1]     IA5String,
		#        dNSName                         [2]     IA5String,
		#        x400Address                     [3]     ORAddress,
		#        directoryName                   [4]     Name,
		#        ediPartyName                    [5]     EDIPartyName,
		#        uniformResourceIdentifier       [6]     IA5String,
		#        iPAddress                       [7]     OCTET STRING,
		#        registeredID                    [8]     OBJECT IDENTIFIER }
		*/
		_X509_PRINTF((MSG_DEBUG, "X509: subjectAltName tag %u: %.*ls",
			hdr.tag, hdr.length, hdr.payload));
		if (hdr.tag == 2) {	// dNSName
			_f_memcpy(dest, hdr.payload, hdr.length);
			dest += hdr.length;
			*dest++ = '\0';  // null-terminate each entry
		}
		payload = hdr.payload + hdr.length;
	}
	
	// add a second null to terminate the list
	*dest++ = '\0';
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_ext_basic_constraints */
// From "x509v3.c":674
int _x509_s3_x509_parse_ext_basic_constraints(struct x509_certificate __far * cert,
                                              char __far * pos, size_t len);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_ext_basic_constraints(struct x509_certificate __far * cert,
                                              char __far * pos, size_t len) {
	struct asn1_hdr hdr; 	// From "x509v3.c":677
	unsigned long value; 	// From "x509v3.c":678
	size_t left; 	// From "x509v3.c":679


	if (asn1_get_next(pos, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE in " \
		 "BasicConstraints; found %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	cert->extensions_present |= (1<<0);
	if (hdr.length==0)
		return 0;
	// extract ASN.1 embedded in payload
	if (asn1_get_next(hdr.payload, hdr.length,
			  &hdr) < 0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL) {
		_X509_PRINTF((MSG_DEBUG, "X509: Failed to parse " \
		 "BasicConstraints" ));
		return  -1;
	}
	if (hdr.tag==0x01) {
		if (hdr.length!=1) {
			_X509_PRINTF((MSG_DEBUG, "X509: Unexpected " \
			 "Boolean length (%u) in BasicConstraints" , hdr.length));
			return  -1;
		}
		cert->ca = hdr.payload[0];
		
		hdr.payload += hdr.length;
		len = (size_t)(pos + len - hdr.payload);
		if (len==0) {
			_X509_PRINTF((MSG_DEBUG, "X509: BasicConstraints - cA=%d" , cert->ca));
			return 0;
		}
		if (asn1_get_next(hdr.payload, len,
				  &hdr) < 0 ||
		hdr.class!=ASN1_CLASS_UNIVERSAL) {
			_X509_PRINTF((MSG_DEBUG, "X509: Failed to parse " \
			 "BasicConstraints" ));
			return  -1;
		}
	}
	if (hdr.tag!=0x02) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected INTEGER in " \
		 "BasicConstraints; found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	left = hdr.length;
	value = 0;
	while (left) {
		value <<= 8;
		value |= *pos++;
		left--;
	}
	cert->path_len_constraint = value;
	cert->extensions_present |= (1<<1);
	_X509_PRINTF((MSG_DEBUG, "X509: BasicConstraints - cA=%d " \
	 "pathLenConstraint=%lu" , cert->ca, cert->path_len_constraint));
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_extension_data */
// From "x509v3.c":758
int _x509_s3_x509_parse_extension_data(struct x509_certificate __far * cert, struct asn1_oid __far * oid,
                                       char __far * pos, size_t len);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_extension_data(struct x509_certificate __far * cert, struct asn1_oid __far * oid,
                                       char __far * pos, size_t len) {
	if (!_x509_s3_x509_id_ce_oid(oid))
		return 1;
	switch ((int)(oid->oid[3])) {
		case 15:
		return _x509_s3_x509_parse_ext_key_usage(cert, pos, len);
		case 17:
		return _x509_s3_x509_parse_subj_alt_name(cert, pos, len);
		case 19:
		return _x509_s3_x509_parse_ext_basic_constraints(cert, pos, len);
		default:
		return 1;
	}
}

/*** BeginHeader _x509_s3_x509_parse_extension */
// From "x509v3.c":784
int _x509_s3_x509_parse_extension(struct x509_certificate __far * cert, char __far * pos,
                                  size_t len, char __far * __far * next);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_extension(struct x509_certificate __far * cert, char __far * pos,
                                  size_t len, char __far * __far * next) {
	char __far * end; 	// From "x509v3.c":787
	struct asn1_hdr hdr; 	// From "x509v3.c":788
	struct asn1_oid oid; 	// From "x509v3.c":789
	int critical_ext /* = 0 */; 	// From "x509v3.c":790
	int res; 	// From "x509v3.c":790
	char buf[80]; 	// From "x509v3.c":791

	critical_ext = 0;

	if (asn1_get_next(pos, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Unexpected ASN.1 header in " \
		 "Extensions: class %d tag 0x%x; expected SEQUENCE" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	*next = end = pos+hdr.length;
	if (asn1_get_oid(pos, (_x509_ptrdiff_t)(end-pos), &oid, &pos)<0) {
		_X509_PRINTF((MSG_DEBUG, "X509: Unexpected ASN.1 data for " \
		 "Extension (expected OID)" ));
		return  -1;
	}
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	(hdr.tag!=0x01 &&
	hdr.tag!=0x04)) {
		_X509_PRINTF((MSG_DEBUG, "X509: Unexpected ASN.1 header in " \
		 "Extensions: class %d tag 0x%x; expected BOOLEAN " \
		 "or OCTET STRING" , hdr.class, hdr.tag));
		return  -1;
	}
	if (hdr.tag==0x01) {
		if (hdr.length!=1) {
			_X509_PRINTF((MSG_DEBUG, "X509: Unexpected " \
			 "Boolean length (%u)" , hdr.length));
			return  -1;
		}
		critical_ext = hdr.payload[0];
		pos = hdr.payload;
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
		(hdr.class!=ASN1_CLASS_UNIVERSAL &&
		hdr.class!=ASN1_CLASS_PRIVATE) ||
		hdr.tag!=0x04) {
			_X509_PRINTF((MSG_DEBUG, "X509: Unexpected ASN.1 header " \
			 "in Extensions: class %d tag 0x%x; " \
			 "expected OCTET STRING" , hdr.class, hdr.tag));
			return  -1;
		}
	}
	asn1_oid_to_str(&oid, buf, sizeof (buf));
	_X509_PRINTF((MSG_DEBUG, "X509: Extension: extnID=%ls critical=%d" , (char  __far * )(buf),
               critical_ext));
	_X509_HEXDUMP((MSG_MSGDUMP, "X509: extnValue" , hdr.payload, hdr.length));
	res = _x509_s3_x509_parse_extension_data(cert, &oid, hdr.payload, hdr.length);
	if (res<0)
		return res;
	if (res==1 &&
	critical_ext) {
		_X509_PRINTF((MSG_INFO, "X509: Unknown critical extension %ls" , (char  __far * )(buf)));
		return  -1;
	}
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_extensions */
// From "x509v3.c":866
int _x509_s3_x509_parse_extensions(struct x509_certificate __far * cert, char __far * pos,
                                   size_t len);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_extensions(struct x509_certificate __far * cert, char __far * pos,
                                   size_t len) {
	char __far * end; 	// From "x509v3.c":869
	struct asn1_hdr hdr; 	// From "x509v3.c":870


	if (asn1_get_next(pos, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Unexpected ASN.1 data " \
		 "for Extensions: class %d tag 0x%x; " \
		 "expected SEQUENCE" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	end = pos+hdr.length;
	while (pos<end) {
		if (_x509_s3_x509_parse_extension(cert, pos, (_x509_ptrdiff_t)(end-pos), &pos)
      <0)
			return  -1;
	}
	return 0;
}

/*** BeginHeader _x509_s3_x509_parse_tbs_certificate */
// From "x509v3.c":896
int _x509_s3_x509_parse_tbs_certificate(char __far * buf, size_t len, struct x509_certificate __far * cert,
                                        char __far * __far * next);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_parse_tbs_certificate(char __far * buf, size_t len, struct x509_certificate __far * cert,
                                        char __far * __far * next) {
	struct asn1_hdr hdr; 	// From "x509v3.c":900
	char __far * pos; 	// From "x509v3.c":901
	char __far * end; 	// From "x509v3.c":901
	size_t left; 	// From "x509v3.c":902
	char sbuf[128]; 	// From "x509v3.c":903
	unsigned long value; 	// From "x509v3.c":904


	if (asn1_get_next(buf, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: tbsCertificate did not start " \
		 "with a valid SEQUENCE - found class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	end = *next = pos+hdr.length;
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0)
		return  -1;
	pos = hdr.payload;
	if (hdr.class==ASN1_CLASS_CONTEXT_SPECIFIC) {
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0)
			return  -1;
		if (hdr.class!=ASN1_CLASS_UNIVERSAL ||
		hdr.tag!=0x02) {
			_X509_PRINTF((MSG_DEBUG, "X509: No INTEGER tag found for " \
			 "version field - found class %d tag 0x%x" , hdr.class, hdr.tag));
			return  -1;
		}
		if (hdr.length!=1) {
			_X509_PRINTF((MSG_DEBUG, "X509: Unexpected version field " \
			 "length %u (expected 1)" , hdr.length));
			return  -1;
		}
		pos = hdr.payload;
		left = hdr.length;
		value = 0;
		while (left) {
			value <<= 8;
			value |= *pos++;
			left--;
		}
		cert->version = (int)value;
		if (cert->version!=X509_CERT_V1 &&
		cert->version!=X509_CERT_V2 &&
		cert->version!=X509_CERT_V3) {
			_X509_PRINTF((MSG_DEBUG, "X509: Unsupported version %d" , cert->version+1));
			return  -1;
		}
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0)
			return  -1;
	}
	else
		cert->version = X509_CERT_V1;
	_X509_PRINTF((MSG_MSGDUMP, "X509: Version X.509v%d" , cert->version+1));
	if (hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x02) {
		_X509_PRINTF((MSG_DEBUG, "X509: No INTEGER tag found for " \
		 "serialNumber; class=%d tag=0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	pos = hdr.payload;
	left = hdr.length;
	while (left) {
		cert->serial_number <<= 8;
		cert->serial_number |= *pos++;
		left--;
	}
	_X509_PRINTF((MSG_MSGDUMP, "X509: serialNumber %lu" , cert->serial_number));
	if (_x509_s3_x509_parse_algorithm_identifier(pos, (_x509_ptrdiff_t)(end-pos), &cert->signature,
                                              &pos))
		return  -1;
	if (_x509_s3_x509_parse_name(pos, (_x509_ptrdiff_t)(end-pos), &cert->issuer, &pos))
		return  -1;
	x509_name_string(&cert->issuer, sbuf, sizeof (sbuf));
	_X509_PRINTF((MSG_MSGDUMP, "X509: issuer %ls" , (char  __far * )(sbuf)));
	if (_x509_s3_x509_parse_validity(pos, (_x509_ptrdiff_t)(end-pos), cert, &pos))
		return  -1;
	if (_x509_s3_x509_parse_name(pos, (_x509_ptrdiff_t)(end-pos), &cert->subject, &pos))
		return  -1;
	x509_name_string(&cert->subject, sbuf, sizeof (sbuf));
	_X509_PRINTF((MSG_MSGDUMP, "X509: subject %ls" , (char  __far * )(sbuf)));
	if (_x509_s3_x509_parse_public_key(pos, (_x509_ptrdiff_t)(end-pos), cert, &pos))
		return  -1;
	if (pos==end)
		return 0;
	if (cert->version==X509_CERT_V1)
		return 0;
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_CONTEXT_SPECIFIC) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected Context-Specific" \
		 " tag to parse optional tbsCertificate " \
		 "field(s); parsed class %d tag 0x%x" , hdr.class, hdr.tag));
		return  -1;
	}
	if (hdr.tag==1) {
		_X509_PRINTF((MSG_DEBUG, "X509: issuerUniqueID" ));
		if (hdr.payload+hdr.length==end)
			return 0;
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
		hdr.class!=ASN1_CLASS_CONTEXT_SPECIFIC) {
			_X509_PRINTF((MSG_DEBUG, "X509: Expected Context-Specific" \
			 " tag to parse optional tbsCertificate " \
			 "field(s); parsed class %d tag 0x%x" , hdr.class, hdr.tag));
			return  -1;
		}
	}
	if (hdr.tag==2) {
		_X509_PRINTF((MSG_DEBUG, "X509: subjectUniqueID" ));
		if (hdr.payload+hdr.length==end)
			return 0;
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
		hdr.class!=ASN1_CLASS_CONTEXT_SPECIFIC) {
			_X509_PRINTF((MSG_DEBUG, "X509: Expected Context-Specific" \
			 " tag to parse optional tbsCertificate " \
			 "field(s); parsed class %d tag 0x%x" , hdr.class, hdr.tag));
			return  -1;
		}
	}
	if (hdr.tag!=3) {
		_X509_PRINTF((MSG_DEBUG, "X509: Ignored unexpected " \
		 "Context-Specific tag %d in optional " \
		 "tbsCertificate fields" , hdr.tag));
		return 0;
	}
	if (cert->version!=X509_CERT_V3) {
		_X509_PRINTF((MSG_DEBUG, "X509: X.509%d certificate and " \
		 "Extensions data which are only allowed for " \
		 "version 3" , cert->version+1));
		return  -1;
	}
	if (_x509_s3_x509_parse_extensions(cert, hdr.payload, hdr.length)<0)
		return  -1;
	pos = hdr.payload+hdr.length;
	if (pos<end) {
		_X509_HEXDUMP((MSG_DEBUG, "X509: Ignored extra tbsCertificate data" , pos, (_x509_ptrdiff_t)(end-pos)));
	}
	return 0;
}

/*** BeginHeader _x509_s3_x509_rsadsi_oid */
// From "x509v3.c":1090
int _x509_s3_x509_rsadsi_oid(struct asn1_oid __far * oid);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_rsadsi_oid(struct asn1_oid __far * oid) {
	return oid->len>=4 &&
	oid->oid[0]==1 &&
	oid->oid[1]==2 &&
	oid->oid[2]==840 &&
	oid->oid[3]==113549;
}

/*** BeginHeader _x509_s3_x509_pkcs_oid */
// From "x509v3.c":1100
int _x509_s3_x509_pkcs_oid(struct asn1_oid __far * oid);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_pkcs_oid(struct asn1_oid __far * oid) {
	return oid->len>=5 &&
	_x509_s3_x509_rsadsi_oid(oid) &&
	oid->oid[4]==1;
}

/*** BeginHeader _x509_s3_x509_digest_oid */
// From "x509v3.c":1108
int _x509_s3_x509_digest_oid(struct asn1_oid __far * oid);
/*** EndHeader */
_x509_debug
// return true for child of 1.2.840.113549.2
int _x509_s3_x509_digest_oid(struct asn1_oid __far * oid) {
	return oid->len>=5 &&
	_x509_s3_x509_rsadsi_oid(oid) &&
	oid->oid[4]==2;
}

/*** BeginHeader _x509_s3_x509_sha1_oid */
// From "x509v3.c":1116
int _x509_s3_x509_sha1_oid(struct asn1_oid __far * oid);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_sha1_oid(struct asn1_oid __far * oid) {
	return oid->len==6 &&
	oid->oid[0]==1 &&
	oid->oid[1]==3 &&
	oid->oid[2]==14 &&
	oid->oid[3]==3 &&
	oid->oid[4]==2 &&
	oid->oid[5]==26;
}

/*** BeginHeader _x509_s3_x509_nistAlgorithm_oid */
int _x509_s3_x509_nistAlgorithm_oid(struct asn1_oid __far * oid);
/*** EndHeader */
const far unsigned long _nistAlgorithm_oid[8] = {2, 16, 840, 1, 101, 3, 4, 2};
// returns the last element of the OID
_x509_debug
int _x509_s3_x509_nistAlgorithm_oid(struct asn1_oid __far * oid) {
	if (oid->len==9 &&
   	_f_memcmp(&oid->oid, &_nistAlgorithm_oid, sizeof _nistAlgorithm_oid)==0 &&
   	oid->oid[8] <= INT_MAX )
   {
   	return (int) oid->oid[8];
   }
   
   return -1;
}

/*** BeginHeader x509_certificate_parse */
// From "x509v3.c":1137
struct x509_certificate __far * x509_certificate_parse(char __far * buf, size_t len);
/*** EndHeader */
_x509_debug
struct x509_certificate __far * x509_certificate_parse(char __far * buf, size_t len) {
	struct asn1_hdr hdr; 	// From "x509v3.c":1139
	char __far * pos; 	// From "x509v3.c":1140
	char __far * end; 	// From "x509v3.c":1140
	char __far * hash_start; 	// From "x509v3.c":1140
	struct x509_certificate __far * cert; 	// From "x509v3.c":1141


	cert = _sys_calloc(sizeof (*cert)+len);
	if (cert==((void  __far * )0))
		return ((void  __far * )0);
	_f_memcpy(cert+1, buf, len);
	cert->cert_start = (char  __far * )(cert+1);
	cert->cert_len = len;
	pos = buf;
	end = buf+len;
	if (asn1_get_next(pos, len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Certificate did not start with " \
		 "a valid SEQUENCE - found class %d tag 0x%x" , hdr.class, hdr.tag));
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	pos = hdr.payload;
	if (pos+hdr.length>end) {
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	if (pos+hdr.length<end) {
		_X509_HEXDUMP((MSG_MSGDUMP, "X509: Ignoring extra data after DER " \
		 "encoded certificate" , pos+hdr.length, (_x509_ptrdiff_t)(end-(pos+hdr.length))));
		end = pos+hdr.length;
	}
	hash_start = pos;
	cert->tbs_cert_start = cert->cert_start+((_x509_ptrdiff_t)(hash_start-buf));
	if (_x509_s3_x509_parse_tbs_certificate(pos, (_x509_ptrdiff_t)(end-pos), cert,
                                         &pos)) {
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	cert->tbs_cert_len = (_x509_ptrdiff_t)(pos-hash_start);
	if (_x509_s3_x509_parse_algorithm_identifier(pos, (_x509_ptrdiff_t)(end-pos), &cert->signature_alg,
                                              &pos)) {
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x03) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected BITSTRING " \
		 "(signatureValue) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	if (hdr.length<1) {
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	pos = hdr.payload;
	if (*pos) {
		_X509_PRINTF((MSG_DEBUG, "X509: BITSTRING - %d unused bits" , *pos));
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	_sys_free(cert->sign_value);
	cert->sign_value = _sys_malloc(hdr.length-1);
	if (cert->sign_value==((void  __far * )0)) {
		_X509_PRINTF((MSG_DEBUG, "X509: Failed to allocate memory for " \
		 "signatureValue" ));
		x509_certificate_free(cert);
		return ((void  __far * )0);
	}
	_f_memcpy(cert->sign_value, pos+1, hdr.length-1);
	cert->sign_value_len = hdr.length-1;
	_X509_HEXDUMP((MSG_MSGDUMP, "X509: signature" , cert->sign_value, cert->sign_value_len));
	return cert;
}

/*** BeginHeader x509_certificate_check_signature */
// From "x509v3.c":1243
int x509_certificate_check_signature(struct x509_certificate __far * issuer,
			struct x509_certificate __far * cert, int _yield);
/*** EndHeader */
// Values for last element of a PKCS-1 OID (1.2.840.113549.1.1)
#define _PKCS1_MD5       4      // md5WithRSAEncryption
#define _PKCS1_SHA1      5      // sha1-with-rsa-signature
#define _PKCS1_SHA256    11     // sha256WithRSAEncryption
#define _PKCS1_SHA384    12     // sha384WithRSAEncryption
#define _PKCS1_SHA512    13     // sha512WithRSAEncryption
#define _PKCS1_SHA224    14     // sha224WithRSAEncryption
_x509_debug
int x509_certificate_check_signature(struct x509_certificate __far * issuer,
			struct x509_certificate __far * cert, int _yield) {
	struct RSA_key_t __far * pk; 	// From "x509v3.c":1246
	char __far * data; 	// From "x509v3.c":1247
	char __far * pos; 	// From "x509v3.c":1248
	char __far * end; 	// From "x509v3.c":1248
	char __far * next; 	// From "x509v3.c":1248
	char __far * da_end; 	// From "x509v3.c":1248
	size_t data_len; 	// From "x509v3.c":1249
	struct asn1_hdr hdr; 	// From "x509v3.c":1250
	struct asn1_oid oid; 	// From "x509v3.c":1251
#ifdef X509_ENABLE_SHA512
	char hash[SHA512_LENGTH];
#else
	char hash[SHA256_LENGTH];
#endif
	size_t hash_len; 	// From "x509v3.c":1253
	unsigned long sig_type, expected_sig_type;
	const char *digest_alg;

	// This function handles PKCS-1 signatures (1.2.840.113549.1)
	if (!_x509_s3_x509_pkcs_oid(&cert->signature.oid) ||
	cert->signature.oid.len!=7 ||
	cert->signature.oid.oid[5]!=1) {
		_X509_PRINTF((MSG_DEBUG, "X509: Unrecognized signature " \
		 "algorithm" ));
		return  -1;
	}
	pk = crypto_public_key_import(issuer->public_key, issuer->public_key_len);
	if (pk==((void  __far * )0))
		return  -1;
	if (_yield)
		pk->flags |= RSA_KEY_PUB_COP_YIELD;
	data_len = cert->sign_value_len;
	data = _sys_malloc(data_len);
	if (data==((void  __far * )0)) {
		crypto_public_key_free(pk);
		return  -1;
	}
	if (crypto_public_key_decrypt_pkcs1(pk, cert->sign_value, cert->sign_value_len,
                                     data, &data_len)<0) {
		_X509_PRINTF((MSG_DEBUG, "X509: Failed to decrypt signature" ));
		crypto_public_key_free(pk);
		_sys_free(data);
		return  -1;
	}
	crypto_public_key_free(pk);
	_X509_HEXDUMP((MSG_MSGDUMP, "X509: Signature data D" , data, data_len));
	if (asn1_get_next(data, data_len, &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
		 "(DigestInfo) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		_sys_free(data);
		return  -1;
	}
	pos = hdr.payload;
	end = pos+hdr.length;
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x10) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected SEQUENCE " \
		 "(AlgorithmIdentifier) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		_sys_free(data);
		return  -1;
	}
	da_end = hdr.payload+hdr.length;
	if (asn1_get_oid(hdr.payload, hdr.length, &oid, &next)) {
		_X509_PRINTF((MSG_DEBUG, "X509: Failed to parse digestAlgorithm" ));
		_sys_free(data);
		return  -1;
	}
	
	sig_type = cert->signature.oid.oid[6];
	digest_alg = NULL;
	switch (_x509_s3_x509_nistAlgorithm_oid(&oid)) {
		case 1: expected_sig_type = _PKCS1_SHA256;  digest_alg = "SHA256"; break;
		case 2: expected_sig_type = _PKCS1_SHA384;  digest_alg = "SHA384"; break;
		case 3: expected_sig_type = _PKCS1_SHA512;  digest_alg = "SHA512"; break;
		case 4: expected_sig_type = _PKCS1_SHA224;  digest_alg = "SHA224"; break;
		case -1: // not the nistAlgorithm.hashAlgs OID
	      if (_x509_s3_x509_sha1_oid(&oid)) {
	         expected_sig_type = _PKCS1_SHA1;
	         digest_alg = "SHA1";
	      }
			break;
	}
	if (digest_alg != NULL) {
		if (sig_type != expected_sig_type) {
			_X509_PRINTF((MSG_DEBUG, "X509: digestAlgorithm %s " \
			 "does not match with certificate " \
			 "signatureAlgorithm (%lu)", digest_alg, sig_type));
			_sys_free(data);
			return  -1;
		}
		goto skip_digest_oid;
	}
	
	if (!_x509_s3_x509_digest_oid(&oid)) {
		_X509_PRINTF((MSG_DEBUG, "X509: Unrecognized digestAlgorithm" ));
		_sys_free(data);
		return  -1;
	}
	switch ((int)(oid.oid[5])) {
		case 5:  // md5
		if (sig_type!=_PKCS1_MD5) {
			_X509_PRINTF((MSG_DEBUG, "X509: digestAlgorithm %s does " \
			 "not match with certificate " \
			 "signatureAlgorithm (%lu)" , "MD5", sig_type));
			_sys_free(data);
			return  -1;
		}
		break;
		case 2:  // md2
		case 4:  // md4
		default:
		_X509_PRINTF((MSG_DEBUG, "X509: Unsupported digestAlgorithm " \
		 "(%lu)" , oid.oid[5]));
		_sys_free(data);
		return  -1;
	}
	skip_digest_oid:
	pos = da_end;
	end = data+data_len;
	if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0 ||
	hdr.class!=ASN1_CLASS_UNIVERSAL ||
	hdr.tag!=0x04) {
		_X509_PRINTF((MSG_DEBUG, "X509: Expected OCTETSTRING " \
		 "(Digest) - found class %d tag 0x%x" , hdr.class, hdr.tag));
		_sys_free(data);
		return  -1;
	}
	_X509_HEXDUMP((MSG_MSGDUMP, "X509: Decrypted Digest" , hdr.payload, hdr.length));
	switch ((int)(sig_type)) {
		case _PKCS1_MD5:  // MD5 with RSA encryption
		md5_vector(1, &cert->tbs_cert_start, &cert->tbs_cert_len, hash);
		hash_len = HMAC_MD5_HASH_SIZE;
		break;
		case _PKCS1_SHA1:  // SHA-1 with RSA Encryption
		sha1_vector(1, &cert->tbs_cert_start, &cert->tbs_cert_len, hash);
		hash_len = HMAC_SHA_HASH_SIZE;
		break;
		case _PKCS1_SHA224: // sha224WithRSAEncryption
		sha224_vector(1, &cert->tbs_cert_start, &cert->tbs_cert_len, hash);
		hash_len = SHA224_LENGTH;
      break;
		case _PKCS1_SHA256: // sha256WithRSAEncryption
		sha256_vector(1, &cert->tbs_cert_start, &cert->tbs_cert_len, hash);
		hash_len = SHA256_LENGTH;
      break;
#ifdef X509_ENABLE_SHA512
		case _PKCS1_SHA384: // sha384WithRSAEncryption
		sha384_vector(1, &cert->tbs_cert_start, &cert->tbs_cert_len, hash);
		hash_len = SHA384_LENGTH;
      break;
		case _PKCS1_SHA512: // sha512WithRSAEncryption
		sha512_vector(1, &cert->tbs_cert_start, &cert->tbs_cert_len, hash);
		hash_len = SHA512_LENGTH;
      break;
#else
		case _PKCS1_SHA384: // sha384WithRSAEncryption
		case _PKCS1_SHA512: // sha512WithRSAEncryption
		_X509_PRINTF((MSG_INFO, "X509: * #define X509_ENABLE_SHA512 to support " \
		"this certificate *"));
#endif
		default:
		_X509_PRINTF((MSG_INFO, "X509: Unsupported certificate signature " \
		 "algorithm (%lu)" , sig_type));
		_sys_free(data);
		return  -1;
	}
   _X509_HEXDUMP((MSG_MSGDUMP, "X509: Certificate hash" , hash, hash_len));
	
	if (hdr.length!=hash_len ||
	_f_memcmp(hdr.payload, hash, hdr.length)!=0) {
		_X509_PRINTF((MSG_INFO, "X509: Certificate Digest does not match " \
		 "with calculated tbsCertificate hash" ));
		_sys_free(data);
		return  -1;
	}
	_sys_free(data);
	_X509_PRINTF((MSG_DEBUG, "X509: Certificate Digest matches with " \
	 "calculated tbsCertificate hash" ));
	return 0;
}

/*** BeginHeader _x509_s3_x509_valid_issuer */
// From "x509v3.c":1437
int _x509_s3_x509_valid_issuer(struct x509_certificate __far * cert);
/*** EndHeader */
_x509_debug
int _x509_s3_x509_valid_issuer(struct x509_certificate __far * cert) {
	if ((cert->extensions_present&(1<<0)) &&
	!cert->ca) {
		_X509_PRINTF((MSG_DEBUG, "X509: Non-CA certificate used as an " \
		 "issuer" ));
		return  -1;
	}

	if (cert->version == X509_CERT_V3 &&
	    !(cert->extensions_present & (1<<0))) {
		_X509_PRINTF((MSG_DEBUG, "X509: v3 CA certificate did not "
			   "include BasicConstraints extension"));
		return -1;
	}

	if ((cert->extensions_present&(1<<2)) &&
	!(cert->key_usage&(1<<5))) {
		_X509_PRINTF((MSG_DEBUG, "X509: Issuer certificate did not have " \
		 "keyCertSign bit in Key Usage" ));
		return  -1;
	}
	return 0;
}

/*** BeginHeader x509_certificate_chain_validate */
// From "x509v3.c":1465
int x509_certificate_chain_validate(struct x509_certificate __far * trusted, struct x509_certificate __far * chain,
                                    int __far * reason, int _yield);
/*** EndHeader */
_x509_debug
int x509_certificate_chain_validate(struct x509_certificate __far * trusted, struct x509_certificate __far * chain,
                                    int __far * reason, int _yield) {
	long unsigned idx; 	// From "x509v3.c":1469
	int chain_trusted /* = 0 */; 	// From "x509v3.c":1469
	struct x509_certificate __far * cert; 	// From "x509v3.c":1470
	struct x509_certificate __far * trust; 	// From "x509v3.c":1470
	char buf[128]; 	// From "x509v3.c":1471
	struct os_time now; 	// From "x509v3.c":1472

	chain_trusted = 0;

	*reason = X509_VALIDATE_OK;
	_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Validate certificate chain" ));
#ifndef X509_NO_RTC_AVAILABLE
	os_get_time(&now);
#endif
	for (cert = chain, idx = 0; cert; cert = cert->next, idx++) {
		x509_name_string(&cert->subject, buf, sizeof (buf));
		_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: %lu: %s" , idx, buf));
		if (chain_trusted)
			continue;
#ifndef X509_NO_RTC_AVAILABLE
		//XXX SJH - can't do this check if no RTC, can we?
		if ((unsigned long)now.sec < (unsigned long)cert->not_before ||
				(unsigned long)now.sec > (unsigned long)cert->not_after) {
			_X509_CHAIN_PRINTF((MSG_INFO, "X509: Certificate not valid " \
			 "(now=%lu not_before=%lu not_after=%lu)" , now.sec, cert->not_before, cert->not_after));
			*reason = X509_VALIDATE_CERTIFICATE_EXPIRED;
			return  -1;
		}
#endif
		if (cert->next) {
			if (x509_name_compare(&cert->issuer, &cert->next->subject)!=0) {
				_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Certificate " \
				 "chain issuer name mismatch" ));
				*reason = X509_VALIDATE_CERTIFICATE_UNKNOWN;
				return  -1;
			}
			if (_x509_s3_x509_valid_issuer(cert->next)<0) {
				*reason = X509_VALIDATE_BAD_CERTIFICATE;
				return  -1;
			}
			if ((cert->next->extensions_present & (1<<1)) &&  // X509_EXT_PATH_LEN_CONSTRAINT
			    idx > cert->next->path_len_constraint) {
				_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: pathLenConstraint"
					   " not met (idx=%lu issuer "
					   "pathLenConstraint=%lu)", idx,
					   cert->next->path_len_constraint));
				*reason = X509_VALIDATE_BAD_CERTIFICATE;
				return -1;
			}
			if (x509_certificate_check_signature(cert->next, cert, _yield)<0) {
				_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Invalid " \
				 "certificate signature within " \
				 "chain" ));
				*reason = X509_VALIDATE_BAD_CERTIFICATE;
				return  -1;
			}
		}
		for (trust = trusted; trust; trust = trust->next) {
			if (x509_name_compare(&cert->issuer, &trust->subject)==0)
				break;
		}
		if (trust) {
			_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Found issuer from the " \
			 "list of trusted certificates" ));
			if (_x509_s3_x509_valid_issuer(trust)<0) {
				*reason = X509_VALIDATE_BAD_CERTIFICATE;
				return  -1;
			}
			if (x509_certificate_check_signature(trust, cert, _yield)<0) {
				_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Invalid " \
				 "certificate signature" ));
				*reason = X509_VALIDATE_BAD_CERTIFICATE;
				return  -1;
			}
			_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Trusted certificate " \
			 "found to complete the chain" ));
			chain_trusted = 1;
		}
	}
	if (!chain_trusted) {
		_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Did not find any of the issuers " \
		 "from the list of trusted certificates" ));
		if (trusted) {
			*reason = X509_VALIDATE_UNKNOWN_CA;
			return  -1;
		}
		_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Certificate chain validation " \
		 "disabled - ignore unknown CA issue" ));
	}
	_X509_CHAIN_PRINTF((MSG_DEBUG, "X509: Certificate chain valid" ));
	return 0;
}

/*** BeginHeader x509_certificate_get_subject */
// From "x509v3.c":1573
struct x509_certificate __far * x509_certificate_get_subject(struct x509_certificate __far * chain,
                                                           struct x509_name __far * name);
/*** EndHeader */
_x509_debug
struct x509_certificate __far * x509_certificate_get_subject(struct x509_certificate __far * chain,
                                                           struct x509_name __far * name) {
	struct x509_certificate __far * cert; 	// From "x509v3.c":1576


	for (cert = chain; cert; cert = cert->next) {
		if (x509_name_compare(&cert->subject, name)==0)
			return cert;
	}
	return ((void  __far * )0);
}

/*** BeginHeader x509_certificate_self_signed */
// From "x509v3.c":1591
int x509_certificate_self_signed(struct x509_certificate __far * cert);
/*** EndHeader */
_x509_debug
int x509_certificate_self_signed(struct x509_certificate __far * cert) {
	return x509_name_compare(&cert->issuer, &cert->subject)==0;
}
// @ TUName[]  ; -- translator directive

/*** BeginHeader x509_test_main */
// From "x509_all.c":390
int x509_test_main(char __far * buf, size_t len);
/*** EndHeader */
_x509_debug
int x509_test_main(char __far * buf, size_t len) {
	struct x509_certificate __far * cert; 	// From "x509_all.c":391


	if (asn1_parse(buf, len, 0)<0)
		_X509_PRINTF((MSG_DEBUG, "Failed to parse DER ASN.1\n" ));
	_X509_PRINTF((MSG_DEBUG, "\n\n" ));
	cert = x509_certificate_parse(buf, len);
	if (!cert)
		_X509_PRINTF((MSG_DEBUG, "Failed to parse X.509 certificate\n" ));
	else
		x509_certificate_free(cert);
	return 0;
}
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader _x509_s4_asn1_class_str */
// From "asn1_test.c":24
char * _x509_s4_asn1_class_str(int class);
/*** EndHeader */
_x509_debug
char * _x509_s4_asn1_class_str(int class) {
	switch ((int)(class)) {
		case ASN1_CLASS_UNIVERSAL:
		return "Universal" ;
		case ASN1_CLASS_APPLICATION:
		return "Application" ;
		case ASN1_CLASS_CONTEXT_SPECIFIC:
		return "Context-specific" ;
		case ASN1_CLASS_PRIVATE:
		return "Private" ;
		default:
		return "?" ;
	}
}

/*** BeginHeader asn1_parse */
// From "asn1_test.c":41
int asn1_parse(char __far * buf, size_t len, int level);
/*** EndHeader */
_x509_debug
int asn1_parse(char __far * buf, size_t len, int level) {
	char __far * pos; 	// From "asn1_test.c":43
	char __far * prev; 	// From "asn1_test.c":43
	char __far * end; 	// From "asn1_test.c":43
	char prefix[10]; 	// From "asn1_test.c":44
	char str[100]; 	// From "asn1_test.c":44
	int _level; 	// From "asn1_test.c":45
	struct asn1_hdr hdr; 	// From "asn1_test.c":46
	struct asn1_oid oid; 	// From "asn1_test.c":47
	char tmp; 	// From "asn1_test.c":48


	_level = level;
	if ((size_t  )_level>sizeof (prefix)-1)
		_level = sizeof (prefix)-1;
	_f_memset(prefix, ' ', _level);
	prefix[_level] = '\0';
	pos = buf;
	end = buf+len;
	while (pos<end) {
		if (asn1_get_next(pos, (_x509_ptrdiff_t)(end-pos), &hdr)<0)
			return  -1;
		prev = pos;
		pos = hdr.payload;
		_X509_PRINTF((MSG_MSGDUMP, "ASN.1:%ls Class %d(%ls) P/C %d(%ls) Tag %u Length %u" ,
                (char  __far * )(prefix), hdr.class, (char  __far * )(_x509_s4_asn1_class_str(
                                                                                          hdr.class)),
                hdr.constructed, (char  __far * )(hdr.constructed ?
		  "Constructed"  :
		  "Primitive" ), hdr.tag, hdr.length));
		if (hdr.class==ASN1_CLASS_CONTEXT_SPECIFIC &&
		hdr.constructed) {
			if (asn1_parse(pos, hdr.length, level+1)<0)
				return  -1;
			pos += hdr.length;
		}
		if (hdr.class!=ASN1_CLASS_UNIVERSAL)
			continue;
		switch ((int)(hdr.tag)) {
			case 0x00:
			if (hdr.length) {
				_X509_PRINTF((MSG_DEBUG, "ASN.1: Non-zero " \
				 "end-of-contents length (%u)" , hdr.length));
				return  -1;
			}
			_X509_PRINTF((MSG_MSGDUMP, "ASN.1:%ls EOC" , (char  __far * )(prefix)));
			break;
			case 0x01:
			if (hdr.length!=1) {
				_X509_PRINTF((MSG_DEBUG, "ASN.1: Unexpected " \
				 "Boolean length (%u)" , hdr.length));
				return  -1;
			}
			tmp = *pos++;
			_X509_PRINTF((MSG_MSGDUMP, "ASN.1:%ls Boolean %ls" , (char  __far * )(prefix),
                 (char  __far * )(tmp ?
			  "TRUE"  :
			  "FALSE" )));
			break;
			case 0x02:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: INTEGER" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x03:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: BitString" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x04:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: OctetString" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x05:
			if (hdr.length) {
				_X509_PRINTF((MSG_DEBUG, "ASN.1: Non-zero Null " \
				 "length (%u)" , hdr.length));
				return  -1;
			}
			_X509_PRINTF((MSG_MSGDUMP, "ASN.1:%ls Null" , (char  __far * )(prefix)));
			break;
			case 0x06:
			if (asn1_get_oid(prev, (_x509_ptrdiff_t)(end-prev), &oid, &prev)<0) {
				_X509_PRINTF((MSG_DEBUG, "ASN.1: Invalid OID" ));
				return  -1;
			}
			asn1_oid_to_str(&oid, str, sizeof (str));
			_X509_PRINTF((MSG_DEBUG, "ASN.1:%ls OID %ls" , (char  __far * )(prefix), (char  __far * )(str)));
			pos += hdr.length;
			break;
			case 0x0D:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: Relative OID" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x10:
			_X509_PRINTF((MSG_MSGDUMP, "ASN.1:%ls SEQUENCE" , (char  __far * )(prefix)));
			if (asn1_parse(pos, hdr.length, level+1)<0)
				return  -1;
			pos += hdr.length;
			break;
			case 0x11:
			_X509_PRINTF((MSG_MSGDUMP, "ASN.1:%ls SET" , (char  __far * )(prefix)));
			if (asn1_parse(pos, hdr.length, level+1)<0)
				return  -1;
			pos += hdr.length;
			break;
			case 0x13:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: PrintableString" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x16:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: IA5String" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x17:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: UTCTIME" , pos, hdr.length));
			pos += hdr.length;
			break;
			case 0x1A:
			_X509_HEXDUMP((MSG_MSGDUMP, "ASN.1: VisibleString" , pos, hdr.length));
			pos += hdr.length;
			break;
			default:
			_X509_PRINTF((MSG_DEBUG, "ASN.1: Unknown tag %d" , hdr.tag));
			//XXX SJH - used to return error, but changed to simply ignore and skip
			pos += hdr.length;
			break;
		}
	}
	return 0;
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader _x509_printf */
// From "x509_all.c":415
void _x509_printf(int level, char *fmt, ...);
/*** EndHeader */
_x509_debug
void _x509_printf(int level, char *fmt, ...) {
	if (level>=__x509_globals._x509_debug_level) {
		va_list args;
		
		va_start(args, fmt);
		vprintf(fmt, args);
		va_end(args);
      printf("\n");
	}
}

/*** BeginHeader _x509_hexdump */
// From "x509_all.c":434
void _x509_hexdump(int level, char __far * title, char __far * buf, size_t len);
/*** EndHeader */
_x509_debug
void _x509_hexdump(int level, char __far * title, char __far * buf, size_t len) {
	if (level<__x509_globals._x509_debug_level)
		return /*void*/;
	printf("X509: === %ls ===\n" , (char  __far * )(title));
	mem_dump(buf, len);
}
/*** BeginHeader */

struct  {
	int _x509_debug_level /* = MSG_MSGDUMP */;	// Hoisted from "x509_all.c":412

} __x509_globals; 	// From "x509_all.c":37
/*** EndHeader */

/*** BeginHeader __x509_initStatics */
// From "x509_all.c":37
void __x509_initStatics();
/*** EndHeader */
_x509_debug
void __x509_initStatics() {
	memset(&__x509_globals, 0, sizeof __x509_globals);
	{
		__x509_globals._x509_debug_level = MSG_MSGDUMP;

	}
}

/*** BeginHeader x509_compare_hostname, x509_validate_hostname */
int x509_compare_hostname(const char __far *cert_name, const char __far *hostname);
int x509_validate_hostname(const struct x509_certificate __far *cert,
	const char __far *hostname);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
x509_compare_hostname							   <X509.LIB>

SYNTAX:  int x509_compare_hostname(const char __far *cert_name,
                                 const char far *hostname);

DESCRIPTION: See if a hostname is covered by a name listed in the certificate
             (either the Subject Common Name (CN) or one of the Subject
             Alternative Names (SANs)).
             
             Helper function for x509_validate_hostname().  See that function
             for additional details.

PARAMETER 1: Subject Common Name or Subject Alternative Name from a certificate.

PARAMETER 2: Hostname to verify

RETURN VALUE: 0: Certificate's hostname is valid for given hostname.
              -EINVAL: NULL passed as one of the two parameters.
              -NETERR_HOST_REFUSED: Certificate is not valid for given hostname.

END DESCRIPTION **********************************************************/

_x509_debug
int x509_compare_hostname(const char __far *cert_name, const char __far *hostname)
{
	const char __far *cn_end, *hostname_end;
   int t;
   
	if (cert_name == NULL || hostname == NULL)
   {
   	return -EINVAL;
   }
   /* Comparison strategy:
      Starting at the ends of the strings, compare all characters until finding
      a mismatch or reaching the start of one or both strings.
   */
   cn_end = _f_strchr(cert_name, '\0') - 1;
   hostname_end = _f_strchr(hostname, '\0') - 1;
      
   _X509_PRINTF((MSG_DEBUG, "X509: compare hostname '%ls' to cert's '%ls'",
   	hostname, cert_name));
   
   while (cn_end >= cert_name && hostname_end >= hostname && *cn_end == *hostname_end)
   {
   	--hostname_end;
      --cn_end;
   }
   
   // cn_end and hostname_end point to characters that do not match, or
   // one or both of them point before the start of the string.
   if (hostname_end < hostname)
   {
   	if (cn_end < cert_name)		// exact match
      {
      	_X509_PRINTF((MSG_DEBUG, "\texact match"));
      	return 0;
      }
      if (_f_memcmp(cert_name, "*.", 2) == 0 && cn_end == &cert_name[1])
      {
      	_X509_PRINTF((MSG_DEBUG, "\tcert *.example.com valid for example.com"));
      	return 0;
      }
      if (_f_memcmp(cert_name, "www.", 4) == 0 && cn_end == &cert_name[3])
      {
      	_X509_PRINTF((MSG_DEBUG, "\tcert www.example.com valid for example.com"));
      	return 0;
      }
   }

   if (cn_end < cert_name)
   {
      if (_f_memcmp(hostname, "www.", 4) == 0 && hostname_end == &hostname[3])
      {
      	_X509_PRINTF((MSG_DEBUG, "\tcert example.com valid for www.example.com"));
      	return 0;
      }
   }
   else if (*cn_end == '*')
   {
   	while (hostname_end >= hostname && *hostname_end != '.')
      {
      	--hostname_end;
      }
      if (hostname_end < hostname)
      {
      	_X509_PRINTF((MSG_DEBUG, "\tcert *.example.com valid for foo.example.com"));
      	return 0;
      }
      // here because *.example.com is NOT valid for foo.bar.example.com
      // fall through to failure case
   }
   
   _X509_PRINTF((MSG_DEBUG, "\tINVALID"));
   return -NETERR_HOST_REFUSED;
}

/* START FUNCTION DESCRIPTION ********************************************
x509_validate_hostname							   <X509.LIB>

SYNTAX:  int x509_validate_hostname(const struct x509_certificate far *cert,
                                 const char far *hostname);

DESCRIPTION: See if a hostname is covered by the Subject Alternative Names
             (SANs) (or the Subject Common Name (CN) if SANs aren't present)
             stored in a certificate.
             
             Handles wildcard matching (*.example.com valid for example.com,
             foo.example.com but not foo.bar.example.com) and securing the
             root domain for the www-hostname (subject name www.example.com
             is valid for hostname example.com and vice versa).

PARAMETER 1: Certificate object

PARAMETER 2: Hostname to verify

RETURN VALUE: 0: Certificate is valid for given hostname.
              -EINVAL: NULL passed as one of the two parameters, or certificate
                       does not have a subject.cn.
              -NETERR_HOST_REFUSED: Certificate is not valid for given hostname.

END DESCRIPTION **********************************************************/
_x509_debug
int x509_validate_hostname(const struct x509_certificate __far *cert,
	const char __far *hostname)
{
	const char __far *alt_name;
   int retval = -NETERR_HOST_REFUSED;
   
	if (cert == NULL) {
   	return -EINVAL;
   }
   
   // Per RFC 6125 the validator must use SAN if present, otherwise it can check CN.
   alt_name = cert->subject_alt_name;
   if (alt_name == NULL) {
   	retval = x509_compare_hostname(cert->subject.cn, hostname);
   } else {
   	// Try all names in subjectAltName.
   	while (retval == -NETERR_HOST_REFUSED && *alt_name) {
   		retval = x509_compare_hostname(alt_name, hostname);
   		alt_name += _f_strlen(alt_name) + 1;  // point to next name
   	}
   }
   
   return retval;
}

/*** BeginHeader _test_x509_compare_hostname */
int _test_x509_compare_hostname(int verbose);
/*** EndHeader */
_x509_debug
int _test_x509_compare_hostname(int verbose)
{
	static const struct {
	   char far *cn;
	   const char far *hostname;
	   int expected_result;
	} __far test_case[] = {
	   { NULL, NULL, -EINVAL },
	   { "example.com", NULL, -EINVAL },
	   { NULL, "example.com", -EINVAL },
	   { "", "", 0 },
	   { "example.com", "example.com", 0 },
	   { "example.com", "", -NETERR_HOST_REFUSED },
	   { "", "example.com", -NETERR_HOST_REFUSED },
	   { "example.com", "example.org", -NETERR_HOST_REFUSED },
	   { "www.example.com", "example.com", 0 },
	   { "example.com", "www.example.com", 0 }, // included for www.google.com hostname
	   { "*.example.com", "example.com", 0 },
	   { "*.example.com", "foo.example.com", 0 },
	   { "*.example.com", "foo.bar.example.com", -NETERR_HOST_REFUSED },
	};
	int TEST_COUNT = (sizeof test_case / sizeof test_case[0]);
	int i, result, failures = 0;

   if (verbose) printf("%s: running %u tests\n", __FUNCTION__, TEST_COUNT);
   
   if (x509_compare_hostname(NULL, "foo") != -EINVAL)
   {
      ++failures;
      if (verbose) printf("FAIL test 0: NULL cert should return -EINVAL\n");
   }
   for (i = 0; i < TEST_COUNT; ++i)
   {
      result = x509_compare_hostname(test_case[i].cn, test_case[i].hostname);
      if (result != test_case[i].expected_result)
      {
      	++failures;
         if (verbose) printf("FAIL test %u: expected %d, got %d\n", i + 1,
         	test_case[i].expected_result, result);
      } 
   }
   
   if (failures)
   {
   	if (verbose)
      	printf("%s: FAILED %u/%u\n", __FUNCTION__, failures, TEST_COUNT);
   	return -1;
   }
   
   if (verbose)
   	printf("%s: PASSED all %u tests\n", __FUNCTION__, TEST_COUNT);
	return 0;
}

/*** BeginHeader */
#endif // _X509_H
/*** EndHeader */

