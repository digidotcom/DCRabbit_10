/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
SSL_DEFS.LIB

DESCRIPTION: Macro and structure definitions for SSL/TLS.

END DESCRIPTION **********************************************************/

/*** BeginHeader _ssl_globals, ssl_ResourcePool */

#ifndef __SSL_DEFS_LIB__
#define __SSL_DEFS_LIB__

#if _RAM_SIZE_ <= 0x20
	#ifndef _ALLOW_TLS_ON_SMALL_RAM_BOARD
	#fatal "The TLS API is not supported on boards with <= 128k RAM"
	#endif
#endif

#ifdef TLS_DEBUG
	// Turn on *all* TLS/SSL-related debugging
	#define HMAC_DEBUG
	#define MPARITH_DEBUG
	#define RSA_DEBUG
	#define SSL_CERT_DEBUG
	#define SSL_TPORT_DEBUG
	#define SSL_V3_DEBUG
	#define TLS_V1_DEBUG
	#define X509_DEBUG
	#define SSL_DEBUG
#endif

#ifdef TLS_VERBOSE
	#ifndef _SSL_PRINTF_DEBUG
		#define _SSL_PRINTF_DEBUG 3
	#endif
#endif

#if (_CPU_ID_ < R3000_R1)
#fatal "SSL is not supported on Rabbit processors before the R3000A " \
       "(R3000 rev. 1)"
#endif

// Standard BCD-coded module version macro - 0x0300 = version 3.01
#define _SSL_VERS 0x0301

// Define macros for appropriate RAND.LIB usage
#define RAND_USE_MD5    // Rehash entropy buffer using MD5 if exhausted
#define NET_ADD_ENTROPY // Use packet timings as entropy source

// Check for ciphers (enable RC4 and RSA, disable AES and PSK by default)

// For TLS 1.2, AES is required and cannot be disabled.
#define _SSL_USE_AES_ 1

// Disable RC4 by default, insecure and may be removed entirely
#ifdef SSL_USE_RC4
   #define _SSL_USE_RC4_ 1
#else
   #define _SSL_USE_RC4_ 0
#endif

// Disable PSK by default
#ifdef SSL_USE_PSK
   #define _SSL_USE_PSK_ 1
#else
   #define _SSL_USE_PSK_ 0
#endif

// Enable RSA by default
#ifndef SSL_DONT_USE_RSA
   #define _SSL_USE_RSA_ 1
#else
   #define _SSL_USE_RSA_ 0
#endif

// Check to see that at least one supported cipher is available
// Actually, now always have NULL encryption...
/*
#if !_SSL_USE_AES_ && !_SSL_USE_RC4_
#error "SSL: No ciphers enabled.  You must enable at least one cipher for SSL."
#error "     Please define SSL_USE_AES or undefine SSL_DONT_USE_RC4."
#fatal "-----------------------------------------------------------------------"
#endif
*/

// Check to see that at least one supported key exchange is available
#if !_SSL_USE_RSA_ && !_SSL_USE_PSK_
#error "SSL: No key exchange enabled.  You must enable at least one KX for SSL."
#error "     Please define SSL_USE_PSK or undefine SSL_DONT_USE_RSA."
#fatal "-----------------------------------------------------------------------"
#endif

// Libraries used by SSL
#ifndef __POOL
	#use "pool.lib"
#endif

#ifndef _TBUF_H
	#use "tbuf.lib"
#endif

#ifndef RAND_H
	#use "RAND.LIB"
#endif

#ifndef __HMAC_LIB__
	#use "hmac.lib"
#endif

#if _SSL_USE_RSA_
	#ifndef __BASE64_LIB__
	   #use "base64.lib"
	#endif
	#ifndef _RSA_H
	   #use "rsa.lib"
	#endif
	#ifndef __SSL_CERT_LIB__
	   #use "ssl_cert.lib"
	#endif
	#ifndef _RSA_X509_H
	   #use "rsa_x509.lib"
	#endif
#endif

// Cipher libraries
#if _SSL_USE_RC4_
	#use "RC4.LIB"
#endif

// Use AES if the user has it and wants to use it
#if _SSL_USE_AES_
	#ifndef __AES_CORE_LIB
		#use AES_CORE.LIB
	#endif
#endif

// Debugging for SSL functions
#ifdef SSL_DEBUG
	#define __SSL_DEBUG__ __debug
   #define _ssl_assert(exp) assert(exp)
#else
	#define __SSL_DEBUG__ __nodebug
   #define _ssl_assert(exp)        // Define to nothing
#endif

// Print debugging information to STDOUT
#ifndef _SSL_PRINTF_DEBUG
#define _SSL_PRINTF_DEBUG 0
#endif

////////////////////////////////////////////////////////////////////////////////
// SSL User-Modifiable Macros
////////////////////////////////////////////////////////////////////////////////

// SSL_CERTIFICATE is the default certificate name, and it is assumed to be
// an ximported .DCC format certificate.  Use of this macro is deprecated.
// Use SSL_new_cert() API with X509 certificates.
// Application code should include a line like the following...
//  #ximport "c:/path/to/cert/mycert.dcc"   SSL_CERTIFICATE
// in which the name SSL_CERTIFICATE is significant in that it defines a
// macro which is used by the library.

#ifndef SSL_MAX_CONNECTIONS
	#ifdef WPA_USE_EAP
		#define SSL_MAX_CONNECTIONS    2
	#else
		#define SSL_MAX_CONNECTIONS    1
	#endif
#endif

#ifndef SSL_NO_SESSION_RENEGOTIATION
#define SSL_NO_SESSION_RENEGOTIATION 0 // Set to 0 to allow session
                                       // resumption; set to 1 to prohibit
                                       // clients from renegotiating a
                                       // connection
#endif

#ifndef SSL_MAX_SESS_RESUMES
#define SSL_MAX_SESS_RESUMES 10 // The maximum number of sessions to save
										  // for reconnects before old copies are
                                // removed from the session resume cache
#endif



#ifndef SSL_WRITE_BUF_SIZE
#define SSL_WRITE_BUF_SIZE 8192   // 8KB is max allowed internal record size
                                  // This is smaller than the 16k allowed
                                  // record size in the SSL spec, but seems
                                  // reasonable.
#endif

#define SSL_OUT_BUF_RESERVE 100	// Do not create new app data record in tls_sm()
											// if less than this amount of space in the
											// output buffer.  This prevents itty-bitty
											// records being created if the transport
											// layer gets backed up on transmit.
// SSL-specific macros
// These maximums are not according to the SSL spec. To conserve memory, these
// instead reflect "normal" message maximums. These can be increased to support
// larger messages, at the expense of memory. (Use in conjunction with the
// workspace size, below)

// Maximum size handshake message (not including certificate messages)
#define SSL_MAX_HANDSHAKE_SIZE		0x200

// Timeout (ms) for handshake progression between successive states
#ifndef SSL_HANDSHAKE_TIMEOUT
	#define SSL_HANDSHAKE_TIMEOUT		12000
#endif

// Ciphersuite priorities, 0 is lowest priority (setting a priority to 0
// means that selecting that suite results in a run-time error)
// Modify these to change selection order of ciphersuites.  Certain
// suites may be permitted or forbidden using tls_set_flags().  By default,
// NULL bulk encryption is not permitted, and RC4 and MD5 are permitted.
// AES and SHA-1 are always permitted (unless AES is not compiled in).
// Among the permitted suites, the order of preference is always selected
// according to these macros...
// !!WATCH OUT! HIT MACRO MAX LENGTH = 32 chars!!
#define TLS_NULL_NULL_NULL_PRI 			  0 // TLS_NULL is used as an error

// NULL bulk encryption priorities...
#define TLS_RSA_NULL_MD5_PRI				1
#define TLS_RSA_NULL_SHA_PRI				2
#define TLS_RSA_NULL_SHA256_PRI			3
#define TLS_PSK_NULL_SHA_PRI				2

// Note that we put the priority of AES above all else if AES is enabled
#define TLS_RSA_AES_128_CBC_SHA_PRI      26
#define TLS_RSA_AES_128_CBC_SHA256_PRI   27
#define TLS_PSK_AES_128_CBC_SHA_PRI      25

#define TLS_RSA_RC4_128_MD5_PRI          13
#define TLS_RSA_RC4_128_SHA_PRI          14
#define TLS_PSK_RC4_128_SHA_PRI          14
/*
#define TLS_RSA_DES_CBC_SHA_PRI          0 // These suites currently unsupported
#define TLS_RSA_3DES_EBE_CBC_SHA_PRI     0
#define TLS_DH_DSS_3DES_EDE_CBC_SHA_PRI  0
#define TLS_DH_anon_3DES_EDE_CBC_SHA_PRI 0
#define TLS_DH_anon_AES_128_CBC_SHA_PRI  0
*/
////////////////////////////////////////////////////////////////////////////////
// End User-modifiable macros
////////////////////////////////////////////////////////////////////////////////

// SSL uses a UNIX 32-bit time stamp (epoch 1970), but the DC RTC has
// an different epoch (1980). This value is the number of seconds in 10
// years, plus the 2 days for leap years in 1972 and 1976
// (60 * 60 * 24 * 365 * 10) + (60 * 60 * 24 * 2)
#define RTC_EPOCH_DIFF 0x12CEA600L

// ********************************************************
// *****                TLS Defaults                  *****
// ********************************************************

// TLS 1.0 is (3,1), 1.1 is (3,2) and 1.2 is (3,3)
#define TLS1_VER_MAJ 3
#define TLS1_VER_MIN 3

// Supported cipher suites.  If adding supported suites, make sure that
// tls_add_ciphersuite() is updated to allow that suite.
#define TLS_NULL_WITH_NULL_NULL 			   0x0000

#define TLS_RSA_WITH_NULL_MD5 				0x0001
#define TLS_RSA_WITH_NULL_SHA 				0x0002
#define TLS_RSA_WITH_NULL_SHA256				0x003B
#define TLS_RSA_WITH_RC4_128_MD5 			0x0004
#define TLS_RSA_WITH_RC4_128_SHA 			0x0005
#define TLS_RSA_WITH_AES_128_CBC_SHA 	   0x002F
#define TLS_RSA_WITH_AES_128_CBC_SHA256   0x003C

#define TLS_PSK_WITH_NULL_SHA					0x002C
#define TLS_PSK_WITH_RC4_128_SHA				0x008A
#define TLS_PSK_WITH_AES_128_CBC_SHA		0x008C

// Currently unsupported cipher suites
#define TLS_RSA_WITH_DES_CBC_SHA 		   0x0009 // DES not supported
#define TLS_RSA_WITH_3DES_EDE_CBC_SHA 	   0x000A // 3DES not currently supported
#define TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA  0x000D // Diffie-Hellman not supported
#define TLS_DH_anon_WITH_3DES_EDE_CBC_SHA 0x001B
#define TLS_DH_anon_WITH_AES_128_CBC_SHA  0x0034

// Bulk cipher algorithms
#define TLS_CIPHER_NULL				0	// NULL (identity) cipher
// #define TLS_CIPHER_3DES_EDE_CBC 	1  // 3DES unsupported
#define TLS_CIPHER_AES_128_CBC 	2  // AES CBC now supported
#define TLS_CIPHER_RC4_128       3

// Key exchange methods
#define TLS_KX_NONE 	    	0
#define TLS_KX_RSA	 		1	// All different RSA key lengths up to (MP_SIZE-2)*8
#define TLS_KX_PSK	 		2	// Pre-shared key (RFC 4279)
// #define TLS_KX_DH_anon 	3	// Diffie-Hellman not supported
// #define TLS_KX_DH 		4

// authentication algorithms
#define TLS_AUTH_NONE 	0
#define TLS_AUTH_RSA 	1
#define TLS_AUTH_PSK 	2
// #define TLS_AUTH_DSS 	3 // DSS not supported

// signature algorithms
#define TLS_SIGN_NONE 	0
#define TLS_SIGN_RSA 	1
#define TLS_SIGN_PSK 	2
// #define TLS_SIGN_DSS 	3 // DSS not supported

// Message digest algorithms
#define TLS_DIGEST_NONE 0
#define TLS_DIGEST_SHA  1
#define TLS_DIGEST_MD5  2
#define TLS_DIGEST_SHA256  3


// ********************************************************
// *****          SSL/TLS limits and types            *****
// ********************************************************

// Message digest sizes
#define SSL_MAX_HASH_SIZE	HMAC_MAX_HASH_SIZE

// These maximums are according to spec to check for errors
#define SSL_MAX_RECORD_SIZE 0x3FFF // Maximum length of a TLS record = 2**14-1

#define SSL_MAX_SESSION_ID       32 // The maximum size for the SSL session ID
#define SSL_MAX_CIPHER_LIST      40 // The maximum entries in a cipher list
#define SESS_ID_SEED_SIZE         6 // The size of the Session ID input seed
#define SSL_SEQ_NUM_SIZE          8 // 64 bits = 8 bytes for sequence number
#define SSL_MAX_CIPHER_BLOCK     20 // Maximum block cipher block size (bytes)
#define SSL_MAX_CIPHER_KEY	  	   32 // Maximum key size (bytes) for bulk ciphers

// PSK data sizes
#define SSL_MAX_PSK_IDENTITY		64	// Maximum PSK identity size, for both
												// the hint from server (in SKE), and the
                                    // actual identity in the CKE message.

// Secret data sizes
#define SSL_MASTER_SEC_SIZE		48 // Size of master secret (RSA-derived)
#define SSL_MAX_PSK					(SSL_MASTER_SEC_SIZE/2-2)
												// Maximum PSK size (octets).  Sized this
                                    // way so it fits in our SSL_Secret data
                                    // structure, same as for RSA.
#define SSL_KEY_BLOCK_SIZE      160 // Maximum size of the key material block
/* Implementation note: The currently defined cipher suite which
   requires the most material is AES_256_CBC_SHA256.  It requires 2 x 32
   byte keys, 2 x 32 byte MAC keys and 2 x 16 initialization vectors,
   for a total 160 bytes of key material.
*/
#define SSL_RANDOM_SIZE          28 // Number of random bytes
#define SSL_MAX_MACSECRET		   SSL_MAX_HASH_SIZE // Maximum size for MAC secrets

#define SSL_EXPLICIT_IV_SIZE     16 // Random bytes inserted before cleartext,
                                    // used an explicit initialization vector in
                                    // block ciphers.

// This is used to define an internal buffer for key derivation
#define SSL_SEEDED_LABEL_MAX (16 + (sizeof(SSL_Random)*2))

// Session ID seed constants
#define SESSION_ID_SEED_1 "\xD9\xC1\xC2\xC2\xC9\xE3"
#define SESSION_ID_SEED_2 "\xC4\xD3\xD9\xD6\xE6\xE9"

// Primitive types
typedef unsigned char SSL_byte_t;	// 8 bits
typedef unsigned int  SSL_uint16_t; // 16 bits (unsigned)
typedef unsigned long SSL_uint32_t; // 32 bits (unsigned)
typedef int				 SSL_int16_t;  // 16 bits (signed)
typedef long			 SSL_int32_t;  // 32 bits (signed)

// State information for the ssl_Socket data structure and
// handshake state machine
typedef enum {
  // TLS/SSL state machine states.  These basically occur in the given order
  // for normal connections, however some are valid only for clients or servers.
  // NOTE: these are explicitly set to powers of 2, since that makes tests for
  // a set of states much more efficient than a sequence of equality tests.
  // NOTE: do not change ordering of these, since code sometimes performs relational
  // tests which assume states proceed in ascending order for normal establishment.
  SSL_STATE_HS_LISTEN        = 0x0001,	// SSL (server) is listening for a ClientHello
  SSL_STATE_SENT_CLI_HELLO   = 0x0002,	// Client sent client hello, waiting for server hello
  SSL_STATE_WAIT_CERT        = 0x0004,	// Client or server waiting for peer certificate
  SSL_STATE_WAIT_SHD         = 0x0008,	// Client waiting for server hello done
  SSL_STATE_WAIT_CCS         = 0x0010,	// Client or server waiting for change cipher spec (CCS)
  SSL_STATE_WAIT_CCS_RESUME  = 0x0020,	// Client or server waiting for CCS when resuming
  SSL_STATE_WAIT_FIN         = 0x0040,	// Client or server waiting for peer finish
  SSL_STATE_WAIT_FIN_RESUME  = 0x0080,	// Client or server waiting for finish when resuming
  SSL_STATE_WAIT_CKE         = 0x0100, // Server waiting for client key exchange
  SSL_STATE_WAIT_CERT_VERIFY = 0x0200,	// Server waiting for client certificate verify
  SSL_STATE_APP_DATA         = 0x0400, // Client or server sending/receiving application data
  SSL_STATE_HALF_CLOSED      = 0x0800, // Logically "half-closed".  This means app can no
  										// longer write to connection.  The actual close
  										// notify alert is sent only when the peer sends
  										// a CN, or app called tls_shutdown with full close.
  SSL_STATE_DRAINING         = 0x1000,	// Close notify draining through transport layer.
  										// This state proceeds to the next when the tport
  										// layer indicates there is no unsent data in
  										// its transmit buffer.
  SSL_STATE_WAIT_CLOSE       = 0x2000, // Waiting for close_notify alert.  Read as "we
  										// sent CN to peer".  This is a timed state.
  SSL_STATE_DONE             = 0x4000, // SSL connection is closed, should not be used
	                           // until reinitialized, however it may be
	                           // reused in client mode in which case the old
	                           // session ID parameters are used.
  SSL_STATE_ERROR            = (int)0x8000  // Some error has occured, stop all processing
} SSL_state_t;

#define SSL_HANDSHAKE_STATES \
            (SSL_STATE_SENT_CLI_HELLO | SSL_STATE_WAIT_CERT | SSL_STATE_WAIT_SHD | \
	          SSL_STATE_WAIT_CCS | SSL_STATE_WAIT_CCS_RESUME | SSL_STATE_WAIT_FIN | \
	          SSL_STATE_WAIT_FIN_RESUME | SSL_STATE_WAIT_CKE | SSL_STATE_WAIT_CERT_VERIFY)

#define SSL_ESTABLISHED_STATES \
            (SSL_STATE_APP_DATA | SSL_STATE_WAIT_CLOSE | \
	          SSL_STATE_HALF_CLOSED | SSL_STATE_DRAINING)

// Event codes for the transport layer event callback
typedef enum {
	TPORT_EVENT_CLOSE_NOTIFY,		// Received close notify alert from peer
	TPORT_EVENT_CLOSE_NOTIFY_TIMEOUT,
											// After sending CN, did not receive CN from
											// peer within specified timeout.  This may be
											// interpreted as a possible truncation attack.
	TPORT_EVENT_FATAL_ALERT,		// Received fatal alert from peer
	// The following APP_* events may actually come via the transport layer itself
	// e.g. the real app calls sock_close, which in turn calls tls_shutdown,
	// which issues one of these events.
	TPORT_EVENT_APP_HALF_CLOSE,	// Application requested half-close
	TPORT_EVENT_APP_FULL_CLOSE,	// Application requested full close
	TPORT_EVENT_APP_ABORT,			// Application requested abort
	TPORT_EVENT_SENT_CLOSE_NOTIFY,// Sent CN to peer
	TPORT_EVENT_SENT_FATAL_ALERT,	// Sent fatal alert
	TPORT_EVENT_ERROR,				// Set error state (may or may not be preceeded by above)
	TPORT_EVENT_HS_COMPLETE,		// Handshake complete, entering APP_DATA state
	TPORT_EVENT_DONE,					// Connection terminated
	TPORT_QUERY_UNSENT,				// Ask tport layer how much unsent data is in
											// its transmit buffer.  This is used when
											// starting the full close timer.  If the
											// tport layer does not know, return 0.
} SSL_event_t;

// Shutdown type codes and flags for tls_shutdown()
typedef enum {
	SHUTDOWN_HALF,		// Half close (prevents further writes, but allows reads).
							// Since the TLS specification effectively forbids true
							// half-close, this flag is interpreted locally as "app
							// has no more data to send".  The actual close notify
							// alert will be deferred until the peer sends its CN,
							// or the app changes to a full shutdown.
	SHUTDOWN_FULL,		// Full close of both read and write.  Sends close notify
							// alert to peer, and sets a timeout for receiving the
							// corresponding CN from the peer.  If the timeout is
							// exceeded (default to 6 seconds) then the connection
							// is purged as follows.  [Note: the transport layer
							// can control the timeout by handling the
							// TPORT_EVENT_SENT_CLOSE_NOTIFY event and calling tls_set_-
							// cn_timeout().  For example, TCP could use a multiple
							// of the current RTT estimate.]
	SHUTDOWN_PURGE,	// Full close and erase all state so that the connection
							// cannot even be resumed.  A close notify is sent, but the
							// state is set back to INIT
	SHUTDOWN_ABORT,	// Application-requested abort.  No close notify alert is
							// sent, however session resume is allowed if applicable.
							// This should be avoided since it leaves the peer thinking
							// there may have been a truncation attack.  Note that the
							// transport is always advised to abort (via the tport
							// callback).  This sends a TPORT_EVENT_APP_ABORT event
							// to the tport handler, which would usually cause the
							// transport to be shut down.
	SHUTDOWN_TPORT_FAIL
							// This is an upcall from the transport layer, and it
							// indicates the transport unexpectedly closed or aborted.
							// Action is similar to SHUTDOWN_ABORT, except no event
							// is sent back to the tport layer.
} SSL_shutdown_type;



// Parameter for MAC generation
typedef enum {
	SSL_MAC_SEND,  		// Generate a MAC to send in a record
	SSL_MAC_RECEIVE   	// Generate a MAC to use to compare to a received MAC
} _ssl_MAC_mode_t;

// Sender state for finished MAC generation
typedef enum {
   SSL_FMAC_CLIENT,		// The sender is a client
   SSL_FMAC_SERVER  		// The sender is a server
} _ssl_MAC_sender_t;


// Record content type enum
typedef enum {
	SSL_REC_change_cipher_spec = 20,
   SSL_REC_alert              = 21,
   SSL_REC_handshake          = 22,
   SSL_REC_application_data   = 23
} SSL_ContentType;

// Handshake message type
typedef enum {
	hello_request 		  = 0,
   client_hello  		  = 1,
   server_hello		  = 2,
   certificate   		  = 11,
   server_key_exchange = 12,
   certificate_request = 13,
   server_hello_done   = 14,
   certificate_verify  = 15,
   client_key_exchange = 16,
   finished            = 20,
   server_request      = 90,
   // length = 255 = 1 byte
} TLS_HandshakeType;
typedef char SSL_Handshake_t;

// Compression method type, currently none exist
typedef enum {
	SSL_CM_null = 0,
   // length = 255 = 1 byte
} SSL_CompressionMethod;

// ********************************************************
// *****      SSL Record Layer Data structures        *****
// ********************************************************

// Protocol version
typedef struct {
	SSL_byte_t major;
   SSL_byte_t minor;
} SSL_ProtocolVersion;

// SSL Record header structure
typedef struct {
	SSL_byte_t          rec_type;// Record type
	SSL_ProtocolVersion version; // Record protocol version
	SSL_uint16_t        length;  // The length of the record (2 bytes)
} SSL_Record_Hdr;

// ********************************************************
// *****        Cross-Version Data structures         *****
// ********************************************************

// Generic header union, used to eliminate copying when working
// with different header versions
typedef union {
   	// Note: The following elements MUST all be the same size,
      // or this will not work.
	   SSL_Record_Hdr v3;   // SSLv3/TLS header
} ssl_Header;  					// Header of current record being read

// ********************************************************
// *****   TLS Handshake Protocol Data structures     *****
// ********************************************************

// Random data structure for Hello messages
typedef struct {
	SSL_uint32_t gmt_unix_time;
   SSL_byte_t   random_bytes[SSL_RANDOM_SIZE];
} SSL_Random;

// PreMasterSecret data structure (the field division being specific to RSA)
typedef struct {
	SSL_ProtocolVersion client_version;		   			// SSL (TLS) version
   SSL_byte_t          random[SSL_MASTER_SEC_SIZE-2]; // The secret
} SSL_PreMasterSecret;

// Identity hint and key identity for PSK.  According to RFC 4279, the
// data may be up to 2**16-1 bytes, however we restrict this to
// about 64 bytes and send alert if exceeded.
typedef struct {
	SSL_uint16_t length;							 	// Length of value in bytes
   SSL_byte_t   data[SSL_MAX_PSK_IDENTITY];	// Identity [hint]
} SSL_PSK_Identity;
typedef struct {
	SSL_uint16_t length;							 	// Length of value in bytes
   SSL_byte_t   data[SSL_MAX_PSK];				// Key (from getPSK callback),
} SSL_PSK;

// Master secret structure
typedef struct {
	SSL_uint16_t length;							 // Length of value in bytes
   SSL_byte_t   data[SSL_MASTER_SEC_SIZE]; // The secret data
} SSL_Secret;

// TLS ExtensionType Values from
// http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml
#define TLS_EXT_SERVER_NAME                                0     // RFC6066
#define TLS_EXT_MAX_FRAGMENT_LENGTH                        1     // RFC6066
#define TLS_EXT_CLIENT_CERTIFICATE_URL                     2     // RFC6066
#define TLS_EXT_TRUSTED_CA_KEYS                            3     // RFC6066
#define TLS_EXT_TRUNCATED_HMAC                             4     // RFC6066
#define TLS_EXT_STATUS_REQUEST                             5     // RFC6066
#define TLS_EXT_USER_MAPPING                               6     // RFC4681
#define TLS_EXT_CLIENT_AUTHZ                               7     // RFC5878
#define TLS_EXT_SERVER_AUTHZ                               8     // RFC5878
#define TLS_EXT_CERT_TYPE                                  9     // RFC6091
#define TLS_EXT_SUPPORTED_GROUPS                           10    // RFC4492
#define TLS_EXT_EC_POINT_FORMATS                           11    // RFC4492
#define TLS_EXT_SRP                                        12    // RFC5054
#define TLS_EXT_SIGNATURE_ALGORITHMS                       13    // RFC5246
#define TLS_EXT_USE_SRTP                                   14    // RFC5764
#define TLS_EXT_HEARTBEAT                                  15    // RFC6520
#define TLS_EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION     16    // RFC7301
#define TLS_EXT_STATUS_REQUEST_V2                          17    // RFC6961
#define TLS_EXT_SIGNED_CERTIFICATE_TIMESTAMP               18    // RFC6962
#define TLS_EXT_CLIENT_CERTIFICATE_TYPE                    19    // RFC7250
#define TLS_EXT_SERVER_CERTIFICATE_TYPE                    20    // RFC7250
#define TLS_EXT_PADDING                                    21    // RFC7685
#define TLS_EXT_ENCRYPT_THEN_MAC                           22    // RFC7366
#define TLS_EXT_EXTENDED_MASTER_SECRET                     23    // RFC7627
// 24-34 unassigned
#define TLS_EXT_SESSION_TICKET                             35    // RFC4507
// 36-65280 unassigned
#define TLS_EXT_RENEGOTIATION_INFO                         65281 // RFC5746
// 65282-65535 unassigned

typedef struct {
	SSL_uint16_t extension_type;            // extension type (see TLS_EXT_*)
   SSL_uint16_t extension_length;          // length of extension data
   const void __far *extension_data;       // location of extension data
} TLS_Extension;

// Client Hello message structure
typedef struct {
  SSL_ProtocolVersion client_version; // SSL (TLS) version
  SSL_Random 	 random;				     // Random data for key
  SSL_byte_t  	 session_id_length;	  // Session ID length
  SSL_byte_t __far *	 session_id;  	  // Session ID pointer (xmem)
  SSL_uint16_t  ciphersuite_length;   // Length(bytes) of ciphersuite offers
  SSL_uint16_t __far *	 cipher_suites;  // Ciphersuite offers (in xmem) - network order
  SSL_byte_t	 compression_length;   // Length of compression method offers
  char __far *	 compression_methods;  // compression method offers (in xmem)
  SSL_uint16_t  extensions_length;    // Length of extensions
} SSL_ClientHello;

// Server hello message
typedef struct {
	SSL_ProtocolVersion 	 server_version;	   // Server SSL (TLS) version
   SSL_Random			    random;				   // Server random
   SSL_byte_t            session_id_length;  // session id length
   SSL_byte_t __far *    	 session_id;         // pointer to session ID data
   SSL_uint16_t	    	 cipher_suite;       // ciphersuite choice
   SSL_CompressionMethod compression_method; // compression method choice
   SSL_uint16_t          extensions_length;    // Length of extensions
} SSL_ServerHello;


// Client Key exchange handshake message
typedef struct {
	union {
		SSL_PreMasterSecret exchange_keys;	// UNencrypted pre master secret (RSA)
      SSL_PSK			    psk;					// Pre-shared key (PSK)
   } by_kx_algo;
} SSL_ClientKeyExchange;

// Server Key exchange handshake message
typedef struct {
	union {
   	// ...Nothing applicable for RSA.
      SSL_PSK_Identity    psk_identity_hint;	// Key identity hint (PSK)
   } by_kx_algo;
} SSL_ServerKeyExchange;

// Handshake message header
typedef struct {
	SSL_Handshake_t msg_type;  // The handshake message type
   SSL_byte_t      length[3]; // Length is an unsigned 24-bit integer
} SSL_Handshake_Hdr_t;

// TLS finished hash structure
typedef sha256_context SSL_Finish_Hash_t;

// ********************************************************
// *****      TLS Configuration Data structures       *****
// ********************************************************

// CipherSuite configuration
typedef struct {
	SSL_uint16_t suite_number;  		// SSL standard ciphersuite number
	char* fulltext_name;      			// Text name of ciphersuite
	SSL_uint16_t key_exchange_alg;   // Key exchange algorithm (ie RSA)
	SSL_uint16_t signature_alg;   	// Signature algorithm (ie RSA)
	SSL_uint16_t authentication_alg; // Authentication algorithm (certificates)
	SSL_uint16_t bulk_cipher_alg;    // The bulk cipher used (DES, RC4)
	SSL_uint16_t digest_alg;         // The MAC digest (MD5, SHA-1)
} SSL_SuiteConfig;

typedef struct {
	SSL_uint16_t key_size;			// Size of the public key being used
#if _SSL_USE_RSA_
	void (*encrypt)(MP_Mod __far * N, MP_Mod __far * expon,
            char __far * data, char __far * output);    // Public key encrypt function
	void (*decrypt)(MP_Mod __far * N, MP_Mod __far * expon,
            char __far * data, char __far * output);    // Public key decrypt function
#endif
} SSL_KeyExchangeConfig;

// NOTE: this is not currently used, since we only support RSA authentication
typedef struct {
	SSL_uint16_t key_size;
	//SSL_uint16_t (*sign)(private_key, message, message_length, signature);
	//SSL_uint16_t (*verify)(public_key, message, message_length, signature);
} SSL_AuthConfig;

// Union of cipher states
typedef union {
#if _SSL_USE_AES_
	AESstreamState aes_state;
#endif
#if _SSL_USE_RC4_
	RC4_state_t rc4_state;  // RC4 stream cipher read state
#endif
	int	dummy;				// Syntactically required if only NULL encryption.
} SSL_BulkCipherState;

// Bulk cipher configuration                       `
typedef struct {
   SSL_BulkCipherState read_state;  // Union of cipher states for reading
   SSL_BulkCipherState write_state; // Union of cipher states for writing
	SSL_uint16_t key_size; 			   // Symmetric cipher has constant key size
	SSL_uint16_t block_size;   		// 0 for stream ciphers
   SSL_byte_t   padding_len; 			// Length of padding for block ciphers
   SSL_byte_t   direction; 			// Cipher direction - this is not actually used
	SSL_byte_t   server_iv[SSL_MAX_CIPHER_BLOCK]; // Initialization Vector
	SSL_byte_t   server_key[SSL_MAX_CIPHER_KEY];	 // The client bulk cipher key
	SSL_byte_t   client_iv[SSL_MAX_CIPHER_BLOCK]; // Initialization Vector
	SSL_byte_t   client_key[SSL_MAX_CIPHER_KEY];	 // The client bulk cipher key
	// Note: all far pointers for following functions
	int (*init)(void __far * state, int direction,
	          char __far * key, int key_length,
             char __far * iv);
	int (*encrypt)(void __far * state, const char __far * message,
            char __far * output, size_t length);
	int (*decrypt)(void __far * state, const char __far * message,
            char __far * output, size_t length);
	// The following fields are only used for block ciphers, and implement
	// a virtual "stream" layer on top of the block cipher.  Since these are
	// shared for encrypt and decrypt functions, it is assumed that full records
	// are processed "atomically" per connection.
   size_t		 partial_block_len;	// Number of bytes in partial block buffer
   _tbuf        partial_tbuf;			// Indicator to where start of incomplete block
   												// will go when completed.  This is a
   												// tbuf since the output area may be
   												// split.
   char			 partial_block[SSL_MAX_CIPHER_BLOCK];
   				 							// buffer for handling blocks split over
   				 								// calls to encrypt/decrypt functions
} SSL_BulkCipherConfig;

// Digest algorithm configuration (TLS uses HMAC as its digest algorithm
typedef struct {
	SSL_uint16_t hash_size; // Size of the output hash
   HMAC_ctx_t   state;		// The HMAC context for this digest
	void (*init)(HMAC_ctx_t __far * ctx, char __far * secret, int s_len,
                           char __far * msg, int m_len);
	void (*add)(HMAC_ctx_t __far * ctx, char __far * msg, int m_len);
	void (*finish)(HMAC_ctx_t __far * ctx, char __far * digest);
} SSL_DigestConfig;

// handles a read or write state, passed into record read/write functions
typedef struct {
   SSL_SuiteConfig __far*       suite;		 // The current ciphersuite
   SSL_KeyExchangeConfig __far* key_exch;    // Key exchange information
   SSL_AuthConfig __far*		   auth;			 // Certificate authentication
	SSL_BulkCipherConfig __far*  bulk_cipher; // The bulk cipher algorithm
	SSL_DigestConfig __far*      digest;		 // MAC digest algorithm
   SSL_Random      server_random;						   // Server random value
   SSL_Random      client_random;                     // Client random value
	SSL_byte_t      server_mac_sec[SSL_MAX_MACSECRET]; // server MAC secret
	SSL_uint16_t	 server_mac_sec_size;					// size of MAC secret
	SSL_byte_t      client_mac_sec[SSL_MAX_MACSECRET]; // The client MAC secret
	SSL_uint16_t	 client_mac_sec_size;					// size of MAC secret
	SSL_byte_t      seq_number[SSL_SEQ_NUM_SIZE];      // Sequence numeber
                                                      // (total = 64 bits)
	SSL_byte_t      rd_seq_number[SSL_SEQ_NUM_SIZE];   // Sequence numeber for
                                                      // reads (total = 64 bits)
} SSL_CipherState;


// Session resumption struct.
// This structure is used to cache the necessary information
// for session resumption. The cache itself is an array of
// these structrues, in which old items are removed in a
// round-robin fashion.  Instances of this are also used by
// the tls_get/set_session() API.
typedef struct {
   SSL_uint16_t suite_number;  	  // SSL standard ciphersuite number
   SSL_Secret   master_secret;     // The master secret used in finished calc
   SSL_byte_t   session_id_length; // session id length
   SSL_byte_t	 session_id[SSL_MAX_SESSION_ID]; // session ID data
} SSL_Session_Resume_t;

#if !SSL_NO_SESSION_RENEGOTIATION
extern __far SSL_Session_Resume_t SSL_session_cache[SSL_MAX_SESS_RESUMES];
#endif



// The "Master" TLS state struct.
// Note that the struct tag name "tls_conection" is for compatibility with the
// wpa_supplicant library.
// The typedef name is, of course, ssl_Socket, which is the normal handle to
// the secure socket used by the application.

typedef struct tls_connection {
	// Important note about first 2 fields: these basically match the layout
	// of tcp_Socket and udp_Socket.  It allows the ip_type field to be used
	// to determine whether the socket is TCP, UDP or SSL.  In the SSL
	// case, the first field points to the underlying TCP socket.  TCP and
	// UDP sockets use this as a linked list of all sockets.
	// NOTE: sock may be null if this is being used in generic transport mode
	// (i.e. using the SSL_TPORT.LIB interface rather than SSL_SOCK.LIB).
	void*        		 sock;		  	// Underlying transport socket (usually a tcp_Socket)
	byte					 ip_type;		// Set to SSL_PROTO if this has an underlying
												// TCP socket for transport.  For other
												// transports, define a different value
												// for this field (e.g. FOO_PROTO).

	// For TCP socket transport, the app_rd and app_wr fields point to the
	// following tbufs.  hs aliases rd (i.e. they use the same data buffer)
	// however the relative sizes of hs and rd are changed depending on
	// state.  Initially, hs has the entire buffer and rd has none, but when
	// APP_DATA state is reached, hs is shrunk to zero and rd uses the full
	// buffer.  This works, because we don't currently allow hs messages during
	// APP_DATA state (such as renegotiation attempts).  Alerts are always
	// processed, since they do not require buffering.
	_tbuf			 rd;				// Current app data read circular buffer
	_tbuf			 wr;				// Current app data write circular buffer
	_tbuf			 hs;				// Current handshake message circular buffer.

   SSL_state_t 	    cur_state; 	// Identifying value for current state
   char               is_psk;			// TRUE if pre-shared key
   char					 is_client;		// True if client
	SSL_CipherState __far*   cipher_state;// Current ciphersuite state
#if _SSL_USE_RSA_
   char					 wait_rsa;		// Non-zero if waiting for RSA operation to
   											// complete, as follows.  Note that only
   											// codes 0, 1 and 2 are currently used,
   											// since other codes are for short RSA
   											// operations which run to completion without
   											// interruption.
#define SSL_WAIT_RSA_NONE	0				// not waiting
#define SSL_WAIT_RSA_PCKE	1				// server processing client key exchange
#define SSL_WAIT_RSA_CCV	2				// client constructing certificate verify
#define SSL_WAIT_RSA_CHAIN	3				// server or client verifying cert chain
#define SSL_WAIT_RSA_PCV	4				// server processing client certificate verify
#define SSL_WAIT_RSA_CCKE	5				// client constructing client key exchange

	word					 	  cert_flags;	// Certificate management flags as follows:
#define SSL_CF_OWN_CERT			0x0001			// cert owned by library
#define SSL_CF_OWN_PEER_CERT	0x0002			// peer_cert owned by library
#define SSL_CF_OWN_TRUST		0x0004			// trusted certs owned by library
   SSL_Cert_t __far*      cert;			// The local certificate (see SSL_CERT.LIB)
   												// This will include private key data.
   SSL_Cert_t __far*      trusted;		// If not null, is a chain of trusted CAs
   												// against which any received certs should be
   												// verified.  These must be in a DER format
   												// (DCC not supported).
   SSL_Cert_t __far*      peer_cert;	// The peer's certificate (may be empty list).
   												// This will contain only public key data.
#endif //_SSL_USE_RSA_
#if _SSL_USE_PSK_
	SSL_PSK_Identity __far * psk_hint;	// Point to identity hint provided
   												// by server (or NULL if not given).
#endif
   SSL_Secret __far*      master_secret;  // The master secret used in finished calc
	SSL_Finish_Hash_t __far* fin_hash; // The hash of all handshake messages sent
												// and received so far.
	struct _ssl_ResourcePool __far* resource_index;
	                                   // Pointer to the resource pool entry
                                		  // (used for freeing resources in
                                		  //  ssl_close) NULL indicates uninitialized
   int					 ssl_errno;		// Most recent error code.  Put here instead
   											// of in a global to maintain re-entrancy.
	int					 TLS_alertno;	// Most recent received alert number
	size_t				 buf_extra;		// Amount of space to free in the app
												// data input buffer.  Set when
												// tls_sm() returns -EAGAIN.
#ifndef TLS_OLDBUF
	size_t				 indata_remain;// Amount of decrypted record data remaining
												// in the transport in buffer.  If non-zero,
												// tls_sm() first drains to the app buffer
												// before continuing with next record.
	size_t				 footer_remain;// If above non-zero, this is additional
												// footer to throw away from tport in buf.
#endif
	word					 flags;			// Flags as follows:
#define SSL_F_REQUESTED_CERT 	0x0001		// Requested certificate from peer
#define SSL_F_REQUIRE_CERT 	0x0002		// Require certificate from peer
#define SSL_F_SEND_CERT 		0x0004		// Peer requested our cert, or we're server with cert specified
#define SSL_F_PEER_CERT_OK		0x0008		// Per cert validated OK (or we had no means to validate).
														// This can also be set initially, in order to pretend all certs
														// are valid.  See tls_set_flags()
#define SSL_F_DISABLE_SSLV3	0x0010		// Set to not accept SSLv3 (always set for clients)
#define SSL_F_NO_RESUME			0x0020		// Set to not accept or attempt session resumption
#define SSL_F_TRIED_RESUME		0x0040		// Set when client hello included old session ID
#define SSL_F_RESUMED			0x0080		// This session was resumed via cached session ID
#define SSL_F_USED_TICKET_KEY	0x0100		// This session was resumed via app-provided ticket key
#define SSL_F_TICKET_KEY		0x0200		// App provided ticket key (pre-master secret)
// 0x0400 unused
#define SSL_F_CLOSE_NOTIFY		0x0800		// Received close notify alert from peer
#define SSL_F_COP_YIELD			0x1000		// Call cop_yield() during long-running calculations
														// This is only meaningful if #use coprocess.lib
#define SSL_F_ENCRYPT			0x4000		// Encrypt outgoing data with current cipher
#define SSL_F_DECRYPT			0x8000		// Decrypt incoming data with current cipher

// Define set of the above flags which may be set by tls_set_flags()
#define SSL_F_OPTIONS			(SSL_F_REQUIRE_CERT|SSL_F_PEER_CERT_OK| \
                               SSL_F_DISABLE_SSLV3|SSL_F_NO_RESUME| \
                               SSL_F_COP_YIELD)	// 0x103A
	word					 tport_flags;	// Flags reserved for use by transport layer.
												// Set/get using tls_set/get_tport_flags().
												// Not otherwise used by TLS/SSL libraries.
	word					 suite_flags;	// Flags which control acceptable cipher suites:
												// Defaults are all zeros.  Following non-default flags
												// must be set by application befor starting the
												// connection (e.g. by specifying on the
												// sock_secure() call.)
	// Dev note: following flag values must not overlap the values in SSL_F_OPTIONS
	// since both sets of flags are combined in the sock_secure() "flags" parameter...
#define SSL_S_ALLOW_NULL		0x0100	// Permit NULL bulk encryption suites.  This
													// allows eavesdropping, but still requires
													// strong authentication and message integrity.
#define SSL_S_FORBID_RC4		0x0200	// Do not permit RC4 stream cipher (force AES)
#define SSL_S_ALLOW_PSK			0x0400	// Allow pre-shared key authentication
#define SSL_S_FORBID_MD5		0x4000	// Do not permit MD5-based hash (force SHA-1)

// Define to all the above flags
#define SSL_S_OPTIONS	(SSL_S_ALLOW_NULL|SSL_S_FORBID_RC4| \
								 SSL_S_FORBID_MD5|SSL_S_ALLOW_PSK)
	SSL_Record_Hdr     hdr;		// Current read record header being processed, in
										// SSLv3/TLS equivalent format.
	SSL_Record_Hdr     wr_hdr;	// Current write record header being generated, in
										// SSLv3/TLS equivalent format.

	int			alerts_sent;	// Counters for fatal alerts sent and received
	int			alerts_recvd;
	char __far *  client_hello_ext;	// Hello extensions (used by wpa_supplicant)
	size_t      client_hello_ext_len;
   SSL_byte_t  session_id_length;  // session id length
   SSL_byte_t  session_id[SSL_MAX_SESSION_ID];  // Session ID data
   SSL_uint16_t n_accept_suites;		// number of acceptable ciphersuites in following
   SSL_uint16_t accept_suites[SSL_MAX_CIPHER_LIST];	// Acceptable suites.  These
   															// are stored in network order.
   unsigned long cn_timeout;	// Any time before sending close notify, this
   									// is set to the number of ms to wait for the
   									// corresponding CN from the peer.  After that,
   									// it becomes the actual timer value.  Set using
   									// tls_set_cn_timeout().  Defaults to 6000ms.
	word	hs_timeout;				// Timeout for handshake state changes in ms.
										// Defaults to 12,000ms.  Helps prevent DOS attacks
										// where peer simply goes away when we are in a
										// state which is waiting for the peer.  TCP
										// keepalives can help with this, but also need
										// a reasonable state change timer.  The value
										// for this timeout is set by a macro
										// SSL_HANDSHAKE_TIMEOUT.
	// If provided, following function tells SSL library when a new record should
	// be created.  This allows a more optimum "Nagle-like" method of deciding
	// when to flush data to the transport layer.  Parameters are:
	//   state - this state (ssl_Socket)
	//   reclen - total size of SSL record data (incl header) which would be
	//     created if a new record was to be created right now.
	// The return value should be zero in order to tell SSL to output a new
	// record to the transport for transmission, or non-zero to tell SSL to
	// defer creation of a new record (if possible).  The non-zero value
	// (if positive) is a hint to TLS as to the optimum size record to
	// create, however there is no guarantee that such a size will be produced.
	// If this function is NULL, SSL always creates new records in tls_sm()
	// if there is at least 1 byte of new data in the app_out buffer.
	// This is not intended to be an application callback.
	int	(*nagle)(struct tls_connection __far * state, size_t reclen);

#if _SSL_USE_RSA_
	// Following function (if not null) allows application to examine certificate
	// fields in order to provide fine control of which peers can connect.
	// This is called if and only if the SSL_F_REQUIRE_CERT flag is set, after a
	// valid certificate is available (for a client cert, we are not sure at this
	// stage whether the client can verify his cert, but if 'trusted' is true
	// we know the cert is at least signed by a trusted authority via cert
	// chaining).  If trusted is false, then no trusted CA list was specified.
	// If there is a trusted CA list, but the certificate could not be validated,
	// then this function will not be called since this always causes an error.
	// Function should return 0 to proceed (allow) or non-zero to disallow.
	// In the latter case, an access_denied alert will be sent to the peer.
	// cert parameter is the peer certificate.  This has several fields (see
	// X509.lib) which indicate the subject and issuer etc.  Most useful field
	// is cert->subject which points to a struct containing ascii representations
	// of the various certificate subject name fields.
	// Function may call x509_name_string() to get a formatted subject name e.g.
	// for messages.
	int		(*policy)(struct tls_connection __far * state,
	                       int trusted,
	                       struct x509_certificate __far * cert,
	                       void __far * data);
	void __far * policy_data;	// Arbitrary data which is provided to policy
									// callback (last parameter).
#endif
	// Following function (if not null) allows the TLS layer to inform the
	// transport layer of various events.  Generally, each transport (such
	// as TCP sockets) will register a callback in order to handle state
	// changes properly, and make it easier for applications to use TLS
	// without worrying too much about the interaction between the layers.
	// This is not intended to be an application callback.  Callback should
	// always return zero for now, except for the TPORT_QUERY_UNSENT "event"
	// (which is really TLS polling the tport layer).
	int		(*tport)(struct tls_connection __far * state, SSL_event_t event,
	                      int event_data);
#if _SSL_USE_PSK_
   // Following function is used to determine the pre-shared key to use,
   // given the identity hint (if a client) or the identity (if server).
   // hint and hint_length are only given if this is a client and the
   // server has provided an identity hint (else they are NULL/0).
   // identity and identity_length specify the identity data and length.
   // For a client, these are output parameters and should be filled in;
   // otherwise for a server they are input parameters.  The maximum
   // identity length is SSL_MAX_PSK_IDENTITY.
   // key points to an area of SSL_MAX_PSK octets, which is to be filled
   // in by this callback, along with *key_length.
   // If this callback is NULL, or it returns non-zero, then PSK cannot be
   // used and will result in an "unknown PSK identity" alert being sent.
   // NOTE: as a server, we do not implement sending an identity hint.
   int		(*getPSK)(struct tls_connection __far * state,
   						const void __far * hint, size_t hint_length,
   						void __far * identity, size_t * identity_length,
                     void __far * key, size_t * key_length);
#endif
} ssl_Socket;

// Define a structure for the resource allocation pool
// Note that none of the members are pointers, since we
// actually want to allocate the space for these
typedef struct _ssl_ResourcePool {
	ssl_Socket __far*		 ssl_sock;		  // SSL Socket of record.  May point to
														// sock_inst field if ssl_new_sock()
														// is used.
	SSL_CipherState 		 cipher;		     // Cipher suite resources
   SSL_SuiteConfig       suite;		     // The current ciphersuite
   SSL_KeyExchangeConfig key_exch;       // Key exchange information
	SSL_BulkCipherConfig  bulk_cipher;    // Bulk cipher resources
	SSL_DigestConfig      digest;         // message digest resources
   SSL_Secret            master_secret;  // The master secret
	SSL_Finish_Hash_t     fin_hash;
#if _SSL_USE_RSA_
   SSL_Cert_t 				 cert;		  	  // Certificate structure (public and private info)
   SSL_Cert_t 				 peer_cert;		  // Peer certificate (public info only)
#endif
#if _SSL_USE_PSK_
	SSL_PSK_Identity      psk_hint;		// Identity hint provided by server.
#endif
	struct _ssl_NResourcePool * nrp;
} ssl_ResourcePool_t;

typedef struct _ssl_NResourcePool {
#if _SSL_USE_RSA_
	#ifndef RSA_DISABLE_CRT
	mp_modexpCRT_state	 modexp_work;	  // Work area for non-blocking RSA.  This needs to be root.
	#else
	mp_modexp_state		 modexp_work;	  // Work area for non-blocking RSA.  This needs to be root.
	#endif
#endif
	ssl_Socket				 sock_inst;		  // SSL socket instance.
} ssl_NResourcePool_t;

// Resource pools for TLS.  "Far" pool is for everything except sockets (ssl and/or TCP).
// Sockets currently need to be root, since there are a lot of changes to libraries required
// to support far sockets.
#define _SSL_RP_ELEMSIZE (sizeof(ssl_ResourcePool_t) + 2*sizeof(long))
#define _SSL_NRP_ELEMSIZE (sizeof(ssl_NResourcePool_t) + 2*sizeof(void *))
extern __far char  ssl_ResourcePool [SSL_MAX_CONNECTIONS * _SSL_RP_ELEMSIZE];
extern     char  ssl_NResourcePool[SSL_MAX_CONNECTIONS * _SSL_NRP_ELEMSIZE];


typedef struct {
	int	done_init;		// True if global initialization done
	int	last_error;		// Last error code if general error
   // Server context.  This is basically constant for SSL.  It controls access
   // to Zserver resources, when we need to obtain a certificate resource.
   // Currently, the app may change it although there is no official API for this.
   // Defaults should be OK.
   const struct ServerContext_t *	context;		// State info for ZSERVER (certificate store etc.)
	Pool_t 			pool;			// Resource pool header
	Pool_t 			npool;		// Near (root) resource pool header
	// The following is an unfortunate necessity until we completely convert
	// TCP/IP to far ptrs.  It allows _ssl_downcast() to work.
	//long				rootable;	// Offset to add to "xmem" pointer to get back to root

} ssl_Globals_t;

extern ssl_Globals_t _ssl_globals;



// Include protocol version-specific libraries
#use "TLSV1.LIB"

// SSL Error handling
#use "SSL_ERROR.LIB"


/*** EndHeader */

ssl_Globals_t _ssl_globals;
// Static pool for allocating resources. The type of this pool is
// a structure containing all the resources that need to be allocated
// internally by TLS
// Move this to far memory when TCP/IP is completely far-ized.
char __far ssl_ResourcePool[SSL_MAX_CONNECTIONS * _SSL_RP_ELEMSIZE];
char     ssl_NResourcePool[SSL_MAX_CONNECTIONS * _SSL_NRP_ELEMSIZE];

/*** BeginHeader _ssl_downcast */
/* START FUNCTION DESCRIPTION ********************************************
_ssl_downcast						<SSL_DEFS.LIB>

SYNTAX: void * _ssl_downcast(void far *);

DESCRIPTION: This is to be used ONLY for converting far ssl_Socket
             pointers to the equivalent root pointer.

             This function will be deprecated in a future release when the
             TCP API supports far pointers throughout.

PARAMETER 1: far SSL socket

RETURN VALUE: Returns equivalent root pointer.  This is only possible
             because ssl_Sockets are actually in root memory, not
             xalloc or malloc memory.

END DESCRIPTION **********************************************************/
void * _ssl_downcast(void __far *);
/*** EndHeader */
// This is an unfortunate necessity until we completely convert TCP/IP to far ptrs.
__nodebug void * _ssl_downcast(void __far * p)
{
	auto long q;
	q = (long)p;
	if ((q & 0xFFFF0000L) == 0xFFFF0000L)
		return (void *)(word)q;
	// failed sanity check
	exit(9999);
}



/*** BeginHeader */
#endif	//__SSL_DEFS_LIB__
/*** EndHeader */

