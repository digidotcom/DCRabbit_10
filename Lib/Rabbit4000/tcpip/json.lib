/* START LIBRARY DESCRIPTION *********************************************
json.lib

Author: Mircea Neacsu
Date:   Aug 18, 2016

DESCRIPTION:
  JSON serialization library

END DESCRIPTION **********************************************************/

/*** BeginHeader */

//JSON data dictionary entry
typedef struct jsonvar_t {
  char *name;           //external name of variable
  void *addr;           //memory address
  char type;            //data type (one of JT_... values)
  char cnt;             //number of elements
} JSONVAR;

// JSON variable types
#define JT_INT    0
#define JT_UINT   1
#define JT_LONG   2
#define JT_ULONG  3
#define JT_STR    4
#define JT_FLT    5

#define JSD_START const JSONVAR json_dict[] ={
#define JSD_END { (char*)0,   (void*)0,           0,        0} }

/* START FUNCTION DESCRIPTION ********************************************
JSD                                                      <json.lib>

SYNTAX:       JSD (variable, count, type)

DESCRIPTION:  This MACRO creates an entry in the JSON data dictionary.
              The JSON name assigned to this variable is the same as the
              variable name.

PARAMETERS:
    variable  the variable that has to be added to to data dictionary

    count     number of elements if the variable is an array or 1 otherwise

    type      type of each variable element. Can be one of:
                  JT_STR    - character string
                  JT_INT    - short (2 bytes) integer
                  JT_UINT   - short (2 bytes) unsigned integer
                  JT_LONG   - long (4 bytes) integer
                  JT_ULONG  - long (4 bytes) unsigned integer
                  JT_FLT    - floating point values

END DESCRIPTION **********************************************************/
#define JSD(V,C,T) {#V, &##V, T, C}


/* START FUNCTION DESCRIPTION ********************************************
JSDN                                                     <json.lib>

SYNTAX:       JSDN (variable, name, count, type)

DESCRIPTION:  This MACRO creates an entry in the JSON data dictionary.

PARAMETERS:
    variable  the variable that has to be added to to data dictionary

    name      JSON name of this variable

    count     number of elements if the variable is an array or 1 otherwise

    type      type of each variable element. Can be one of:
                  JT_STR    - character string
                  JT_INT    - short (2 bytes) integer
                  JT_UINT   - short (2 bytes) unsigned integer
                  JT_LONG   - long (4 bytes) integer
                  JT_ULONG  - long (4 bytes) unsigned integer
                  JT_FLT    - floating point values

END DESCRIPTION **********************************************************/
#define JSDN(V,N,C,T) {#N, &##V, T, C}


#undef DPRINTF
#ifdef JSON_DEBUG
#define DPRINTF(A) printf A
#else
#define DPRINTF(A)
#endif

/*** EndHeader */

/*** BeginHeader json_begin, json_end, jsonify*/
void json_begin (HttpState *state);
int jsonify (HttpState *state, void *addr);
void json_end (HttpState *state);

/*** EndHeader */

// Sizes of data elements (same order as JT_.. values)
const int jsz[] = {sizeof(int), sizeof(unsigned int), sizeof(long), 
  sizeof(unsigned long), sizeof(char*), sizeof(float)};

__far char* const reply_hdr = "HTTP/1.1 200 OK\r\n"     \
                              "Cache-Control: no-cache\r\n"  \
                              "Content-Type: text/plain\r\n" \
                              "Access-Control-Allow-Origin: *\r\n" \
                              "Connection: Keep-Alive\r\n";


/* START FUNCTION DESCRIPTION ************************************************
json_begin                                        <json.lib>

  Description:  Sends reply headers and initializes output pointer to start of
                buffer.

  Syntax:       void json_begin (HttpState *state)

  Parameters:
      state     HTTP state pointer, as provided in the parameter to the CGI
                function.


END DESCRIPTION *************************************************************/
void json_begin (HttpState *state)
{
  http_sock_fastwrite (state, reply_hdr, strlen(reply_hdr));

  *state->buffer = '{';
  state->p = state->buffer+1;
}

/* START FUNCTION DESCRIPTION ************************************************
jsonify                                           <json.lib>

  Description:  Serializes a varaible to JSON format

  Syntax:       int jsonify (HttpState *state, void *var)

  Parameters:
      state     HTTP state pointer, as provided in the parameter to the CGI
                function.
      var       variable to serialize

  Return:       0 if successful
                -1  = variable not found in JSON data dictionary

END DESCRIPTION *************************************************************/
int jsonify (HttpState *state, void *addr)
{
  const JSONVAR *entry;
  int i;
  __far char *p;

  for (entry=json_dict; entry->name && entry->addr != addr; entry++)
    ;

  if (!entry->name)
  {
    DPRINTF (("Missing dictionary entry!!"));
    return -1;   //oops! entry not found
  }
  p = state->p;

  *p++ = '"';
  _f_strcpy (p, entry->name);
  p += strlen(p);
  *p++ = '"';
  *p++ = ':';

  if (entry->cnt > 1)
    *p++ = '[';

  i=0;
  while (i<entry->cnt)
  {
    switch (entry->type)
    {
      case JT_STR:
        sprintf (p, "\"%s\"", (char*)addr);
        break;
      case JT_INT:
        sprintf (p, "%d", *(int*)addr);
        break;
      case JT_UINT:
        sprintf (p, "%u", *(int*)addr);
        break;
      case JT_LONG:
        sprintf (p, "%ld", *(long*)addr);
        break;
      case JT_ULONG:
        sprintf (p, "%lu", *(long*)addr);
        break;
      case JT_FLT:
        sprintf (p, "%g", *(float*)addr);
        break;
    }
    p += strlen(p);
    i++;
    if (i < entry->cnt)
      *p++ = ',';
    (char*)addr += jsz[entry->type];
  }
  if (entry->cnt > 1)
    *p++ = ']';

  *p++ = ',';
  state->p = p;
  return 0;
}

/* START FUNCTION DESCRIPTION ************************************************
json_end                                          <json.lib>

  Description:  Send out the JSON formatted buffer

  Syntax:       void json_end (HttpState *state)

  Parameters:
      state     HTTP state pointer, as provided in the parameter to the CGI
                function.

END DESCRIPTION *************************************************************/
void json_end (HttpState *state)
{
  static char lenbuf[80];
  unsigned int len;

  //replace last comma with closing brace and add <CR><LF>
  _f_strcpy (state->p-1, "}\r\n");

  //figure out content length
  state->p += 2;
  len = (unsigned int)(state->p-state->buffer);
  sprintf (lenbuf, "Content-Length: %u\r\n\r\n", len);
  http_sock_fastwrite (state, lenbuf, strlen(lenbuf));
  http_sock_fastwrite (state, state->buffer, len);
}

/*** BeginHeader readpost*/
int readpost (HttpState *state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ************************************************
readpost                                          <json.lib>
  Function:     readpost

  Description:  Read POST data in HTTP state buffer. Data is read up
                to content length header.

  Syntax:       int readpost (HttpState *state)

  Parameters:
    state       HTTP state

  Return:
    -1:   content-length is greater than the total socket receive buffer size
          (HTTP_MAXBUFFER)

    -2:   the socket is closed or closing, but insufficient data is in the
          buffer to satisfy the request

    -3:   content-length <= 0 or invalid socket

     0:   insufficient data is in the buffer to satisfy the request. Try
          again later since the socket is still able to receive data from the peer

    >0:   content-length

END DESCRIPTION *************************************************************/
int readpost (HttpState *state)
{
  int len;
  if (state->content_length > HTTP_MAXBUFFER - 1)
    return -1;
  else
    len = (int)state->content_length;
  if (len <= 0)
    return -3;

  len = sock_aread (&state->s, state->p, len);
  if (len > 0)
    state->buffer[len] = 0;
  return len;
}

/*** BeginHeader url_post, url_parse*/
int url_post (HttpState *state);
int url_parse (HttpState *state);
unsigned long atoul (char *str);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ************************************************
url_post                                       <json.lib>

  Description:  Read and parse an URL-encoded post response. Keywords in the POST
                response are parsed in variables based on JSON data dictionary.

  Syntax:       int url_post (HttpState *state)

  Parameters:
      state     HTTP state

  Return:
      -1: content-length is greater than the total socket receive buffer
          size (HTTP_MAXBUFFER)

      -2: the socket is closed or closing, but insufficient data
          is in the buffer to satisfy the request

      -3: content-length <= 0 or invalid socket

       0: insufficient data is in the buffer to satisfy the request. Try again
          later since the socket is still able to receive data from the peer

      >0: number of fields parsed

END DESCRIPTION *************************************************************/
int url_post (HttpState *state)
{
  int len;

  if ((len = readpost (state)) <= 0)
    return len;   //wait for more data or die
  return urlparse (state);
}

const JSONVAR* json_find (char *name, int *idx)
{
  static const JSONVAR *entry;
  char *pi;
  if (pi = strchr (name, '_'))
  {
    *pi++ = 0;
    *idx = atoi(pi);
  }
  else
    *idx = 0;

  for (entry = json_dict; entry->name; entry++)
  {
    if (!strcmp (name, entry->name))
    {
      if (*idx < entry->cnt)
        return entry;
      return NULL;
    }
  }
  return NULL;
}

/* START FUNCTION DESCRIPTION ************************************************
url_parse                                         <json.lib>
  Description:  Parse an URL-encoded post response. Keywords in the POST
                response are parsed corresponding variables from JSON dictionary.

  Syntax:       int url_parse (HttpState *state)

  Parameters:
      state     HTTP state

  Return:       number of fields parsed.
END DESCRIPTION *************************************************************/
int url_parse (HttpState *state)
{
  __far char *ptr;
  __far char *pd, *tmp;
  char key[256], val[256];
  const JSONVAR *k;
  int len, nv, idx;
  void *pv;

  nv = 0;
  ptr = state->buffer;
  pd = key;
  *pd = 0;
  len = 0;
  while (*ptr)
  {
    if (*ptr == '=')
    {
      //end of keyword
      *pd = 0;
      k = json_find (key, &idx);
      ptr++;
      if (k)
      {
        //copy value
        pd = val;
        len = 0;
        *pd = 0;
        while (*ptr && *ptr != '&')
        {
          if (++len < sizeof (val) - 1)
            *pd++ = *ptr;
          ptr++;
        }
        *pd = 0;
        if (http_urldecode (val, val, len + 1))
        {
          pv = (char*)(k->addr) + jsz[k->type]*idx;
          DPRINTF (("Setting %s[%d] = %s\n", key, idx, val));
          switch (k->type)
          {
          case JT_STR:
            strcpy ((char *)pv, val);
            break;
          case JT_INT:
            *(int*)pv = (int)_f_strtol (val, &pd, 0);
            break;
          case JT_UINT:
            *(unsigned int*)pv = (unsigned int)atoul (val);
            break;
          case JT_LONG:
            *(long *)pv = _f_strtol (val, &pd, 0);
            break;
          case JT_ULONG:
            *(unsigned long *)pv = atoul (val);
            break;
          case JT_FLT:
            *(float *)pv = atof (val);
            break;
          }
          nv++;
        }
      }
      else
      {
        //keyword not found - advance to next keyword
        while (*ptr && *ptr != '&')
          *ptr++;
      }
      if (!*ptr)
        break;
      ptr++;
      pd = key;
      len = 0;
    }
    else
    {
      //copy keyword
      if (++len < sizeof (key) - 1)
        *pd++ = *ptr;
      ptr++;
    }
  }
  return nv;
}



/*
  Convert from string to unsigned long
*/
unsigned long atoul (char *str)
{
  unsigned long val;
  val = 0;
  while (*str && *str >='0' && *str <= '9')
  {
    val *= 10;
    val += *str++ - '0';
  }
  return val;
}

int dequoute (__far char **pin, char *out, int sz)
{
  __far char *in;
  int i, v;
  char c;
  
  in=*pin;
  
  if (*in++ != '"')
    return 0;
  
  while (sz)
  {
    if (*in == '\')
    {
      in++;
      switch (*in) 
      {
        case '\\':
        case '/':        
        case '"': *out++ = *in; break;
        case 'b': *out++ = '\b'; break;
        case 'f': *out++ = '\f'; break;
        case 'n': *out++ = '\n'; break;
        case 'r': *out++ = '\r'; break;
        case 't': *out++ = '\t'; break;
        case 'u': 
          in++;
          v = 0;
          for (i=0; i<4; i++)
          {
            if (*in && isxdigit (*in))
            {
              c= tolower(*in);
              v = v*16 + (c & 0x0f);
              if (c >= 'a')
                v += 9;
              in++;
            }
            else
              return 0; //invalid unicode escape sequence
          }
          *out++ = v & 0xff;
          
        default:
          return 0; //illegal escape sequence
      }
      sz--;
    }
    else if (*in == '"')
    {
      *pin = ++in;  //update pointer
      return 1;
    }
    else if (!*in)
      return 0;     //end of input
    else
    {
      *out++ = *in++;
      sz--;
    }
  }
  return 0;   //string too long
}

/* START FUNCTION DESCRIPTION ************************************************
json_parse                                         <json.lib>
  Description:  Parse an JSON encoded post response. The buffer is assumed to
                contain only one JSON object whose members are parsed in 
                corresponding variables from JSON dictionary.

  Syntax:       int json_parse (HttpState *state)

  Parameters:
      state     HTTP state

  Return:       number of fields parsed.
END DESCRIPTION *************************************************************/
int json_parse (HttpState *state)
{
  __far char *p;
  int fields, fsm, n;
  char buffer[256];
  char *pb;
  const JSONVAR *entry;
  
  fields = 0;
  
  fsm = 0;
  
  while (*p)
  {
    switch (fsm)
    {
    case 0: //wait for start of object
      if (isspace (*p))
        break;
      if (*p == '{')
        fsm = 1;
      else
        fsm = 88;
      break;
      
    case 1: //wait for start of key
      if (isspace (*p))
        break;
      else if (*p == '"')
        if (dequote (&p, buffer, sizeof(buffer))
        {
          for (entry = json_dict; entry->name && strcmp (buffer, entry->name); entry++)
            ;
          if (entry->name)
            fsm = 2;
          else
          {
            fsm = 88;
            DPRINTF (("JSON key not found: %s\n", key));
          }          
        }
        else
          fsm = 88;
        break;
      
    case 2: //wait for ':' delimiter
      if (isspace (*p))
        break;
      else if (*p == ':')
      {
        fsm = 3;
        pb = buffer;
        n = 0;
      }
      else
        fsm = 88;
      break;
      
    case 3: //accumulate value
      if (isspace (*p))
        break;
      else if (*p == '"' && dequote (&p, buffer, sizeof(buffer))
      {
        if (entry->type == JT_STR)
          strcpy ()
      }
        fsm = 6;
      else if (*p == '[')
        fsm = 7;
      else if (*p == '{')
        fsm = 88; //we don't support emedded objects for the moment
      else
      {
        if (entry->type < JT_STR) //must be one of integer types
        {
          if (isdigit (*p))
          {
            *pb++ = *p;
            n++;
            fsm = 8;
          }
          else if (!strncmp (p, "true", 4))
            iassign (entry, 1);
          else if (!strncmp (p, "false", 5))
            iassign (entry, 0);
          else if (!strncmp (p, "null", 4))
            fsm = 88;   //not supported
          else
            fsm = 88;          
        }
        else
          fsm = 88;
      }
      break;
      
    case 6:   //string value
    case 7:   //array value
    case 8:   //number value
    
    case 88:  //error
    case 99:  //finished
    }
    p++;
  }
  
  //hmm, normal exit is through state 99 of state machine.
  return fields;
}