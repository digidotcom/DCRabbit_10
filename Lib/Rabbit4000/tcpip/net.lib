/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 * net.lib
 *
 *    Portions used with permission of Erick Engelke.
 *
 * General networking API.  This is the "top-level" library
 * for the networking library suite.  It also includes the
 * packet driver interface.
 *
 * Relevant RFCs:
 *
 *   1122, 1123:	Host requirements (Internet standard 0003)
 *
 */

/* START LIBRARY DESCRIPTION *********************************************
NET.LIB

DESCRIPTION:
   This is the top-level library for inclusion of networking code.

	Control Macros
	--------------

	#define USE_ETHERNET      0x01
	#define USE_PPP_SERIAL    0x04
	#define USE_PPPOE         0x01
	#define USE_WIFI          0x01
	#define USE_LOOPBACK      0x01

	  Specify the interface(s) to be supported for TCP/IP networking,
	  and the number of such interfaces.  Define to '0' to disable
	  support for that interface.  Non-zero values are a bitmask
	  which indicates the hardware interface(s) to be used for the
	  specified protocol:

	  USE_ETHERNET can be set to 0x01, 0x02 or 0x03.  Most boards
	  only support 0x01, meaning the "first" ethernet device.  Boards
	  with two ethernet devices can set 0x02 to mean _only_ use the
	  second device, or 0x03 to allow use of both devices for normal
	  networking.

	  USE_PPP_SERIAL can only be set to SERA (0x01), SERB (0x02),
	  SERC (0x04), SERD (0x08), SERE (0x10), SERF (0x20) or a bitwise
	  OR combination of those values.  This maps PPP over serial to
	  one or more of the 6 on-board serial ports.  See ifconfig()
	  documentation for details about setting up serial ports and
	  their flow control pins.

	  USE_PPPOE is set in the same way as USE_ETHERNET.  The bitmask
	  in this case indicates which of the ethernet device(s) are to
	  be used for PPP over Ethernet.

     USE_WIFI is set to either 0 (disabled) or 1 (enabled) for boards
     with a Wi-Fi interface.

     USE_LOOPBACK is either 0 (disabled) or 1 (enabled) for any board.
     The loopback interface is usually accessed via IP address 127.x.y.z
     (or IF_LOOPBACK) and reflects packets back to this device.

	  If none of these macros are defined, then the old behavior is used,
	  which is to include one (and only one) of the link-layer drivers.
	  If any are defined, whether or not to zero, then you should NOT
	  define PKTDRV, PPPOE or MULTI_IF.

	#define VIRTUAL_ETH			0

     Define to a positive number (1-6) to allow additional 'virtual'
     ethernet interfaces to be added dynamically after sock_init.
     Virtual ethernets allow the ethernet interface to pretend to be
     several hosts (each with unique IP address, netmask etc.).  All
     VE's have the same MAC address, however, so DHCP can only be
     used on the 'real' ethernet interface.

     If this is defined non-zero, then USE_ETHERNET must also be
     defined non-zero.

     This macro is intended to allow for official support of multi-
     homing i.e. one Rabbit device pretending to be several host
     IP addresses.  This can be useful for some embedded applications
     and network setups, but is not recommended unless there is
     a very good reason.

     Currently, broadcast packets received on the real ethernet
     interface are not distributed to any of the virtual i/f's.  The
     demultiplexing occurs only at the unicast IP level.

	#define PPPOE

	  If you define PKTDRV to be "ppp.lib", then you can also define this
	  to use PPP over Ethernet.  For other packet drivers, this define has
	  no effect.

	  Do _not_ define this if defining any of the above USE_* macros.

	#define DISABLE_ARP

	  This does not completely disable ARP, since it is essential for
	  ethernet.  ARP is not required for PPP (Point to Point Protocol).
	  If defined, a very simplified ARP will be generated.  This version does
	  not do things like refresh the ARP cache or select the best router.

	  -- Note: this flag not implemented; you always get full ARP.

	#define DISABLE_DNS

	  Do not include Domain Name Server functions.  You will not be able to
	  resolve hostnames; you will only be able to specify dotted decimal
	  IP addresses.  DNS requires UDP, thus if you define DISABLE_UDP, you
	  must also define this macro.

	#define USE_DHCP

	  Include BOOTP/DHCP code.  Allows dynamic configuration of IP addresses
	  etc.  See BOOTP.LIB for details.  DHCP requires UDP, thus if you define
	  this macro you must _not_ define DISABLE_UDP.

	#define USE_SNMP  1

	  Include SNMP code.  See SNMP.LIB for details.  SNMP requires UDP, thus
	  if you define this macro you must _not_ define DISABLE_UDP.

	#define DISABLE_UDP

	  Do not include UDP (User Datagram Protocol) functions.  If this is defined,
	  then you will not be able to use DNS or DHCP.  You will get a compiler
	  warning if there is a conflict with the above macro definitions.

	#define DISABLE_TCP

	  Do not include TCP (Transmission Control Protocol).  If this is defined,
	  then you will not be able to use many of the TCP-based servers and/or
	  clients such as FTP, HTTP, mail etc.  If your application only needs UDP,
	  then you can save quite a lot of code by not including TCP.

   Global Variables
   ----------------


END DESCRIPTION **********************************************************/


/*** BeginHeader */
#ifndef NET_H
#define NET_H

// Set flag for backward compatibility.  This is "advanced networking".
#define NET_ENHANCED

#define DCRTCP
#ifdef SLICING
	#undef SLICING
#endif

#ifdef MCOS
	#define MCOS_LOCKS

   #define NET_COARSELOCK
   #define NET_COMMON_DNS_LOCK
#endif

#ifdef NET_DEBUG
	#define _net_nodebug
#else
	#define _net_nodebug __nodebug
#endif

/*
 *		basic configuration options
 */


#ifndef MY_DOMAIN
	#define MY_DOMAIN			NULL
	#define MY_DOMAINNULL
#endif

/* maximum size of any one domain name to be looked up,
	including any global domain concatenated to the requested domain. */
#ifndef MAX_DOMAIN_LENGTH
	#define MAX_DOMAIN_LENGTH	128
#endif

/*
 *		defines the input and output buffer sizes for a socket
 */

//sockets connected to reserved ports can be closed
//without the 2MSL delay period
#ifndef TCP_FASTSOCKETS
	#define TCP_FASTSOCKETS 1
#endif

/*
 * This determines the size of the TCP buffers.  If not specified,
 * but SOCK_BUF_SIZE is, then TCP_BUF_SIZE takes on the value of
 * SOCK_BUF_SIZE.  It also has further backwards compatibility with
 * tcp_MaxBufSize.
 */
#ifndef TCP_BUF_SIZE
	#ifdef SOCK_BUF_SIZE
		#define TCP_BUF_SIZE SOCK_BUF_SIZE
	#else
		#ifdef tcp_MaxBufSize
			#define TCP_BUF_SIZE (tcp_MaxBufSize * 2)
		#else
			#if RAM_SIZE < 32		// less than 256k
				#define TCP_BUF_SIZE 2048
			#else
				#define TCP_BUF_SIZE 4096
			#endif
		#endif
	#endif
#endif

/*
 * Determines the maximum number of TCP sockets with preallocated
 * buffers.  If MAX_SOCKETS is defined instead, then
 * MAX_TCP_SOCKET_BUFFERS will take the value of MAX_SOCKETS for
 * backwards compatibility.
 */
#ifndef MAX_TCP_SOCKET_BUFFERS
	#ifdef MAX_SOCKETS
		#define MAX_TCP_SOCKET_BUFFERS MAX_SOCKETS
	#else
		#if RAM_SIZE < 32		// less than 256k
			#define MAX_TCP_SOCKET_BUFFERS 2
		#else
			#define MAX_TCP_SOCKET_BUFFERS 4
		#endif
	#endif
#endif

/*
 * This determines the size of the UDP buffers.  If not specified,
 * but SOCK_BUF_SIZE is, then UDP_BUF_SIZE takes on the value of
 * SOCK_BUF_SIZE.  It also has further backwards compatibility with
 * tcp_MaxBufSize.
 */
#ifndef UDP_BUF_SIZE
	#ifdef SOCK_BUF_SIZE
		#define UDP_BUF_SIZE SOCK_BUF_SIZE
	#else
		#ifdef tcp_MaxBufSize
			#define UDP_BUF_SIZE (tcp_MaxBufSize * 2)
		#else
			#if RAM_SIZE < 32		// less than 256k
				#define UDP_BUF_SIZE 2048
			#else
				#define UDP_BUF_SIZE 4096
			#endif
		#endif
	#endif
#endif

/*
 * Determines the maximum number of UDP sockets with preallocated
 * buffers.  Defaults to NO UDP buffers.  DHCP and/or SNMP allocate
 * and manage their own buffers, so they need not be considered
 * in this setting.
 */
#ifndef MAX_UDP_SOCKET_BUFFERS
	#define MAX_UDP_SOCKET_BUFFERS 0
#endif

/*
 * Determines the number of socket locks that are allocated.  For
 * uCOS/II, this effectively limits the number of sockets that can
 * be allocated.
 */
#ifndef MAX_SOCKET_LOCKS
	#define MAX_SOCKET_LOCKS (MAX_TCP_SOCKET_BUFFERS + MAX_UDP_SOCKET_BUFFERS)
#endif

#ifdef DISABLE_DNS
	#define ACTUAL_SOCKET_LOCKS	MAX_SOCKET_LOCKS
#else
	#define ACTUAL_SOCKET_LOCKS	(MAX_SOCKET_LOCKS+1)
#endif

#ifndef ETH_MTU
	#if WIFI_ONBOARD && R5000 == CPU_ID_MASK(_CPU_ID_)
		#define ETH_MTU 1489		// less 11 bytes for padding 5.5, 11 Mbps (_WIFI_SILKEN_DAC)
	#else
		#define ETH_MTU 1500		// MTU for Ethernet and WIFI (PPPoE will use this minus 8)
	#endif
#endif
#ifndef PPP_MTU
   #define PPP_MTU ETH_MTU		// MTU for serial PPP, default to same as ethernet
#endif

#if ETH_MTU > PPP_MTU
	#define MAX_MTU	ETH_MTU
	#define MIN_MTU	PPP_MTU
#else
	#define MAX_MTU	PPP_MTU
	#define MIN_MTU	ETH_MTU
#endif

/* This symbol specifies the total number of incoming and outgoing packets for
 all interfaces (not just ethernet, as the name implies).  These buffers
 are currently xalloc'd, and each buffer is typically about 1600 bytes.
 WifiG needs more to operate effectively. */
#ifndef ETH_MAXBUFS
	#if RAM_SIZE < 64		// Small board, less than 256K RAM, so economize
	   #ifdef USE_WIFI
	   	// No wifi board known with small memory, but just in case...
	      #define ETH_MAXBUFS       6
	   #else
	      #define ETH_MAXBUFS       4
	   #endif
	#else
	   #ifdef USE_WIFI
	      #define ETH_MAXBUFS       32
	   #else
	   	#define ETH_MAXBUFS       10
	   #endif
	#endif
#endif


// Set up some defines for dealing with the automagic macros dealing with
// Ethernet that come from the system ID block.  These separate out the
// compile-time and run-time portions, and indicate if the given interface
// has multiple possible chipsets that must be resolved at run-time.
#define _DC_ETH_COMPILETIME_MASK		0x0000ffff
#define _DC_ETH_RUNTIME_MASK			0xf8000000
#define _DC_ETH_MULTI					0x00001000


#ifdef NET_ADD_ENTROPY
	// Use packet arrival times to help seed random number generators (see RAND.LIB)
	#ifndef RAND_H
		#use "rand.lib"
	#endif
#endif

/* If user defines VIRTUAL_ETH to a positive value, then he can create additional
 ethernet interfaces on the fly.  The additional interfaces use the IF_ETH hardware,
 but allow a different home address and netmask.  This is how "multi-homing" is
 now officially supported.  VIRTUAL_ETH is only supported if at least one broadcast
 ethernet interface is selected (USE_ETHERNET > 0).  The virtual interface numbers
 get tacked on after the PPP's (if any).  A maximum of 16 total i/f's is
 supported. */
#ifndef VIRTUAL_ETH
	#define VIRTUAL_ETH		0
#endif


#ifndef USE_ETHERNET
	#define USE_ETHERNET 0
#endif

#ifndef USE_PPP_SERIAL
	#define USE_PPP_SERIAL 0
#endif

#ifndef USE_VSPD
	#define USE_VSPD 0
#endif

#ifndef USE_PPPOE
	#define USE_PPPOE 0
#endif

#ifndef USE_WIFI
   #define USE_WIFI 0
#endif

#ifndef USE_LOOPBACK
	#define USE_LOOPBACK 0
#endif

// If USE_PPPOE, then ensure USE_ETHERNET equal to it
#if USE_PPPOE
	#if (USE_PPPOE & USE_ETHERNET) != USE_PPPOE
   	#warns "If you define USE_PPPOE, then define USE_ETHERNET to be at least the same."
      #warns "...redefining USE_ETHERNET = USE_PPPOE, which may not be what you want."
      #undef USE_ETHERNET
      #define USE_ETHERNET USE_PPPOE
   #endif
#endif



#if USE_PPP_SERIAL & ~0x3FL
   #fatal "USE_PPP_SERIAL: invalid; use combination of 0x01,0x02,0x04,0x08,0x10,0x20 (SERA-F)"
#endif
// Maximum simultaneous PPP serial interfaces
#define MAX_PPP_SERIAL  6

#if USE_ETHERNET & ~0x3L
	#fatal "USE_ETHERNET: invalid ethernet device specified"
#endif

#if VIRTUAL_ETH && !USE_ETHERNET
	#fatal "If VIRTUAL_ETH non-zero, then must also define USE_ETHERNET non-zero"
#endif

#if USE_PPPOE & ~0x3L
	#fatal "USE_PPPOE: invalid PPPoE device specified"
#endif

#if USE_WIFI & ~0x3L
   #fatal "USE_WIFI: invalid WiFi device specified"
#endif

#if USE_LOOPBACK & ~0x1L
   #fatal "USE_LOOPBACK: invalid loopback device specified"
#endif

// This is rather ugly, but I can't think of a neater way to get the preprocessor to
// count the number of '1' bits in a constant.
#define USING_PPP_SERIAL	((USE_PPP_SERIAL & 1) + \
								 (USE_PPP_SERIAL>>1 & 1) + \
								 (USE_PPP_SERIAL>>2 & 1) + \
								 (USE_PPP_SERIAL>>3 & 1) + \
								 (USE_PPP_SERIAL>>4 & 1) + \
								 (USE_PPP_SERIAL>>5 & 1))

/* Virtual serial packet driver.  This allows an ordinary serial port to look
 like a TCP stream.  It uses the PPPLINK driver, but without PPP.  The PPPLINK
 instance operates in raw mode only.  Incoming packets have the INBAND flag set,
 which causes pkt_received() to pass them to the interface's ioctl(..PD_INBAND..)
 handler.  The vspd_ioctl() passes these packets to a special TCP handler,
 tcp_stream_handler(). To the application, this looks just like a real TCP
 socket.  Other protocols (including UDP) are not currently supported. */
#define USING_VSPD		((USE_VSPD & 1) + \
								 (USE_VSPD>>1 & 1) + \
								 (USE_VSPD>>2 & 1) + \
								 (USE_VSPD>>3 & 1) + \
								 (USE_VSPD>>4 & 1) + \
								 (USE_VSPD>>5 & 1))

#define USING_PPPLINK (USING_PPP_SERIAL + USING_VSPD)

#define VSPD_LOCALHOST	0x7F000001		// localhost IP address for VSPD
													// interfaces (127.0.0.1)

#if USE_VSPD & USE_PPP_SERIAL
	#error "You cannot use the same serial port for PPP and VSPD."
   #fatal "Check your definitions of USE_PPP_SERIAL and USE_VSPD to make sure no bits overlap."
#endif

#define USING_PPPOE ((USE_PPPOE & 1) + (USE_PPPOE>>1 & 1))

// These are defined by pktdrv.lib, based on actual hardware available
#define USING_ETHERNET ((USE_ETHERNET & 1) + (USE_ETHERNET>>1 & 1))
#define USING_LOOPBACK	USE_LOOPBACK
#define USING_WIFI ((USE_WIFI & 1) + (USE_WIFI>>1 & 1))
// Work out any board-specific things.  This also may redefin "USING_ETHERNET"
// based on actual number of ethernets installed.
#use "BOARD_DEPS.LIB"

#if USING_LOOPBACK
	// Slot the loopback iface in the 2nd ethernet slot.  This means we can't use
   // loopback with two Ethernets, but since no hardware supports 2 eths, then it
   // saves having to expand the interface table.
   #if USING_ETHERNET > 1
   	#fatal "Cannot use two Ethernet interfaces with loopback"
   #endif
#endif

#define PPP_OVERHEAD		6		// HDLC address, control, check fields, plus PPP
										//		protocol.
#define ETH_OVERHEAD		24		// Ethernet header (14 bytes plus 4 byte CRC), plus 6 for DMAETH100
#define PPPOE_OVERHEAD	32		// Ethernet, plus PPPoE header (6) plus PPP
										//		protocol (2)
#if CPU_ID_MASK(_CPU_ID_) == R5000
	#define WIFI_OVERHEAD	86		// sizeof(WiFiMacBuffer) plus SNAP header plus 10 extra
										// for SILKEN_DAC
#else
	#define WIFI_OVERHEAD	76
#endif

#define MAX_OVERHEAD		WIFI_OVERHEAD
#define NET_BUFSIZE		(MAX_MTU+MAX_OVERHEAD)


// MULTI_IF is a bitmask of interfaces required.
#if USE_ETHERNET || USE_PPP_SERIAL || USE_PPPOE || USE_VSPD || USE_WIFI || USE_LOOPBACK
	#define MULTI_IF  (USE_ETHERNET | USE_WIFI << 2 | USE_PPPOE << 4 | USE_PPP_SERIAL << 6 | \
				USE_VSPD << 6 | USE_LOOPBACK << 1)
	#if !VIRTUAL_ETH && (MULTI_IF & -MULTI_IF) == MULTI_IF
		// Go back to old-style definition if only zero or one interface after all
		#undef MULTI_IF
	#endif
#endif

#ifdef MULTI_IF
	#ifdef PKTDRV
		#undef PKTDRV
	#endif
#endif

// Determine if not using any broadcast media (Ethernet or WiFi).  If so, can
// cut out a lot of ARP code.
#ifdef MULTI_IF
	#if !(MULTI_IF & (0x0F & ~(USE_LOOPBACK<<1)))
		#define ARP_MINIMAL
	#endif
#else
	#ifdef USING_PPP
		#define ARP_MINIMAL
   #elif USING_LOOPBACK
		#define ARP_MINIMAL
	#endif
#endif


// Define buffer size (not including ll_prefix overhead).
// Definitions select in order of decreasing overhead size.
#if USING_WIFI
	#define ETH_BUFSIZE (MAX_MTU + WIFI_OVERHEAD)
#else
#if USING_PPPOE
	#define ETH_BUFSIZE (MAX_MTU + PPPOE_OVERHEAD)
#else
	#ifndef ARP_MINIMAL		// if not defined, assume using ethernet
		#define ETH_BUFSIZE (MAX_MTU + ETH_OVERHEAD)
	#else
		#define ETH_BUFSIZE (MAX_MTU + PPP_OVERHEAD)
	#endif
#endif
#endif

// Set IF_PPPX to be the first PPP interface defined (in order PPPOE0,1
//	then SERA, B, ... F)
#if USE_PPPOE & 0x01
	#define IF_PPPX	IF_PPPOE0
#elif USE_PPPOE & 0x02
	#define IF_PPPX	IF_PPPOE1
#elif USE_PPP_SERIAL & 0x01
	#define IF_PPPX	IF_PPP0
#elif USE_PPP_SERIAL & 0x02
	#define IF_PPPX	IF_PPP1
#elif USE_PPP_SERIAL & 0x04
	#define IF_PPPX	IF_PPP2
#elif USE_PPP_SERIAL & 0x08
	#define IF_PPPX	IF_PPP3
#elif USE_PPP_SERIAL & 0x10
	#define IF_PPPX	IF_PPP4
#elif USE_PPP_SERIAL & 0x20
	#define IF_PPPX	IF_PPP5
#endif

// Determine whether the ppp driver is needed
#if USE_PPPOE||USE_PPP_SERIAL
	#ifndef PPP_PKTDRV_LIB
   	#define PPP_PKTDRV_LIB	"ppp.lib"
   #endif
#endif

// Needed for all interfaces.  This library provides basic packet buffering services,
// plus it includes the necessary packet driver(s) based on board type.
#use "pktdrv.lib"

#define IF_CHKSUM_OFFLOAD(i)	0

#ifndef MULTI_IF
	// No multiple interface support.  Old-style compatibility.
	#define IF_MAX			1
	#define IF_DEFAULT	0
	#define IF_ETH_MAX	1
   #if USING_ETHERNET || USING_PPPOE || USING_PPP_SERIAL || USING_VSPD || USING_WIFI || \
   		USING_LOOPBACK
		#define IF_SET			0x0001		// Bitmask of valid interfaces
   #else
   	#define IF_SET			0
      #warns "#use dcrtcp.lib, but no interfaces defined.  Define one or more "
      #warns "of USE_ETHERNET, USE_WIFI, USE_PPP_SERIAL, USE_PPPOE or USE_VSPD."
   #endif
	#if USING_ETHERNET
		#if USING_PPPOE
			#define IF_PPPOE0			0
			#define IF_USES_ETH(i)	0
			#define IF_PKT_ETH(i)	1
         #define IF_PKT_REAL_WIFI(i)	0 //Real WiFi Interface
			#define IF_PKT_SER(i)	0
			#define IF_P2P(i)			1
			#define IF_BCAST_CAPABLE(i)	0
			#define IF_MCAST_CAPABLE(i)	0
		#else
			#define IF_ETH0			0
			#define IF_USES_ETH(i)	1
			#define IF_PKT_ETH(i)	1
         #define IF_PKT_REAL_WIFI(i)	0
			#define IF_PKT_SER(i)	0
			#define IF_P2P(i)			0
			#define IF_BCAST_CAPABLE(i)	1
			#define IF_MCAST_CAPABLE(i)	1
		#endif
   #elif USING_WIFI
			#define IF_WIFI0			0
			#define IF_USES_ETH(i)	1
			#define IF_PKT_ETH(i)	1
         #define IF_PKT_REAL_WIFI(i)	1
			#define IF_PKT_SER(i)	0
			#define IF_P2P(i)			0
			#define IF_BCAST_CAPABLE(i)	1
			#define IF_MCAST_CAPABLE(i)	1
   #elif USING_LOOPBACK
			#define IF_LOOPBACK		0
			#define IF_USES_ETH(i)	0
			#define IF_PKT_ETH(i)	0
         #define IF_PKT_REAL_WIFI(i)	0
			#define IF_PKT_SER(i)	0
			#define IF_P2P(i)			0
			#define IF_BCAST_CAPABLE(i)	0
			#define IF_MCAST_CAPABLE(i)	0
         #undef IF_CHKSUM_OFFLOAD
			#define IF_CHKSUM_OFFLOAD(i)	1
	#else
   	// Note: since PPP over serial and VSPD are not allowed to use the same
      // serial port, we just use the IF_PPPn interface name for either type.
		#if USE_PPP_SERIAL & 0x01 || USE_VSPD & 0x01
			#define IF_PPP0			0	// PPP over serial port A
		#elif USE_PPP_SERIAL & 0x02 || USE_VSPD & 0x02
			#define IF_PPP1			0	// PPP over serial port B etc.
		#elif USE_PPP_SERIAL & 0x04 || USE_VSPD & 0x04
			#define IF_PPP2			0
		#elif USE_PPP_SERIAL & 0x08 || USE_VSPD & 0x08
			#define IF_PPP3			0
		#elif USE_PPP_SERIAL & 0x10 || USE_VSPD & 0x10
			#define IF_PPP4			0
		#elif USE_PPP_SERIAL & 0x20 || USE_VSPD & 0x20
			#define IF_PPP5			0
		#endif
		#define IF_USES_ETH(i)	0
		#define IF_PKT_ETH(i)	0
      #define IF_PKT_REAL_WIFI(i)	0
		#define IF_PKT_SER(i)	1
      #if USE_PPP_SERIAL
			#define IF_P2P(i)			1
      #else
      	#define IF_P2P(i)			0
      #endif
		#define IF_BCAST_CAPABLE(i)	0
		#define IF_MCAST_CAPABLE(i)	0
	#endif
	#if USING_ETHERNET > 1
		#undef USING_ETHERNET
		#define USING_ETHERNET 1
	#elif USING_WIFI > 1
		#undef USING_WIFI
		#define USING_WIFI 1
	#endif
#else
	// Support multiple interfaces.
	#if (USING_ETHERNET || USING_WIFI || USING_LOOPBACK)
		#define IF_ETH0	0		// Ethernet NIC 0
		#define IF_ETH1	1		// Ethernet NIC 1 (only if dual port board)
      #define IF_LOOPBACK 1	// Loopback uses same slot as 2nd ethernet
      #define IF_WIFI0	2
      #define IF_WIFI1	3
		#define IF_PPPOE0	4		// PPP over ethernet (using NIC 0)
		#define IF_PPPOE1	5		// PPP over ethernet (using NIC 1)
		#define IF_PPP0	6		// PPP over serial
		#define IF_PPP1	7
		#define IF_PPP2	8
		#define IF_PPP3	9
      #define IF_PPP4   10
      #define IF_PPP5   11
      #define IF_MAX    12    // Maximum number of interfaces
		#define IF_ETH_MAX  (USING_ETHERNET+USING_WIFI) // Maximum (pseudo-)ethernet NICs (1..4)
      #if VIRTUAL_ETH
      	// Note that IF_MAX denotes the end of the real interfaces.  The virtual ones follow.
	      // Test if interface uses ethernet NIC (we don't count PPPoE, even though it uses ethernet)
	      #define IF_USES_ETH(i) ((word)(i) < USING_WIFI || (word)i >= IF_MAX)
	      #define IF_PKT_ETH(i) ((word)(i) < IF_PPP0 || (word)i >= IF_MAX)
	      #define IF_PKT_SER(i) ((word)(i) >= IF_PPP0 && (word)i < IF_MAX)
	      // Test if i/f is a point-to-point link
	      #define IF_P2P(i) ((i) >= IF_PPPOE0 && (word)i < IF_MAX)
      #else
	      // Test if interface uses ethernet NIC (we don't count PPPoE, even though it uses ethernet)
	      #define IF_USES_ETH(i) ((word)(i) < USING_WIFI)
	      #define IF_PKT_ETH(i) ((word)(i) < IF_PPP0)
	      // Test if i/f is a point-to-point link
	      #define IF_P2P(i) (1u<<(i) & (USE_PPP_SERIAL<<IF_PPP0|USE_PPPOE<<IF_PPPOE0))
	      // Test if i/f uses an async serial physical layer
	      #define IF_PKT_SER(i) (1u<<(i) & (USE_PPP_SERIAL<<IF_PPP0|USE_VSPD<<IF_PPP0))
      #endif
      #define IF_PKT_REAL_WIFI(i) (USING_WIFI&&((word)(i) == IF_WIFI0 || \
      													(word)(i) == IF_WIFI1))
		#define IF_SET		MULTI_IF	// Bitmask of valid interfaces
      #define IF_BCAST_CAPABLE(i)	pd_bcast_capable(i)
      #define IF_MCAST_CAPABLE(i)	pd_mcast_capable(i)
	#else
		#define IF_PPP0	0		// PPP over serial
		#define IF_PPP1	1
		#define IF_PPP2	2
		#define IF_PPP3	3
      #define IF_PPP4   4
      #define IF_PPP5   5
      #define IF_MAX    6     // Maximum number of interfaces
		#define IF_ETH_MAX 1		// Max ethernet i/f.  This is 1 (not 0) to avoid
										// code complications, however the table entry is
										// not used.
		#define IF_USES_ETH(i) 0
		#define IF_PKT_ETH(i) 0
      #define IF_PKT_REAL_WIFI(i) 0
		#define IF_PKT_SER(i) 1

      #define IF_P2P(i) (1u<<(i) & USE_PPP_SERIAL)
      #define IF_BCAST_CAPABLE(i)   0
      #define IF_MCAST_CAPABLE(i)   0
		#define IF_SET		(MULTI_IF>>6)	// Bitmask of valid interfaces
	#endif
   #if USING_LOOPBACK
      #undef IF_CHKSUM_OFFLOAD
      #define IF_CHKSUM_OFFLOAD(i)  (i==IF_LOOPBACK)
   #endif
#endif
#define IF_ANY		0xFF	// Any interface
#ifdef IF_WIFI1
	#define IF_IS_WIFI(i)	((i==IF_WIFI0)||(i==IF_WIFI1))
#else
	#ifdef IF_WIFI0
		#define IF_IS_WIFI(i)	(i==IF_WIFI0)
	#else
		#define IF_IS_WIFI(i)	0
	#endif
#endif

// Default primary network interface and hardware type code
#define IF_DEFAULT_IS_P2P	0
#ifndef IF_DEFAULT
	#ifdef USING_PPP
		#undef IF_DEFAULT_IS_P2P
		#define IF_DEFAULT_IS_P2P	1
		#define IF_DEFAULT			IF_PPPX
	#elif USING_ETHERNET
		#if USE_ETHERNET == 0x02
			#define IF_DEFAULT		IF_ETH1
		#else
			#define IF_DEFAULT		IF_ETH0
		#endif
   #elif USING_WIFI
		#if USE_WIFI == 0x02
			#define IF_DEFAULT		IF_WIFI1
		#else
			#define IF_DEFAULT		IF_WIFI0
		#endif
   #else
   	#define IF_DEFAULT	IF_LOOPBACK
	#endif
#endif


// Include loopback library if required
#if USING_LOOPBACK
	#use "loopback.lib"
#endif


/*
 * Macros for working with IP addresses.  Some of these macros expand to function
 * calls in order to reduce code size.  The macro expansions depend on MULTI_IF.
 * If no multiple interface support, code size is reduced.  The macros which take
 * an 'iface' parameter check for the specific interface, otherwise they test for
 * a match on any interface.
 *
 * The IS_* macros return a boolean indication of whether the given IP address
 * has a given property.
 *
 * The MY_* macros return IP addresses relevant to this host.
 *
 * Note that we do not really distinguish between "network" and "subnet" i.e. we
 * do not encode knowledge of the class A,B,C,D,E network address ranges, except
 * that class D (multicast) must be recognised.  One consequence of this is that
 * we neither generate nor accept "all subnets broadcast" addresses.
 *
 * If multiple interfaces are supported then they MUST be on distinct,
 * non-overlapping, subnets.
 */

#ifdef MULTI_IF
	#define IS_ANY_MY_ADDR(ip)						is_any_my_addr(ip)
	#define IS_NONLOCAL_SUBNET(ip, iface)		is_nonlocal_subnet(ip, iface)
	#define IS_ALL_NONLOCAL_SUBNET(ip)			is_all_nonlocal_subnet(ip)
	#define IS_SUBNET_BCAST_ADDR(ip, iface) 	is_subnet_bcast_addr(ip, iface)
	#define IS_SUBNET_NET_ADDR(ip, iface)		is_subnet_net_addr(ip, iface)
	#define MY_ADDR(iface)							_if_tab[iface].ipaddr
	#define MY_SUBNET_MASK(iface)					_if_tab[iface].mask

#else
	#define IS_ANY_MY_ADDR(ip)						IS_MY_ADDR(ip,IF_DEFAULT)
	#define IS_NONLOCAL_SUBNET(ip, iface)		is_nonlocal_subnet(ip, IF_DEFAULT)
	#define IS_ALL_NONLOCAL_SUBNET(ip)			IS_NONLOCAL_SUBNET(ip, IF_DEFAULT)
	#define IS_SUBNET_BCAST_ADDR(ip, iface) 	is_subnet_bcast_addr(ip, IF_DEFAULT)
	#define IS_SUBNET_NET_ADDR(ip, iface)		is_subnet_net_addr(ip, IF_DEFAULT)
	#define MY_ADDR(iface)							_if_tab[IF_DEFAULT].ipaddr
	#define MY_SUBNET_MASK(iface)					_if_tab[IF_DEFAULT].mask
#endif

#define IS_MY_ADDR(ip, iface)			is_my_addr(ip, iface)
#define IS_LOCAL_SUBNET(ip, iface) 	(!IS_NONLOCAL_SUBNET(ip, iface))
#define IS_ANY_LOCAL_SUBNET(ip) 		(!IS_ANY_NONLOCAL_SUBNET(ip))
#define IS_ANY_BCAST_ADDR(ip)       is_subnet_bcast_addr(ip, IF_ANY)
#define IS_ANY_NET_ADDR(ip)         is_subnet_net_addr(ip, IF_ANY)
#define IS_MULTICAST_ADDR(ip)			(((ip) & 0xF0000000) == 0xE0000000)
#define IS_LOOPBACK_ADDR(ip)			(((ip) & 0xFF000000) == IPADDR(127,0,0,0))
#define IS_LINKLOCAL_ADDR(ip)			(((ip) & 0xFFFF0000) == IPADDR(169,254,0,0))

// Following also allow my own address(es) as valid.  The *_SOURCE macros check
// for proper source IP address in incoming datagrams.  The *_DEST macros check
// for valid destination addresses in outgoing datagrams.
#define IS_VALID_LOCAL_SOURCE(ip, iface)	is_valid_source(ip, iface, 1)
#define IS_ANY_VALID_LOCAL_SOURCE(ip)		is_valid_source(ip, IF_ANY, 1)
#define IS_VALID_SOURCE(ip, iface)			is_valid_source(ip, iface, 0)
#define IS_ANY_VALID_SOURCE(ip)				is_valid_source(ip, IF_ANY, 0)

#define MY_BCAST_ADDR(iface)					0xFFFFFFFF
#define MY_SUBNET_NET_ADDR(iface)			(MY_ADDR(iface) & MY_SUBNET_MASK(iface))
#define MY_SUBNET_BCAST_ADDR(iface)			(MY_ADDR(iface) | ~MY_SUBNET_MASK(iface))


// Number of entries in ARP cache table.  Must be between 1 and 199 inclusive.
// (The numbers 224-255 are reserved for special flags such as broadcast,
// and 200-223 are reserved for future use).
// Should be set to the number of permanent entries, plus router entries,
// plus the number of simultaneously active TCP and UDP sockets.  For the
// majority of applications, the default should be more than enough.
#ifndef ARP_TABLE_SIZE
	#ifndef ARP_MINIMAL
		#define ARP_TABLE_SIZE				(5*(USING_ETHERNET+USING_WIFI)+IF_MAX)
	#else
		#define ARP_TABLE_SIZE				1
	#endif
#endif

// Number of entries in router table.  The default is set up for one
// router per interface, plus an extra one for each broadcast (i.e. ethernet)
// interface, to handle possible redirections.
#ifndef ARP_ROUTER_TABLE_SIZE
	#define ARP_ROUTER_TABLE_SIZE		(IF_MAX+USING_ETHERNET+USING_WIFI)
#endif



/* Reserve ports ignores unlistened SYNs for specified ports */
#define USE_RESERVEDPORTS


#ifdef _DC10_LEGACY
	// These macros should not have been in use, will be removed in future release
	#define MAXINT 0x7fff   // Use stdc INT_MAX instead
	// Use functions (i_min, i_max, u_min, u_max,
	//				long_min, long_max, ulong_min, ulong_max)
	#define min(X,Y) (((X)<=(Y))?(X):(Y))
	#define max(X,Y) (((X)>=(Y))?(X):(Y))
	// Use memcpy()
	#define movmem(X,Y,Z) memcpy((Y),(X),(Z))
	#define FP_OFF(X) ((unsigned int)X)
	// These already defined
	#define TRUE            1
	#define true            TRUE
	#define FALSE           0
	#define false           FALSE
	/* these are visible for select routine return values */
	#define SOCKESTABLISHED 1
	#define SOCKDATAREADY   2
	#define SOCKCLOSED      4

	// These have been deprecated a long time
	#define my_ip_addr   _if_tab[IF_DEFAULT].ipaddr
	#define sin_mask     _if_tab[IF_DEFAULT].mask
	#define _mtu         _if_tab[IF_DEFAULT].mtu
	#define multihomes 0    // never did this (can use virtual ethernets)
#endif

/*
 *	Determine which libraries and functionality to include.
 */



#ifdef  DISABLE_UDP
	#ifdef USE_DHCP
		#warnt "Cannot set USE_DHCP if also DISABLE_UDP"
		#undef USE_DHCP
	#endif
	#ifndef DISABLE_DNS
		#warnt "Disabling DNS because DISABLE_UDP"
		#define DISABLE_DNS
	#endif
#endif



// Network layer protocol field values in network order, as stored in the
// ethernet header
#define IP_TYPE         0x0008		// Really 0x0800
#define ARP_TYPE			0x0608		// Really 0x0806
#define IS_PPPOE_TYPE(t) (((t)&0x00FF) == 0x88)		// High (network order) byte
																	// of type==0x88 -> is PPPoE.
#define PPPOE_TYPE		0x6488		// Really 0x8864 - PPPoE session data
#define PPPOE_DISC		0x6388		// Really 0x8863 - PPPoE link establishment

#ifndef MAX_STRING
	#define MAX_STRING      50				// Hostname strings are limited in length
#endif

#ifndef MAX_NAMESERVERS
	#define MAX_NAMESERVERS 2
#endif




// Separate spaces for TCP and UDP mode flags...

// TCP modes:
#define TCP_MODE_BINARY 0       /* default mode */
#define TCP_MODE_ASCII  1
#define TCP_MODE_NAGLE  0       /* Nagle algorithm */
#define TCP_MODE_NONAGLE 2
#define TCP_MODE_FULLCLOSE  0       /* Old style, do full close */
#define TCP_MODE_HALFCLOSE  4			/* Support half-close on this socket */
#define ALL_TCP_MODES (TCP_MODE_ASCII|TCP_MODE_NONAGLE|TCP_MODE_HALFCLOSE)

#define tcp_set_binary(s) ((s)->sock_mode &= ~TCP_MODE_ASCII)
#define tcp_set_ascii(s) ((s)->sock_mode |= TCP_MODE_ASCII)

#define tcp_set_nagle(s) ((s)->sock_mode &= ~TCP_MODE_NONAGLE)
#define tcp_set_nonagle(s) ((s)->sock_mode |= TCP_MODE_NONAGLE)

#define tcp_set_fullclose(s) ((s)->sock_mode &= ~TCP_MODE_HALFCLOSE)
#define tcp_set_halfclose(s) ((s)->sock_mode |= TCP_MODE_HALFCLOSE)

// UDP modes:
#define UDP_MODE_CHK    0       /* default to having checksums */
#define UDP_MODE_NOCHK  1
#define UDP_MODE_NOICMP 0       /* default to not buffering ICMP error messages */
#define UDP_MODE_ICMP   2
#define UDP_MODE_NODICMP 0      /* default to not being the default ICMP message
											  buffering socket */
#define UDP_MODE_DICMP   4
#define UDP_MODE_CONTIG 0       /* default to sending contiguous data to the
											  UDP data handler */
#define UDP_MODE_NOCONTIG   8
#define ALL_UDP_MODES (UDP_MODE_NOCHK|UDP_MODE_ICMP|UDP_MODE_DICMP|UDP_MODE_NOCONTIG)

#define udp_set_chk(s) ((s)->sock_mode &= ~UDP_MODE_NOCHK)
#define udp_set_nochk(s) ((s)->sock_mode |= UDP_MODE_NOCHK)

#define udp_set_noicmp(s) ((s)->sock_mode &= ~UDP_MODE_ICMP)
#define udp_set_icmp(s) ((s)->sock_mode |= UDP_MODE_ICMP)

#define udp_set_nodicmp(s) ((s)->sock_mode &= ~UDP_MODE_DICMP)
#define udp_set_dicmp(s) ((s)->sock_mode |= UDP_MODE_DICMP)

#define udp_set_contig(s) ((s)->sock_mode &= ~UDP_MODE_NOCONTIG)
#define udp_set_nocontig(s) ((s)->sock_mode |= UDP_MODE_NOCONTIG)

#define ALL_MODES (ALL_TCP_MODES|ALL_UDP_MODES)


// Parameter identifiers ("tags") for ifconfig().
// **** MAINTAINER NOTES *****
//      . Tag values must be >= 256 (0x100) and < 0xFF00.
//
//      *** Do not alter numbers after DC10.60 release, since persistent ***
//      *** and backward-compatible network settings depend on these     ***
//      *** tags having consistent meaning over releases.                ***
//
//      . Try to keep total numeric ranges "compact".
#define IFS_END							300		// End of parameter list
#define IFS_NOP							301		// do nothing, used for padding
#define IFS_IPADDR						302		// Set IP address [longword]
#define IFG_IPADDR						303		// Get IP address [longword *]
#define IFS_NETMASK						304		// Set netmask [longword]
#define IFG_NETMASK						305		// Get netmask [longword *]
#define IFS_MTU							306		// Set maximum transmission unit [word]
#define IFG_MTU							307		// Get MTU [word *]
#define IFS_UP								308		// Bring up interface [no parameter]
#define IFS_DOWN							310		// Bring down interface [no parameter]
#define IFS_ROUTER_SET					312		// Delete all rounters, then set this one [longword]
#define IFS_ROUTER_SET_STATIC			313		// Set restricted router [longword,longword,longword]
#define IFS_ROUTER_ADD					314		// Add rounter [longword]
#define IFS_ROUTER_ADD_STATIC			315		// Add restricted router [longword,longword,longword]
#define IFS_ROUTER_DEL					318		// Delete router [longword].  If 0 parm, delete all routers.
#define IFG_ROUTER_DEFAULT				321		// Get default router [longword *]
#define IFS_HWA							322		// Set hardware address [byte[6]]
#define IFG_HWA							323		// Get hardware address [byte[6]]
#define IFS_NAMESERVER_SET				326		// Delete all nameservers, then set this one [longword]
#define IFS_NAMESERVER_ADD				328		// Add nameserver [longword]
#define IFS_DHCP							332		// Use DHCP to configure this interface, or not [int]
#define IFG_DHCP							333		// Get whether DHCP to be used [int *]
#define IFS_ICMP_CONFIG					334		// Use "arp -s" ping to configure IP address, or not [int]
#define IFG_ICMP_CONFIG					335		// Get whether ping configure [int *]
#define IFS_DEBUG							336		// Set debug level [int]
#define IFG_DEBUG							337		// Get debug level [int *]
#define IFS_PPP_SPEED					340		// Set PPP speed in bits/sec [longword]
#define IFG_PPP_SPEED					341		// Get PPP speed in bits/sec [longword *]
#define IFG_DHCP_OK						343		// Get whether DHCP actually OK [int *]
#define IFS_ICMP_CONFIG_RESET			344		// After ping configured OK, allow new ping configure [no parameter]
#define IFG_ICMP_CONFIG_OK				345		// Get whether ping configured OK [int *]
#define IFS_DHCP_TIMEOUT				346		// Set DHCP timeout seconds [int]
#define IFG_DHCP_TIMEOUT				347		// Get DHCP timeout seconds [int *]
#define IFS_DHCP_FALLBACK				348		// Set DHCP fallback [int]
#define IFG_DHCP_FALLBACK				349		// Get DHCP fallback [int *]
#define IFS_PPP_ACCEPTIP				352		// Accept peer's idea of our local IP address
#define IFG_PPP_ACCEPTIP				353
#define IFS_PPP_REMOTEIP				354		// Try to set peer's IP address
#define IFG_PPP_REMOTEIP				355
#define IFS_PPP_SETREMOTEIP			IFS_PPP_REMOTEIP
#define IFS_PPP_ACCEPTDNS				356		// Accept a DNS server IP address from peer
#define IFG_PPP_ACCEPTDNS				357
#define IFS_PPP_REMOTEDNS				358		// Set DNS server IP address for peer
#define IFG_PPP_REMOTEDNS				359
#define IFS_PPP_SETREMOTEDNS			IFS_PPP_REMOTEDNS
#define IFS_PPP_AUTHCALLBACK			360		// Called when a peer attempts to authenticate
#define IFS_PPP_INIT						362		// Sets up PPP with default parameters
#define IFS_PPP_REMOTEAUTH				363		// Sets username and password to give to peer
#define IFG_PPP_REMOTEAUTH				364
#define IFS_PPP_LOCALAUTH				365		// Required username and password for incoming peer
#define IFG_PPP_LOCALAUTH				366
#define IFS_PPP_RTSPIN					367		// Define the RTS pin [int, char *, int]
#define IFG_PPP_RTSPIN					368
#define IFS_PPP_CTSPIN					369		// Define the CTS pin [int, int]
#define IFG_PPP_CTSPIN					370
#define IFS_PPP_FLOWCONTROL			371		// Turn hardware flow control on/off (1/0) [int]
#define IFG_PPP_FLOWCONTROL			372
#define IFS_PPP_SENDEXPECT				373		// Sequence of send/expect strings separated by '\r' [char *]
#define IFG_PPP_SENDEXPECT				374
#define IFS_PPP_USEMODEM				375		// Turn on/off modem handling step [int]
#define IFG_PPP_USEMODEM				376
#define IFS_PPP_HANGUP					377		// string to send to the modem when shutting down
#define IFG_PPP_HANGUP					378
#define IFS_PPP_MODEMESCAPE			379		// Send a standard escape sequence '+++' before SENDEXPECT or HANGUP
#define IFG_PPP_MODEMESCAPE			380
#define IFS_PPP_USEPORTD				382		// Use parallel port D pins for serial ports A,B (IF_PPP0,1) -
#define IFG_PPP_USEPORTD				383		//   otherwise uses the normal parallel port C pins.
#define IFG_PPP_PEERADDR				385		// Return the PPP peer IP address
#define IFS_IF_CALLBACK					390		// Set interface up/down callback [void (*)()]
#define IFG_DHCP_INFO               393		// Get DHCP goodies [DHCPInfo **]
#define IFG_DHCP_FELLBACK				395		// Get DHCP fallback status [int *]
#define IFS_DHCP_OPTIONS            396    // Set DHCP custom options  [int] [char *] [int (*)()]
#define IFG_DHCP_OPTIONS            397    // Get DHCP custom options  [int *] [char **]
#define IFS_DHCP_QUERY              398    // Set DHCP query  [int]
#define IFG_DHCP_QUERY              399    // Get DHCP query  [int *]
#define IFS_DHCP_DOMAIN             400   // Set DHCP 'get host & domain name' flag  [int]
#define IFG_DHCP_DOMAIN             401   // Get DHCP host/domain flag  [int *]
#define IFS_NAMESERVER_DEL				402	// Delete nameserver [longword]
#define IFS_DHCP_FB_IPADDR          404   // Set DHCP fallback IP address [longword]
#define IFG_DHCP_FB_IPADDR          405   // Get DHCP fallback IP address [longword *]
#define IFS_PPP_PASSIVE					406	// Set PPP passive mode [bool]
#define IFG_PPP_PASSIVE					407	// Get PPP passive mode [bool *]
#define IFS_USE_DMA						408	// Rabbit 4000: use DMA to serial port
#define IFS_USE_SERIAL					410	// Rabbit 4000: use serial port directly
#define IFS_PPP_USEPORTE				412	// Rabbit 4000: Use parallel port E pins for serial ports E,F
#define IFG_PPP_USEPORTE				413	// 	(IF_PPP0,1) - See also IFS_USEPORTD


#if USING_WIFI
	// these options can only be used if Wi-Fi is enabled, reserve 512-1023
#define IFX_WIFI_MIN						512	// ifconfig() exits if option is between _MIN
#define IFX_WIFI_MAX						700	// and _MAX and the given interface is not Wi-Fi

#define IFS_WIFI_SSID					512	// Set Wi-Fi SSID [int, byte *]
#define IFG_WIFI_SSID					513	// Get Wi-Fi SSID [int *, byte *]
#define IFS_WIFI_MULTI_DOMAIN			514	// Enable Multi-Domain [bool]
#define IFG_WIFI_MULTI_DOMAIN			515	// Status of Multi-Domain enable [bool *]
#define IFS_WIFI_REGION					516	// Set Wi-Fi region id [int]
#define IFG_WIFI_REGION					517	// Get Wi-Fi region id [int *]
#define IFG_WIFI_REGION_INFO			518	// Get Wi-Fi region info [wifi_region *]

// regions for IFS_WIFI_REGION and IFG_WIFI_REGION
// see wifi_wln_api.lib for definitions of each region
enum {
	IFPARAM_WIFI_REGION_AMERICAS,
	IFPARAM_WIFI_REGION_MEXICO_INDOORS,
	IFPARAM_WIFI_REGION_MEXICO_OUTDOORS,
	IFPARAM_WIFI_REGION_CANADA,
	IFPARAM_WIFI_REGION_EMEA,
	IFPARAM_WIFI_REGION_FRANCE,
	IFPARAM_WIFI_REGION_ISRAEL,
	IFPARAM_WIFI_REGION_CHINA,
	IFPARAM_WIFI_REGION_JAPAN,
	IFPARAM_WIFI_REGION_AUSTRALIA,

   IFPARAM_WIFI_REGION_END_OF_LIST
};

#define IFS_WIFI_MODE					519	// Set Infrastructure or Ad-Hoc [int]
#define IFG_WIFI_MODE					520	// Get Infrastructure or Ad-Hoc setting [int *]

// options for IFS_WIFI_MODE and IFG_WIFI_MODE
enum {
	IFPARAM_WIFI_ADHOC = WLN_BSS_IBSS,
	IFPARAM_WIFI_INFRASTRUCTURE = WLN_BSS_ESS,
	IFPARAM_WIFI_ADHOC_JOIN_ONLY = WLN_BSS_IB_WIFI_SS_JOIN,
	IFPARAM_WIFI_ANY = WLN_BSS_ANY,
	IFPARAM_WIFI_NO_JOIN = WLN_BSS_NONE,
	IFPARAM_WIFI_JOIN = (WLN_BSS_NONE<<1)
};

#define IFS_WIFI_CHANNEL				521	// Set Wi-Fi channel [int]
#define IFG_WIFI_CHANNEL				522	// Get Wi-Fi channel setting [int *]
#define IFS_WIFI_TX_RATE				523	// Set max Wi-Fi transmit rate [int]
#define IFG_WIFI_TX_RATE				524	// Get max Wi-Fi transmit rate [int *]

// rates for IFS_WIFI_TX_RATE and IFG_WIFI_TX_RATE
enum {
	IFPARAM_WIFI_TX_RATE_ANY	= 0,
   IFPARAM_WIFI_TX_RATE_1		= 10,
   IFPARAM_WIFI_TX_RATE_2		= 20,
   IFPARAM_WIFI_TX_RATE_5_5	= 55,
   IFPARAM_WIFI_TX_RATE_6		= 60,
   IFPARAM_WIFI_TX_RATE_9		= 90,
   IFPARAM_WIFI_TX_RATE_11		= 110,
   IFPARAM_WIFI_TX_RATE_12		= 120,
   IFPARAM_WIFI_TX_RATE_18		= 180,
   IFPARAM_WIFI_TX_RATE_24		= 240,
   IFPARAM_WIFI_TX_RATE_36		= 360,
   IFPARAM_WIFI_TX_RATE_48		= 480,
   IFPARAM_WIFI_TX_RATE_54		= 540,
};

#define IFS_WIFI_TX_POWER				525	// Set max Wi-Fi transmit power [int]
#define IFG_WIFI_TX_POWER				526	// Get max Wi-Fi transmit power [int *]
#define IFS_WIFI_FRAG_THRESHOLD		527	// Set Wi-Fi fragment threshold [int]
#define IFG_WIFI_FRAG_THRESHOLD		528	// Get Wi-Fi fragment threshold [int *]
#define IFS_WIFI_RTS_THRESHOLD		529	// Set Wi-Fi RTS threshold [int]
#define IFG_WIFI_RTS_THRESHOLD		530	// Get Wi-Fi RTS threshold [int *]

#define IFS_WIFI_ENCRYPTION			540	// Set Wi-Fi encryption types [word]
#define IFG_WIFI_ENCRYPTION			541	// Get Wi-Fi encryption types [word *]

// encryption types for IFS_WIFI_ENCRYPTION and IFG_WIFI_ENCRYPTION
// user can select one or more by ORing multiple options
#define IFPARAM_WIFI_ENCR_ANY			((word) WLN_ENCR_ANY)
#define IFPARAM_WIFI_ENCR_NONE		((word) WLN_ENCR_OPEN)
#define IFPARAM_WIFI_ENCR_WEP			((word) WLN_ENCR_WEP)
#define IFPARAM_WIFI_ENCR_TKIP		((word) WLN_ENCR_TKIP)
#define IFPARAM_WIFI_ENCR_CCMP		((word) WLN_ENCR_CCMP)

#define IFS_WIFI_AUTHENTICATION		542	// Set Wi-Fi Authentication types [word]
#define IFG_WIFI_AUTHENTICATION		543	// Get Wi-Fi Authentication types [word *]

// authentication types for IFS_WIFI_AUTHENTICATION and IFG_WIFI_AUTHENTICATION
#define IFPARAM_WIFI_AUTH_ANY			((word) WLN_AUTH_ANY)	// Don't use with EAP
#define IFPARAM_WIFI_AUTH_OPEN		((word) WLN_AUTH_OPEN)
#define IFPARAM_WIFI_AUTH_SHAREDKEY	((word) WLN_AUTH_SHAREDKEY)
#define IFPARAM_WIFI_AUTH_WPA_PSK	((word) WLN_AUTH_WPA_PSK)
#define IFPARAM_WIFI_AUTH_WPA_8021X	((word) WLN_AUTH_WPA_8021X)
// methods below aren't supported by the Wi-Fi driver
#define IFPARAM_WIFI_AUTH_WEP_8021X	((word) WLN_AUTH_WEP_8021X)
#define IFPARAM_WIFI_AUTH_LEAP		((word) WLN_AUTH_LEAP)

#define IFS_WIFI_WEP_KEYNUM			550	// Set Wi-Fi WEP key number (0-3) [int]
#define IFG_WIFI_WEP_KEYNUM			551	// Get Wi-Fi WEP key number (0-3) [int *]
#define IFS_WIFI_WEP_KEY_BIN			552	// Set Wi-Fi WEP key (5 or 13 bytes) [int, int, byte *]
#define IFG_WIFI_WEP_KEY_BIN			553	// Get Wi-Fi WEP key [int, int *, byte *]

// sizes for IFS_WIFI_WEP_KEY_BIN and IFG_WIFI_WEP_KEY_BIN
enum{
	IFPARAM_WIFI_WEP_KEY40	= WLN_WEP40_SIZE,		// 5
   IFPARAM_WIFI_WEP_KEY104	= WLN_WEP104_SIZE		// 13
};

#define IFS_WIFI_WEP_KEY_HEXSTR		554	// Set Wi-Fi WEP key (10 or 26 char hex string) [int, char *]
#define IFG_WIFI_WEP_KEY_HEXSTR		555	// Get Wi-Fi WEP key as hex string [int, char *]

#ifdef WIFI_USE_WPA						// Options only valid if WPA is enabled
#define IFS_WIFI_WPA_PSK_PASSPHRASE	560	// Set Wi-Fi WPA PSK using passphrase [char *]
#define IFS_WIFI_WPA_PSK_HEXSTR		561	// Set Wi-Fi WPA PSK using 64-char hex string [char *]
#define IFG_WIFI_WPA_PSK_HEXSTR		562	// Get Wi-Fi WPA PSK as 64-char hex string [char *]
#define IFS_WIFI_WPA_PSK_BIN			563	// Set Wi-Fi WPA PSK using 32-byte array [byte *]
#define IFG_WIFI_WPA_PSK_BIN			564	// Get Wi-Fi WPA PSK as 32-byte array [byte *]
#endif	// #ifdef WIFI_USE_WPA

#define IFG_WIFI_STATUS					570	// Get Wi-Fi status [wifi_status *]
#define IFS_WIFI_SCAN					571	// Initiate Wi-Fi Scan with callback [void (*)()]

	// Wi-Fi options related to roaming
#define IFS_WIFI_BSSID						580	// Set address of AP (byte[6])
#define IFG_WIFI_BSSID						581	// Get address of AP (byte[6])
#define IFS_WIFI_ROAM_ENABLE				582	// Enable/disable roaming (bool)
#define IFG_WIFI_ROAM_ENABLE				583	// Get roaming enabled state (bool *)
#define IFS_WIFI_ROAM_BEACON_MISS		584	// Set number of lost beacons to trigger roaming event (int)
#define IFG_WIFI_ROAM_BEACON_MISS		585	// Get number of lost beacons to trigger roaming event(int *)

	// Wi-Fi options for WPA Enterprise/WPA2
#define IFS_WIFI_WPA_PROTOCOL				600	// Set acceptable WPA protocol(s) [word]
#define IFG_WIFI_WPA_PROTOCOL				601	// Get acceptable WPA protocol(s) [word *]
	#define IFPARAM_WIFI_WPA_PROTOCOL_WPA	 ((word)WPA_PROTO_WPA)			// WPA/IEEE 802.11i/D3.0
	#define IFPARAM_WIFI_WPA_PROTOCOL_WPA2  ((word)WPA_PROTO_RSN)			// WPA2/IEEE 802.11i
	#define IFPARAM_WIFI_WPA_PROTOCOL_RSN   IFPARAM_WIFI_WPA_PROTOCOL_WPA2
	#define IFPARAM_WIFI_WPA_PROTOCOL_ALL   ((word)0xFFFF)

#define IFS_WIFI_PAIRWISE_ENCRYPTION	604	// Set Wi-Fi pairwise encryption types [word]
#define IFG_WIFI_PAIRWISE_ENCRYPTION	605	// Get Wi-Fi pairwise encryption types [word *]
	// For acceptable values, see description for IFS_WIFI_ENCRYPTION.  Only
	// NONE, TKIP or CCMP are allowed:
	// CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
	// TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
	// NONE = Use only Group Keys (deprecated, should not be included if APs support
	//	pairwise keys)

#define IFS_WIFI_EAP_METHODS				606	// Set acceptable EAP methods. [longword]
#define IFG_WIFI_EAP_METHODS				607	// Get acceptable EAP methods [longword *]
	// The parameter for above is a bitmask with one or more of the following ORed together.
	// Note that methods which do not have compiled-in support via the WPA_USE_EAP
	// macro will be ignored.  Currently, we only support EAP_TYPE_TLS and EAP_TYPE_PEAP.
	// #define WPA_USE_EAP		(WPA_USE_EAP_TLS|WPA_USE_EAP_PEAP)
	// would be required.
	#define IFPARAM_EAP_PEAP					WLN_EAP_PEAP
	#define IFPARAM_EAP_TLS						WLN_EAP_TLS
	//#define IFPARAM_EAP_ANY						WLN_EAP_ANY				// Any method
	//#define IFPARAM_EAP_INNER_ANY				WLN_EAP_INNER_ANY		// Any wrapped method


#define IFS_WIFI_IDENTITY					608	// Set identity string for EAP [char *]
#define IFG_WIFI_IDENTITY					609	// Get identity string for EAP [char **]
#define IFS_WIFI_ANONYMOUS_IDENTITY		610	// Set anonymous identity string for "outer" EAP [char *]
#define IFG_WIFI_ANONYMOUS_IDENTITY		611	// Get anonymous identity string for "outer" EAP [char **]
#define IFS_WIFI_PASSWORD					612	// Set password string for EAP [char *]
#define IFG_WIFI_PASSWORD					613	// Get password string for EAP [char **]
#define IFS_WIFI_CA_CERT					614	// Set CA certificate [SSL_Cert_t far *].  If no CA
																// cert provided, then the access server is not
																// verified, which introduces risk of 'access
																// server spoofing'.
#define IFG_WIFI_CA_CERT					615	// Get CA certificate [SSL_Cert_t far **]
#define IFS_WIFI_CA_CERT2					616	// Set "inner" CA certificate [SSL_Cert_t far *]
#define IFG_WIFI_CA_CERT2					617	// Get "inner" CA certificate [SSL_Cert_t far **]
#define IFS_WIFI_CA_CERT_PATH				618	// Set CA certificate as a Zserver resource path [char *]
#define IFS_WIFI_CA_CERT2_PATH			620	// Set "inner" CA certificate Zserver path [char *]
#define IFS_WIFI_CLIENT_CERT				622	// Set client certificate [SSL_Cert_t far *]
#define IFG_WIFI_CLIENT_CERT				623	// Get client certificate [SSL_Cert_t far **]
#define IFS_WIFI_CLIENT_CERT2				624	// Set "inner" client certificate [SSL_Cert_t far *]
#define IFG_WIFI_CLIENT_CERT2				625	// Get "inner" client certificate [SSL_Cert_t far **]
#define IFS_WIFI_CLIENT_CERT_PATH		626	// Set client certificate as Zserver file [char *,char *]
																// 1st parm is for cert, 2nd parm for private key.
																// If 1st parm NULL, then delete resources.
#define IFS_WIFI_CLIENT_CERT2_PATH		628	// Set "inner" client certificate as Zserver file [char *,char *]
#define IFS_WIFI_EAP_PSK_PASSPHRASE		630	// Set Wi-Fi EAP PSK using passphrase [char *]
#define IFS_WIFI_EAP_PSK_HEXSTR			632	// Set Wi-Fi EAP PSK using 64-char hex string [char *]
#define IFG_WIFI_EAP_PSK_HEXSTR			633	// Get Wi-Fi EAP PSK as 64-char hex string [char *]
#define IFS_WIFI_EAP_PSK_BIN				634	// Set Wi-Fi EAP PSK using 32-byte array [byte *]
#define IFG_WIFI_EAP_PSK_BIN				635	// Get Wi-Fi EAP PSK as 32-byte array [byte *]
#define IFS_WIFI_SUBJECT_MATCH			638	// Set substring to be matched against the subject of the
														//	authentication server certificate [char *]
	//The subject string is in following format (for example):
	// 	/C=US/ST=CA/L=Davis/CN=Test1-AS/emailAddress=test1_as@digi.com
	// so this parameter string could be set to "/L=Davis/CN=Test" to allow all access servers with a
	// location of "Davis" and a common name starting with "Test".
#define IFS_WIFI_SUBJECT_MATCH2			640	// Set "inner" subject match substring [char *]
#define IFS_WIFI_ALTSUBJECT_MATCH		642	// Set semicolon separated string of entries to be matched against
															//	the alternative subject name of the authentication server
															// certificate [char *]
//	If this string is set, the server sertificate is only accepted if it
//	contains one of the entries in an alternative subject name extension.
//	altSubjectName string is in following format: TYPE:VALUE
//	Example: EMAIL:server@example.com
//	Example: DNS:server.example.com;DNS:server2.example.com
//	Following types are supported: EMAIL, DNS, URI
#define IFS_WIFI_ALTSUBJECT_MATCH2		644	// Set "inner" altsubject match [char *]
// The following are for convenience when "hard-coding" certificates (e.g. from #ximported files).
// Pass a zero longword as the parameter in order to delete any resources which were allocated
// on a previous call (since the library manages the SSL_Cert_t structures which are created).
#define IFS_WIFI_CA_CERT_XIM				650	// Set CA certificate as #ximport DER/PEM format [longword]
#define IFS_WIFI_CA_CERT2_XIM				652	// Set CA certificate 2 as #ximport DER/PEM format [longword]
#define IFS_WIFI_CLIENT_CERT_XIM			654	// Set client certificate and private key as two #ximport
															// DER/PEM format files [longword, longword]
															// 1st parm is for certificate itself, 2nd for private key.
#define IFS_WIFI_CLIENT_CERT2_XIM		656	// Set client certificate/key 2 [longword, longword]

#define IFS_WIFI_EAP_TLS_FLAGS			658	// Set TLS flags for EAP-PEAP and
															// EAP-TLS connections. [word]
#define IFG_WIFI_EAP_TLS_FLAGS			659	// Get TLS flags for EAP-PEAP and
															// EAP-TLS connections. [word *]
	// The parameter for above is a bitmask with one or more of the SSL_F_*
	// macros ORed together.  See documentation for tls_set_flags() for a list
	// of flags and their meaning.


// DEVNOTE: if you add options beyond 700, be sure to update IFX_WIFI_MAX above.
#endif	// #if USING_WIFI

// These are used only for the default interface.
#ifndef USE_DHCP
	#ifndef MY_IP_ADDRESS
	   #define MY_IP_ADDRESS	"169.254.0.0"
   #endif
	#ifndef MY_NETMASK
   	#define MY_NETMASK		"255.255.0.0"
   #endif
#endif

// Set up default interface initializations.
// IFCONFIG_ALL : all items not specific to any particular interface
// IFCONFIG_DEFAULT : all items for the default interface (IF_DEFAULT).
// If not defined, these definitions are compatible with previous releases.
// The user can also define IFCONFIG_ETH0, IFCONFIG_PPP0 etc., in which
// case those definitions will be used for the specified interface instead
// of the defaults.
#ifndef IFCONFIG_ALL
	#ifdef MY_GATEWAY
		#define _MY_GATEWAY IFS_ROUTER_SET,aton(MY_GATEWAY),
	#else
		#define _MY_GATEWAY
	#endif
	#ifdef MY_NAMESERVER
		#define _MY_NAMESERVER IFS_NAMESERVER_SET,aton(MY_NAMESERVER),
	#else
		#define _MY_NAMESERVER
	#endif
	#define IFCONFIG_ALL _MY_GATEWAY _MY_NAMESERVER IFS_END
#endif

#ifndef IFCONFIG_DEFAULT
	#ifdef USE_DHCP
		#define _USE_DHCP IFS_DHCP,1,
	#else
		#define _USE_DHCP
	#endif
	#if IF_DEFAULT_IS_P2P
		#ifndef PPP_SPEED
			#define PPP_SPEED 19200
		#endif
		#define _PPP_STUFF IFS_PPP_SPEED,(longword)PPP_SPEED,IFS_PPP_INIT,
	#else
		#define _PPP_STUFF
	#endif
	#define IFCONFIG_DEFAULT IFS_IPADDR,aton(MY_IP_ADDRESS), \
				IFS_NETMASK,aton(MY_NETMASK),_USE_DHCP _PPP_STUFF IFS_UP
#endif

#define sockaddr_in sockaddr

// Include published structures and typedefs
#use "NET_DEFS.LIB"

// Include published variable/state information
#use "NET_VARS.LIB"

/*
 * Locks for use in a reentrant environment
 */

#ifdef MCOS_LOCKS
	INT8U InitSocketLock(sock_type *s);

	typedef struct {
		OS_EVENT *lock;
		sock_type *s;
	} socket_lock_block;

	extern socket_lock_block sock_lock_array[ACTUAL_SOCKET_LOCKS];

	/* the actual lock funcitons */
	void IPSemPend(OS_EVENT *lock, char *lock_count);
	void IPSemPost(OS_EVENT *lock, char *lock_count);

	/* an individual socket lock, for use on sock rx/tx
		buffers, and the sock structure itself */
#ifndef NET_COARSELOCK
	#define LOCK_SOCK(s)		/*printf("%d Lock sock: %x (%d)\n",(int)OSPrioCur, s, (int)((udp_Socket *)(s))->lock_count);*/ \
				IPSemPend( ((udp_Socket *)(s))->lock, &(((udp_Socket *)(s))->lock_count) )
	#define UNLOCK_SOCK(s)	/*printf("%d UnLock sock: %x (%d)\n",(int)OSPrioCur, s, (int)((udp_Socket *)(s))->lock_count);*/ \
				IPSemPost( ((udp_Socket *)(s))->lock, &(((udp_Socket *)(s))->lock_count) )
#endif
	/* global locks, for use on global vars/lists, and global tasks like DNS */
	typedef struct {
		OS_EVENT			*lock;			/* the actual semaphore */
		char				 lock_count;	/* how many times we grabbed the semaphore */
	} GlobalLock;
	#define LOCK_GLOBAL(l)		IPSemPend((l).lock, &((l).lock_count))
	#define UNLOCK_GLOBAL(l)	IPSemPost((l).lock, &((l).lock_count))

	// Some conditional locking, for routines which do not need lock if not yet
	// called sock_init().
	#define LOCK_GLOBAL_IF_INIT(l)	if (_initialized) IPSemPend((l).lock, &((l).lock_count))
	#define UNLOCK_GLOBAL_IF_INIT(l)	if (_initialized) IPSemPost((l).lock, &((l).lock_count))

#ifdef NET_COARSELOCK
	#define LOCK_SOCK(s) LOCK_GLOBAL(TCPGlobalLock)
	#define UNLOCK_SOCK(s) UNLOCK_GLOBAL(TCPGlobalLock)
#endif
#ifdef NET_COMMON_DNS_LOCK
   extern GlobalLock TCPGlobalLock;
   #define LOCK_DNS() LOCK_GLOBAL(TCPGlobalLock)
   #define UNLOCK_DNS() UNLOCK_GLOBAL(TCPGlobalLock)
#else
	extern GlobalLock TCPGlobalLock, DNSGlobalLock;
   #define LOCK_DNS() LOCK_GLOBAL(DNSGlobalLock)
   #define UNLOCK_DNS() UNLOCK_GLOBAL(DNSGlobalLock)
#endif

	/* a quick lock, usualy implemented by turning off interrupts; this
		should NOT stay locked for long! */
	#define LOCK_QUICK()		OS_ENTER_CRITICAL()
	#define UNLOCK_QUICK()	OS_EXIT_CRITICAL()
#else
	/* no multitasker - locks are not necessary */
   #define LOCK_DNS()
   #define UNLOCK_DNS()
	#define LOCK_SOCK(s)
	#define UNLOCK_SOCK(s)
	#define LOCK_GLOBAL(l)
	#define UNLOCK_GLOBAL(l)
	#define LOCK_GLOBAL_IF_INIT(l)
	#define UNLOCK_GLOBAL_IF_INIT(l)
	#define LOCK_QUICK()
	#define UNLOCK_QUICK()
#endif

/*
 * End of locks section
 */


/* START FUNCTION DESCRIPTION ********************************************
sock_wait_established                   <NET.LIB>

SYNTAX: void sock_wait_established(void* s, int seconds, int (*fptr)(),
          int* status);

KEYWORDS:		tcpip

DESCRIPTION: 	Macro which waits until a connection is established for
               TCP sockets.  Returns immediately for UDP sockets.  On
               an error the macro jumps to the local, user-supplied sock_err
               label. If fptr, a user-supplied function, returns non-zero
               the macro returns.

PARAMETER1:    socket
PARAMETER2:    number of seconds to wait before timing out
PARAMETER3:    function to call repeatedly while waiting
PARAMETER4:    status word

RETURN VALUE:  none

SEE ALSO:      sock_wait_input, sock_wait_closed

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
sock_wait_input                        <NET.LIB>

SYNTAX: void sock_wait_input(void* s, int seconds, int (*fptr)(),
          int* status);

KEYWORDS:		tcpip

DESCRIPTION: 	Macro which waits until input exists for a established
               TCP socket.  If the socket is in ASCII mode this function
               waits until a complete string exists or the buffer is
               full.  Returns immediately for UDP sockets.  On an error
               the macro jumps to the local sock_err label. If fptr
               returns non-zero the macro returns.

PARAMETER1:    socket
PARAMETER2:    number of seconds to wait before timing out
PARAMETER3:    function to call repeatedly while waiting
PARAMETER4:    status word

RETURN VALUE:  none

SEE ALSO:      sock_wait_established, sock_wait_closed, sock_mode

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
sock_wait_closed                       <NET.LIB>

SYNTAX: void sock_wait_closed(void * s, int seconds, int (*fptr)(),
           int* status);

KEYWORDS:		tcpip

DESCRIPTION: 	Macro which waits until a TCP connection is fully closed.
               Returns immediately for UDP sockets.  On an error the macro
               jumps to the local sock_err label. If fptr, a user-supplied
               function, returns non-zero the macro returns.

PARAMETER1:    socket
PARAMETER2:    number of seconds to wait before timing out
PARAMETER3:    function to call repeatedly while waiting
PARAMETER4:    status word

RETURN VALUE:  none

SEE ALSO:      sock_wait_established, sock_wait_input

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
sock_tick                       <NET.LIB>

SYNTAX: void sock_tick(void* s, int * optional_status_ptr);

KEYWORDS:		tcpip

DESCRIPTION: 	This macro calls tcp_tick to quickly check incoming and
					outgoing data and to manage all the open sockets.  If our
					particular socket, s, is either closed or made inoperative
					due to an error condition, sock_tick sets the value of
					*optional_status_ptr (if the pointer is not NULL) to 1,
					then jumps to a local, user-supplied label, sock_err.  If
					the socket connection is fine and the pointer is not NULL
					*optional_status_ptr is set to 0

PARAMETER1:    socket
PARAMETER2:    status word

RETURN VALUE:  none

SEE ALSO:      sock_wait_established, sock_wait_input

END DESCRIPTION **********************************************************/

#define sock_wait_established( s, seconds, fn, statusptr ) \
    if (_ip_delay0( (sock_type*)s, seconds, fn, statusptr )) goto sock_err;
#define sock_wait_input( s, seconds, fn , statusptr ) \
    if (_ip_delay1( (sock_type*)s, seconds, fn, statusptr )) goto sock_err;
#define sock_tick( s, statusptr ) \
    if ( !tcp_tick(s)) { \
    	if (statusptr != NULL) *(int *)statusptr = 1 ; goto sock_err; } \
    else { if (statusptr != NULL) *(int *)statusptr = 0; }
#define sock_wait_closed(s, seconds, fn, statusptr )\
    if (_ip_delay2( (sock_type*)s, seconds, fn, statusptr )) goto sock_err;
/*** EndHeader */



/* START FUNCTION DESCRIPTION ********************************************
sock_init                              <NET.LIB>

SYNTAX: int sock_init();

KEYWORDS:		tcpip, initialization

DESCRIPTION: 	This function initializes the packet driver and DCRTCP
               using the compiler defaults for configuration.  This
               function should be called before using other DCRTCP
               functions.

               The return value indicates if sock_init() was successful.
               If it returns 0, then everything was successful.  If it
               returns 1, then the packet driver initialization failed.

					Note that the network interface will not necessarily be
               available immediately after sock_init() is called, even
               if you are simply using an Ethernet interface with a
               static configuration.  This is especially true if you are
               using DHCP.  If you need to make a network connection
               directly after calling sock_init(), then you will probably
               want to use code like the following:

               sock_init();
               while (ifpending(IF_DEFAULT) == IF_COMING_UP) {
                  tcp_tick(NULL);
               }

               The while loop will not finish until the interface has either
               completely come up or has failed (see the documentation for
               ifpending() for more information).

               If you use ucos2.lib, be sure to call OSInit() before
               calling sock_init().

RETURN VALUE:  Integer code as follows:
						0: OK.
						1: Ethernet packet driver initialisation failed.
						Other: reserved.

END DESCRIPTION **********************************************************/



/*** BeginHeader sock_init */

int sock_init ();
// For backwards compatibility.  sock_init() does not call exit().
#define sock_init_noexit sock_init
#ifdef USE_IGMP
	#use IGMP.LIB
#endif

/*** EndHeader */

#ifdef MCOS_LOCKS
socket_lock_block sock_lock_array[ACTUAL_SOCKET_LOCKS];
#ifdef NET_COMMON_DNS_LOCK
GlobalLock TCPGlobalLock;
#else
GlobalLock TCPGlobalLock, DNSGlobalLock;
#endif

__nodebug INT8U InitSocketLock(sock_type *s)
{
	static int i;
	static udp_Socket *sock;
	static long s_addr;
	static byte stackseg;

#GLOBAL_INIT { memset(sock_lock_array, 0, sizeof(sock_lock_array)); }

	sock = (udp_Socket *)s;

   for(i=0; i<ACTUAL_SOCKET_LOCKS; i++) {
   	if(sock_lock_array[i].s == s) {
   		/* found our lock */
   		sock->lock = sock_lock_array[i].lock;
   		sock->lock->OSEventPtr = NULL;
   		sock->lock_count = 0;
   		return 0;
   	}
   	if(sock_lock_array[i].s == NULL) {
   		/* we were not in the list - mark the next free space ours */
   		sock_lock_array[i].s = s;
   		sock_lock_array[i].lock = sock->lock = OSSemCreate(1);	// allocate a new semaphore
   		sock->lock_count = 0;
   		sock->lock->OSEventPtr = NULL;
   		return 0;
   	}
   }
   return 1;
}

__nodebug void IPSemPend(OS_EVENT *lock, char *lock_count)
{
   OS_ENTER_CRITICAL();
#if 0
   if (lock == (OS_EVENT *)0) {						// Validate 'lock'
      OS_EXIT_CRITICAL();
   } else if (lock->OSEventType != OS_EVENT_TYPE_SEM) {	// Validate event block type
      OS_EXIT_CRITICAL();
   } else
#endif
   if ((unsigned)(INT8U)lock->OSEventPtr == (unsigned)(void *)OSPrioCur) {	// we have the lock already
   	*lock_count += 1;
   	OS_EXIT_CRITICAL();
   } else if (lock->OSEventCnt > 0) {				// If sem. is positive, resource available ...
      lock->OSEventCnt--;								// ... decrement semaphore only if positive.
      *lock_count = 0;									// init lock count
      lock->OSEventPtr = (void *)OSPrioCur;		// set that we have the lock
      OS_EXIT_CRITICAL();
   } else if (bios_intnesting > 0) {				// See if called from ISR ...
      OS_EXIT_CRITICAL();								// ... can't PEND from an ISR
   } else {													// Otherwise, must wait until event occurs
      OSTCBCur->OSTCBStat    |= OS_STAT_SEM;		// Resource not available, pend on semaphore
      OSTCBCur->OSTCBDly      = 0;					// Store pend timeout in TCB
      OS_EventTaskWait(lock);							// Suspend task until event or timeout occurs
      OS_EXIT_CRITICAL();
      OS_Sched(); 											// Find next highest priority task ready
      OS_ENTER_CRITICAL();
		lock->OSEventPtr = (void *)OSPrioCur;		// we got the lock back
      if (OSTCBCur->OSTCBStat & OS_STAT_SEM) {	// Must have timed out if still waiting for event
         OS_EventTO(lock);
         OS_EXIT_CRITICAL();
      } else {
         OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
         OS_EXIT_CRITICAL();
      }
   }
}

__nodebug void IPSemPost(OS_EVENT *lock, char *lock_count)
{
    OS_ENTER_CRITICAL();
#if 0
    if (lock == (OS_EVENT *)0) {						// Validate 'pevent'
        OS_EXIT_CRITICAL();
        return; // (OS_ERR_PEVENT_NULL);
    }
    if (lock->OSEventType != OS_EVENT_TYPE_SEM) {	// Validate event block type
        OS_EXIT_CRITICAL();
        return; // (OS_ERR_EVENT_TYPE);
    }
#endif
    if ((unsigned)(INT8U)lock->OSEventPtr == (unsigned)(void *)OSPrioCur) {
    	if(*lock_count > 0) {
    		*lock_count -= 1;
    		OS_EXIT_CRITICAL();
    		return; // just decrement the count - lock will be freed later
    	}
    }
    lock->OSEventPtr = (void *)OS_PRIO_INVALID;	// freeing the lock - mark it as not used

    if (lock->OSEventGrp) {							// See if any task waiting for semaphore
        OS_EventTaskRdy(lock, (void *)0, OS_STAT_SEM);	// Ready highest prio task waiting on event
        OS_EXIT_CRITICAL();
        OS_Sched();										// Find highest priority task ready to run
        return; // (OS_NO_ERR);
    } else {
        if (lock->OSEventCnt < 65535) {			// Make sure semaphore will not overflow
            lock->OSEventCnt++;						// Increment semaphore count to register event
            OS_EXIT_CRITICAL();
            return; // (OS_NO_ERR);
        } else {											// Semaphore value has reached its maximum
            OS_EXIT_CRITICAL();
            return; // (OS_SEM_OVF);
        }
    }
}
#endif

_net_nodebug
int sock_init ()
{
   auto int i;
   auto longword timer;

#ifdef MCOS_LOCKS
	if (!_initialized) {
		TCPGlobalLock.lock = OSSemCreate(1);
		TCPGlobalLock.lock_count = 0;
		TCPGlobalLock.lock->OSEventPtr = NULL;
	#ifndef NET_COMMON_DNS_LOCK
		DNSGlobalLock.lock = OSSemCreate(1);
		DNSGlobalLock.lock_count = 0;
		DNSGlobalLock.lock->OSEventPtr = NULL;
   #endif
	}
#endif
	if (_initialized) {
		_abort_socks(NETERR_IFDOWN, IF_ANY);

		// Clobber interfaces
		_if_request = 0;
		_if_prequest = 0;
		_if_actual = 0;
		_if_dhcp = 0;
		_if_dhcp_lease = 0;
		for (i = 0; i < IF_MAX; i++)
			_if_tab[i].up = 0;
	}

#ifdef USING_SSL
	tls_init(NULL);
#endif

	_arp_init();

   // Initialize packet driver(s)
   if (pkt_init()) return 1;

#ifdef USE_IGMP
	_igmp_init();
#endif

#ifndef DISABLE_TCP
	tcp_sock_init();
#endif

#ifndef DISABLE_UDP
	udp_sock_init();
#endif

#ifndef DISABLE_DNS
	_dns_init();
#endif

	// Exit here if we've already run sock_init()
   if (_initialized) return 0;

#ifdef USE_SNMP
	// Initialise the SNMP timers and base epoch
	_snmp.ms_ref = MS_TIMER;
	_snmp.upd_timeout = _SET_SHORT_TIMEOUT(30000);

#endif

   // Reset the various tables
   memset(_hostname, 0, sizeof(_hostname));


   //prt_nicreg(0);

	// This is necessary to allow the ethernet to come online, as it were.  This delay can be as
	// short as 50ms or less, but some switching hubs with auto-negotiate take longer.  We
	// take the conservative approach and allow 1 second.  This is only needed at boot time.
	// If not done, the consequences are not severe, except that initial packet(s) will be
	// dropped.  This sucks, but there is no way to tell whether the device is ready to send.
   // pd_havelink() returns true even if not ready.  Sigh.
#if USING_ETHERNET
	// This was only for some of the external chipsets.  Define this macro in the
	// appropriate section in BOARD_DEPS.LIB if needed.
	#ifdef _ETHERNET_INIT_DELAY_MS
	timer = _SET_SHORT_TIMEOUT(_ETHERNET_INIT_DELAY_MS);
	while (!_CHK_SHORT_TIMEOUT(timer));
	#endif
#endif
	//prt_nicreg(0);

   _initialized = 1;	// This indicates sock_init() has been called at least once.

   tcp_config_defaults();

	// Check ARP timeouts (and other background processes) at most about 5Hz
	_arp_tick_strat = _SET_SHORT_TIMEOUT(207);

   return 0;
}



/*** BeginHeader sock_init_or_exit */
void sock_init_or_exit(int verbose);
#ifndef NET_SIOE_TIMEOUT
	// Default timeout for message interval.  Message seen if takes this
	// long to bring default interface up.
	#define NET_SIOE_TIMEOUT 5000L
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sock_init_or_exit                   <NET.LIB>

SYNTAX: void sock_init_or_exit(int verbose);

KEYWORDS:		tcpip

DESCRIPTION: 	This is a convenience function intended mainly for sample
               code which starts a network interface.  It is equivalent
               to the following sequence:

                 if (sock_init() != 0)
                    exit(-NETERR_IFDOWN);
                 while (ifpending(IF_DEFAULT) == IF_COMING_UP)
                    tcp_tick(NULL);
                 if (ifpending(IF_DEFAULT) != IF_UP)
                    exit(-NETERR_IFDOWN);

               In other words, it attempts to initialize the network stack
               via sock_init().  It then waits for the default interface
               to come active (or fail).  If the default interface fails
               to start, then exit() is called.

               This function is primarily for debugging and sample code,
               since there is an indeterminate wait for
               the interface to start.  Production applications may not
               wish to incur this delay at startup, and also they should
               handle network errors in a manner other that exit() since
               exit() is really only useful in a debug environment.

               In particular, if the interface is a WiFi interface, then
               this function will wait until the interface is associated
               with an access point.  If it appears to wait indefinitely,
               then there is probably an error in the configuration such
               as a mis-typed SSID, or incorrect security keys.

               NOTE: don't use this function if you intend the network
               interface to be down after sock_init().

PARAMETER1:    non-zero to print handy message on success.  Message shows
					IP address and netmask of default interface.  Also will
					print messages at intervals while the interface is in a
					pending state.  This can happen if the interface takes
					a long time to come up.  In the case of an ethernet interface,
					if you accidentally leave the cable unplugged then this
					function will loop forever, printing messages at a default
					5 second interval.

RETURN VALUE:  none.  May exit(-NETERR_IFDOWN) if error.

SEE ALSO:      sock_init, ifpending, tcp_tick

END DESCRIPTION **********************************************************/

__debug
void sock_init_or_exit(int verbose)
{
	auto char ip[16], netmask[16];
	auto longword tmo;
	auto word iface, cucount, cuif, upif;

	if (verbose)
		printf("sock_init_or_exit: hit any key to terminate\n");
	if (sock_init()) {
		if (verbose)
			printf("sock_init_or_exit: sock_init() failed\n");
		exit(-NETERR_IFDOWN);
	}
	tmo = _SET_TIMEOUT(NET_SIOE_TIMEOUT);
#ifdef MULTI_IF
	upif = 0;
	cuif = 0;
	do {
		tcp_tick(NULL);
		cucount = 0;
		for (iface = 0; iface < IF_MAX; ++iface) {
			if (ifpending(iface) == IF_COMING_UP) {
				++cucount;
				if (!(cuif & 1u<<iface)) {
					if (verbose)
						printf("sock_init_or_exit: interface %u coming up\n", iface);
					cuif |= 1u<<iface;
				}
			}
			else if (ifpending(iface) == IF_UP) {
				if (!(upif & 1u<<iface)) {
					if (verbose)
						printf("sock_init_or_exit: interface %u now up\n", iface);
					upif |= 1u<<iface;
				}
			}
		}
		if (_CHK_TIMEOUT(tmo)) {
			if (verbose)
				printf("sock_init_or_exit: %u interface(s) still coming up\n", cucount);
			tmo = _SET_TIMEOUT(NET_SIOE_TIMEOUT);
		}
		if (kbhit()) {
			break;
		}
	} while (cucount);
   if (verbose)
      ip_print_ifs();
#else
	while (ifpending(IF_DEFAULT) == IF_COMING_UP) {
		tcp_tick(NULL);
		if (_CHK_TIMEOUT(tmo)) {
			if (verbose)
				printf("sock_init_or_exit: waiting for interface...\n");
			tmo = _SET_TIMEOUT(NET_SIOE_TIMEOUT);
		}
		if (kbhit()) {
			if (verbose)
				ip_print_ifs();
			return;
		}
	}
	if (ifpending(IF_DEFAULT) != IF_UP) {
		if (verbose)
			printf("sock_init_or_exit: interface failed to start\n");
		exit(-NETERR_IFDOWN);
	}
	if (verbose) {
		inet_ntoa(ip, _if_tab[IF_DEFAULT].ipaddr);
		inet_ntoa(netmask, _if_tab[IF_DEFAULT].mask);
		printf("Network default interface up at IP=%s  mask=%s\n", ip, netmask);
		ip_print_ifs();
	}
#endif
}


/*** BeginHeader */

/* START FUNCTION DESCRIPTION ********************************************
ntohs                                  <NET.LIB>

SYNTAX: word ntohs( word value );

KEYWORDS:		tcpip, byte order, network order

DESCRIPTION: 	convert a network ordered word to a host ordered word.
               This is a macro.

PARAMETER1: 	networked ordered word

RETURN VALUE:  network word in host format exa. 0xff00 == ntohs(0x00ff)

SEE ALSO:      htons, ntohl, htonl

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
ntohl                                  <NET.LIB>

SYNTAX: longword ntohl( longword value );

KEYWORDS:		tcpip, byte order, network order

DESCRIPTION: 	convert a network ordered double word to a host ordered
               double word.  This is a macro.

PARAMETER1: 	network ordered word

RETURN VALUE:  network word in host format exa. 0x11223344 ==
               ntohl(0x44332211)

SEE ALSO:      htons, ntohs, htonl

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
htons                                  <NET.LIB>

SYNTAX: word htons( word value );

KEYWORDS:		tcpip, byte order, network order

DESCRIPTION: 	convert a host ordered word to a network ordered word.
               This is a macro.

PARAMETER1: 	host ordered word

RETURN VALUE:  host word in network format exa. 0x2211 == ntohs(0x1122)

SEE ALSO:      htonl, ntohl, ntohs

END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
htonl                                  <NET.LIB>

SYNTAX: longword htonl( longword value );

KEYWORDS:		tcpip, byte order, network order

DESCRIPTION: 	convert a host ordered double word to a network ordered
               double word.  This is a macro.

PARAMETER1: 	host ordered word

RETURN VALUE:  host word in network format exa. 0x11223344 ==
               ntohl(0x44332211)

SEE ALSO:      htons, ntohs, ntohl

END DESCRIPTION **********************************************************/
#ifndef ntohs
#define ntohs intel16
#define htons intel16
#define ntohl intel
#define htonl intel
#endif
/*** EndHeader */

/*** BeginHeader sock_rbsize */
/* START FUNCTION DESCRIPTION ********************************************
sock_rbsize                            <NET.LIB>

SYNTAX: int sock_rbsize( void* s );

KEYWORDS:		tcpip, socket

DESCRIPTION: 	returns the size of the read buffer

PARAMETER1: 	socket

RETURN VALUE:  size of the read buffer for the socket

SEE ALSO:      sock_rbused, sock_rbleft, sock_tbsize,	sock_tbused,
               sock_tbleft

END DESCRIPTION **********************************************************/

int sock_rbsize( void *s );
/*** EndHeader */

_net_nodebug
int sock_rbsize( void* s )
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
#ifndef DISABLE_UDP
   if (_IS_UDP_SOCK(s))
   	return _UDP_FIELD(s, rd.maxlen);
#endif
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s))
   	return _TCP_FIELD(s, app_rd->maxlen);
#endif
   	return 0;
}

/*** BeginHeader sock_rbused */
/* START FUNCTION DESCRIPTION ********************************************
sock_rbused                            <NET.LIB>

SYNTAX: int sock_rbused( void* s );

KEYWORDS:		tcpip, socket

DESCRIPTION: 	returns the number of used bytes in the receive buffer

PARAMETER1: 	socket

RETURN VALUE:  number of used bytes in the receive buffer

SEE ALSO:      sock_rbsize, sock_rbleft, sock_tbsize, sock_tbused,
               sock_tbleft

END DESCRIPTION **********************************************************/

int sock_rbused( void *s );
/*** EndHeader */

_net_nodebug
int sock_rbused( void *s )
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
#ifndef DISABLE_UDP
   if (_IS_UDP_SOCK(s))
   	return _UDP_FIELD(s, rd.len);
#endif
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s))
   	return _TCP_FIELD(s, app_rd->len);
#endif
   	return 0;
}

/*** BeginHeader sock_rbleft */
/* START FUNCTION DESCRIPTION ********************************************
sock_rbleft                            <NET.LIB>

SYNTAX: int sock_rbleft( void* s );

KEYWORDS:		tcpip, socket

DESCRIPTION: 	returns the number of bytes left in the receive buffer

PARAMETER1: 	socket

RETURN VALUE:  number of bytes left in the receive buffer

SEE ALSO:      sock_rbsize, sock_rbused, sock_tbsize, sock_tbused,
               sock_tbleft

END DESCRIPTION **********************************************************/

int sock_rbleft( void *s );
/*** EndHeader */

_net_nodebug
int sock_rbleft( void *s )
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
#ifndef DISABLE_UDP
   if (_IS_UDP_SOCK(s))
   	return _UDP_FIELD(s, rd.maxlen) - _UDP_FIELD(s, rd.len);
#endif
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s))
   	return _TCP_FIELD(s, app_rd->maxlen) - _TCP_FIELD(s, app_rd->len);
#endif
   	return 0;
}

/*** BeginHeader sock_tbsize */
/* START FUNCTION DESCRIPTION ********************************************
sock_tbsize                            <NET.LIB>

SYNTAX: int sock_tbsize( void* s );

KEYWORDS:		tcpip, socket

DESCRIPTION: 	returns the size of the transmit buffer

PARAMETER1: 	socket

RETURN VALUE:  size of the transmit buffer for the socket

SEE ALSO:      sock_rbsize, sock_rbused, sock_rbleft, sock_tbused,
               sock_tbleft

END DESCRIPTION **********************************************************/

int sock_tbsize( void *s );
/*** EndHeader */


_net_nodebug
int sock_tbsize( void *s )
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s))
   	return _TCP_FIELD(s, app_wr->maxlen);
#endif
   	return 0;
}

/*** BeginHeader sock_tbused */
/* START FUNCTION DESCRIPTION ********************************************
sock_tbused                            <NET.LIB>

SYNTAX: int sock_tbused( void* s );

KEYWORDS:		tcpip, socket

DESCRIPTION: 	returns the number of byte used in the transmit buffer

PARAMETER1: 	socket

RETURN VALUE:  number of byte used in the transmit buffer

SEE ALSO:      sock_rbsize, sock_rbused, sock_rbleft, sock_tbsize,
					sock_tbleft

END DESCRIPTION **********************************************************/

int sock_tbused( void *s );
/*** EndHeader */

_net_nodebug
int sock_tbused( void *s )
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s))
   	return _TCP_FIELD(s, app_wr->len);
#endif
   	return 0;
}

/*** BeginHeader sock_tbleft */
/* START FUNCTION DESCRIPTION ********************************************
sock_tbleft                            <NET.LIB>

SYNTAX: int sock_tbleft( void* s );

KEYWORDS:		tcpip, socket

DESCRIPTION: 	returns the number of bytes left in the transmit buffer

PARAMETER1: 	socket

RETURN VALUE:  number of bytes left in the transmit buffer

SEE ALSO:      sock_rbsize, sock_rbused, sock_rbleft, sock_tbsize,
					sock_tbused

END DESCRIPTION **********************************************************/

int sock_tbleft( void *s );
/*** EndHeader */

_net_nodebug
int sock_tbleft( void *s )
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s))
   	return _TCP_FIELD(s, app_wr->maxlen) - _TCP_FIELD(s, app_wr->len);
#endif
   	return 0;
}


/*** BeginHeader _add_server */
void _add_server( int *counter, int max, longword *array, longword value );
/*** EndHeader */

#ifdef _DC10_LEGACY
_net_nodebug void _add_server( int *counter, int max, longword *array, longword value )
{
   auto int i, duplicate;

   duplicate=0;

   if( value && ( *counter < max )) {
      for(i=0;i<*counter; i++) {
         if( array[i] == value)
            duplicate=1;
      }
      if(!duplicate)
         array[ (*counter)++ ] = value;
   }
}
#else
	#error "_add_server() deprecated."
#endif


/*** BeginHeader if_max_mtu */
word if_max_mtu(int iface);
/*** EndHeader */

_net_nodebug word if_max_mtu(int iface)
{
	// Return the maximum allowable MTU for a given interface number
	if (IF_PKT_SER(iface))
		return ETH_BUFSIZE - PPP_OVERHEAD;
	else if (IF_USES_ETH(iface))
		return ETH_BUFSIZE - ETH_OVERHEAD;
	else if (IF_PKT_REAL_WIFI(iface))
		return ETH_BUFSIZE - WIFI_OVERHEAD;
	return ETH_BUFSIZE - PPPOE_OVERHEAD;
}


/*** BeginHeader ifctl_tick */
int ifctl_tick(int iface);
/*** EndHeader */
/*
	This is only called for interfaces where _if_request is not equal to _if_actual.
	Also, if _if_request is not equal to _if_prequest, then an up/down is in progress.
	(Both above tests are per interface bit in a bitmask)
 */

_net_nodebug
int ifctl_tick(int iface)
{
	auto word up, change;
	auto longword ipaddr;
	auto ATHandle ath;
	auto word ifmask;
	auto int retval;
   auto IFTEntry * ie;
#ifdef USE_DHCP
	auto word dhcp;
#endif

	ifmask = 1 << iface;
	ie = _if_tab + iface;

	up = _if_request & ifmask;
	change = (_if_request ^ _if_prequest) & ifmask;
#ifdef USE_DHCP
	if (!up && change)
	{
   	if (ie->flags & IFF_DHCP_OK)
   	{
	      // First time down for DHCP, and it was up
	      ie->dhcp->state = DHCP_ST_RELEASE;
	      retval = dhcp_tick(iface);
      }
      else if (_if_dhcp & ifmask)
      {
      	// First time down for DHCP, and it was not yet up.  Just abandon
         // the state machine.
			_if_dhcp &= ~ifmask;
      }
   }
	if (dhcp = _if_dhcp & ifmask)
	{
   	retval = dhcp_tick(iface);
      if (retval != IFCTL_PEND)
      {
      	_if_dhcp &= ~ifmask;
      }
	#ifdef USE_LINKLOCAL
	   else if (up && ie->linklocal)
	   {
	   	// Try to bring up a link-local address while DHCP is pending.
	      linklocal_tick( iface);
	   }
	#endif
   }
   else
#endif
   {
	   if (ie->ncd->ifctl)
	   {
	      retval = ie->ncd->ifctl(ie->state, up, change);
	   }
	   else
	   {
	      retval = IFCTL_OK;
	   }
	   _if_prequest ^= change;
	}
#ifdef USE_DHCP
	if (up && retval == IFCTL_OK && !dhcp && ie->flags & IFF_DHCP)
	{
	#ifdef USE_LINKLOCAL
		if (ie->linklocal)
		{
			/*
			   This interface's link is just now up and DHCP is about to be
			   initiated, but link-local addressing is in use and may have
			   previously configured a link-local address. Temporarily disable
			   link-local addressing so as to cede priority to DHCP (per RFC 3297,
			   section 2.11).
			*/
			linklocal_disable(iface);
		}
	#endif
   	// Link and basic IP layers up successfully, and not already doing dhcp
   	// acquisition, and want to do dhcp for this interface: start off the dhcp process.
		retval = dhcp_init(iface);
      if (retval == IFCTL_PEND)
      {
      	_if_dhcp |= ifmask;	// Mark for continuation next time.
      }
   }
#endif

	if (retval == IFCTL_OK)
	{
		ie->up = up ? 1 : 0;
      #if VIRTUAL_ETH
	      // If this is ethernet, bring up/down any dependent virtual interfaces
	      virtual_set(iface, ie->up);
      #endif

		if (up)
		{
      	// Finished coming up
			_if_actual |= ifmask;

			// Check now for consistent IP address.  If not, abort current sockets.
			// This can happen with Wifi where we roam to a different network
			// or DHCP gives us a different addr than when we disassociated.
			if (!ie->ipaddr) {
				// Statically configured
				ie->ipaddr = ie->static_ip;
				ie->mask = ie->static_mask;
			}
			if (ie->ldown_ipaddr &&
					(ie->ldown_ipaddr != ie->ipaddr || ie->ldown_mask != ie->mask))
				_abort_socks(NETERR_IFDOWN, IF_ANY);
			ie->ldown_ipaddr = 0;
			ie->ldown_mask = 0;

			// For efficiency, initiate ARP resolution for default router and DNS
			// server, as applicable.  The DNS server is resolved if available,
			// since it is likely to be either the same as the router, or accessible
			// via the router.  Otherwise, just the default router is resolved.
			// Note that these "starts" are never completed, since the purpose is
			// only to populate the ARP cache.
		#ifndef DISABLE_DNS
			if (ipaddr = servlist_first(&_dns_server_table, 0, NULL))
				arpresolve_start(ipaddr);
			else
		#endif
			if ((ath = router_for_iface(0, NULL, NULL, IF_DEFAULT)) >= 0) {
				arpcache_ipaddr(ath, &ipaddr);
				arpresolve_start(ipaddr);
			}
		}
		else
		{
      	// Finished coming down
			_if_actual &= ~ifmask;
         arpcache_purge_iface(iface);
         #ifdef USE_DHCP
         // Turn off these flags
			ie->flags &= ~(IFF_DHCP_OK|IFF_DHCP_FELLBACK);
         #endif
         // Zero these out to avoid use of bad addr
         ie->ipaddr = 0;
         ie->mask = 0;
		}
#ifdef USE_IF_CALLBACK
		if (ie->ifcallback)
		{
			ie->ifcallback(iface, up);
		}
#endif
	}
	else if (retval == IFCTL_FAIL)
	{
		// On failure, make requested state = actual state to prevent
		// repeated retrying - application will need to recover.
		if (up)
		{
			_if_request &= ~ifmask;
		}
		else
		{
			_if_request |= ifmask;
		}
		_if_prequest = _if_prequest & ~ifmask | _if_request & ifmask;
	}
	return retval;
}

/*** BeginHeader ifctl_ethernet */
int ifctl_ethernet(int iface, int up, int change);
/*** EndHeader */

_net_nodebug int ifctl_ethernet(int iface, int up, int change)
{
#ifdef USE_LINKLOCAL
	auto int retval;
#endif

	// Only action required is to possibly issue ARP probe for our IP address
	// when coming up.  Note that this function is called by individual driver
   // ifctl() functions, if they are ethernet drivers.
	if (up && !pd_havelink(iface))
	{
   	return IFCTL_PEND;
	}

#ifdef USE_LINKLOCAL
	if (up && linklocal_is_enabled( iface))
	{
		// bringing up a non-DHCP interface with link-local addressing
		if ( (retval = linklocal_tick( iface)) != IFCTL_OK )
		{
			return retval;
		}
	}
#endif

#ifndef ARP_NO_ANNOUNCE
	if (up && _if_tab[iface].ipaddr && !(_if_tab[iface].flags & IFF_DHCP))
	{
		// We think we have a valid IP address.  Send an ARP request to make sure
		// nobody else is claiming the same address.  We won't know the result
		// until later.  Don't do this if going to use DHCP, since DHCP
		// effectively does this check anyway.
		_arp_request(_if_tab[iface].ipaddr, 0, iface);
	}
#endif
	return IFCTL_OK;
}


/*** BeginHeader ifpending */
int ifpending(int iface);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ifpending                               <NET.LIB>

SYNTAX: int ifpending(int iface)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Returns indication of whether the specified interface is
               up, down, pending up or pending down at the network (IP
               connectivity) level.  This reveals more
               information than ifstatus(), which only indicates the
               current state (up or down).

               Note: ANDing the return value with 0x01 indicates a
               pending condition; ANDing with 0x02 is equivalent to
               the return from ifstatus(), except that ifstatus()
               returns '1' instead of '2'.

               Example:
                 // assume IF_DEFAULT is down.  Bring it up...
                 ifconfig(IF_DEFAULT, IFS_UP, IFS_END);
                 while (ifpending(IF_DEFAULT) == IF_COMING_UP)
                    tcp_tick(NULL);
                 if (ifpending(IF_DEFAULT) == IF_UP)
                    // came up OK
                 else
                    // failed to come up

PARAMETER1: 	iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.

RETURN VALUE:  IF_DOWN if interface is down and not pending up,
               IF_COMING_UP if interface is down but pending up,
               IF_UP if interface is up and not pending down,
               IF_COMING_DOWN if interface is up but pending down.

SEE ALSO:      ifconfig, ifdown, ifup, ifstatus
END DESCRIPTION **********************************************************/
_net_nodebug
int ifpending(int iface)
{
	auto word mask;

	mask = 1u << iface;
	if (_if_request & mask)
		if (_if_actual & mask)
			return IF_UP;
		else
			return IF_COMING_UP;
	else
		if (_if_actual & mask)
			return IF_COMING_DOWN;
		else
			return IF_DOWN;
}


/*** BeginHeader linkpending */
int linkpending(int iface);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
linkpending                               <NET.LIB>

SYNTAX: int linkpending(int iface)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Returns indication of whether the specified link is
               up, down, pending up or pending down.  This is similar
               to ifpending(), except that it shows the lower level
               (link) status.  Ethernet has a simple link status which
               is achieved mostly at the hardware level.  WiFi is
               more complex, since there are a number of packets
               exchanged before the station is associated with an
               access point (or ad-hoc network).

               Note: ANDing the return value with 0x01 indicates a
               pending condition.


PARAMETER1: 	iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.

RETURN VALUE:  IF_DOWN if link is down and not pending up,
               IF_COMING_UP if link is down but pending up,
               IF_UP if link is up and not pending down,
               IF_COMING_DOWN if link is up but pending down.

SEE ALSO:      ifpending
END DESCRIPTION **********************************************************/
_net_nodebug
int linkpending(int iface)
{
	int up = pd_havelink(iface) && _if_tab[iface].lnk;
	//Note: currently, don't check pending.
	return up ? IF_UP : IF_DOWN;
}

/*** BeginHeader ifup */
int ifup(int iface);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ifup                               <NET.LIB>

SYNTAX: int ifup(int iface);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function attempts to activate the specified
               interface.  The action depends on the previous status
               reported by ifpending().

               ifpending()     Action
               --------------  ---------------------------------
               IF_UP           None, returns IFCTL_OK.
               IF_COMING_UP    None, returns IFCTL_PEND.
               IF_DOWN         Starts bringing interface up
                                using normal procedure.
               IF_COMING_DOWN  Depends on interface capabilities:
                                see below, but note that in
                                practice this always returns
                                IFCTL_FAIL.

               If the interface is currently "coming down", then the
               action taken when ifup() is called depends on the
               interface.  Some interfaces may not allow the interface
               to come back up in this condition, in which case
               IFCTL_FAIL will be returned.  Try again later when the
               interface is fully down, or you can call ifdown()
               to force the interface down immediately.  If the
               interface allows changing requested state when
               coming down, then the return value will be either
               IFCTL_PEND or IFCTL_OK.  Currently, the only interface
               types which do not come down instantly are PPP over
               async serial and PPPoE.  These do NOT currently
               implement calling ifup() when they are pending down.

PARAMETER1: 	iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.

RETURN VALUE:  IFCTL_OK if OK,
               IFCTL_FAIL if error (bad iface or iface is coming down),
               IFCTL_PEND if OK but not complete.

SEE ALSO:      ifconfig, ifdown, ifstatus, ifpending

END DESCRIPTION **********************************************************/

_net_nodebug
int ifup(int iface)
{
	auto word pend;

	if (iface >= IF_MAX)
		return IFCTL_FAIL;
	if ((pend = ifpending(iface)) == IF_UP)
		return IFCTL_OK;
   if (pend == IF_COMING_UP)
   	return IFCTL_PEND;
   if (pend == IF_COMING_DOWN)
   	return IFCTL_FAIL;
	_if_request |= 1 << iface;
	return ifctl_tick(iface);
}

/*** BeginHeader ifdown */
int ifdown(int iface);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ifdown                               <NET.LIB>

SYNTAX: int ifdown(int iface);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function attempts to deactivate the specified
               interface.  The action depends on the previous status
               reported by ifpending().

               ifpending()     Action
               --------------  ---------------------------------
               IF_DOWN         None, returns IFCTL_OK.
               IF_COMING_UP    Cancels bringing up, starts down.
               IF_UP           Starts bringing interface down
                                using normal "graceful" procedure.
               IF_COMING_DOWN  Forces down.  This cuts short any
                                normal termination procedure.

PARAMETER1: 	iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.

RETURN VALUE:  IFCTL_OK if OK,
               IFCTL_FAIL if error,
               IFCTL_PEND if OK but not complete.

SEE ALSO:      ifconfig, ifup, ifstatus, ifpending

END DESCRIPTION **********************************************************/

_net_nodebug
int ifdown(int iface)
{
	auto word pend, mask;

	if (iface >= IF_MAX)
		return IFCTL_FAIL;
	if (IF_DOWN == (pend = ifpending(iface)))
		return IFCTL_OK;
   mask = 1<<iface;
   if (pend == IF_COMING_DOWN) {
   	_if_actual &= ~mask;	// Cut short
      _if_prequest &= ~mask;
      return IFCTL_OK;
   }
   if (pend == IF_COMING_UP) {
   	// If it was coming up, pretend it was fully up so that the ifctl_tick function gets driven.
      _if_actual |= mask;
      _if_prequest |= mask;
   }
	_if_request &= ~mask;
	_abort_socks(NETERR_IFDOWN, iface);
	return ifctl_tick(iface);
}

/*** BeginHeader ifmtu */
int ifmtu(int iface, longword ip);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ifmtu                               <NET.LIB>

SYNTAX: int ifmtu(int iface, longword ip)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Returns MTU (maximum transmission unit) of specified
					interface, optionally for a given IP address destination.

PARAMETER1: 	iface - interface number, or IF_ANY.
PARAMETER2: 	IP address.  If zero, get minimum MTU.  If 0xFFFFFFFF,
					get maximum MTU.  Otherwise, try to get a better path MTU
               estimate when using the given IP address as a destination.

RETURN VALUE:  Interface MTU.
END DESCRIPTION **********************************************************/
_net_nodebug
int ifmtu(int iface, longword ip)
{
	int do_min = ip == 0;
   int emtu = do_min ? 32767 : 0;
   int mtu;
   IFTEntry * ifte;

	if (iface != IF_ANY) {
		ifte = _if_tab + iface;
      mtu = ifte->ncd->ioctl(ifte->state, PD_MTU_BY_IPADDR, ip);
      if (!mtu)
      	mtu = ifte->mtu;
      return mtu;
   }

   // Loop over all interfaces
	for (iface = 0; iface < IF_MAX; ++iface) {
   	if (!is_valid_iface(iface))
      	continue;
      mtu = ifmtu(iface, ip);
      if (do_min) {
      	if (mtu < emtu)
         	emtu = mtu;
      }
      else {
      	if (mtu > emtu)
         	emtu = mtu;
      }
	}
	return emtu;
}



/*** BeginHeader ifconfig */
int ifconfig(int iface,...);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ifconfig                               <NET.LIB>

SYNTAX: int ifconfig(int iface,...);

KEYWORDS:      tcpip, socket

DESCRIPTION:   This function sets and gets network parameters at runtime.
               An arbitrary number of parameters may be set or retrieved
               in one call.

               Example:
                 ifconfig(IF_ETH0,
                   IFS_IPADDR, aton("10.10.6.100"),
                   IFS_NETMASK, 0xFFFFFF00uL,
                   IFS_ROUTER_SET, aton("10.10.6.1"),
                   IFS_NAMESERVER_SET, aton("192.68.1.123"),
                   IFS_NAMESERVER_ADD, aton("192.68.1.124"),
                   IFS_UP,
                   IFS_END);

               This example assumes the interface is initially down.
               It configures the home IP address, netmask, router (gateway), and
               two nameservers.  Finally, the interface is made
               active (IFS_UP).  IFS_END is required to terminate the
               parameter list.

               **NOTE**

                 Since bringing the interface up/down may take a long time
                 for certain interface types, particularly when DHCP is used,
                 it is not recommended to use IFS_DOWN in combination with
                 parameters which require the interface to be down, such as
                 IFS_IPADDR.  Use of IFS_DOWN (or implicit use) may cause
                 unexpected behavior.

                 It is OK to use IFS_UP at the end of the parameter list.

                 To bring an interface down cleanly, use the following
                 coding idiom:

                   ifdown(IF_ETH0);
                   while (ifpending(IF_ETH0) == IF_COMING_DOWN)
                   	tcp_tick(NULL);

                 (substitute the appropriate interface identifier for
                 IF_ETH0 in the above).


               Debugging note: if you experience an error dialog indicating
               "bad parameter passed to I/O function", this is often
               caused by this function encountering a bad parameter.  In this
               case, it is easier to debug if you temporarily
                 #define NET_VERBOSE
               at the top of your application code.  This will cause this
               function to print some more details about the parameter that
               it found to be in error.  The parameter numbers refer to
               IFS/IFG parameter identifiers, not to the sub-parameters of
               the identifiers.  In the above example, IFS_DOWN would be
               considered the first parameter, and IFS_UP would be the 7th
               (not the 12th).

               Most errors are caused by:
               1. passing an int when a long is expected, so be sure to add
                  the appropriate cast in your code.
               2. forgetting to terminate the parameter list with IFS_END.

PARAMETER1:    iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
                 IF_ANY
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.  IF_ANY may be used only for the
               parameters which are not specific to any particular
               interface.  It can also be used, where applicable, to
               mean "all interfaces" if the operation would make
               sense when applied to all interfaces.
PARAMETER2:    Parameters 2 through n are polymorphic (like printf()
               parameters).  Parameters are provided in groups (usually
               pairs) with the first param in the group being one of a
               documented set of identifiers, and subsequent params in
               the group being the value specific to that identifier.
               The list of param groups MUST be terminated using the
               identifier "IFS_END".   The parameter identifiers are:

Command                    Parameters     Description
------------------------   ------------   ----------------------------
IFS_END                    none           End of parameter list
IFS_UP                     none           Bring up interface
IFS_DOWN                   none           Bring down interface
IFS_IPADDR <1>             longword       Set home IP address. <18>
IFG_IPADDR                 longword *     Get home IP address
IFS_NETMASK                longword       Set netmask
IFG_NETMASK                longword *     Get netmask
IFS_MTU                    word           Set maximum trans. unit
IFG_MTU                    word *         Get MTU
IFS_ROUTER_SET <4>         longword       Delete all rounters, then set
                                          this one as a default router
IFS_ROUTER_SET_STATIC <4,5>               Set static router:
                           longword,         IP address of router
                           longword,         subnet served
                           longword          subnet mask
IFS_ROUTER_ADD <4>         longword       Add general rounter
IFS_ROUTER_ADD_STATIC <4,5>               Add static router:
                           longword,         IP address of router
                           longword,         subnet served
                           longword          subnet mask
IFS_ROUTER_DEL <4>         longword       Delete router.  If IP is 0,
                                          delete all routers.
IFG_ROUTER_DEFAULT <7>     longword *     Get default router
IFS_HWA <1>                byte *         Set hardware address (6 bytes)
IFG_HWA                    byte *         Get hardware address.  All zero
														bytes for interfaces without HWA.
IFS_NAMESERVER_SET <4>     longword       Delete all predefined name-
                                          servers, then set this one
IFS_NAMESERVER_ADD <4>     longword       Add nameserver to list <36>
IFS_NAMESERVER_DEL <4>     longword       Delete nameserver.  If IP
                                          is 0, delete all nameservers.
IFS_DHCP <8>               bool <2>       Use DHCP to configure this
                                          interface
IFG_DHCP <8>               bool *         Get whether DHCP to be used
                                          and interface is qualified
                                          to use DHCP.
IFG_DHCP_OK <8>            bool *         Get whether DHCP actually
                                          configured OK.
IFS_DHCP_TIMEOUT <8>       int            Set DHCP overall timeout in
                                          seconds.
IFG_DHCP_TIMEOUT <8>       int *          Get DHCP overall timeout in
                                          seconds.
IFS_DHCP_QUERY <8>         bool   <16>    Set whether DHCP uses INFORM.
IFG_DHCP_QUERY <8>         bool *         Get whether DHCP uses INFORM.
IFS_DHCP_DOMAIN <8>        bool           Set whether to use domain
                                          and/or hostname info.
IFG_DHCP_DOMAIN <8>        bool *         Get flag setting.
IFS_DHCP_FALLBACK <8>      bool           Set whether DHCP allows
                                          fallback to static config.
IFG_DHCP_FALLBACK <8>      bool *         Get whether DHCP allows
                                          fallback to static config.
IFS_DHCP_FB_IPADDR         longword       Set the DHCP fallback IP
                 <8>                      address. <17>
IFG_DHCP_FB_IPADDR <8>     longword *     Get the DHCP fallback IP
                                          address. <17>
IFG_DHCP_FELLBACK <8>      bool *         Get whether DHCP actually had
                                          to use fallbacks.
IFS_DHCP_OPTIONS <8>       int, char *,   Set DHCP custom options. <15>
                           int(*)()
IFG_DHCP_OPTIONS <8>       int *, char ** Get DHCP custom options.
IFG_DHCP_INFO <8>          DHCPInfo**     Get DHCP information, or NULL
                                          if not qualified.
IFS_ICMP_CONFIG <3,9>      bool           Allow "arp -s" ping to
                                          configure IP address
IFG_ICMP_CONFIG            bool *         Is ping configure enabled?
IFG_ICMP_CONFIG_OK         bool *         Get whether ping configured
                                          successfully.
IFS_ICMP_CONFIG_RESET      none           After ping configure OK, allow
                                          further ping conf.
IFS_DEBUG <4>              int            Set debug level
IFG_DEBUG <4>              int *          Get debug level
IFS_IF_CALLBACK <3,12>     void (*)()     Set interface up/down callback
                                          callback, or NULL.

The following commands are for PPP interfaces only: <14>

IFS_PPP_INIT               none           Sets up PPP with default
                                          parameters.  This should be
                                          used before any other PPP
                                          setting parameters.
IFS_PPP_SPEED              longword       Set serial PPP speed (bps)
IFG_PPP_SPEED              longword *     Get serial PPP speed
IFS_PPP_ACCEPTIP           bool           Accept peer's idea of our
                                          local IP address
IFG_PPP_ACCEPTIP           bool *
IFS_PPP_REMOTEIP           longword       Try to set peer's IP addr.
IFG_PPP_REMOTEIP           longword *
IFS_PPP_ACCEPTDNS          bool           Accept a DNS server IP address
                                          from peer
IFG_PPP_ACCEPTDNS          bool *
IFS_PPP_REMOTEDNS          longword,      Set DNS server IP addresses
                           longword       for peer (prim., sec.)
IFG_PPP_REMOTEDNS          longword *, longword *
IFS_PPP_AUTHCALLBACK       int (*)()      Called when a peer attempts
                                          to authenticate <10>
IFS_PPP_REMOTEAUTH         char *,char *  Sets username and password
                                          to give to peer.  If both empty,
                                          turns off PAP.
IFG_PPP_REMOTEAUTH         char **, char **
IFS_PPP_LOCALAUTH          char *,char *  Required username and password
                                          for incoming peer
IFG_PPP_LOCALAUTH          char **, char **
IFS_PPP_RTSPIN <11>        int, char *, int
                                          Define the RTS pin
IFG_PPP_RTSPIN             int *, char **, int *
IFS_PPP_CTSPIN <11>        int, int       Define the CTS pin
IFG_PPP_CTSPIN             int *, int *
IFS_PPP_FLOWCONTROL        bool           Turn hardware flow control on
                                          or off
IFG_PPP_FLOWCONTROL        bool *
IFS_PPP_USEPORTD           bool           Use parallel port D instead of
                                          par port C for serial ports
                                          A and B. For Rabbit4000 process-
                                          ors, Serial ports E and F use
                                          this define as well.
IFG_PPP_USEPORTD           bool *
IFS_PPP_USEPORTE           bool           Use parallel port E instead of
                                          par port C for serial ports
                                          E and F. (Rabbit 4000 only)
IFG_PPP_USEPORTE           bool *
IFG_PPP_PEERADDR           longword *     Get the PPP peer address.
                                          Returns 0 if no connection.

IFS_PPP_PASSIVE            bool           Set passive mode for PPP.
                                          If TRUE, then interface will
                                          wait indefinitiely for a
                                          connection after its initial
                                          connection attempt.
IFG_PPP_PASSIVE            bool *

The following commands are only for modems on PPP interfaces: <19>

IFS_PPP_SENDEXPECT         char *         A series of strings to send and
                                          then expect, each seperated by
                                          a carriage return('\r'). <13>
IFG_PPP_SENDEXPECT         char **
IFS_PPP_USEMODEM           bool           Specify whether to use modem
                                          dialout string.
IFG_PPP_USEMODEM           bool *
IFS_PPP_MODEMESCAPE        bool           Specify whether or not to
                                          add an escape sequence
                                          <delay>+++<delay> before
                                          sending send/expect or hangup
                                          strings
IFG_PPP_MODEMESCAPE        bool *
IFS_PPP_HANGUP             char *         Optional string to send to
                                          modem to shut it down, in
                                          send-expect format. <13>
IFG_PPP_HANGUP             char **

The following commands are only for PPP or VSPD interfaces, on Rabbit4000
processors, since they rely on the existence of DMA channels: <20>

IFS_USE_DMA                dma_chan_t,    Use the specified DMA channel
                           dma_chan_t,    instead of the serial port.
                           word           First channel for source,
                                          second for dest.  Last param
                                          specifies I/O port address -
                                          use 0 to select default.
IFS_USE_SERIAL             <none>         Use the serial port directly.
                                          This undoes the effect of
                                          IFS_USE_DMA.

The following commands are only for Wi-Fi interfaces: <21>

IFS_WIFI_SSID <1,22>       int, byte *    Set the SSID for the Wi-Fi
                                          device.  (length, buffer).  If the
                                          length is zero, then the SSID length
                                          is computed from the SSID up to but
                                          not including a null terminator.
IFG_WIFI_SSID <22>         int *, byte *  Get the currently configured
                                          SSID. (length, 32-byte buffer)
IFS_WIFI_MULTI_DOMAIN <1>  bool           Enable multi-domain (only
                                          works on AP with 802.11d).
IFG_WIFI_MULTI_DOMAIN      bool *         Is multi-domain enabled?
IFS_WIFI_REGION <1>        int            Set region <23>
IFG_WIFI_REGION            int *          Get region number <23>
IFG_WIFI_REGION_INFO       wifi_region *  Get region settings <23>
IFS_WIFI_MODE <1>          int            Join mode <37>
IFG_WIFI_MODE              int *				Get join mode <37>
IFS_WIFI_CHANNEL <1>       int            Set channel (1-14); if using
                                          infrastructure, can set to 0
                                          for automatic.
IFG_WIFI_CHANNEL           int *          Get current channel setting.
IFS_WIFI_ENCRYPTION <1>    word           Set encryption (none, WEP,
                                          TKIP or CCMP). <24>
IFG_WIFI_ENCRYPTION        word *
IFS_WIFI_AUTHENTICATION    word           Set authentication (any, open,
                                          shared, WPA PSK). <24>
IFG_WIFI_AUTHENTICATION    word *
IFS_WIFI_TX_RATE           int            Set max Tx rate <25>
IFG_WIFI_TX_RATE           int *          Get max Tx rate <25>
IFS_WIFI_TX_POWER          int            Set max Tx power (0-15)
IFG_WIFI_TX_POWER          int *          Get max Tx power setting
IFS_WIFI_FRAG_THRESHOLD    int (256-2346) Set fragment threshold
IFG_WIFI_FRAG_THRESHOLD    int *
IFS_WIFI_RTS_THRESHOLD     int (1-2347)   Set RTS (request-to-send)
                                          threshold
IFG_WIFI_RTS_THRESHOLD     int *
IFS_WIFI_SCAN              void (*)()     Initiate a Wi-Fi scan <26>
IFG_WIFI_STATUS            wifi_status *  Get current MAC status <27>

Commands for managing WEP<28> shared and WPA<29> pre-shared keys:

IFS_WIFI_WEP_KEYNUM        int            Set which of 4 WEP keys to use
IFG_WIFI_WEP_KEYNUM        int *
IFS_WIFI_WEP_KEY_BIN       int,           Set WEP key number param1
                           int,              to param2 bytes (5 or 13)
                           byte *            at param3
IFG_WIFI_WEP_KEY_BIN       int,           Get WEP key number param1
                           int *,            store length at param2
                           byte *            store key at param3
IFS_WIFI_WEP_KEY_HEXSTR    int,           Set WEP key # param1 to 10 or
                           char *         26 char hex string at param2
IFG_WIFI_WEP_KEY_HEXSTR    int,           Put WEP key # param1 in hex
                           char *         string at param2
IFS_WIFI_WPA_PSK_PASSPHRASE   char *      Set WPA PSK to hash based on
                                          SSID and passphrase in param2
IFS_WIFI_WPA_PSK_HEXSTR    char[65]       Set WPA PSK to 64-character
                                          hex string
IFG_WIFI_WPA_PSK_HEXSTR    char[65]       Get WPA PSK as a 64-character
                                          hex string
IFS_WIFI_WPA_PSK_BIN       byte[32]       Set 32-byte WPA PSK
IFG_WIFI_WPA_PSK_BIN       byte[32]       Get 32-byte WPA PSK

The following commands are related to Wi-Fi roaming:

IFS_WIFI_ROAM_ENABLE       bool   			Set Roaming on and off
IFG_WIFI_ROAM_ENABLE       bool *         Get Roaming enabled state

IFS_WIFI_ROAM_BEACON_MISS  int				Set number of beacons that must be
														missed before a scan for a new
														Access Point is initiated.
IFG_WIFI_ROAM_BEACON_MISS  int *          Get number of beacons that must be
														missed before a scan for a new
														Access Point is initiated.

Commands for WPA Enterprise (EAP-TLS and/or EAP-PEAP-MSCHAPV2)

IFS_WIFI_WPA_PROTOCOL		word         Set WPA and/or WPA2 (= RSN) protocols
IFG_WIFI_WPA_PROTOCOL		word *             <30>

IFS_WIFI_PAIRWISE_ENCRYPTION	word      Set encryption (none, WEP,
                                          TKIP or CCMP). <24,31>
IFG_WIFI_PAIRWISE_ENCRYPTION	word *

IFS_WIFI_EAP_TLS_FLAGS		word         Set flags passed to tls_set_flags()
                                          before opening TLS connection used for
                                          both EAP-TLS and EAP-PEAP-MSCHAPV2.
IFG_WIFI_EAP_TLS_FLAGS		word *

IFS_WIFI_EAP_METHODS			longword     Set acceptable EAP method.
IFG_WIFI_EAP_METHODS			longword *         <32>


IFS_WIFI_IDENTITY	         char *       Set identity string for EAP
IFG_WIFI_IDENTITY	         char **
IFS_WIFI_ANONYMOUS_IDENTITY	char *    Set anonymous identity string for
                                            "outer" EAP
IFG_WIFI_ANONYMOUS_IDENTITY	char **
IFS_WIFI_PASSWORD	         char *       Set password string for (typically) PEAP
IFG_WIFI_PASSWORD	         char **

IFS_WIFI_EAP_PSK_PASSPHRASE	char *    Set Wi-Fi EAP PSK using passphrase
IFS_WIFI_EAP_PSK_HEXSTR		char[65]   	 Set Wi-Fi EAP PSK using hexadecimal
IFG_WIFI_EAP_PSK_HEXSTR		char[65]
IFS_WIFI_EAP_PSK_BIN			byte[32]     Set Wi-Fi EAP PSK using binary
IFG_WIFI_EAP_PSK_BIN			byte[32]
IFS_WIFI_SUBJECT_MATCH		char *	    Set substring to be matched against the
                                        subject of the authentication server
                                        certificate <34>
IFS_WIFI_SUBJECT_MATCH2		char *       Set "inner" subject match substring
IFS_WIFI_ALTSUBJECT_MATCH	char *	    Set semicolon separated string of
                                        entries to be matched against the
                                        alternative subject name of the
                                        authentication server certificate <35>
IFS_WIFI_ALTSUBJECT_MATCH2	char *

Commands for setting security certificates (only used with WPA Enterprise)
See note <33> for details.

IFS_WIFI_CA_CERT	         SSL_Cert_t far *
IFG_WIFI_CA_CERT	         SSL_Cert_t far **
IFS_WIFI_CA_CERT2          SSL_Cert_t far *
IFG_WIFI_CA_CERT2				SSL_Cert_t far **
IFS_WIFI_CLIENT_CERT			SSL_Cert_t far *
IFG_WIFI_CLIENT_CERT			SSL_Cert_t far **
IFS_WIFI_CLIENT_CERT2		SSL_Cert_t far *
IFG_WIFI_CLIENT_CERT2		SSL_Cert_t far **
IFS_WIFI_CA_CERT_PATH		char *
IFS_WIFI_CA_CERT2_PATH		char *
IFS_WIFI_CLIENT_CERT_PATH	char *, char *
IFS_WIFI_CLIENT_CERT2_PATH	char *, char *
IFS_WIFI_CA_CERT_XIM			longword
IFS_WIFI_CA_CERT2_XIM		longword
IFS_WIFI_CLIENT_CERT_XIM   longword, longword
IFS_WIFI_CLIENT_CERT2_XIM	longword, longword


Notes:

 <1> Setting the value of these parameters may require the interface(s)
     to be brought down temporarily.  If this is necessary it will be
     brought up again before return, however any sockets that were open
     on that interface will have been aborted.

     **NOTE** It is not recommended to rely on the automatic interface
     down/up behavior, since it can lead to unexpected results for some
     combination of options.  Instead, manually bring the interface down
     before calling ifconfig().  See note at top of this function description
     for more details.

     If the interface is brought down, this may cause a blocking
     wait for Wifi and PPP, which need to send at least one packet to
     terminate cleanly).

 <2> The "bool" parameter really means an integer, whose value is 0 for
     false, or non-zero for true.

 <3> These parameters may be set for IF_ANY i.e. all interfaces.

 <4> These parameters do not care about the value of "iface" because
     they are not specific to an interface.

 <5> "Static router" means a router which handles routing to a specified
     subnet destination.  When a router is selected for a given IP
     address, the most specific static router will be used.  For example,
     given the following setup:
        Router         Subnet          Mask
        10.10.6.1      0               0
        10.10.6.2      10.99.0.0       255.255.0.0
        10.10.6.3      10.99.57.0      255.255.255.0
     then, given a destination IP address (which is not on the local
     subnet 10.10.6.0), the router will be selected according to the
     following algorithm:
        If address is 10.99.57.*, use 10.10.6.3
        else if address is 10.99.*.*, use 10.10.6.2
        else use 10.10.6.1
     Note that IFS_ROUTER_SET is basically the same as
     IFS_ROUTER_SET_STATIC, except that the subnet and mask parameters
     are automatically set to zero.  Most simple networks with a single
     router to non-local subnets will use a single IFS_ROUTER_SET.

 <6> (deprecated).

 <7> When retrieving the default router, the interface parameter may be
     either a specific interface number (to get the default router for
     that interface), or IF_ANY which will retrieve an overall default
     router.  If no router is configured, zero is stored.

 <8> The DHCP parameters are only available if USE_DHCP is defined, and
     will only work if the interface is qualified for DHCP.  The
     IFS_DHCP parameter will cause acquisition or release of the
     specified interface.

 <9> If DHCP and ping configure are both set, then the completion of
     DHCP will automatically turn off ping configure.  If DHCP fails,
     then ping configure will be allowed after the set timeout for DHCP.
     Ping config cannot override DHCP until DHCP has timed out.  This is
     the case whenever a DHCP lease is obtained whether or not at
     sock_init() time.

<10> The authentication callback is invoked with the
     following parameters:
        int auth_cb (char *user, int userlen, char *pass, int passlen)
     The parameters indicate userid, password and their lengths (not
     null terminated).  The callback should return 1 if OK, 0 if not
     authorized.

<11> The parameters for the RTS/CTS pin assignments are
        RTS: int port_address, char * shadow_reg, int port_pin
        CTS: int port_address, int port_pin
     where port_address is the parallel port internal I/O address e.g.
     PEDR for port E.  shadow_reg is the appropriate shadow register for
     the parallel port data register e.g. &PEDRShadow for port E.
     port_pin is a number from 0-7 indicating the pin number of the port.

<12> The interface up/down callback function is called with two
     parameters: ifcallback(int iface, int up) where iface is the
     interface number, and up is non-zero if the interface has just come
     up, or zero if it has just come down.  This functionality is only
     available if you #define USE_IF_CALLBACK before #use "dcrtcp.lib".

<13> Setting send/expect automatically turns on IFS_PPP_USEMODEM.  See
     the documentation for chat_init() for details on the syntax for
     these strings.  The specified strings MUST be in static storage,
     since only the pointers are stored rather than copying the strings.
     Note that two substitution parameters are available: %0 may be used
     to insert the current user name (as set using the
     IFS_PPP_REMOTEAUTH command) and %1 is the corresponding password.
     This is useful if your logon script uses the same userid/password
     as is used by PPP during its authentication (PAP) stage.

<14> You will get a runtime error (non-zero return code) if you apply
     one of the PPP-specific parameters to a non-PPP interface.

<15> DHCP custom options processing:  First parameter (int) is length of
     options list.  2nd parameter (char *) points to options list.  This
     is a byte array containing values from the DHCP_VN_* definitions in
     BOOTP.LIB (these are taken from the list in RFC2132).  Also, option
     '0' is used to indicate the boot file name.  If the boot file name
     is provided, then the TFTP server IP address can be obtained from
     the di->bootp_host field of the structure provided to the callback
     (see below).  This options list must be in static storage, since
     only the pointer is saved.

     The 3rd parameter may be NULL, or is a pointer to a callback
     function to process the custom options.  The callback function has
     the following prototype:
        int my_callback (int iface, DHCPInfo *di, int opt, int len,
                              char * data)

       iface: interface number.
          di: DHCP information struct.  Read only, except you can modify
              the 'data' field if desired.  See the definition of this
              struct in NET.LIB for details.
        opt: DHCP option number (DHCP_VN_*); or 0 for the boot file name.
        len: length of option data in bytes
       data: pointer to data for this option.  Read only.

     The callback is only invoked for options which were requested and
     which were not handled internally (such as DHCP_VN_SUBNET).  The
     return value from the callback should be zero, for future
     compatibility.  The callback should not make any long computations,
     blocking calls, or call any other tcp/ip functions, since it would
     delay the main application.  If uC/OS is in use, it should also be
     re-entrant and definitely not call any tcp/ip functions. Note that
     the following options are always retrieved and MUST NOT be provided
     in the options list:
         All DHCP protocol options (50-61),
         DHCP_VN_SUBNET,
         DHCP_VN_TIMEOFF,
         DHCP_VN_ROUTER,    *
         DHCP_VN_DNS,       *
         DHCP_VN_SMTPSRV,   *
         DHCP_VN_NTPSRV,    *
         DHCP_VN_COOKIE     *
     (* - only forbidden if DHCP_NUM_ROUTERS etc. are defined non-zero).

<16> This parameter specifies that DHCP INFORM message is used for
     Ethernet interfaces, and is applicable if the IP address is
     configured other than by DHCP.  The parameter is always TRUE for
     PPP interfaces.

<17> The DHCP fallback address parameters are used in preference to
     IFS_IPADDR (the "current" address).  This indicates the static IP
     address to use in case DHCP could not be used to configure the
     interface.  See also the following note.

<18> The action of IFS_IPADDR depends on the current interface state.
     If the i/f has the IFS_DHCP flag set, then this parameter sets only
     the fallback IP address without changing the current i/f status.
     Otherwise, the i/f is reconfigured with the new address
     immediately, which may require it to be brought down then up.
     IFS_IPADDR always sets the DHCP fallback address, but you can also
     use the IFS_DHCP_FB_IPADDR parameter to set the fallback address
     without ever changing the i/f status.

<19> These commands are not available if you #define PPP_NO_MODEM.

<20> These commands are only available if the processor is a Rabbit
     4000 or above.  The 4000 and 5000 processors have 8 channels of
     DMA (Direct Memory Access), and the 6000 has 16 channels.

     Any PPP over async serial, or VSPD (Virtual Stream
     Packet Driver) interface may be switched between its normal fixed
     async serial port and a pair of DMA channels allocated to the
     application via the DMAalloc() function in DMA.LIB.  The DMA
     channels should not be modified by the application while in use by
     the network library.

     When specifying DMA channels (type dma_chan_t), you also provide a
     third, word, parameter which specifies the I/O register to be the
     source and destination for incoming and outgoing data respectively.
     This does not need to be a serial port data register, but it
     usually would be.  Currently, only internal I/O registers are
     supported for this function.  This parameter may be zero in order
     to select the default serial I/O port.

     The application is responsible for setting serial port parameters
     as desired.  When using DMA channels, the network library routines
     do not make any changes to or make any assumptions about the
     underlying I/O port.  The same applies to the DMA channel.  For
     example, the application is responsible for enabling the external
     DMA request line if, for example, it is desired to implement
     hardware transmit flow control.

     Use of a DMA channel reduces the amount of CPU overhead taken up
     servicing interrupts.  This allows higher communication rates, or
     allows the application to perform more useful work in the same
     time.

     If the DMA channels are released via IFS_USE_SERIAL then it is the
     application's responsibility to re-use or unallocate the DMA
     channels as desired.

<21> You will get a runtime error (non-zero return code) if you apply
     one of the Wi-Fi-specific parameters to a non-Wi-Fi interface.
     See the "Wi-Fi Configuration" documentation in tcp_config.lib for
     details on configuring the Wi-Fi interface.

<22> Set/get the SSID (Service Set Identifier) which is used to identify
     a particular wireless network.  Since the SSID can contain any byte
     (including nulls), it's necessary to provide the length along with
     the SSID.  See wifi_ssid_to_str() for creating a null-terminated,
     printable version of the SSID, with nulls and non-printable
     characters (byte values 0x00-0x20 and 0x7F-0xFF) replaced with '?'.

<23> The Wi-Fi hardware can be configured for different regions, each
     with their own limits on power levels and useable channels.  Valid
     settings follow:

   IFPARAM_WIFI_REGION_AMERICAS           Americas, including the US (ch. 1-11)
   IFPARAM_WIFI_REGION_AUSTRALIA          Australia (ch. 1-11)
   IFPARAM_WIFI_REGION_CANADA             Canada (ch. 1-11)
   IFPARAM_WIFI_REGION_CHINA              China (ch. 1-11)
   IFPARAM_WIFI_REGION_EMEA               Europe, Middle East, Africa (ch. 1-13)
   IFPARAM_WIFI_REGION_FRANCE             France (ch. 10-13)
   IFPARAM_WIFI_REGION_ISRAEL             Israel (ch. 3-11)
   IFPARAM_WIFI_REGION_JAPAN              Japan (ch. 1-13)
   IFPARAM_WIFI_REGION_MEXICO_INDOORS     Mexico indoors (ch. 1-11)
   IFPARAM_WIFI_REGION_MEXICO_OUTDOORS    Mexico outdoors (ch. 9-11)

     The wifi_region structure populated by IFG_WIFI_REGION_INFO
     contains the following elements:

        typedef struct {
           char   id;                  // IFPARAM_WIFI_REGION_* value
           char  country[16];          // description of region
           int   first_channel;        // First channel
           int   last_channel;         // Last channel
           unsigned int channel_mask;  // Channel mask
           int   max_pwr_dBm;          // Max power, dBm
           int   max_pwr_index;        // Max Power index
        } wifi_region;

<24> For the Wi-Fi encryption and authentication settings, you can OR
     together the options you want to use.

     Encryption options:
        IFPARAM_WIFI_ENCR_ANY    Use any type of encryption
        IFPARAM_WIFI_ENCR_NONE   Connect to open (unencrypted) networks
        IFPARAM_WIFI_ENCR_WEP    Connect to WEP networks
        IFPARAM_WIFI_ENCR_TKIP   Connect to TKIP (WPA) networks
        IFPARAM_WIFI_ENCR_CCMP   Connect to CCMP (WPA2) networks

     TKIP (WPA) and CCMP (WPA2) are only allowed if WIFI_USE_WPA is defined.
     CCMP (WPA2) is only allowed if WIFI_AES_ENABLED is defined as well.
     
     If connecting to an access point configured for "WPA mixed mode", you must
     enable TKIP and CCMP (IFPARAM_WIFI_ENCR_TKIP | IFPARAM_WIFI_ENCR_CCMP) in
     order to use CCMP encryption.  This is because mixed mode networks use
     TKIP for broadcast messages, and either TKIP or CCMP (depending on the
     client's settings) for unicast messages.

     Authentication options:
        IFPARAM_WIFI_AUTH_ANY       Use any type of authentication
                                    Don't use this when using 802.1X (EAP)
                                    authentication.  Always set to ONE of
                                    the following, as appropriate.
        IFPARAM_WIFI_AUTH_OPEN      Use open system (no) authentication
        IFPARAM_WIFI_AUTH_SHAREDKEY WEP shared key authentication
        IFPARAM_WIFI_AUTH_WPA_PSK   WPA PSK (pre-shared key) auth
        IFPARAM_WIFI_AUTH_WPA_8021X WPA with 802.1X (EAP) authentication.
                                    This option is only available when
                                    WPA_USE_EAP is defined.


     Note that when using WEP encryption, open authentication is actually
     more secure than shared key authentication.

     It is recommended to use only ONE of the above settings (for
     authentication or encryption) when using 802.1X (EAP), and do not use ANY.

<25> Sets or gets the maximum transmission rate, as a multiple of
     100 kbps.  Use the macros below, or their integer equivalents.
     Note that some speeds are only available on 802.11g hardware.
     (The RCM4400W has an 802.11b interface.)

         Macro                      Integer  Rate
         IFPARAM_WIFI_TX_RATE_ANY       0     Any
         IFPARAM_WIFI_TX_RATE_1        10     1.0 Mbps
         IFPARAM_WIFI_TX_RATE_2        20     2.0 Mbps
         IFPARAM_WIFI_TX_RATE_5_5      55     5.5 Mbps
         IFPARAM_WIFI_TX_RATE_6        60     6.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_9        90     9.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_11      110    11.0 Mbps
         IFPARAM_WIFI_TX_RATE_12      120    12.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_18      180    18.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_24      240    24.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_36      360    36.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_48      480    48.0 Mbps (802.11g)
         IFPARAM_WIFI_TX_RATE_54      540    54.0 Mbps (802.11g)

<26> IFS_WIFI_SCAN initiates a scan of all valid channels for the
     current region.  A pointer to a scan callback function is
     passed as the only parameter to IFS_WIFI_SCAN.  The callback
     function must have the following function prototype:

         void scan_callback (far wifi_scan_data *data);

     When the scan has completed, the scan callback function is
     called.  A Wi-Fi scan can be done without taking the interface
     down, but it will briefly interrupt the network connectivity
     as it scans the channels on the wireless network.

     The scan data is provided to the callback function in its data
     parameter.  The wifi_scan_data structure has the following
     definition:

         typedef struct {
            int                  count;
            _wifi_wln_scan_bss   bss[_WIFI_SCAN_NUM];
         } wifi_scan_data;

     _WIFI_SCAN_NUM is set to 16 in wifi_wln_api.lib, but you can override
     the default value by defining it in the project options defines box.
     "count" contains
     the number of access points that were detected.  "bss" is an array
     where each element corresponds to a detected access point.
     _wifi_wln_scan_bss has the following definition:

         typedef struct {
            uint8       ssid[WLN_SSID_SIZE];	// Service Set Identifier
            int         ssid_len;	// Length of the above
            int         channel;		// 1-WLN_CHAN_NUM (0 to search)
            mac_addr    bss_addr;	// BSS ID (AP MAC address)
            uint16      bss_caps;	// BSS capabilities,
            										// one of more of WLN_CAP_xxx
            uint8       wpa_info[WLN_WPAIE_SIZE];
            								// WPA/RSN information element
            uint8       erp_info;	// 802.11g extended rate PHY information
            uint16      rates;		// Operational rates,
            										// one or more of WLN_RATE_xxx
            uint16      rates_basic;// Basic rates,
            										// one or more of WLN_RATE_xxx
            uint16      atim;			// Ad hoc ATIM window size
            int         tx_rate;		// Maximum transmit rate (in 100 kbps)
            int         rx_signal;	// Received signal strength,
            										// (moving average, range 0-107)
         } _wifi_wln_scan_bss;


     See the WiFiScan.c sample program for an example of using
     IFS_WIFI_SCAN.

<27> The IFG_WIFI_STATUS command returns the current Wi-Fi MAC status
     into the user-supplied buffer or data structure area.  Note that
     the buffer must be large enough to hold the entire wifi_status
     structure (size can be checked with sizeof(wifi_status)).

     The wifi_status structure has the following definition:

         typedef struct {
            wln_state   state;
            uint8       ssid[WLN_SSID_SIZE];
            int         ssid_len;
            int         channel;
            mac_addr    bss_addr;
            uint16      bss_caps;
            uint8       wpa_info[WLN_WPAIE_SIZE];
            uint32      authen;
            uint32      encrypt;
            int         tx_rate;
            int         rx_rate;
            int         rx_signal;
            int         tx_power;
            uint8       country_info[WLN_COUNTRY_STRLEN];
				int			link;
         } wifi_status;

    The structure elements have the following definitions:
         state       Association state: one of WLN_ST_xxx (see below)
         ssid        Current service set ID (SSID)
         ssid_len    Service set ID length
         channel     Current channel: 1-14
         bss_addr    BSS ID (AP MAC address)
         tx_rate     Current transmit rate (in 100 kbps)
         rx_rate     Last received rate (in 100 kbps)
         rx_signal   Received signal strength (running average)(range 0-107)

     The other fields are used internally by the Wi-Fi driver.

     The association state is set to one of the following:
         WLN_ST_STOPPED       Wi-Fi driver is stopped
         WLN_ST_SCANNING      Currently performing a scan
         WLN_ST_ASSOC_ESS     Associated with an AP
         WLN_ST_AUTH_ESS      Authenticated with an AP
         WLN_ST_JOIN_IBSS     Joined an existing ad-hoc network
         WLN_ST_START_IBSS    Started an ad-hoc network

<28> WEP shared keys are used for WEP shared key authentication and for
     WEP encryption.  The Wi-Fi driver stores up to 4 different WEP keys
     (numbered 0 to 3) of either 5 or 13 bytes.  Use IFS_WIFI_WEP_KEYNUM
     to select the key to use.  Use IFS_WIFI_WEP_KEY_BIN to set the key
     to 5 or 13 bytes.  Use IFS_WIFI_WEP_KEY_HEXSTR to set the key with
     a 10 or 26 character hex string.

     When passing the key size to IFS_WIFI_WEP_KEY_BIN, you can use the
     IFPARAM_WIFI_WEP_KEY40 (5-byte key) or IFPARAM_WIFI_WEP_KEY104
     (13-byte key).

<29> WPA pre-shared keys (PSK) are used for WPA PSK authentication and
     for TKIP and CCMP encryption.  Setting the key with a passphrase
     can take 20 seconds on an RCM4400W.  Setting the key directly as
     hex is much more efficient.

     IFS_WIFI_WPA_PSK_PASSPHRASE takes a null-terminated ASCII string of
     up to 63 characters and combines it with the SSID to create the key
     (so be sure to set the SSID before setting the passphrase).  After
     generating the key, you can use IFG_WIFI_WPA_PSK_HEXSTR to get the
     key as a 64-character hex string for use with
     IFS_WIFI_WPA_PSK_HEXSTR.  Note that if you change the SSID after
     setting the passphrase, you will need to reset the passphrase by
     using the IFS_WIFI_WPA_PSK_PASSPHRASE command again.

     IFS_WIFI_WPA_PSK_HEXSTR takes a null-terminated ASCII string of 64
     hex digits and uses it for the key.


<30> Set the protocol parameter to one of
	  IFPARAM_WIFI_WPA_PROTOCOL_WPA	  - WPA/IEEE 802.11i/D3.0
     IFPARAM_WIFI_WPA_PROTOCOL_RSN    - WPA2/IEEE 802.11i
     IFPARAM_WIFI_WPA_PROTOCOL_ALL    - support both WPA and RSN
     Default is to support both protocols.

<31> For acceptable values, see description for IFS_WIFI_ENCRYPTION.  Only
     NONE, TKIP or CCMP are allowed:
     CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
     TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
     NONE = Use only Group Keys (deprecated, should not be included if APs support
       pairwise keys)

<32> The parameter for this command is one or the following:
        IFPARAM_EAP_PEAP         for PEAP-MSCHAPV2
	     IFPARAM_EAP_TLS          for TLS
	  Methods which do not have compiled-in support via the WPA_USE_EAP
	  macro will be ignored.  Currently, only EAP_TYPE_TLS and EAP_TYPE_PEAP are
	  supported.  For both of these, you would need to have
	   #define WPA_USE_EAP		(WPA_USE_EAP_TLS|WPA_USE_EAP_PEAP)

	  Note: the parameter identifier is IFS_EAP_METHODS (plural), however in this
	  release only one method may be selected, which implies that the type of
	  authentication must be known in advance for the given SSID.

<33> Certificates may be configured via several different formats: native
     binary structure, #ximport file, and Zserver resource.

     The binary structure, SSL_Cert_t, is created and manipulated using the
     API provided in SSL_CERT.LIB.  This is convenient where programmatic
     manipulation is required, or certificates are stored in a form which is
     not directly supported by ifconfig(), or if the certificates are to be
     used with, say, an HTTPS server.  For example, client certificates
     may have the private key information stored separately from the
     corresponding certificate.  CA (Certificate Authority) information may
     require more than one certificate in a certificate chain.  Such chains
     can only be constructed using the SSL_CERT API.

     When using a binary structure form, make sure to explicitly cast pointers
     to such to far pointers.  The compiler cannot do this automatically, since
     it does not know the expected type of the ifconfig() parameters.  If this
     is not done, then memory corruption may result.  For example,
	   auto SSL_Cert_t ca_cert;
	   memset(&ca_cert, 0, sizeof(ca_cert));
	   SSL_new_cert(&ca_cert, ......);
      ifconfig(IF_WIFI0, IFS_WIFI_CA_CERT, (SSL_Cert_t far *)&ca_cert, IFS_END);
     Without the cast, a near pointer would be passed to ifconfig(), since the
     ca_cert structure is an auto (near) structure.  This would cause serious
     errors.

     Instead of providing binary certificate structures, you can provide
     #ximport file symbols or Zserver resource names ("paths").  This helps
     to simplify the calling code because the SSL_CERT API does not need to
     be used, however this is achieved at the cost of some flexibility.

     The commands with '2' in their identifier provide information for so-called
     "inner methods" of EAP.  Currently, there are no supported EAP methods
     which require inner certificates, however these parameters are provided
     for upward compatibility.

     The only "get" form commands apply to the binary structure form.  You
     can set a certificate using any form, then access the resulting structure
     (created internally by the SSL_CERT API) using the "get" commands.

     If you use the _PATH or _XIM forms, you can also pass a (long)0 parameter
     in order to remove that certificate and any associated resources.

     The CA certificates are used to establish a mutually trusted authority
     for verifying any certificates (and public keys) received from the
     access server.  Most embedded applications will use a single, locally-
     defined, CA.  Alternatively, a recognized commercial CA certificate
     may be used if the AS is certified by one.

     Client certificates generally require two parts: the certificate itself,
     and the corresponding private key.  The commands which take two parameters
     provide the certificate in the first parameter, and the private key in
     the second.  The PEM file format may contain both parts, thus the same
     PEM file resource may be used for both parameters, and the library will
     extract the correct information.

     Certificate files (either #ximport or Zserver) are allowed to be in either
     DER (binary) or PEM (Privacy Enhanced Mail) format.  PEM format must not
     have the private key encrypted; it must be saved without DES or any other
     encryption.  PEM format is automatically detected.  If the file appears
     not to be in PEM format, then it is assumed to be DER encoded.  Utilities
     such as openSSL allow these formats to be manipulated easily.  If an
	  unsupported format certificate or private key is provided, the most likely
	  consequence will be inability to establish a connection or become
	  authenticated.

	  NOTE: verification of certificates will normally include examination of
	  the validity dates of the certificate.  This requires a correctly set
	  real-time clock.  If such a clock is not available, or is set to the
	  wrong wall-clock date/time, then certificate verification will fail.
	  To avoid this (at the cost of reduced security) you can
	   #define X509_NO_RTC_AVAILABLE
	  in order to bypass the date/time check.

	  NOTE: commands such as IFG_WIFI_CA_CERT which return pointers to
	  certificates do not make a new copy of the data.  Instead, they return
	  pointers to internal structures which may be in use by the network
	  libraries.  Thus, the application should not alter these data.


<34>	The subject string is in following format (for example):
	    /C=US/ST=CA/L=Davis/CN=Test1-AS/emailAddress=test1_as@digi.com
	   so this command string could be set to "/L=Davis/CN=Test" to allow all
	   access servers with a location of "Davis" and a common name starting
	   with "Test".

<35>  If this string is set, the server sertificate is only accepted if it
      contains one of the entries in an alternative subject name extension.
      altSubjectName string is in following format: TYPE:VALUE
      Example: EMAIL:server@example.com
      Example: DNS:server.example.com;DNS:server2.example.com
      Following types are supported: EMAIL, DNS, URI

<36>  Caller is responsible for ensuring that nameservers are not added
      beyond the configured limit.  There is no error checking.  Excess
      entries are ignored.  MAX_NAMESERVERS defines the maximum number
      of entries that can be added to the nameserver table, however the
      table also includes extra entries that may be populated with
      nameservers which are discovered via DHCP.  The total number
      of entries is defined by the macro DNS_TABLE_SIZE, however the number
      of user-definable entries should be limited to MAX_NAMESERVERS.

<37>	For IFS_WIFI_MODE, join mode is one of the following constants:
	      IFPARAM_WIFI_ADHOC : join or create an IBSS (ad-hoc network)
	      IFPARAM_WIFI_INFRASTRUCTURE : join an ESS only
	      IFPARAM_WIFI_ADHOC_JOIN_ONLY : join an IBSS (but do not create)
	      IFPARAM_WIFI_ANY : join any type of network
	      IFPARAM_WIFI_NO_JOIN : temporarily, do not join any network
	      IFPARAM_WIFI_JOIN : restore joining to whatever was selected
	         before (or you can just explicitly set the join type).
	   When retrieving (via IFG_WIFI_MODE), the return value should be
	   bitwise ANDed with ~IFPARAM_WIFI_NO_JOIN in order to mask out the
	   no-join flag (if any).  It can then be compared with the first
	   four types.  ..NO_JOIN and ..JOIN turn this bit on and off.
	   NO_JOIN should be used when just scanning without intent to
	   select any network.


RETURN VALUE:  If no error, returns 0.  Otherwise, returns the identifier
               of the first parameter group which encountered an error,
               which will be a non-zero value.
               Returns -1 if iface parameter invalid.
               An exception (run-time error) is raised if the parameter
               list contains an invalid parameter number.

SEE ALSO:      sock_init, ip_print_ifs, ifstatus, ifpending

END DESCRIPTION **********************************************************/

_net_nodebug
int ifconfig(int iface,...)
{
	return vifconfig(iface, (char *)(&iface + 1));
}

/*** BeginHeader vifconfig */
int vifconfig(int iface, char * p);
/*** EndHeader */
// Define macro to check for sock_init() having been called.  Some parameters will
// not work unless sock_init has been called. (uC/OS environment only)
#ifdef NET_DEBUG
	#ifdef MCOS_LOCKS
		#define _FAIL_IF_NOT_INIT	if (!_initialized) goto _ifc_error
	#else
		#define _FAIL_IF_NOT_INIT
	#endif
#else
	#define _FAIL_IF_NOT_INIT
#endif

/* START FUNCTION DESCRIPTION ********************************************
vifconfig                               <NET.LIB>

SYNTAX: int vifconfig (int iface, char *p);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function is an alternate interface to ifconfig(),
               where a pointer to the parameters is passed to the
               function instead of passing the parameters on the stack.

               See the documentation to ifconfig() for full details.

PARAMETER1: 	iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
                 IF_ANY
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.  IF_ANY may be used only for the
               parameters which are not specific to any particular
               interface.  It can also be used, where applicable, to
               mean "all interfaces" if the operation would make
               sense when applied to all interfaces.

PARAMETER2: 	Pointer to commands and their parameters.  Note that
               only pointers to strings and byte arrays stored
               elsewhere, and not the strings/byte arrays themselves,
               should be included with the parameters.

RETURN VALUE:  If no error, returns 0.  Otherwise, returns the identifier
               of the first parameter group which encountered an error,
               which will be a non-zero value.
               Returns -1 if iface parameter invalid.
               An exception (run-time error) is raised if the parameter
               list contains an invalid parameter number.

SEE ALSO:      ifconfig, sock_init, ip_print_ifs, ifstatus, ifpending

END DESCRIPTION **********************************************************/

_net_nodebug int vifconfig(int iface, char * p)
{
	auto int ident, i, j, wasup;
#ifdef NET_VERBOSE
	auto int parm_no;
	auto int last_parm;
#endif
#ifdef USE_DHCP
   auto DHCPInfo * di;
#endif
	auto int ival, * ipval;
	auto word wval, * wpval;
	auto char *cptr, *cptr2;
	auto char **cptrptr;
	auto word onflags, offflags;
	auto longword lval, lval2, lval3, * lpval;
	auto byte * bpval;
	auto word ru, rif;
	auto ATHandle ath;
#ifdef USING_PPP
	auto PPPState *ppp;
#endif
#if USING_WIFI
	auto int lock_level;
	auto word brset, ofdmset;
	#ifdef WIFI_USE_WPA
	   auto int wpa_update;
	   #ifdef WPA_USE_EAP
			struct SSL_Cert_t_t __far ** cm;	// managed certificate pointer
	   #endif
	#endif
#endif
	auto IFTEntry * ifte;
	auto dma_chan_t rxchan, txchan;
   auto int ioctlrc;

	if (iface < 0 || iface != IF_ANY && !(1u<<(word)iface & IF_SET)) {
   #ifdef NET_VERBOSE
   	printf("NET: ifconfig(%d...) invalid interface\n", iface);
   #endif
		return -1;
   }

  	LOCK_GLOBAL_IF_INIT(TCPGlobalLock);
   // Initialize packet drivers.  This only does anything the first time called.  We do
   // this here in case ifconfig() is being called before sock_init().
   pkt_init();

	if (iface != IF_ANY) {
   	ifte = _if_tab + iface;
#ifdef USE_DHCP
	   di = ifte->dhcp;
#endif
#ifdef USING_PPP
		if (IF_P2P(iface))
			ppp = ifte->u.ppp.ppp_state;
		else
			ppp = NULL;
#endif
		wasup = ifpending(iface);
	}
	else {
   	ifte = NULL;
#ifdef USE_DHCP
	   di = NULL;
#endif
#ifdef USING_PPP
		ppp = NULL;
#endif
   }
#if USING_WIFI
	#ifdef WIFI_USE_WPA
	   wpa_update = 0;
	#endif
#endif

#ifdef NET_VERBOSE
	// Count identifier parameters for more useful error messages.
	parm_no = 0;
	ident = -1;
#endif

	for (;;) {
#ifdef NET_VERBOSE
		// remember last successful parameter
		last_parm = ident;
#endif
		ident = *(int *)p;
		p += sizeof(int);
#ifdef NET_VERBOSE
		++parm_no;
#endif

#if USING_WIFI
      // Wi-Fi options only work on a Wi-Fi interface
      if ((! IF_IS_WIFI(iface)) && (ident >= IFX_WIFI_MIN)
      	&& (ident <= IFX_WIFI_MAX)) {
			goto _ifc_error;
      }
	#ifdef WIFI_USE_WPA
   	// need to call wpa_set_params() if any of the following changes:
      //		encrypt, authen, ssid, wpa_psk, identity, password, options,
      //		eap_methods, wep keys
   	switch (ident) {
			case IFS_WIFI_ENCRYPTION:
         case IFS_WIFI_AUTHENTICATION:
         case IFS_WIFI_SSID:
         case IFS_WIFI_WPA_PSK_PASSPHRASE:
         case IFS_WIFI_WPA_PSK_HEXSTR:
         case IFS_WIFI_WPA_PSK_BIN:
			// no setters for identity
         // no setters for password
         // no setters for WLN_OPT_VERIFYCERT option
			// no setters for eap_methods
         case IFS_WIFI_WEP_KEYNUM:
         case IFS_WIFI_WEP_KEY_BIN:
         case IFS_WIFI_WEP_KEY_HEXSTR:
      #ifdef WPA_USE_EAP
      	case IFS_WIFI_WPA_PROTOCOL:
      	case IFS_WIFI_PAIRWISE_ENCRYPTION:
      	case IFS_WIFI_EAP_METHODS:
      	case IFS_WIFI_IDENTITY:
      	case IFS_WIFI_ANONYMOUS_IDENTITY:
      	case IFS_WIFI_PASSWORD:
      	case IFS_WIFI_CA_CERT:
      	case IFS_WIFI_CA_CERT2:
      	case IFS_WIFI_CA_CERT_PATH:
      	case IFS_WIFI_CA_CERT2_PATH:
      	case IFS_WIFI_CLIENT_CERT:
      	case IFS_WIFI_CLIENT_CERT2:
      	case IFS_WIFI_CLIENT_CERT_PATH:
      	case IFS_WIFI_CLIENT_CERT2_PATH:
      	case IFS_WIFI_CA_CERT_XIM:
      	case IFS_WIFI_CA_CERT2_XIM:
      	case IFS_WIFI_CLIENT_CERT_XIM:
      	case IFS_WIFI_CLIENT_CERT2_XIM:
         case IFS_WIFI_EAP_PSK_PASSPHRASE:
         case IFS_WIFI_EAP_PSK_HEXSTR:
         case IFS_WIFI_EAP_PSK_BIN:
      	case IFS_WIFI_SUBJECT_MATCH:
      	case IFS_WIFI_SUBJECT_MATCH2:
      	case IFS_WIFI_ALTSUBJECT_MATCH:
      	case IFS_WIFI_ALTSUBJECT_MATCH2:
      #endif
         	wpa_update = 1;
            break;
      }
	#endif
#endif

/*
		When adding new options to vifconfig(), here's how you can extract
      parameters of various types:

	      ival = *(int *)p;				// 16-bit int
	      p += sizeof(int);
         // <something> = ival;

	      wval = *(word *)p;			// 16-bit word
	      p += sizeof(word);
         // <something> = wval;

			lval = *(longword *)p;		// 32-bit word
			p += sizeof(longword);
         // lval = <something>;

	      ipval = *(int **)p;			// pointer to 16-bit int
	      p += sizeof(int *);
	      // *ipval = <something>;

	      wpval = *(word **)p;			// pointer to 16-bit word
	      p += sizeof(word *);
	      // *wpval = <something>;

			lpval = *(longword **)p;	// pointer to 32-bit word
			p += sizeof(longword *);
			// *lpval = <something>;

	      cptr = *(char **)p;			// pointer to char array (string)
	      p += sizeof(char *);
			// strcpy from or to cptr

	      bptr = *(byte **)p;			// pointer to byte array
	      p += sizeof(byte *);
			// memcpy from or to bptr

*/

		switch (ident) {
      	case IFS_NOP:
         	// do nothing, advance to next option
            break;

			case IFS_END:
				if (iface != IF_ANY &&
                (wasup == IF_UP || wasup == IF_COMING_UP)) {
            	// v27274: block until interface completely down.  This is
            	// never very long, but is necessary for Wifi to behave properly.
            	while (ifpending(iface) == IF_COMING_DOWN)
            		tcp_tick(NULL);
            	if (ifpending(iface) == IF_DOWN)
						ifup(iface);	// Start coming up (but don't check for errors)
				}
				goto _clean_return;
			case IFS_UP:
				_FAIL_IF_NOT_INIT;
				if (iface == IF_ANY)
					for (i = 0; i < IF_MAX; i++)
						ifup(i);
				else
					if (ifup(iface) == IFCTL_FAIL)
						goto _ifc_error;
					else
						wasup = ifpending(iface);
				break;
			case IFS_DOWN:
				_FAIL_IF_NOT_INIT;
				if (iface == IF_ANY)
					for (i = 0; i < IF_MAX; i++)
						ifdown(i);
				else
					if (wasup != IF_DOWN && wasup != IF_COMING_DOWN &&
						ifdown(iface) == IFCTL_FAIL)
						goto _ifc_error;
					else
						wasup = ifpending(iface);
				break;
			case IFS_IPADDR:
				if (!ifte)
					goto _ifc_error;
				lval = *(longword *)p;
				p += sizeof(longword);

				ifte->static_ip = lval;
      	#ifdef USE_DHCP
				// IFS_IPADDR always sets the fallback address when DHCP enabled
				if (di)
					di->fallback_ip = lval;
			#endif

			// If not using DHCP, make sure interface is down and then set IP addr.
			#ifdef USE_DHCP
         	if (!(ifte->flags & IFF_DHCP))
         #else
         	if (1)		// DHCP disabled, so always do this...
         #endif
				{
	            if (wasup == IF_UP || wasup == IF_COMING_UP)
	            {
	               ifdown(iface);
	            }
	            ifte->ipaddr = lval;
	         #ifdef USE_LINKLOCAL
	            if (IS_LINKLOCAL_ADDR( ifte->ipaddr))
	            {
	               // Kick off link-local address selection, using 0.0.0.0
	               // until link-local library can secure an address.
	               if (linklocal_init( iface, ifte->ipaddr) != IFCTL_OK)
	               {
	                  goto _ifc_error;
	               }
	            }
	            else if (ifte->linklocal)
	            {
	               // Setting a non-link-local address on an iface previously
	               // set up for link local.  Disable the state machine.
	               linklocal_disable( iface);
	            }
	         #endif
				}

				break;
			case IFG_IPADDR:
				if (!ifte)
					goto _ifc_error;
				lpval = *(longword **)p;
				p += sizeof(longword *);
				*lpval = ifte->ipaddr;
				break;
			case IFS_NETMASK:
				if (!ifte)
					goto _ifc_error;
				ifte->static_mask = ifte->mask = *(longword *)p;
				p += sizeof(longword);
				break;
			case IFG_NETMASK:
				if (!ifte)
					goto _ifc_error;
				lpval = *(longword **)p;
				p += sizeof(longword *);
				*lpval = ifte->mask;
				break;
			case IFS_MTU:
				if (!ifte)
					goto _ifc_error;
				ifte->mtu = *(word *)p;
				wval = if_max_mtu(iface);
				if (ifte->mtu > wval)
					ifte->mtu = wval;
				p += sizeof(word);
				break;
			case IFG_MTU:
				if (!ifte)
					goto _ifc_error;
				wpval = *(word **)p;
				p += sizeof(word *);
				*wpval = ifte->mtu;
				break;
			case IFS_ROUTER_SET:
				router_del_all();
				// fall thru
			case IFS_ROUTER_ADD:
				lval = *(longword *)p;
				p += sizeof(longword);
				lval2 = 0;
				lval3 = 0;
				goto _ifc_router;
			case IFS_ROUTER_SET_STATIC:
				router_del_all();
				// fall thru
			case IFS_ROUTER_ADD_STATIC:
				lval = *(longword *)p;
				p += sizeof(longword);
				lval2 = *(longword *)p;
				p += sizeof(longword);
				lval3 = *(longword *)p;
				p += sizeof(longword);
			_ifc_router:
				_FAIL_IF_NOT_INIT;
				// just ignore 0.0.0.0, to allow for MY_GATEWAY="0.0.0.0"
				if (lval)
				{
	            i = ip_iface(lval, 2);
	            if (i == IF_ANY)
	               if (iface == IF_ANY)
	                  i = IF_DEFAULT;   // Cannot really determine, use default
	               else
	                  i = iface;
	            if (router_add(lval, i, lval2, lval3, 0) < 0)
	               goto _ifc_error;
				}
				break;
			case IFS_ROUTER_DEL:
				_FAIL_IF_NOT_INIT;
				lval = *(longword *)p;
				p += sizeof(longword);
				if (!lval)
					router_del_all();
				else
					router_delete(lval);
				break;
			case IFG_ROUTER_DEFAULT:
				_FAIL_IF_NOT_INIT;
				lpval = *(longword **)p;
				p += sizeof(longword *);
				if ((ath = router_for_iface(0, &ru, &rif, iface)) < 0)
					*lpval = 0;
				else
					arpcache_ipaddr(ath, lpval);
				break;
			case IFS_HWA:
				if (iface == IF_ANY || !my_eth_addr[iface])
					goto _ifc_error;
				bpval = *(byte **)p;
				p += sizeof(byte *);
				pd_sethwaddr(iface, bpval);
				memcpy(my_eth_addr[iface], bpval, 6);
				break;
			case IFG_HWA:
				if (iface == IF_ANY)
					goto _ifc_error;
				bpval = *(byte **)p;
				p += sizeof(byte *);
            if (my_eth_addr[iface])
					memcpy(bpval, my_eth_addr[iface], 6);
            else
            	memset(bpval, 0, 6);
				break;
			case IFS_NAMESERVER_SET:
#ifndef DISABLE_DNS
				servlist_delete(&_dns_server_table, 0, DNS_PREDEFINED);
#endif
				// fall thru
			case IFS_NAMESERVER_ADD:
				lval = *(longword *)p;
				p += sizeof(longword);
#ifndef DISABLE_DNS
				// ignore 0.0.0.0, to allow for MY_NAMESERVER="0.0.0.0"
				if (lval)
				{
					servlist_add(&_dns_server_table, lval, DNS_PREDEFINED, NULL);
				}
#endif
				break;
			case IFS_NAMESERVER_DEL:
				lval = *(longword *)p;
				p += sizeof(longword);
#ifndef DISABLE_DNS
				servlist_delete(&_dns_server_table, lval, 0xFFFF); // all sources
#endif
				break;
			#ifdef USE_DHCP
			case IFS_DHCP_TIMEOUT:
				if (!di)
					goto _ifc_error;
				di->overall_timeout = *(word *)p;
				p += sizeof(word);
				break;
			case IFG_DHCP_TIMEOUT:
				if (!di)
					goto _ifc_error;
				wpval = *(word **)p;
				p += sizeof(word *);
				*wpval = di->overall_timeout;
				break;
			case IFS_DHCP_FB_IPADDR:
				if (!di)
					goto _ifc_error;
				di->fallback_ip = *(longword *)p;
				p += sizeof(longword);
				break;
			case IFG_DHCP_FB_IPADDR:
				if (!di)
					goto _ifc_error;
				lpval = *(longword **)p;
				p += sizeof(longword *);
				*lpval = di->fallback_ip;
				break;
			case IFS_DHCP_FALLBACK:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_FALLBACK;
				goto _ifc_setflags;
			case IFS_DHCP_QUERY:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_QUERY;
				goto _ifc_setflags;
			case IFS_DHCP_DOMAIN:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_DOMAIN;
				goto _ifc_setflags;
			case IFS_DHCP:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP;
			#endif
			_ifc_setflags:
				ival = *(int *)p;
				p += sizeof(int);
				if (ival)
					offflags = 0xFFFF;
				else
					offflags = ~onflags, onflags = 0;
				if (iface == IF_ANY)
					for (i = 0; i < IF_MAX; i++)
						ifte->flags = ifte->flags & offflags | onflags;
				else
					ifte->flags = ifte->flags & offflags | onflags;
			#ifdef USE_DHCP
				if (ident == IFS_DHCP) {
					// Special processing for DHCP.
					if (!ival) {
                  // If iface currently coming up with DHCP, but flag says no
                  // DHCP, then do an ifdown, because there might indeed be
                  // no DHCP server.  If it's already up, then don't bring
                  // down since we're OK.
                  if (wasup == IF_COMING_UP) {
                  	ifdown(iface);
                  }
               }
				}
			#endif
				break;
			#ifdef USE_DHCP
			case IFS_DHCP_OPTIONS:
         	// Takes int (length), char* (options list), int (*)() (callback).
				if (!di)
					goto _ifc_error;
				di->num_req_options = *(word *)p;	// length
				p += sizeof(word);
            di->req_options = *(char **)p;	// options list
            p += sizeof(char *);
				di->opt_callback = *(int (**)())p;
				p += sizeof(int (*)());
            break;
			case IFG_DHCP_OPTIONS:
         	// Takes int* (length return), char** (options list return).
				if (!di)
					goto _ifc_error;
				wpval = *(word **)p;	// length
				p += sizeof(word*);
            *wpval = di->num_req_options;
            cptrptr = *(char ***)p;	// options list
            p += sizeof(char **);
            *cptrptr = di->req_options;
            break;
			case IFG_DHCP_INFO:
				wpval = *(word **)p;
				p += sizeof(word *);
				*(DHCPInfo **)wpval = di;
            break;
			case IFG_DHCP:
				if (iface == IF_ANY)
					goto _ifc_error;
            if (!di) {
			  		ipval = *(int **)p;
					p += sizeof(int *);
					*ipval = 0;	// Not qualified
               break;
            }
				onflags = IFF_DHCP;
			#endif
			_ifc_getflags:
				if (iface == IF_ANY)
					goto _ifc_error;
				ipval = *(int **)p;
				p += sizeof(int *);
				// v21515: *all* specified flags must be on
				*ipval = (ifte->flags & onflags) == onflags;
				break;
			#ifdef USE_DHCP
			case IFG_DHCP_FALLBACK:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_FALLBACK;
				goto _ifc_getflags;
			case IFG_DHCP_QUERY:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_QUERY;
				goto _ifc_getflags;
			case IFG_DHCP_DOMAIN:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_DOMAIN;
				goto _ifc_getflags;
			case IFG_DHCP_FELLBACK:
				if (!di)
					goto _ifc_error;
				onflags = IFF_DHCP_FELLBACK | IFF_DHCP;
				goto _ifc_getflags;
			case IFG_DHCP_OK:
				onflags = IFF_DHCP_OK | IFF_DHCP;
				goto _ifc_getflags;
			#endif
			case IFS_ICMP_CONFIG:
				onflags = IFF_ICMP_CONFIG;
				goto _ifc_setflags;
			case IFG_ICMP_CONFIG:
				onflags = IFF_ICMP_CONFIG;
				goto _ifc_getflags;
				break;
			case IFG_ICMP_CONFIG_OK:
				onflags = IFF_ICMP_CFG_OK;
				goto _ifc_getflags;
				break;
			case IFS_ICMP_CONFIG_RESET:
				if (!ifte)
					goto _ifc_error;
				ifte->flags &= ~IFF_ICMP_CFG_OK;
				break;
			case IFS_DEBUG:
				debug_on = *(int *)p;
				p += sizeof(int);
				break;
			case IFG_DEBUG:
				ipval = *(int **)p;
				p += sizeof(int *);
				*ipval = debug_on;
				break;

#if USING_PPPLINK
			case IFS_PPP_SPEED:
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_SPEED, (longword *)p);
				p += sizeof(longword);
				break;

			case IFG_PPP_SPEED:
				lpval = *(longword **)p;
            *lpval = 0;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_SPEED, lpval);
				p += sizeof(longword *);
				break;
#endif

#ifdef USING_PPP

	#if !USING_PPPLINK
			case IFS_PPP_SPEED:
				p += sizeof(longword);
				break;

			case IFG_PPP_SPEED:
				p += sizeof(longword *);
				break;
	#endif

			case IFS_PPP_ACCEPTIP:
				if (!ppp) goto _ifc_error;
            if (*(int *)p) {
					ppp->ipcp.flags |= IPCP_F_IP_NEGOT;
					ppp->ipcp.local_ip = 0L; //make sure zeroed out
            }
            else
            	ppp->ipcp.flags &= ~IPCP_F_IP_NEGOT;
				p += sizeof(int);
				break;

			case IFG_PPP_ACCEPTIP:
				if (!ppp) goto _ifc_error;
				ipval = *(int **)p;
				*ipval = (ppp->ipcp.flags & IPCP_F_IP_NEGOT) != 0;
				p += sizeof(int *);
				break;

			case IFS_PPP_REMOTEIP:
				if (!ppp) goto _ifc_error;
				if (*(longword *)p) {
					ppp->ipcp.remote_ip = *(longword *)p;
					ppp->ipcp.flags |= IPCP_F_HAVE_HIS_IP;
            }
            else
					ppp->ipcp.flags &= ~IPCP_F_HAVE_HIS_IP;
				p += sizeof(longword);
				break;

			case IFG_PPP_REMOTEIP:
				if (!ppp) goto _ifc_error;
				lpval = *(longword **)p;
				if(ppp->ipcp.flags & IPCP_F_HAVE_HIS_IP)
					*lpval = ppp->ipcp.remote_ip;
				else
					*lpval = 0L;
				p += sizeof(longword *);
				break;


			case IFS_PPP_ACCEPTDNS:
				if (!ppp) goto _ifc_error;
            if (*(int *)p) {
					ppp->ipcp.flags |= IPCP_F_DNS_NEGOT;
					ppp->ipcp.primary_dns = 0L;
					ppp->ipcp.secondary_dns = 0L;
            }
            else
            	ppp->ipcp.flags &= ~IPCP_F_DNS_NEGOT;
				p += sizeof(int);
				break;

			case IFG_PPP_ACCEPTDNS:
				if (!ppp) goto _ifc_error;
				ipval = *(int **)p;
				*ipval = (ppp->ipcp.flags & IPCP_F_DNS_NEGOT) != 0;
				p += sizeof(int *);
				break;

			case IFS_PPP_REMOTEDNS:
				if (!ppp) goto _ifc_error;
				if (*(longword *)p) {
            	ppp->ipcp.flags |= IPCP_F_HAVE_HIS_DNS;
					ppp->ipcp.primary_dns = *(longword *)p;
					ppp->ipcp.secondary_dns = *(longword *)(p + sizeof(longword));
				}
            else
            	ppp->ipcp.flags &= ~IPCP_F_HAVE_HIS_DNS;
				p += 2*sizeof(longword);
				break;

			case IFG_PPP_REMOTEDNS:
				if (!ppp) goto _ifc_error;
				lpval = *(longword **)p;
				*lpval = ppp->ipcp.primary_dns;
				lpval = *(longword **)(p + sizeof(longword *));
				*lpval = ppp->ipcp.secondary_dns;
				p += 2*sizeof(longword *);
				break;

			case IFS_PPP_AUTHCALLBACK:
				if (!ppp) goto _ifc_error;
				ppp->pap.require_auth = 1;
				ppp->pap.local_auth_callback = *(int (**)())p;
				p += sizeof(int (*)());
				break;

			case IFS_PPP_INIT:
				if (!ppp) goto _ifc_error;
            // This code should not be used.  ifup/ifdown does everything necessary.
            // It is harmless (but inefficient) to do this provided the interface is currently down.
				PPPinitialize(ppp, ifte->state, iface, ifte->ncd, NULL, NULL);
				break;

			case IFS_PPP_REMOTEAUTH:
				if (!ppp) goto _ifc_error;
				ppp->pap.have_auth = 1;
				strcpy(ppp->pap.remote_username, *(char **)p);
				strcpy(ppp->pap.remote_password, *(char **)(p + sizeof(char *)));
				if (!*ppp->pap.remote_username &&
				    !*ppp->pap.remote_password)
					ppp->pap.have_auth = 0;
				p += 2*sizeof(char *);
				break;

			case IFG_PPP_REMOTEAUTH:
				if (!ppp) goto _ifc_error;
				cptrptr = *(char ***)p;
				*cptrptr = ppp->pap.remote_username;
				cptrptr = *(char ***)(p + sizeof(char **));
				*cptrptr = ppp->pap.remote_password;
				p += 2*sizeof(char **);
				break;


			case IFS_PPP_LOCALAUTH:
				if (!ppp) goto _ifc_error;
				ppp->pap.require_auth = 1;
				ppp->pap.local_auth_callback = NULL; //use single login combo
				strcpy(ppp->pap.local_username, *(char **)p);
				strcpy(ppp->pap.local_password, *(char **)(p + sizeof(char *)));
				p += 2*sizeof(char *);
				break;

			case IFG_PPP_LOCALAUTH:
				if (!ppp) goto _ifc_error;
				cptrptr = *(char ***)p;
				if(!ppp->pap.local_auth_callback)
					*cptrptr = ppp->pap.local_username;
				else
					*cptrptr = NULL;
				cptrptr = *(char ***)(p + sizeof(char **));
				if(!ppp->pap.local_auth_callback)
					*cptrptr = ppp->pap.local_password;
				else
					*cptrptr = NULL;
				p += 2*sizeof(char **);
				break;
#endif

#if USING_PPPLINK
			case IFS_PPP_RTSPIN:
            // We now ignore the shadow register, since the ioctl computes it.
            i = FLOWCTL_RTS;
            j = 1 << *(int *)(p + sizeof(int) + sizeof(char *));
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWIN, &i, p, &j);
				p += sizeof(char *) + 2*sizeof(int);
				break;

			case IFG_PPP_RTSPIN:
            i = FLOWCTL_QUERY;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWIN, &i, *(int **)p, &j);
            cptrptr = *(char ***)(p + sizeof(int *));
            *cptrptr = NULL;  // We don't return the shadow any more
            ipval = *(int **)(p + sizeof(int *) + sizeof(char **));
            *ipval = 0;
            if(j) {
               while(j >>= 1)
                  *ipval++;
            }
				p += sizeof(char **) + 2*sizeof(int *);
				break;

			case IFS_PPP_CTSPIN:
            i = FLOWCTL_CTS;
            j = 1 << *(int *)(p + sizeof(int));
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWOUT, &i, p, &j);
				p += 2*sizeof(int);
				break;

			case IFG_PPP_CTSPIN:
            i = FLOWCTL_QUERY;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWOUT, &i, *(int **)p, &j);
            ipval = *(int **)(p + sizeof(int *));
            *ipval = 0;
            if(j) {
               while(j >>= 1)
                  *ipval++;
            }
				p += 2*sizeof(int *);
				break;

			case IFS_PPP_FLOWCONTROL:
            // We treat inbound and outbound the same.  Also assume hardware f.c.
            if (*(int *)p)
            	*(int *)p = FLOWCTL_CTS;
            else
            	*(int *)p = FLOWCTL_NONE;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWIN, p, NULL, NULL);
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWOUT, p, NULL, NULL);
				p += sizeof(int);
				break;

			case IFG_PPP_FLOWCONTROL:
				if(IF_PKT_SER(iface)) {
					ipval = *(int **)p;
	         	*ipval = FLOWCTL_QUERY;
               // Retrieve just the outbound setting
					ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLOWOUT, ipval, NULL, NULL);;
				}
            else
            	*ipval = FLOWCTL_NONE;
				p += sizeof(int *);
				break;
#endif

#ifdef USING_PPP
			case IFS_PPP_SENDEXPECT:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_SENDEX, *(char **)p);
            // Also turn on 'usemodem'
            i = 1;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_USEMODEM, &i);
			#endif
				p += sizeof(char *);
				break;

			case IFG_PPP_SENDEXPECT:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
				if(IF_PKT_SER(iface)) {
					cptrptr = *(char ***)p;
               *cptrptr = (char *)ifte->ncd->ioctl(ifte->state, PD_PPPLINK_SENDEX, NULL);
				}
			#endif
				p += sizeof(char **);
				break;

			case IFS_PPP_USEMODEM:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
				if(IF_PKT_SER(iface))
					ifte->ncd->ioctl(ifte->state, PD_PPPLINK_USEMODEM, p);
			#endif
				p += sizeof(int);
				break;

			case IFG_PPP_USEMODEM:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
				if(IF_PKT_SER(iface)) {
					ipval = *(int **)p;
					*ipval = ifte->ncd->ioctl(ifte->state, PD_PPPLINK_USEMODEM, NULL);
				}
			#endif
				p += sizeof(int *);
				break;

			case IFS_PPP_HANGUP:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_HANGUP, *(char **)p);
			#endif
				p += sizeof(char *);
				break;

			case IFG_PPP_HANGUP:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
				if(IF_PKT_SER(iface)) {
					cptrptr = *(char ***)p;
               *cptrptr = (char *)ifte->ncd->ioctl(ifte->state, PD_PPPLINK_HANGUP, NULL);
				}
			#endif
				p += sizeof(char **);
				break;

			case IFS_PPP_MODEMESCAPE:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
				if(IF_PKT_SER(iface))
					ifte->ncd->ioctl(ifte->state, PD_PPPLINK_MODEMESC, p);
			#endif
				p += sizeof(int);
				break;

			case IFG_PPP_MODEMESCAPE:
			#if USING_PPP_SERIAL
				if (!ppp) goto _ifc_error;
				if(IF_PKT_SER(iface)) {
					ipval = *(int **)p;
					*ipval = ifte->ncd->ioctl(ifte->state, PD_PPPLINK_MODEMESC, NULL);
				}
			#endif
				p += sizeof(int *);
				break;

#endif

#if USING_PPPLINK
			case IFS_PPP_USEPORTD:
            if (*(int *)p)
               i = 0xFFFF;
            else
               i = 0;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLAGS, &i, PPPPORT_ALT);
				p += sizeof(int);
				break;

			case IFG_PPP_USEPORTD:
            ipval = *(int **)p;
            *ipval = ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLAGS, NULL, 0) & PPPPORT_ALT;
				p += sizeof(int *);
				break;

			case IFS_PPP_USEPORTE:
            if (*(int *)p)
               i = 0xFFFF;
            else
               i = 0;
            ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLAGS, &i, PPPPORT_ALT2);
				p += sizeof(int);
				break;

			case IFG_PPP_USEPORTE:
            ipval = *(int **)p;
            *ipval = ifte->ncd->ioctl(ifte->state, PD_PPPLINK_FLAGS, NULL, 0) & PPPPORT_ALT2;
				p += sizeof(int *);
				break;
#endif // USING_PPPLINK

#ifdef USING_PPP
			case IFS_PPP_PASSIVE:
				if (!ppp) goto _ifc_error;
            ppp->passive = (char)*(int *)p;
				p += sizeof(int);
				break;

			case IFG_PPP_PASSIVE:
				if (!ppp) goto _ifc_error;
				ipval = *(int **)p;
				*ipval = ppp->passive;
				p += sizeof(int *);
				break;

			case IFG_PPP_PEERADDR:
				if (!ppp) goto _ifc_error;
				lpval = *(longword **)p;
				*lpval = _if_tab[iface].u.ppp.peeraddr;
				p += sizeof(longword *);
				break;


#endif

#ifdef USE_IF_CALLBACK
			case IFS_IF_CALLBACK:
				if (iface == IF_ANY)
					for (i = 0; i < IF_MAX; i++)
					{
						_if_tab[i].ifcallback = *(void (**)())p;
					}
				else
            {
               _if_tab[iface].ifcallback = *(void (**)())p;
            }
				p += sizeof(void (*)());
				break;
#endif

#if USING_PPPLINK
      case IFS_USE_DMA:
         rxchan = *(dma_chan_t *)p; p += sizeof(dma_chan_t);
         txchan = *(dma_chan_t *)p; p += sizeof(dma_chan_t);
         wval = *(word *)p; p += sizeof(word);
         ioctlrc = ifte->ncd->ioctl(ifte->state, PD_DMA, rxchan, txchan, wval);
         #ifdef NET_VERBOSE
         if (ioctlrc)
            printf("NET: IFS_USE_DMA: ioctl returned %d\n", ioctlrc);
         #endif
         break;
      case IFS_USE_SERIAL:
         ioctlrc = ifte->ncd->ioctl(ifte->state, PD_SERIAL);
         #ifdef NET_VERBOSE
         if (ioctlrc)
            printf("NET: IFS_USE_SERIAL: ioctl returned %d\n", ioctlrc);
         #endif
         break;
#endif

#if USING_WIFI
		case IFS_WIFI_SSID:							// int, byte *
         if (wasup == IF_UP || wasup == IF_COMING_UP) ifdown(iface);

         wval = *(word *)p;
         if (wval > WLN_SSID_SIZE) goto _ifc_error;
			p += sizeof(word);

         bpval = *(byte **)p;
			p += sizeof(byte *);

			// If zero length specified, compute from string length.  This is
			// handy, since SSIDs almost never contain null characters.
			if (!wval)
				wval = strlen(bpval);

         memcpy (_wifi_macParams.ssid, bpval, wval);
         _wifi_macParams.ssid_len = wval;

			// if 1-31 bytes, null-terminate SSID in structure
			if (wval < WLN_SSID_SIZE) _wifi_macParams.ssid[wval] = 0;

      	break;

      case IFG_WIFI_SSID:							// int *, byte[32]
	      wpval = *(word **)p;
	      p += sizeof(word *);
	      *wpval = _wifi_macParams.ssid_len;

         bpval = *(byte **)p;
			p += sizeof(byte *);
			memcpy (bpval, _wifi_macParams.ssid, _wifi_macParams.ssid_len);

      	break;

      case IFS_WIFI_MULTI_DOMAIN:				// bool
         if (wasup == IF_UP || wasup == IF_COMING_UP) ifdown(iface);

			wval = *(word *)p;
         p += sizeof(word);
			if (wval > 1) goto _ifc_error;
	      if (wval) {
	         _wifi_macParams.options |= WLN_OPT_MULTI_DOMAIN;

	         _wifi_scan.chan_mask = _wifi_macParams.chan_mask = WIFICONF_CHANMASK_ALL;
	         _wifi_macStatus.tx_power = -1;
	         _wifi_macParams.tx_power_max = _wifi_macParams.tx_power = WLN_TXPOWER_MIN;
	      } else {
	         _wifi_macParams.options &= ~WLN_OPT_MULTI_DOMAIN;

	         // Set Max allowable power level limit for current region
	         _wifi_macParams.tx_power_max = _wifi_region_current->max_pwr_index;

	         // Initially set RF to approx half the allowable power range
	         _wifi_macStatus.tx_power = (_wifi_macParams.tx_power_max/2) + 1;
	         _wc_SetTxPower(_wifi_macStatus.tx_power);

	         // Set allowable channel range for current region
	         _wifi_scan.chan_mask = _wifi_macParams.chan_mask =
            	_wifi_region_current->channel_mask;
	      }
      	break;

      case IFG_WIFI_MULTI_DOMAIN:				// bool *
         ipval = *(int **)p;
         p += sizeof(int *);
         *ipval = (_wifi_macParams.options & WLN_OPT_MULTI_DOMAIN) ? 1 : 0;
      	break;

      case IFS_WIFI_REGION:						// int
         if (wasup == IF_UP || wasup == IF_COMING_UP) ifdown(iface);
         wval = *(word *)p;
         p += sizeof(word);
         if (_wifi_setregion(wval) != wval) goto _ifc_error;
         break;

      case IFG_WIFI_REGION:						// int *
         ipval = *(int **)p;
         p += sizeof(int *);
         *ipval = _wifi_region_current->id;
      	break;

      case IFG_WIFI_REGION_INFO:					// wifi_region *
         bpval = *(byte **)p;
			p += sizeof(byte *);
			memcpy (bpval, _wifi_region_current, sizeof(*_wifi_region_current));
      	break;

	   case IFS_WIFI_MODE:  						// int
         if (wasup == IF_UP || wasup == IF_COMING_UP) ifdown(iface);

	      ival = *(int *)p;
	      p += sizeof(int);
	      if (ival & WLN_BSS_NONE) {
				_wifi_macParams.bss_type |= WLN_BSS_NONE;
				if (ival & WLN_BSS_NONE<<1)
					_wifi_macParams.bss_type &= ~WLN_BSS_NONE;
	      }
	      else
				_wifi_macParams.bss_type = ival;
	      break;

	   case IFG_WIFI_MODE:  						// int *
	      ipval = *(int **)p;
	      p += sizeof(int *);
			switch (_wifi_macParams.bss_type) {
				case WLN_BSS_IBSS:
            	*ipval = IFPARAM_WIFI_ADHOC;
            	break;

            case WLN_BSS_ESS:
            	*ipval = IFPARAM_WIFI_INFRASTRUCTURE;
            	break;

            default:
            	// bss_type should always be WLN_BSS_IBSS or WLN_BSS_ESS
               // if it's not (for some reason), return -1 as an error result
            	*ipval = -1;
         }
	      break;

	   case IFS_WIFI_CHANNEL:  					// int
         if (wasup == IF_UP || wasup == IF_COMING_UP) ifdown(iface);
	      wval = *(word *)p;
	      p += sizeof(word);

         // is this a valid channel? (0 to 14)
			if (wval > 14) goto _ifc_error;

         // set to auto-select (infrastructure network)
         if (wval == 0) {
         	_wifi_scan.chan_mask = _wifi_macParams.chan_mask;
         // does current region allow this channel?
			} else if (_wifi_macParams.chan_mask & (1 << (wval - 1))) {
            _wifi_scan.chan_mask = 1 << (wval - 1);
         } else goto _ifc_error;

			_wifi_macParams.channel = wval;
	      break;

	   case IFG_WIFI_CHANNEL:  					// int *
	      ipval = *(int **)p;
	      p += sizeof(int *);
         // note, returns current channel, not set channel
         // if you set zero, you can read something else back
         // *ipval = _wifi_macStatus.channel;

			// for now, return the configured channel
         *ipval = _wifi_macParams.channel;
	      break;

	   case IFS_WIFI_ENCRYPTION:   				// word
         if (wasup == IF_UP || wasup == IF_COMING_UP) ifdown(iface);
	      wval = *(word *)p;
	      p += sizeof(word);
	      #ifndef WIFI_AES_ENABLED
	      	if (wval == IFPARAM_WIFI_ENCR_CCMP) {
	            #ifdef NET_VERBOSE
	               printf("NET: IFPARAM_WIFI_ENCR_CCMP only valid if " \
	               	"WIFI_AES_ENABLED defined\n");
	            #endif
					goto _ifc_error;
				}
	      #endif
         _wifi_macParams.encrypt = wval;
	      break;

	   case IFG_WIFI_ENCRYPTION:   				// word *
	      wpval = *(word **)p;
	      p += sizeof(word *);
         *wpval = (word) (_wifi_macParams.encrypt & 0x0000FFFF);
	      break;

	   case IFS_WIFI_AUTHENTICATION:   			// word
	      wval = *(word *)p;
	      p += sizeof(word);
         _wifi_macParams.authen = wval;
	      break;

	   case IFG_WIFI_AUTHENTICATION:   			// word *
	      wpval = *(word **)p;
	      p += sizeof(word *);
         *wpval = (word) (_wifi_macParams.authen & 0x0000FFFF);
	      break;

	   case IFS_WIFI_TX_RATE:  					// int
	      wval = *(word *)p;
	      p += sizeof(word);
	      brset = NCPSKBRSR_SET;
	      ofdmset = 0;
	      if (_wifi_macParams.options & WLN_OPT_BONLY &&
	          !(wval < IFPARAM_WIFI_TX_RATE_6 ||
	            wval == IFPARAM_WIFI_TX_RATE_11))
	      	goto _ifc_error;
         switch (wval) {
            // 802.11b rates
            case IFPARAM_WIFI_TX_RATE_ANY: ofdmset = 0xFF; break;
            case IFPARAM_WIFI_TX_RATE_1: brset = 0x01; break;
            case IFPARAM_WIFI_TX_RATE_2: brset = 0x03; break;
            case IFPARAM_WIFI_TX_RATE_5_5:
            	#if !_WIFI_SILKEN_DAC
               brset = 0x07;
               #endif
               break;
            case IFPARAM_WIFI_TX_RATE_11:
               #if !_WIFI_SILKEN_DAC
               brset = 0x0F;
               #endif
               break;

            // 802.11g rates
            case IFPARAM_WIFI_TX_RATE_6: ofdmset = 0x01; break;
            case IFPARAM_WIFI_TX_RATE_9: ofdmset = 0x03; break;
            case IFPARAM_WIFI_TX_RATE_12: ofdmset = 0x07; break;
            case IFPARAM_WIFI_TX_RATE_18: ofdmset = 0x0F; break;
            case IFPARAM_WIFI_TX_RATE_24: ofdmset = 0x1F; break;
            case IFPARAM_WIFI_TX_RATE_36: ofdmset = 0x3F; break;
            case IFPARAM_WIFI_TX_RATE_48: ofdmset = 0x7F; break;
            case IFPARAM_WIFI_TX_RATE_54: ofdmset = 0xFF; break;
            default:
               goto _ifc_error;
         }
			lock_level = _WIFI_DISABLE();
         _wc_write8(NCPSKBRSR, brset);
         _wc_write8(NCOFDMBRSR, ofdmset);
         _wifi_macParams.tx_rate = (int) wval;
         _wifi_UpdateRate();
         _WIFI_ENABLE(lock_level);
	      break;

	   case IFG_WIFI_TX_RATE:  					// int *
	      wpval = *(word **)p;
	      p += sizeof(word *);
         *wpval = (word) _wifi_macParams.tx_rate;
	      break;

	   case IFS_WIFI_TX_POWER: 					// int
	      ival = *(int *)p;
	      p += sizeof(int);
         if ((ival < 0) || (ival > 15)) goto _ifc_error;
         if (ival > _wifi_macParams.tx_power_max) ival = _wifi_macParams.tx_power_max;
	      _wifi_macStatus.tx_power = ival;
	      _wc_SetTxPower(ival);
	      break;

	   case IFG_WIFI_TX_POWER: 					// int *
	      ipval = *(int **)p;
	      p += sizeof(int *);
	      *ipval = _wifi_macStatus.tx_power;
	      break;

	   case IFS_WIFI_FRAG_THRESHOLD: 			// int (256-2346)
	      ival = *(int *)p;
	      p += sizeof(int);
	      if ((ival == 0) || (ival > _WIFI_DATA_SIZE+_WIFI_BUF_SIZE))
	         _wifi_macParams.frag_thresh = _WIFI_DATA_SIZE+_WIFI_BUF_SIZE;
	      else if (ival < 0)
         	goto _ifc_error;
	      else if (ival < 256)
	         _wifi_macParams.frag_thresh = 256;
	      else
	         _wifi_macParams.frag_thresh = ival;
	      // Make the fragmentation threshold even
	      _wifi_macParams.frag_thresh &= ~1;
	      _wifi_maxFragSize = _wifi_macParams.frag_thresh;
	      break;

	   case IFG_WIFI_FRAG_THRESHOLD: 			// int *
	      ipval = *(int **)p;
	      p += sizeof(int *);
	      *ipval = _wifi_macParams.frag_thresh;
	      break;

	   case IFS_WIFI_RTS_THRESHOLD:  			// int (1-2347)
	      ival = *(int *)p;
	      p += sizeof(int);
	      if ((ival <= 0) || (ival > 2347))
	         _wifi_macParams.rts_thresh = 2347;
	      else
	         _wifi_macParams.rts_thresh = ival;
	      break;

	   case IFG_WIFI_RTS_THRESHOLD:  			// int *
	      ipval = *(int **)p;
	      p += sizeof(int *);
	      *ipval = _wifi_macParams.rts_thresh;
	      break;

      case IFS_WIFI_SCAN:							// void (*)()
      	_wifi_scan.callback = *(void (**)())p;
			p += sizeof(void (*)());

         if (_wifi_scan.callback == NULL) goto _ifc_error;
			_wifi_StartScan("", 0, WLN_CHAN_SCAN, TRUE);
			break;

      case IFG_WIFI_STATUS:						// wifi_status *
         bpval = *(byte **)p;
			p += sizeof(byte *);
         memcpy (bpval, &_wifi_macStatus, sizeof (wifi_status));
			break;

	   case IFS_WIFI_WEP_KEYNUM:  				// int
	      wval = *(word *)p;
	      p += sizeof(word);
         if (wval > 3) goto _ifc_error;
         _wifi_macParams.wep_key_id = (int) wval;
	      break;

	   case IFG_WIFI_WEP_KEYNUM:  				// int *
	      ipval = *(int **)p;
	      p += sizeof(int *);
         *ipval = _wifi_macParams.wep_key_id;
	      break;

	   case IFS_WIFI_WEP_KEY_BIN: 				// int, int, byte *
	      wval = *(word *)p;	// key num
	      p += sizeof(word);
         if (wval > 3) goto _ifc_error;

	      ival = *(int *)p;		// key size
	      p += sizeof(int);

         bpval = *(byte **)p;	// key data
			p += sizeof(byte *);

			switch (ival) {
				case 0:
            case IFPARAM_WIFI_WEP_KEY40:
            case IFPARAM_WIFI_WEP_KEY104:
            	// if length valid, save it and copy the key
					_wifi_macParams.wep_key_len[wval] = ival;
               if (ival)
               	memcpy (_wifi_macParams.wep_key[wval], bpval, ival);
					break;
            default:
            	goto _ifc_error;
         }
	      break;

	   case IFG_WIFI_WEP_KEY_BIN: 				// int, int *, byte *
	      wval = *(word *)p;	// key num
	      p += sizeof(word);
         if (wval > 3) goto _ifc_error;

	      ipval = *(int **)p;	// ptr to key size
	      p += sizeof(int *);
         *ipval = _wifi_macParams.wep_key_len[wval];

         bpval = *(byte **)p;	// key data
			p += sizeof(byte *);
         memcpy (bpval, _wifi_macParams.wep_key[wval], *ipval);
	      break;

	   case IFS_WIFI_WEP_KEY_HEXSTR: 			// int, char *
	      wval = *(word *)p;	// key num
	      p += sizeof(word);
         if (wval > 3) goto _ifc_error;

         cptr = *(char **)p;
			p += sizeof(char *);

         // ignore optional 0x prefix on hex string
			if ((cptr[0] == '0') && (cptr[1] == 'x')) cptr += 2;

         // find length of key, aborting if over 26 characters
         ival = 0;		// length of key (in hex)
         bpval = cptr;
			while (*bpval++) {
				if (++ival > (2 * IFPARAM_WIFI_WEP_KEY104)) break;
         }

			switch (ival) {
				case 0:
            case IFPARAM_WIFI_WEP_KEY40 * 2:
            case IFPARAM_WIFI_WEP_KEY104 * 2:
            	ival >>= 1;
         		_wifi_macParams.wep_key_len[wval] = ival;
		         bpval = _wifi_macParams.wep_key[wval];
               for (i = 0; i < ival; i++) {
						j = hexstrtobyte (cptr);
                  if (j == -1) goto _ifc_error;		// invalid hex string
                  *bpval++ = j;
                  cptr += 2;
               }
               break;

            default:
               goto _ifc_error;
         }
	      break;

	   case IFG_WIFI_WEP_KEY_HEXSTR:				// int, char *
	      wval = *(word *)p;	// key num
	      p += sizeof(word);
         if (wval > 3) goto _ifc_error;

         cptr = *(char **)p;		// buffer to store key as hex string
			p += sizeof(char *);

         ival = _wifi_macParams.wep_key_len[wval];		// bytes in key
			bpval = _wifi_macParams.wep_key[wval];			// pointer to key

         if (ival == 0) *cptr = 0;				// empty key
         else for (i = 0; i < ival; i++) {
				cptr += sprintf (cptr, "%02X", *bpval++);
         }
	      break;

#ifdef WIFI_USE_WPA
	   case IFS_WIFI_WPA_PSK_PASSPHRASE:   	// char *
         cptr = *(char **)p;
			p += sizeof(char *);

	      #ifdef WIFI_VERBOSE_PASSPHRASE
	      	printf ("Generating PSK from passphrase (takes 40 sec or so)...\n");
	      #endif
	      pbkdf2_sha1 (cptr, _wifi_macParams.ssid, _wifi_macParams.ssid_len, 4096,
	         _wifi_macParams.wpa_psk, sizeof(_wifi_macParams.wpa_psk));
	      #ifdef WIFI_VERBOSE_PASSPHRASE
	         printf ("...done\n");
	         printf ("Sick of waiting?... then use the following instead:\n");
	         printf ("  IFC_WIFI_WPA_PSK_HEXSTR, \"");
	         for (i = 0; i < sizeof(_wifi_macParams.wpa_psk); ++i)
	            printf("%02X", _wifi_macParams.wpa_psk[i]);
	         printf ("\"\nwhich is valid for passphrase \"%s\"\n", cptr);
	         printf ("when used with SSID \"%.*s\".\n",
	            _wifi_macParams.ssid_len, _wifi_macParams.ssid_len ? _wifi_macParams.ssid : "");
	      #endif
	      break;

	   case IFS_WIFI_WPA_PSK_HEXSTR:				// char[65]
         cptr = *(char **)p;
			p += sizeof(char *);

	      #ifdef WIFI_VERBOSE_PASSPHRASE
				printf("Using hexadecimal PSK\n");
	      #endif
         // ignore optional 0x prefix on hex string
			if ((cptr[0] == '0') && (cptr[1] == 'x')) cptr += 2;

         bpval = _wifi_macParams.wpa_psk;
         for (i = 0; i < 32; i++) {
				j = hexstrtobyte (cptr);
				if (j == -1) goto _ifc_error;
            *bpval++ = j;
            cptr += 2;
         }
	      break;

	   case IFG_WIFI_WPA_PSK_HEXSTR:				// char[65]
         cptr = *(char **)p;
			p += sizeof(char *);
         bpval = _wifi_macParams.wpa_psk;
			for (i = 0; i < 32; i++) {
				cptr += sprintf (cptr, "%02X", *bpval++);
         }
	      break;

	   case IFS_WIFI_WPA_PSK_BIN: 				// byte[32]
         bpval = *(byte **)p;
			p += sizeof(byte *);
         memcpy (_wifi_macParams.wpa_psk, bpval, sizeof(_wifi_macParams.wpa_psk));
	      break;

	   case IFG_WIFI_WPA_PSK_BIN: 				// byte[32]
         bpval = *(byte **)p;
			p += sizeof(byte *);
         memcpy (bpval, _wifi_macParams.wpa_psk, sizeof(_wifi_macParams.wpa_psk));
	      break;
	#ifdef WPA_USE_EAP
		case IFS_WIFI_WPA_PROTOCOL:
	      _wifi_macParams.protocol = *(word *)p;
	      p += sizeof(word);
	      break;
	   case IFG_WIFI_WPA_PROTOCOL:
	      **(int **)p = _wifi_macParams.protocol;
	      p += sizeof(int *);
	      break;

		case IFS_WIFI_PAIRWISE_ENCRYPTION:
	      _wifi_macParams.pairwise_encr = *(word *)p;
	      p += sizeof(word);
	      break;
	   case IFG_WIFI_PAIRWISE_ENCRYPTION:
	      **(int **)p = _wifi_macParams.pairwise_encr;
	      p += sizeof(int *);
	      break;

		case IFS_WIFI_EAP_TLS_FLAGS:
	      _wifi_macParams.tls_flags = *(word *)p;
	      p += sizeof(word);
	      break;
	   case IFG_WIFI_EAP_TLS_FLAGS:
	      **(int **)p = _wifi_macParams.tls_flags;
	      p += sizeof(int *);
	      break;

		case IFS_WIFI_EAP_METHODS:
	      _wifi_macParams.eap_methods = *(longword *)p;
	      p += sizeof(longword);
	      break;
	   case IFG_WIFI_EAP_METHODS:
	      **(longword **)p = _wifi_macParams.eap_methods;
	      p += sizeof(longword *);
	      break;

		// vifconfig cases
		case IFS_WIFI_IDENTITY:
         cptr = *(char **)p;
			p += sizeof(char *);
			strncpy(_wifi_macParams.identity, cptr, sizeof(_wifi_macParams.identity));
	      break;
	   case IFG_WIFI_IDENTITY:
         cptrptr = *(char ***)p;
			p += sizeof(char **);
			*cptrptr = _wifi_macParams.identity;
	      break;

		case IFS_WIFI_ANONYMOUS_IDENTITY:
         cptr = *(char **)p;
			p += sizeof(char *);
			if (cptr)
				strncpy(_wifi_macParams.anonymous_identity, cptr, sizeof(_wifi_macParams.anonymous_identity));
			else
				_wifi_macParams.anonymous_identity[0] = 0;
	      break;
	   case IFG_WIFI_ANONYMOUS_IDENTITY:
         cptrptr = *(char ***)p;
			p += sizeof(char **);
			*cptrptr = _wifi_macParams.anonymous_identity;
	      break;

		case IFS_WIFI_PASSWORD:
         cptr = *(char **)p;
			p += sizeof(char *);
			strncpy(_wifi_macParams.password, cptr, sizeof(_wifi_macParams.password));
	      break;
	   case IFG_WIFI_PASSWORD:
         cptrptr = *(char ***)p;
			p += sizeof(char **);
			*cptrptr = _wifi_macParams.password;
	      break;

		case IFS_WIFI_CA_CERT:
         _wifi_macParams.ca_cert = *(struct SSL_Cert_t_t __far **)p;
			p += 4; //sizeof(struct SSL_Cert_t_t far *);
	      break;
	   case IFG_WIFI_CA_CERT:
         **(struct SSL_Cert_t_t __far ***)p = _wifi_macParams.ca_cert;
			p += 4; //sizeof(struct SSL_Cert_t_t far **);
	      break;

		case IFS_WIFI_CA_CERT2:
         _wifi_macParams.ca_cert2 = *(struct SSL_Cert_t_t __far **)p;
			p += 4; //sizeof(struct SSL_Cert_t_t far *);
	      break;
	   case IFG_WIFI_CA_CERT2:
         **(struct SSL_Cert_t_t __far ***)p = _wifi_macParams.ca_cert2;
			p += 4; //sizeof(struct SSL_Cert_t_t far **);
	      break;

		case IFS_WIFI_CLIENT_CERT:
         _wifi_macParams.client_cert = *(struct SSL_Cert_t_t __far **)p;
			p += 4; //sizeof(struct SSL_Cert_t_t far *);
	      break;
	   case IFG_WIFI_CLIENT_CERT:
         **(struct SSL_Cert_t_t __far ***)p = _wifi_macParams.client_cert;
			p += 4; //sizeof(struct SSL_Cert_t_t far **);
	      break;

		case IFS_WIFI_CLIENT_CERT2:
         _wifi_macParams.client_cert2 = *(struct SSL_Cert_t_t __far **)p;
			p += 4; //sizeof(struct SSL_Cert_t_t far *);
	      break;
	   case IFG_WIFI_CLIENT_CERT2:
         **(struct SSL_Cert_t_t __far ***)p = _wifi_macParams.client_cert2;
			p += 4; //sizeof(struct SSL_Cert_t_t far **);
	      break;

#define __CERT_PRIVKEY	1		// get private key also
#define __ZSERV_FORM  	1		// Zserver path form

		case IFS_WIFI_CA_CERT_PATH:
			cm = &_wifi_macParams.ca_cert_managed;
			ival = !__CERT_PRIVKEY;	// no private key
			wval = __ZSERV_FORM;	// Zserver path form
			goto _common_cert_xim;
		case IFS_WIFI_CA_CERT2_PATH:
			cm = &_wifi_macParams.ca_cert2_managed;
			ival = !__CERT_PRIVKEY;	// no private key
			wval = __ZSERV_FORM;	// Zserver path form
			goto _common_cert_xim;
		case IFS_WIFI_CLIENT_CERT_PATH:
			cm = &_wifi_macParams.client_cert_managed;
			ival = __CERT_PRIVKEY;	// get private key also
			wval = __ZSERV_FORM;	// Zserver path form
			goto _common_cert_xim;
		case IFS_WIFI_CLIENT_CERT2_PATH:
			cm = &_wifi_macParams.client_cert2_managed;
			ival = __CERT_PRIVKEY;	// get private key also
			wval = __ZSERV_FORM;	// Zserver path form
			goto _common_cert_xim;
		case IFS_WIFI_CA_CERT_XIM:
			cm = &_wifi_macParams.ca_cert_managed;
			ival = !__CERT_PRIVKEY;	// no private key
			wval = !__ZSERV_FORM;	// #ximport form
			goto _common_cert_xim;
		case IFS_WIFI_CA_CERT2_XIM:
			cm = &_wifi_macParams.ca_cert2_managed;
			ival = !__CERT_PRIVKEY;	// no private key
			wval = !__ZSERV_FORM;	// #ximport form
			goto _common_cert_xim;
		case IFS_WIFI_CLIENT_CERT_XIM:
			cm = &_wifi_macParams.client_cert_managed;
			ival = __CERT_PRIVKEY;	// get private key also
			wval = !__ZSERV_FORM;	// #ximport form
			goto _common_cert_xim;
		case IFS_WIFI_CLIENT_CERT2_XIM:
			cm = &_wifi_macParams.client_cert2_managed;
			ival = __CERT_PRIVKEY;	// get private key also
			wval = !__ZSERV_FORM;	// #ximport form
		_common_cert_xim:
			if (wval == __ZSERV_FORM) {
				lval = (long)(char __far *)*(char **)p;
				p += sizeof(char *);
			}
			else {
	         lval = *(longword *)p;
	         p += sizeof(longword);
	      }
			if (ival == __CERT_PRIVKEY) {
				if (wval == __ZSERV_FORM) {
	            lval2 = (long)(char __far *)*(char **)p;
	            p += sizeof(char *);
				}
				else {
	            lval2 = *(longword *)p;
	            p += sizeof(longword);
				}
			}
			if (*cm) {
				SSL_free_cert(*cm);
				_sys_free(*cm);
				*cm = NULL;
			}
			if (!lval)
				break;
			*cm = _sys_calloc(sizeof(SSL_Cert_t));
			if (!*cm)
				goto _ifc_error;
			i = SSL_new_cert(*cm, lval, wval == __ZSERV_FORM ?
			                                    SSL_DCERT_Z : SSL_DCERT_XIM, 0);
			if (i)
				goto _ifc_error;
			if (ival) {
				i = SSL_set_private_key(*cm, lval2, wval == __ZSERV_FORM ?
				                                 SSL_DCERT_Z : SSL_DCERT_XIM);
				if (i)
					goto _ifc_error;
			}
	      break;
#undef __CERT_PRIVKEY
#undef __ZSERV_FORM


	   case IFS_WIFI_EAP_PSK_PASSPHRASE:   	// char *
         cptr = *(char **)p;
			p += sizeof(char *);

	      #ifdef WIFI_VERBOSE_PASSPHRASE
	      	printf ("Generating EAP PSK from passphrase (takes 40 sec or so)...\n");
	      #endif
	      pbkdf2_sha1 (cptr, _wifi_macParams.ssid, _wifi_macParams.ssid_len, 4096,
	         _wifi_macParams.eappsk, sizeof(_wifi_macParams.eappsk));
	      #ifdef WIFI_VERBOSE_PASSPHRASE
	         printf ("...done\n");
	         printf ("Sick of waiting?... then use the following instead:\n");
	         printf ("  IFS_WIFI_EAP_PSK_HEXSTR, \"");
	         for (i = 0; i < sizeof(_wifi_macParams.eappsk); ++i)
	            printf("%02X", _wifi_macParams.eappsk[i]);
	         printf ("\"\nwhich is valid for passphrase \"%s\"\n", cptr);
	         printf ("when used with SSID \"%.*s\".\n",
	            _wifi_macParams.ssid_len, _wifi_macParams.ssid_len ? _wifi_macParams.ssid : "");
	      #endif
	      break;

	   case IFS_WIFI_EAP_PSK_HEXSTR:				// char[65]
         cptr = *(char **)p;
			p += sizeof(char *);

	      #ifdef WIFI_VERBOSE_PASSPHRASE
				printf("Using hexadecimal EAP PSK\n");
	      #endif
         // ignore optional 0x prefix on hex string
			if ((cptr[0] == '0') && (cptr[1] == 'x')) cptr += 2;

         bpval = _wifi_macParams.eappsk;
         for (i = 0; i < 32; i++) {
				j = hexstrtobyte (cptr);
				if (j == -1) goto _ifc_error;
            *bpval++ = j;
            cptr += 2;
         }
	      break;

	   case IFG_WIFI_EAP_PSK_HEXSTR:				// char[65]
         cptr = *(char **)p;
			p += sizeof(char *);
         bpval = _wifi_macParams.eappsk;
			for (i = 0; i < 32; i++) {
				cptr += sprintf (cptr, "%02X", *bpval++);
         }
	      break;

	   case IFS_WIFI_EAP_PSK_BIN: 				// byte[32]
         bpval = *(byte **)p;
			p += sizeof(byte *);
         memcpy (_wifi_macParams.eappsk, bpval, sizeof(_wifi_macParams.eappsk));
	      break;

	   case IFG_WIFI_EAP_PSK_BIN: 				// byte[32]
         bpval = *(byte **)p;
			p += sizeof(byte *);
         memcpy (bpval, _wifi_macParams.eappsk, sizeof(_wifi_macParams.eappsk));
	      break;

		case IFS_WIFI_SUBJECT_MATCH:
         cptr = *(char **)p;
			p += sizeof(char *);
			strncpy(_wifi_macParams.subject_match, cptr, sizeof(_wifi_macParams.subject_match));
	      break;

		case IFS_WIFI_SUBJECT_MATCH2:
         cptr = *(char **)p;
			p += sizeof(char *);
			strncpy(_wifi_macParams.subject_match2, cptr, sizeof(_wifi_macParams.subject_match2));
	      break;

		case IFS_WIFI_ALTSUBJECT_MATCH:
         cptr = *(char **)p;
			p += sizeof(char *);
			strncpy(_wifi_macParams.altsubject_match, cptr, sizeof(_wifi_macParams.altsubject_match));
	      break;

		case IFS_WIFI_ALTSUBJECT_MATCH2:
         cptr = *(char **)p;
			p += sizeof(char *);
			strncpy(_wifi_macParams.altsubject_match2, cptr, sizeof(_wifi_macParams.altsubject_match2));
	      break;

	#endif	// WPA_USE_EAP
#endif	// WIFI_USE_WPA

		// Options for Wi-Fi Roaming
	   case IFS_WIFI_ROAM_ENABLE:             // bool
			ival = *(int *)p;
         p += sizeof(int);
			_wifi_scan.roam_enabled = ival;
			break;

	   case IFG_WIFI_ROAM_ENABLE:             // bool *
			ipval = *(int **)p;
         p += sizeof(int *);
		   *ipval = _wifi_scan.roam_enabled;
			break;

	   case IFS_WIFI_ROAM_BEACON_MISS:           // int
			ival = *(int *)p;
         p += sizeof(int);
         _wifi_scan.roam_beacon_loss = ival;
			break;

	   case IFG_WIFI_ROAM_BEACON_MISS:           // int *
         ipval = *(int **)p;
         p += sizeof(int *);
         *ipval = _wifi_scan.roam_beacon_loss;
			break;



#endif
			default:
#ifndef NET_VERBOSE
				// Only throw this exception if not verbose.  Else it's a pain
				// to find out the offending parameter.
				exception(-ERR_BADPARAMETER);
#endif
				goto _ifc_error;	// This should never execute
		}
	}

_clean_return:
	ident = 0;
_ifc_error:
#ifdef NET_VERBOSE
	if (ident) {
		printf("NET: ifconfig() bad or inappropriate IFS/IFG parameter ID: %d\n",
					ident);
		printf("  Apparently at IFS/IFG parameter number %d\n", parm_no);
		printf("  Last apparently successful IFS/IFG parameter is %d\n",
					last_parm);
		exception(-ERR_BADPARAMETER);
	}
#endif

#if USING_WIFI
	#ifdef WIFI_USE_WPA
	   if (wpa_update) wpa_set_params (&_wifi_macParams);
	#endif
#endif

	UNLOCK_GLOBAL_IF_INIT(TCPGlobalLock);
	return ident;
}

/*** BeginHeader is_valid_iface */
int is_valid_iface(int iface);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
is_valid_iface                               <NET.LIB>

SYNTAX: int is_valid_iface(int iface)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function returns a boolean indicator of whether the
               given interface number is valid for the configuration.

PARAMETER1: 	iface - interface number.

RETURN VALUE:  non-zero if the interface is valid;
					0 if the interface does not exist.

SEE ALSO:      ifconfig, ifup, ifdown, ifstatus

END DESCRIPTION **********************************************************/
_net_nodebug
int is_valid_iface(int iface)
{
	return (1u<<iface) & IF_SET;
}


/*** BeginHeader _net_notify_link */
int _net_notify_link(word iface, int up);
/*** EndHeader */
/*
	This is called from link layer when link status chages.  For Ethernet, this
	is basically plugging/unplugging the cable.  For Wifi, it is associating/
	disassociating with the AP.

	For Ethernet, we don't get this notification (yet), hence Ethernet link
	up/down events have no effect on the higher layers.

	WiFi driver calls this routine since it is much more likely to switch
	to different AP's/networks (esp. when roaming).

	Link down is not necessarily a disaster, so we shouldn't abort open sockets
	or anything, but we should remember the IP address/netmask we were using.
	On link up, redo DHCP if we are using it on this interface.  If we get the
	same IP/netmask then we continue as if nothing happened.  If different, we
	abort sockets.
*/
_net_nodebug
int _net_notify_link(word iface, int up)
{
	auto word ifmask;
   auto IFTEntry * ie;

	ifmask = 1 << iface;
	ie = _if_tab + iface;

	if (!up) {
		// Link down, save current IP addrs
		ie->ldown_ipaddr = ie->ipaddr;
		ie->ldown_mask = ie->mask;
		ie->lnk = 0;
	}
	else {
		ie->lnk = 1;
		// Link up.
		if (ifpending(iface) == IF_COMING_UP || ifpending(iface) == IF_UP) {
			// This causes mismatch between prequest and request, which
			// invokes normal ifup processing in ifctl_tick().
			// (Note that we don't set _if_prequest, since don't want the
			// "change" flag set, otherwise state gets trashed.)
			_if_actual &= ~ifmask;
	      #ifdef USE_DHCP
	      // This required to trigger DHCP when comes back up
	      _if_dhcp &= ~ifmask;
	      #endif
		}
	}
}


/*** BeginHeader virtual_eth */
int virtual_eth(word real_iface, longword ipaddr, longword netmask,
	void * resv);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
virtual_eth                                  <NET.LIB>

SYNTAX: int virtual_eth(word real_iface, longword ipaddr, longword netmask,
               void * resv)

KEYWORDS:		tcpip, interface

DESCRIPTION: 	Create a new virtual ethernet interface.  You must
               #define VIRTUAL_ETH to a positive number (1-6) for this
               function to work.

               Virtual ethernet interfaces have some restrictions:
               1. You cannot use DHCP
               2. Broadcast/multicast packets are not received.
               3. Some ifconfig() settings (such as MTU size) are
                  not settable.
               4. Once a virtual interface is created, it cannot
                  be destroyed.  In practice, this means that all
                  virtual i/f's should be created at boot time
                  (after sock_init).

               The virtual i/f will be created in the same up/down
               state as the real i/f.  Changes to the up/down state
               of the real i/f will affect all virtual i/f's tied
               to that interface.

               The callback function for a virtual i/f is set to NULL.

PARAMETER1: 	The real interface to use.  This must be IF_ETH0, or
               may be IF_ETH1 for boards with two ethernet chips.
PARAMETER2:    The IP address to assign this interface.  This must not
               be the same as the IP address of any other interface.
PARAMETER3:    Netmask to use.  If zero, then the netmask of the real
               interface will be used.
PARAMETER4:    Pointer reserved for future use.  Pass as NULL.

RETURN VALUE:  -1: failed because VIRTUAL_ETH was not defined, or the
                   number of virtual interfaces exceeds the value specified
                   by VIRTUAL_ETH, or the real_iface parameter was not
                   valid.
               otherwise: returns the interface number to use for this
                   virtual interface.  This should be passed to any
                   other function which requires the interface number to
                   be specified.

SEE ALSO:      ifconfig

END DESCRIPTION **********************************************************/
#if !VIRTUAL_ETH
	#warnt "virtual_eth() does nothing if VIRTUAL_ETH not defined non-zero"
#endif
_net_nodebug int virtual_eth(word real_iface, longword ipaddr,
	longword netmask, void * resv)
{
	static word num_virtuals;
   auto word vif;
   auto IFTEntry * ift;
   auto IFTEntry * rift;

#if VIRTUAL_ETH
	#GLOBAL_INIT { num_virtuals = 0; }

	if (real_iface >= USING_ETHERNET + USING_WIFI || num_virtuals == VIRTUAL_ETH)
   	return -1;
	vif = IF_MAX + num_virtuals++;
   ift = _if_tab + vif;
   rift = _if_tab + real_iface;
   ift->u.eth.eflags = EFLAG_VIRT;
	ift->u.eth.riface = real_iface;
	ift->up = rift->up;
   if (ift->up) {
   	_if_actual |= 1<<vif;
   	_if_request |= 1<<vif;
   }
   ift->mtu = rift->mtu;
   ift->ipaddr = ipaddr;
   if (netmask)
   	ift->mask = netmask;
   else
   	ift->mask = rift->mask;
	ift->state = rift->state;
	ift->ncd = rift->ncd;
#ifdef USE_IF_CALLBACK
   ift->ifcallback = NULL;
#endif
   my_eth_addr[vif] = my_eth_addr[real_iface];
   return vif;
#else
	return -1;
#endif
}

/*** BeginHeader virtual_set*/
void virtual_set(word real_iface, int up);
/*** EndHeader */

_net_nodebug void virtual_set(word real_iface, int up)
{
	// Make all virtual ethernet interfaces reflect state (up/down) or real interface.
   auto word mask, i;
   auto IFTEntry * ift;

   for (mask = 1<<(i = IF_MAX); i < IF_MAX+VIRTUAL_ETH; mask <<= 1, ++i) {
   	ift = _if_tab + i;
   	if (ift->u.eth.riface == real_iface) {
      	if (up) {
         	_if_actual |= mask;
            _if_request |= mask;
            ift->up = 1;
         }
         else {
         	_if_actual &= ~mask;
            _if_request &= ~mask;
            ift->up = 0;
         }
      }
   }
}

/*
 * _inet_atoeth - read src, dump to ethernet buffer
 *		  and return pointer to end of text string
 */

/*** BeginHeader _inet_atoeth */
char *_inet_atoeth( char *src, byte *eth );
/*** EndHeader */

_net_nodebug char *_inet_atoeth( char *src, byte *eth ) {
   auto word count, val;
   auto byte ch, icount;

   val = count = icount = 0;
   while((ch = toupper(*src++)) != 0 ) {
      if(ch == ':' ) continue;
      if(ch == ',' ) break;

      if((ch -= '0') > 9) ch -= 7;
      val = (val << 4) + ch;

      if( icount ) {
         eth[ count++ ] = val;
         if(count > 5) break;
         val = icount = 0;
      } else
         icount = 1;
   }
   if( *src == ',' ) ++src;
   return( src );
}

/*** BeginHeader tcp_config_defaults */
void tcp_config_defaults();
/*** EndHeader */

_net_nodebug
void tcp_config_defaults()
{
	// Interface-specific defaults
#ifdef IF_LOOPBACK
	#ifdef IFCONFIG_LOOPBACK
		ifconfig(IF_LOOPBACK, IFCONFIG_LOOPBACK, IFS_END);
	#endif
#endif
#ifdef IF_ETH0
	#ifdef IFCONFIG_ETH0
		ifconfig(IF_ETH0, IFCONFIG_ETH0, IFS_END);
	#elif IF_DEFAULT == IF_ETH0
		ifconfig(IF_DEFAULT, IFCONFIG_DEFAULT, IFS_END);
	#endif
#endif
#ifdef IF_ETH1
	#ifdef IFCONFIG_ETH1
		ifconfig(IF_ETH1, IFCONFIG_ETH1, IFS_END);
	#elif IF_DEFAULT == IF_ETH1
		ifconfig(IF_DEFAULT, IFCONFIG_DEFAULT, IFS_END);
	#endif
#endif
#ifdef IF_WIFI0
	#ifdef IFCONFIG_WIFI0
		ifconfig(IF_WIFI0, IFCONFIG_WIFI0, IFS_END);
	#elif IF_DEFAULT == IF_WIFI0
		ifconfig(IF_DEFAULT, IFCONFIG_DEFAULT, IFS_END);
	#endif
#endif
#ifdef IF_WIFI1
	#ifdef IFCONFIG_WIFI1
		ifconfig(IF_WIFI1, IFCONFIG_WIFI1, IFS_END);
	#elif IF_DEFAULT == IF_WIFI1
		ifconfig(IF_DEFAULT, IFCONFIG_DEFAULT, IFS_END);
	#endif
#endif
#ifdef IF_PPPOE0
	#ifdef IFCONFIG_PPPOE0
		ifconfig(IF_PPPOE0, IFCONFIG_PPPOE0, IFS_END);
	#elif IF_DEFAULT == IF_PPPOE0
		ifconfig(IF_DEFAULT, IFCONFIG_DEFAULT, IFS_END);
	#endif
#endif
#ifdef IF_PPPOE1
	#ifdef IFCONFIG_PPPOE1
		ifconfig(IF_PPPOE1, IFCONFIG_PPPOE1, IFS_END);
	#elif IF_DEFAULT == IF_PPPOE1
		ifconfig(IF_DEFAULT, IFCONFIG_DEFAULT, IFS_END);
	#endif
#endif
#ifdef IF_PPP0
	#ifdef IFCONFIG_PPP0
		ifconfig(IF_PPP0, IFCONFIG_PPP0, IFS_END);
	#endif
#endif
#ifdef IF_PPP1
	#ifdef IFCONFIG_PPP1
		ifconfig(IF_PPP1, IFCONFIG_PPP1, IFS_END);
	#endif
#endif
#ifdef IF_PPP2
	#ifdef IFCONFIG_PPP2
		ifconfig(IF_PPP2, IFCONFIG_PPP2, IFS_END);
	#endif
#endif
#ifdef IF_PPP3
	#ifdef IFCONFIG_PPP3
		ifconfig(IF_PPP3, IFCONFIG_PPP3, IFS_END);
	#endif
#endif
#ifdef IF_PPP4
	#ifdef IFCONFIG_PPP4
		ifconfig(IF_PPP4, IFCONFIG_PPP4, IFS_END);
	#endif
#endif
#ifdef IF_PPP5
	#ifdef IFCONFIG_PPP5
		ifconfig(IF_PPP5, IFCONFIG_PPP5, IFS_END);
	#endif
#endif

	// Non-specific default.  This is done last, since addition of routers
	// requires basic interface-specific stuff to be set up first.
	ifconfig(IF_ANY, IFCONFIG_ALL, IFS_END);
}



/*** BeginHeader sock_yield */
int sock_yield( void *s, void (*fn)( /*void*/ ) );
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sock_yield                                 <NET.LIB>

SYNTAX: int sock_yield( void *s, void (*fn)() );

DESCRIPTION:	This function, if called prior to one of the blocking
					functions, will cause fn, the user-defined function
					that is passed in as the second parameter,  to be called
					repeatedly while the blocking function is in a busywait
					state.

PARAMETER1:	TCP socket
PARAMETER2:	User-defined function

RETURN VALUE:	0.

KEYWORDS: tcpip, sock_read, sock_write
END DESCRIPTION **********************************************************/
/*
 * sock_yield - enable user defined yield function
 */
_net_nodebug
int sock_yield( void *s, void (*fn)( /*void*/ ) )
{
	_SYS_CALL_VARS
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif

   if (_IS_TCP_SOCK(s))
      _TCP_FIELD(s, usr_yield) = fn;
   else
      system_yield = fn;
   return 0;
}

/*** BeginHeader sock_mode */
/* START FUNCTION DESCRIPTION ********************************************
sock_mode                              <NET.LIB>

SYNTAX: void sock_mode(void* s, word mode);

KEYWORDS:		tcpip, ip address

DESCRIPTION: 	Change some of the socket options.  Depending on whether
               s is a TCP or UDP socket, you may pass OR'ed combinations
               of the following flags in the mode parameter.  For a TCP
               socket, only the TCP_MODE_* flags are relevant.  For a
               UDP socket, only the UDP_MODE_* flags are relevant.  Do
               not use the wrong flags for the given socket type.

               Note: it is more convenient, faster, and safer to use the
               macro equivalent, if it is only desired to change one
               mode at a time.  If you use this function, then you must
               specify the setting of all relevant flags (TCP or UDP).
               The macros do not do socket locking so, strictly speaking,
               uC/OS users should call this function rather than use the
               macros.

               TCP modes:

                TCP_MODE_BINARY (default)
                TCP_MODE_ASCII
                  tcp and udp sockets are usually in binary mode which
                  means an arbitrary stream of bytes is allowed.  By
                  changing this to TCP_MODE_ASCII, some of the DCRTCP
                  functions will see a stream of records terminated
                  with a newline character.  The new behavior means
                  sock_bytesready will only return true when a complete
                  newline terminated string is in the buffer.  sock_puts
                  will append a newline to any output.  sock_gets (which
                  should only be used in ASCII mode) removes the newline
                  and null terminates the string.

                  Macros:
                    tcp_set_binary(s)
                    tcp_set_ascii(s)

                TCP_MODE_NAGLE (default)
                TCP_MODE_NONAGLE
                  The Nagle algorithm may substantially reduce network
                  traffic with little negative effect on a user.  By
                  default, Nagle is selected.  This method, which only
                  effects tcp connections can be used by selecting the
                  TCP_MODE_NONAGLE flag.

                  Macros:
                    tcp_set_nagle(s)
                    tcp_set_nonagle(s)

                TCP_MODE_FULLCLOSE (default, unless your app #defines
                                    TCP_NO_CLOSE_ON_LAST_READ)
                TCP_MODE_HALFCLOSE
						Support half-close i.e. sock_close() only closes the
                  transmit side of the socket, but allows indefinite
                  receives until the peer closes.  This prevents the
                  normal close timeout from being set.  If full-close
                  then, when reading, if the socket is half-closed by
                  the peer, then the socket will be automatically closed
                  from this side.

                  Macros:
                    tcp_set_fullclose(s)
                    tcp_set_halfclose(s)

               UDP modes:

                UDP_MODE_CHK (default)
                UDP_MODE_NOCHK
               	Checksums are required for tcp, but not for udp.  If
               	you are providing a checking at a higher level, the
               	low level checksum may be redundant.  The checksum for
               	UDP can be disabled by selecting the TCP_MODE_NOCHK
               	flag.

                  Macros:
                    udp_set_chk(s)
                    udp_set_nochk(s)

                UDP_MODE_NOICMP (default)
                UDP_MODE_ICMP
                  Marks this socket for receipt of ICMP error messages.
                  The messages are queued like normal received datagrams,
                  and read using udp_recvfrom(), which returns -3 when
                  ICMP messages are returned instead of normal datagrams.
                  Only ICMP messages which are relevant to the current
                  binding of the socket are queued.

                  Macros:
                    udp_set_noicmp(s)
                    udp_set_icmp(s)

                UDP_MODE_NODICMP (default)
                UDP_MODE_DICMP
                  Marks this socket as the default receiver of ICMP
                  messages which cannot be assigned to a particular UDP
                  socket.  This would be used for UDP sockets which are
                  used with many different sendto addresses, since the
                  ICMP message may refer to a message sent some time ago
                  (with different destination address than the most
                  recent).  Only one UDP socket should be set with this
                  mode.

                  Macros:
                    udp_set_nodicmp(s)
                    udp_set_dicmp(s)

                UDP_MODE_CONTIG (default)
                UDP_MODE_NOCONTIG
                  Specify whether data passed to the UDP data handler (if
                  any) for this socket is to be contiguous or not.
                  Contiguous mode is slightly less efficient, since the
                  UDP process may to copy data from the network packet
                  buffers into a temporary xmem area.  Non-contig mode
                  is more efficient, but the data handler may need to
                  process data from two xmem areas.  Since this is more
                  complex to handle, there may be no nett efficiency gain.
                  Contig is the default, since it is compatible with
                  Dynamic C releases prior to DC 9.0, which always
                  provided contiguous data.

                  Macros:
                    udp_set_contig(s)
                    udp_set_nocontig(s)

PARAMETER1: 	socket
PARAMETER2: 	new mode

RETURN VALUE:  resulting mode flags

SEE ALSO:      inet_addr

END DESCRIPTION **********************************************************/

word sock_mode( void *s, word mode );
/*** EndHeader */

_net_nodebug
word sock_mode( void *s, word mode )
{
	auto word retval;

	mode &= ALL_MODES;	// Don't allow bad bits through
	LOCK_QUICK();
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
   retval = _TCP_FIELD(s, sock_mode) = _TCP_FIELD(s, sock_mode) & ~ALL_MODES | mode;
   UNLOCK_QUICK();
   return retval & ALL_MODES;
}

/*** BeginHeader sock_alive */
/* START FUNCTION DESCRIPTION ********************************************
sock_alive                               <NET.LIB>

SYNTAX: int sock_alive(void * s);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function performs the same test as tcp_tick(s) i.e.
               it checks the status of the socket and returns 0 if the
               socket is fully closed.

               You can pass a pointer to a TCP or UDP socket.  UDP
               sockets (being connectionless) will be 'alive' unless
               they are currently closed.  TCP sockets will be alive
               in any state (including listening and other unconnected
               states) unless the TCP socket is completely closed.

               The processing overhead of tcp_tick() is avoided for cases
               where several sockets need to be checked in succession.

               When this function returns zero for a socket, the socket
               is then ready for a new call to tcp_open(), udp_open or
               tcp_listen() and friends.

PARAMETER1: 	TCP or UDP socket pointer

RETURN VALUE:  0: socket connection reset or fully closed.  Socket ready
                 for re-use in another connection after calling an
                 open function.
               non-zero: connection is opening, established, listening,
                 or in the process of closing.

SEE ALSO:      tcp_open, tcp_listen, sock_close, sock_abort, tcp_tick,
					udp_open

END DESCRIPTION **********************************************************/
int sock_alive(void * s);
/*** EndHeader */

_tcp_nodebug
int sock_alive(void * s)
{
	auto int retval;
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif

#ifndef DISABLE_TCP
   LOCK_GLOBAL(TCPGlobalLock);	// Global lock because of potential unthread.
#endif
	LOCK_SOCK(s);
#ifndef DISABLE_TCP
   if (_IS_TCP_SOCK(s) &&
       _TCP_FIELD(s, state) & tcp_StateCLOSED &&
       !_TCP_FIELD(s, rd.len)) {
      tcp_unthread(_TCP_SOCK(s));
      _SOCK_TYPE(s) = 0;
   }
#endif
   retval = _SOCK_TYPE(s);
   UNLOCK_SOCK(s);
#ifndef DISABLE_TCP
   UNLOCK_GLOBAL(TCPGlobalLock);
#endif
   return retval;
}

/*** BeginHeader sock_waiting */
/* START FUNCTION DESCRIPTION ********************************************
sock_waiting                               <NET.LIB>

SYNTAX: int sock_waiting(void * s);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function determines whether a TCP socket is waiting
               for a connection establishment.  It returns TRUE (non-zero)
               if and only if the socket is open, but not YET established.

               The purpose of this function is to simplify the application
               logic in programs which interleave TCP/IP functions with
               other processing i.e. "non-blocking" style.

               Note: it is an error to pass a UDP socket to this function.
               UDP sockets are connectionless, so there is no concept of
               "waiting for a connection".

PARAMETER1: 	TCP socket pointer.  This should be a TCP socket which
					was opened using tcp_listen, tcp_extlisten, tcp_open
               or tcp_extopen.

RETURN VALUE:  0: socket is not waiting.  In this case, then next
                  tests that the application should perform are:
                  a.  sock_established(): if this returns TRUE, then a
                    connection is currently established.  The application
                    can now communicate using sock_read, sock_write etc.,
                    then finally call sock_close().
                  b.  sock_alive(): if this returns FALSE, then the
                    socket was aborted by the peer.  The application may
                    re-open or re-listen the socket.
                  c.  Otherwise, the socket was established, but is now
                    closing because the peer closed its side of the
                    connection.  The application MAY be able to read
                    and/or write to the socket (depending on protocol)
                    however the amount of readable data will be
                    limited.  The application should call sock_close()
                    or sock_abort().
                  In cases (a) and (c), a socket should not be re-opened
                  until sock_alive() on that socket returns 0.
                  Note that '0' is returned for invalid sockets (e.g.
                  UDP sockets or sockets which are closed).
               non-zero: the socket is waiting for a connection.  The
                  application should keep calling tcp_tick() until
                  this function returns 0.

SEE ALSO:      tcp_open, tcp_listen, sock_close, sock_abort, tcp_tick,
					sock_established, sock_alive

END DESCRIPTION **********************************************************/
int sock_waiting(void * s);
/*** EndHeader */

_tcp_nodebug
int sock_waiting(void * s)
{
	auto int retval;

	LOCK_SOCK(s);
   retval = 0;
#ifdef USING_SSL
   if (_IS_SSL_SOCK(s)) {
   	// If the underlying TCP socket is in LISTEN, ARP etc. states, then the SSL
   	// socket will be in INIT state, so the following test will suffice.
   	// In addition, SSL socket is considered to be waiting if the SSL handshake
   	// is in progress.
   	// If in ERROR state, then it is also considered to be "waiting", since an
   	// alert message is being sent, and the transport is closing down.  This is
   	// useful when the socket is in handshake states, since we do not want an
   	// error to "wake up" the application.  Instead, the transport eventually closes
   	// and the socket becomes "dead" without ever becoming alive.
		retval = (word)_SSL_FIELD(s, cur_state) < (word)SSL_STATE_APP_DATA ||
		         _SSL_FIELD(s, cur_state) == SSL_STATE_ERROR;
   }
   else
#endif
   if (_IS_TCP_SOCK(s))
   	retval = _TCP_FIELD(s, state) & (tcp_StateLISTEN|tcp_StateARP|tcp_StateSYNSENT|tcp_StateSYNREC);
   UNLOCK_SOCK(s);
   return retval;
}

/*** BeginHeader sock_writable */
/* START FUNCTION DESCRIPTION ********************************************
sock_writable                               <NET.LIB>

SYNTAX: int sock_writable(void * s);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function determines whether a socket may have data
               written to it using (e.g.) sock_fastwrite() or
               udp_sendto().

               The parameter may be either a TCP socket or a UDP socket.

               The return value is more than a simple boolean: it also
               indicates the amount of data the socket is guaranteed
               to accept with a sock_fastwrite() call that immediately
               follows.

               Note: a TCP socket may be writable before it is established.
               In this case, any written data is transferred as soon as
               the connection is established.

PARAMETER1: 	TCP or UDP socket pointer.

RETURN VALUE:  If parameter is a TCP socket (tcp_Socket *):
					  0: socket is not writable.  It was closed by the
                    application or it may have been aborted by the peer.
                 non-zero: the socket is writable.  The amount of data
                    that the socket would accept is this value minus 1;
                    which may turn out to be zero if the socket's buffer
                    is temporarily full.  On a freshly-established socket,
                    and at any other time when all data has been
                    acknowledged by the peer, the return value (minus one)
                    indicates the maximum socket transmit buffer size.
               If parameter is a UDP socket (udp_Socket *):
                 0: socket is not open.
                 non-zero: socket is open.  This value minus 1 equals the
                 maximum size datagram payload that would be sent without
                 fragmentation at the IP level.
                 Note: the maximum payload depends on the interface which
                 is selected.  Since this is not known a-priori, the
                 interface with the largest MTU is arbitrarily selected.

SEE ALSO:      tcp_open, tcp_listen, sock_close, sock_abort, tcp_tick,
					sock_established, sock_alive, sock_waiting, sock_readable,
               udp_open, udp_sendto

END DESCRIPTION **********************************************************/
int sock_writable(void * s);
/*** EndHeader */

_tcp_nodebug
int sock_writable(void * s)
{
	auto int retval;

	LOCK_SOCK(s);
   switch (_SOCK_TYPE(s)) {
#ifdef USING_SSL
	case SSL_PROTO:
		if (_SSL_FIELD(s, cur_state) & (SSL_STATE_DONE | SSL_STATE_DRAINING | SSL_STATE_HALF_CLOSED |
		                                SSL_STATE_WAIT_CLOSE | SSL_STATE_ERROR))
			retval = 0;
   	else
   		retval = 1 +  _tbuf_remain(_TCP_FIELD(_TCP_SOCK_OF_SSL(s), app_wr));
      break;
#endif
#ifndef DISABLE_TCP
   case TCP_PROTO:
   	if (_TCP_FIELD(s, state) & (tcp_StateCLOSED | tcp_StateLASTACK | tcp_StateFINWT1 |
                   tcp_StateFINWT2 | tcp_StateCLOSING | tcp_StateTIMEWT))
   		retval = 0;
   	else
   		retval = 1 +  _tbuf_remain(_TCP_FIELD(s, app_wr));
      break;
#endif
#ifndef DISABLE_UDP
   case UDP_PROTO:
   	retval = (MAX_MTU+1) - (sizeof(in_Header) + sizeof(udp_Header));
		break;
#endif
   default:
   	retval = 0;
   }
   UNLOCK_SOCK(s);
   return retval;
}

/*** BeginHeader sock_readable */
/* START FUNCTION DESCRIPTION ********************************************
sock_readable                               <NET.LIB>

SYNTAX: int sock_readable(void * s);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This function determines whether a socket may have data
               read from it using (e.g.) sock_fastread() or
               udp_recvfrom().

               The parameter may be either a TCP socket or a UDP socket.

               The return value is more than a simple boolean: it also
               indicates the amount of data the socket is guaranteed
               to deliver with a sock_fastread() call that immediately
               follows (provided that the buffer length is at least that
               long).

               Note: a TCP socket may be readable after it is closed,
               since there may be pending data in the buffer that has not
               been read by the application, and it is also possible for
               the peer to keep sending data

PARAMETER1: 	TCP or UDP socket pointer.

RETURN VALUE:  If parameter is a TCP socket (tcp_Socket *):
					  0: socket is not readable.  It was aborted by the
                    application or the peer has closed the socket and all
                    pending data has been read by the application.  This
                    can be used as a definitive "EOF" indication for a
                    receive stream.
                 non-zero: the socket is readable.  The amount of data that
                    the socket would deliver is this value minus 1; which
                    may turn out to be zero if the socket's buffer is
                    temporarily empty, or the socket is not yet connected
                    to a peer.
               If parameter is a UDP socket (udp_Socket *):
                 0: socket is not open, or there is no pending datagram.
                 non-zero: socket is open.  This value minus 1 equals the
                 size of the next datagram in the receive buffer, that
                 would be returned by udp_recvfrom() etc.  Note that
                 ICMP error messages are also considered if the socket
                 is set up to receive ICMP messages.  In particular, a
                 return value of 1 indicates an empty datagram is ready.

SEE ALSO:      tcp_open, tcp_listen, sock_close, sock_abort, tcp_tick,
					sock_established, sock_alive, sock_waiting, sock_writable,
               udp_open, udp_recvfrom

END DESCRIPTION **********************************************************/
int sock_readable(void * s);
/*** EndHeader */

_tcp_nodebug
int sock_readable(void * s)
{
#ifndef DISABLE_UDP
	auto _udp_datagram_info udi;
#endif
	auto int retval;

	LOCK_SOCK(s);
   switch (_SOCK_TYPE(s)) {
#ifdef USING_SSL
	case SSL_PROTO:
   	if (_TCP_FIELD(_TCP_SOCK_OF_SSL(s), app_rd)->len)
	      retval = _TCP_FIELD(_TCP_SOCK_OF_SSL(s), app_rd)->len + 1;
		else if (!sock_alive(_TCP_SOCK_OF_SSL(s)) ||
		         _SSL_FIELD(s, cur_state) & (SSL_STATE_DONE | SSL_STATE_ERROR))
			retval = 0;
		else
			retval = 1;
		break;
#endif
#ifndef DISABLE_TCP
   case TCP_PROTO:
   	if (_TCP_FIELD(s, app_rd)->len)
	      retval = _TCP_FIELD(s, app_rd)->len + 1;
	   else if (_TCP_FIELD(s, state) &
               (tcp_StateCLOSWT | tcp_StateLASTACK | tcp_StateCLOSING | tcp_StateTIMEWT))
	      retval = 0; // Already read the FIN flag
	   else
	      retval = 1; // Readable, but currently no data
      break;
#endif
#ifndef DISABLE_UDP
   case UDP_PROTO:
   	if (udp_peek(_UDP_SOCK(s), &udi))
      	retval = udi.len + 1;
      else
      	retval = 0;
		break;
#endif
   default:
   	retval = 0;
   }
   UNLOCK_SOCK(s);
   return retval;
}

/*
 * ip user level timer stuff
 *   void ip_timer_init( void *s, int delayseconds )
 *   int  ip_timer_expired( void *s )
 *	- 0 if not expired
 */

/*** BeginHeader ip_timer_init */
/* START FUNCTION DESCRIPTION ********************************************
ip_timer_init                          <NET.LIB>

SYNTAX: void ip_timer_init( void* s, word seconds );

KEYWORDS:		tcpip, socket, timer

DESCRIPTION: 	set a timer inside the socket structure

PARAMETER1: 	socket
PARAMETER2: 	number of seconds for the timeout, if the seconds is zero
               never timeout.

RETURN VALUE:  none

SEE ALSO:      ip_timer_expired

END DESCRIPTION **********************************************************/

void ip_timer_init( void *s , int delayseconds );
/*** EndHeader */

_net_nodebug
void ip_timer_init( void *s , int delayseconds )
{
   if(delayseconds)
      _TCP_FIELD(s, usertimer) = set_timeout( delayseconds );
   else
      _TCP_FIELD(s, usertimer) = 0;
}

/*** BeginHeader ip_timer_expired */
/* START FUNCTION DESCRIPTION ********************************************
ip_timer_expired                       <NET.LIB>

SYNTAX: word ip_timer_expired( void* s );

KEYWORDS:		tcpip, socket, timer

DESCRIPTION: 	check the timer inside the socket structure which was set
               by ip_timer_init

PARAMETER1: 	socket

RETURN VALUE:  0 if not expired
               1 if expired

SEE ALSO:      ip_timer_init

END DESCRIPTION **********************************************************/

int ip_timer_expired( void *s );
/*** EndHeader */

_net_nodebug
int ip_timer_expired( void *s )
{
   if (!_TCP_FIELD(s, usertimer))   /* cannot expire */
      return 0;
   return chk_timeout(_TCP_FIELD(s, usertimer));
}


/*** BeginHeader findfreeport */
word findfreeport( word oldport, word proto_tcp );
/*** EndHeader */

/*
 * findfreeport - return unused local port
 *              - oldport = 0:normal port, 1:special port (513-1023)
 *              - we need not be this picky, but it doesn't hurt
 * 		- added TCP/UDP flag so we can pick unique ports and
 *             avoid reconnecting with a socket in TIME_WAIT (the
 *             original "oldport+510" scan needs a rewrite someday)
 */
_net_nodebug
word findfreeport( word oldport, word proto_tcp )
{
   auto word temp;
   auto tcp_Socket *s;

   if(( oldport > 1 ) && (oldport < 0xffff))
      return( oldport );

   LOCK_GLOBAL(TCPGlobalLock);

   if( oldport == 0) {
      if(proto_tcp) {
#ifndef DISABLE_TCP
         if((oldport=next_tcp_port++)>=32767-510) next_tcp_port=1024;
#endif
			;
#ifndef DISABLE_UDP
      } else {
         if((oldport=next_udp_port++)>=32767-510) next_udp_port=1024;
#endif
      }
   } else oldport = 513;

   for( temp = oldport ; temp < oldport + 510 ; ++temp ) {
      if(!proto_tcp) {
#ifndef DISABLE_UDP
         if(( s = (tcp_Socket*)udp_allsocs) != NULL ) {
            while( s->next && (s->myport != temp))
               s = (tcp_Socket*)s->next;
            if( s->myport == temp ) continue;
         }
#endif
			;
#ifndef DISABLE_TCP
      } else {
         if( (s = tcp_allsocs ) != NULL ) {
            while( s->next && (s->myport != temp ))
               s = s->next;
            if( s->myport == temp ) continue;
         }
#endif
      }
      break;
   }
   UNLOCK_GLOBAL(TCPGlobalLock);
   return( temp );
}

/*** BeginHeader sock_abort */

/* START FUNCTION DESCRIPTION ********************************************
sock_abort                             <NET.LIB>

SYNTAX: void sock_abort(void* s)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Close a connection by sending a RST (reset).  Under UDP
               there is no difference between sock_close and sock_abort.

PARAMETER1: 	socket to abort connection

RETURN VALUE:  none

SEE ALSO:      sock_close, sock_open

END DESCRIPTION **********************************************************/

void sock_abort( void *s );
/*** EndHeader */

_net_nodebug
void sock_abort( void *s )
{
	switch (_SOCK_TYPE(s)) {
#ifdef USING_SSL
   case SSL_PROTO:
   	tls_shutdown(_SSL_SOCK(s), SHUTDOWN_ABORT, NULL);
   	tls_connection_deinit(&_ssl_globals, _SSL_SOCK(s));
      break;
#endif
#ifndef DISABLE_TCP
   case TCP_PROTO:
      tcp_abort(_TCP_SOCK(s));
      break;
#endif
#ifndef DISABLE_UDP
   case UDP_PROTO:
      udp_close(_UDP_SOCK(s));
      break;
#endif
	}
}


/*** BeginHeader _abort_socks */

/* START FUNCTION DESCRIPTION ********************************************
_abort_socks                             <NET.LIB>

SYNTAX: int _abort_socks(word reason, byte iface)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Abort all open TCP and UDP sockets.  This routine may be
               called if the network becomes unavailable, for example
               because a DHCP address lease expired or because an IP
               address conflict was encountered.

               This function is generally intended for internal library
               use, but may be invoked by applications in special
               circumstances.

PARAMETER1: 	Reason code.  A suitable NETERR_* constant as defined in
               NETERRNO.LIB.  This code is set as the error code for
               each socket which was affected.
PARAMETER2:		Specific interface on which active connections are to
               be aborted, or pass IF_ANY to abort connections on all
               active interfaces.

RETURN VALUE:  0

SEE ALSO:      sock_abort, sock_error

END DESCRIPTION **********************************************************/

int _abort_socks(word reason, byte iface);
/*** EndHeader */

_net_nodebug
int _using_iface(int iface, int bound_iface, longword ipaddr)
{
	if (!ipaddr || ipaddr == ~0UL)
		return 0;	// No particular interface for unassigned or broadcast
	if (iface == IF_ANY)
		return 1;	// Always match for IF_ANY
	if (bound_iface == iface)
		return 1;	// Match if specific binding
	if (bound_iface == IF_ANY && iface == ip_iface(ipaddr, 0))
		return 1;	// Match using ip_iface() if non-specific binding
	return 0;
}

_net_nodebug
int _abort_socks(word reason, byte iface)
{
	// Abort or close active and passive sockets.
	// This is called if the IP address is changed or relinquished, in
	// order to terminate any active connections (if changed) or all
	// active and passive sockets (if relinquished).  "reason" is an
	// error code which is set into the socket's error message buffer.
	// If, on entry, my_ip_addr is zero then it is assumed that the
	// IP address was relinquished.  Otherwise, it is assumed to have
	// changed.
   auto udp_Socket *s, **sp;
   auto tcp_Socket *t;
	auto tcp_Pending __far *p;


   LOCK_GLOBAL(TCPGlobalLock);

#ifndef DISABLE_UDP
   // First, do UDP sockets
   sp = &udp_allsocs;
   while (s = *sp) {
      if (_using_iface(iface, s->iface, s->hisaddr)) {
   		LOCK_SOCK(s);
         *sp = s->next;
         s->ip_type = 0;	// Mark this sock as closed (for sock_alive()).
         sock_msg(s, reason);
   		UNLOCK_SOCK(s);
      }
      else
        sp = &s->next;
   }
#endif

#ifndef DISABLE_TCP
   // Then do TCP sockets and pending sockets
   do {
   	for (t = tcp_allsocs; t; t = t->next)
      	if (_using_iface(iface, t->iface, t->hisaddr)) {
	   		tcp_abort(t);
   			sock_msg(t, reason);
      		break;
      	}
	} while (t);

   do {
   	for (p = tcp_allpending; p; p = p->next)
   		if (iface == IF_ANY || ip_iface(p->hisaddr, 0) == iface) {
				tcp_abortpending(p);
				break;
			}
   } while (p);
#endif
   UNLOCK_GLOBAL(TCPGlobalLock);
   return 0;
}

/*** BeginHeader sock_dataready */
int sock_dataready( void *s );
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sock_dataready                         <NET.LIB>

SYNTAX: int sock_dataready( void *s );

KEYWORDS:		tcpip, socket

DESCRIPTION:   *** This function deprecated.  Use sock_bytesready instead ***

					return the number of bytes waiting to be read.  If the
					socket is in ASCII mode, it returns 0 if the newline
					character has not been read yet.

					For UDP sockets, it returns the number of bytes in the
					next datagram.

PARAMETER1: 	socket

RETURN VALUE:  0		no bytes waiting to be read (or newline not yet
							read if the socket is in ASCII mode)
					> 0	number of bytes waiting to be read

SEE ALSO:      sock_bytesready

END DESCRIPTION **********************************************************/

_net_nodebug
int sock_dataready( void *s )
{
   auto int len;
   auto char c;
   auto udp_Socket* udp_sock;
   auto tcp_Socket* tcp_sock;
   auto _udp_datagram_info udp_datagram_info;

   LOCK_SOCK(s);
   switch (((sock_type *)s)->tcp.ip_type) {
#ifndef DISABLE_UDP
	case UDP_PROTO:
		udp_sock = (udp_Socket *)s;
	   if (!(len = udp_sock->rd.len)) {
      	UNLOCK_SOCK(s);
	   	return (0);
	   }
	   _tbuf_xread((char __far *)&udp_datagram_info, &udp_sock->rd, 0,
	                   sizeof(_udp_datagram_info));
     	UNLOCK_SOCK(s);
	   return (udp_datagram_info.len);
#endif
#ifndef DISABLE_TCP
	case TCP_PROTO:
		tcp_sock = (tcp_Socket *)s;

	   if (!(len = tcp_sock->rd.len)) {
      	UNLOCK_SOCK(s);
	   	return (0);
	   }

	   if (tcp_sock->sock_mode & TCP_MODE_ASCII) {
	      if (tcp_sock->sock_mode & TCP_SAWCR) {
   	      tcp_sock->sock_mode &= ~TCP_SAWCR;
      	   _tbuf_xread(&c, &tcp_sock->rd, 0, 1);
         	if (c == '\n' || c == '\0') {
         		_tbuf_delete(&tcp_sock->rd, 1);
         		--len;
            	if (!len) {
            		UNLOCK_SOCK(s);
            		return (0);
           		}
         	}
      	}

      	/* check for terminating \r */
      	if (_tbuf_findchar(&tcp_sock->rd, '\r', len, 0) != -1) {
      		UNLOCK_SOCK(s);
         	return (len);
      	}
      	if (_tbuf_findchar(&tcp_sock->rd, '\n', len, 0) != -1) {
      		UNLOCK_SOCK(s);
         	return (len);
      	}

			if (len == tcp_sock->rd.maxlen ||
			    tcp_sock->state & (tcp_StateCLOSWT | tcp_StateCLOSING |
                                tcp_StateLASTACK | tcp_StateTIMEWT |
                                tcp_StateCLOSED)) {
				UNLOCK_SOCK(s);
				return (len);
			}

      	UNLOCK_SOCK(s);
      	return (0);
   	} else {
      	UNLOCK_SOCK(s);
      	return (len);
      }
#endif
	default:
		UNLOCK_SOCK(s);
		return (0);
	}
}


/*** BeginHeader sock_bytesready */
int sock_bytesready(void *s);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sock_bytesready                        <NET.LIB>

SYNTAX: int sock_bytesready(void *s);

KEYWORDS:		tcpip, socket

DESCRIPTION:	For TCP sockets:

					If the socket is in binary mode, sock_bytesready returns the
					number of bytes waiting to be read.   If there are no bytes
					waiting, it returns -1.

					For ASCII mode sockets, this function returns the length of
					a pending line in the buffer.  For this use, it is recommended
					that new code uses the sock_stringready() function, since it
					is more flexible and efficient in specifying line delimiters,
					and returns more information.

					In ASCII mode, sock_bytesready returns -1 if there are no bytes
					waiting to be read or the line that is waiting is incomplete
					(no line terminating character has been read.)  A line is
					considered to be available when any of the following:
 						* the buffer is full enough to preclude the peer sending
 						   more data until we have read something from the buffer.
						* the socket is no longer readable as defined by
						   sock_readable()
						* a complete line is waiting, with a \r\n, \r\0, \n, \r,
						   or \0 terminator.  Note that the length of the
						   terminator (1 or 2) is not included in the return
						   value.  \r is accepted as a line terminator only if
						   it is not followed by \n or \0.
					Effectively, the line semantics are the same as for sock_gets().
					If called, sock_gets() will consume the line teminator.

					In ASCII mode, an empty line will be read as a complete line
					with length 0, which will be the value returned.

					For UDP sockets:

					Returns the number of bytes in the next datagram to be read.
					If it is a datagram with no data (an empty datagram), then it
					will return 0.  If there are no datagrams waiting, then it
					returns -1.

PARAMETER1: 	socket

RETURN VALUE:	-1		no bytes waiting to be read
					0		in ASCII mode, a blank line is waiting to be read,
					      or, for UDP, an empty datagram is waiting to be read
					> 0	number of bytes waiting to be read

SEE ALSO:      sock_wait_established, sock_established, sock_state,
					sock_stringready

END DESCRIPTION **********************************************************/

_net_nodebug
int sock_bytesready(void *s)
{
	auto unsigned int linelen, linelen0, linelenr, linelenn, delim;
   auto tcp_Socket* tcp_sock;
   auto int rdable, retval, sr;

   LOCK_SOCK(s);

   rdable = sock_readable(s);
   retval = -1;	// assume insufficient data

   switch (_SOCK_TYPE(s)) {
#ifndef DISABLE_UDP
	case UDP_PROTO:
	   retval = rdable-1;
	   break;
#endif
#ifdef USING_SSL
	case SSL_PROTO:
		tcp_sock = _TCP_SOCK_OF_SSL(s);
		goto _tcp_proc;
#endif
#ifndef DISABLE_TCP
	case TCP_PROTO:
		tcp_sock = _TCP_SOCK(s);
	_tcp_proc:
		// If readable, but currently no data available; or unreadable because closed
		if (rdable <= 1) {
#ifndef TCP_NO_CLOSE_ON_LAST_READ
			// If there is no data to read, and we are in CLOSWT state (i.e. the
			// peer will not send any more data), then automatically close our
			// side of the connection.  This is the "old" behavior.
			//FIXME - this is wrong place for this, need to be in read.
			if (tcp_sock->state & tcp_StateCLOSWT)
				tcp_close(tcp_sock);
#endif
			break;
		}

		// At least some data to read...

		if (tcp_sock->sock_mode & TCP_MODE_ASCII) {
			// A 'line' by library definition is terminated with a \r\n, or a bare \r or bare \n.
			// We find the first \n or \r, however the \r must not be at the very end of
			// available data (otherwise, a \n could follow and
			// we would incorrectly read an empty line).  The returned length does not include the
			// terminating character(s).
			// NOTE: for historical reasons (including consistency with sock_gets()), a nul
			// character (\0) is considered equivalent to \n.
			// A string is also considered to be terminated by EOF of the socket, and also if the
			// buffer is full.  The latter is somewhat unsatisfactory, but is better than having
			// the application block forever.
	      delim = DELIM_NULL | DELIM_LF | DELIM_CR | DELIM_CRLF;
	      sr = sock_stringready(tcp_sock, &delim, 0);
	      if (0 >= sr)
	      	break;
	      retval = sr;
	      if (delim) {
	         --retval;
	         if (delim == DELIM_CRLF)
	            --retval;
			}
			break;
			}
		else
			retval = rdable - 1;
#endif
			}

				UNLOCK_SOCK(s);
	return retval;

}

/*** BeginHeader sock_close */

/* START FUNCTION DESCRIPTION ********************************************
sock_close                             <NET.LIB>

SYNTAX: void sock_close(void* s)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	close an open socket.  the socket cannot be reused until
               it is completely closed.  You can tell a tcp socket is
               closed by tcp_tick(s)==0 or by running sock_wait_closed(s)
               or by checking sock_alive().

PARAMETER1: 	socket

RETURN VALUE:  none

SEE ALSO:      sock_open, sock_abort, sock_tick, sock_wait_closed

END DESCRIPTION **********************************************************/

void sock_close( void *s );
/*** EndHeader */

_net_nodebug
void sock_close( void *s )
{
   switch(_SOCK_TYPE(s)) {
#ifndef DISABLE_UDP
   case UDP_PROTO :
      udp_close(_UDP_SOCK(s));
      break;
#endif
#ifdef USING_SSL
	case SSL_PROTO:
		// Graceful shutdown, then close socket after complete
		tls_shutdown(_SSL_SOCK(s), SHUTDOWN_FULL, &_TCP_SOCK_OF_SSL(s)->wr);
      break;
#endif
#ifndef DISABLE_TCP
   case TCP_PROTO :
      tcp_close(_TCP_SOCK(s));
      break;
#endif
   }
}

/*** BeginHeader sock_set_ttl */
/* START FUNCTION DESCRIPTION ********************************************
sock_set_ttl                             <NET.LIB>

SYNTAX: void sock_set_ttl(void* s, byte ttl)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Set the IP Time To Live field in outgoing packets for this
               socket.  The given TTL will be in effect until the socket
               is closed.  When a socket is opened (or re-opened), the
               TTL will be set to the default (TCP_TTL or UDP_TTL as
               appropriate).  If not overridden, the defaults are 64
               in both cases.

PARAMETER1: 	Pointer to open TCP or UDP socket
PARAMETER2: 	Time To Live.  This is a value between 1 and 255.  A value
               of zero is also accepted, but will have undesirable
               consequences.

SEE ALSO:      tcp_extopen, sock_set_tos

END DESCRIPTION **********************************************************/

void sock_set_ttl(void* s, byte ttl);
/*** EndHeader */

_net_nodebug
void sock_set_ttl(void* s, byte ttl)
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
   _TCP_FIELD(s, ttl) = ttl;
}

/*** BeginHeader sock_set_tos */
/* START FUNCTION DESCRIPTION ********************************************
sock_set_tos                             <NET.LIB>

SYNTAX: void sock_set_tos(void* s, byte tos)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Set the IP Type Of Service field in outgoing packets for
               this socket.  The given TOS will be in effect until the
               socket is closed.  When a socket is opened (or re-opened),
               the TOS will be set to the default (TCP_TOS or UDP_TOS as
               appropriate).  If not overridden, the defaults are zero
               (IPTOS_DEFAULT) in both cases.

PARAMETER1: 	Pointer to open TCP or UDP socket
PARAMETER2: 	Type Of Service.  This should be one of the following
               values:
                 IPTOS_DEFAULT    Default service
                 IPTOS_CHEAP      Minimize monetary cost
                 IPTOS_RELIABLE   Maximize reliability
                 IPTOS_CAPACIOUS  Maximize throughput
                 IPTOS_FAST       Minimize delay
                 IPTOS_SECURE     Maximize security.
               Other value may be used (since TOS is just a number between
               0 and 255), but this should only be done for experimental
               purposes.

SEE ALSO:      tcp_extopen, sock_set_ttl

END DESCRIPTION **********************************************************/

void sock_set_tos(void* s, byte tos);
/*** EndHeader */

_net_nodebug
void sock_set_tos(void* s, byte tos)
{
#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
   _TCP_FIELD(s, tos) = tos;
}

/*** BeginHeader sock_iface */
/* START FUNCTION DESCRIPTION ********************************************
sock_iface                             <NET.LIB>

SYNTAX: byte sock_iface(void* s)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Retrieve the interface number of an open socket.  May
               return IF_ANY for unbound sockets.

PARAMETER1: 	Pointer to open TCP or UDP socket.

SEE ALSO:      tcp_extopen, udp_extopen, tcp_extlisten, udp_extlisten

END DESCRIPTION **********************************************************/

byte sock_iface(void* s);
/*** EndHeader */

_net_nodebug
byte sock_iface(void* s)
{
	auto word iface;

#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
	if (_TCP_FIELD(s, sath))
		arpcache_iface(_TCP_FIELD(s, sath), &iface);
	else
		iface = _TCP_FIELD(s, iface);
   return iface;
}

/*** BeginHeader sock_resolved */
/* START FUNCTION DESCRIPTION ********************************************
sock_resolved                             <NET.LIB>

SYNTAX: int sock_resolved(void * s)

KEYWORDS:		tcpip, socket

DESCRIPTION: 	Check whether the socket has a valid destination hardware
               address.  This is typically used for UDP sockets, but may
               also be used for TCP sockets.  If this function returns
               zero (FALSE), then any datagrams you send using udp_send()
               or udp_sendto() may not be transmitted because the
               destination hardware address is not known.

               If the current destination IP address of the socket is
               zero (i.e. the socket is passively opened), this function
               returns zero, since datagrams cannot be transmitted from
               a passively opened socket.

               If udp_bypass_arp() is in effect, the return value from
               this function is unaffected, however datagrams will still
               be sent to the specified hardware address (since the normal
               resolve process is bypassed).

               Note that a hardware address may become invalid after being
               valid, since the underlying ARP table may need to purge
               the entry.  This would be rare, but if any UDP application
               needs to ensure that all packets are actually transmitted,
               which is a questionable goal since UDP is unreliable,
               then this function should be consulted before each send.
               If this function returns 0, then the UDP socket should
               be re-opened.

               The hardware address may also be invalidated if udp_sendto()
               is called with a different destination IP address, that has
               not been determined based on an incoming datagram.

               This function is not required for TCP sockets, since the
               TCP library handles these details internally.

PARAMETER1: 	Pointer to open TCP or UDP socket

RETURN VALUE:	0: destination hardware address not valid
               non-zero: destination hardware address resolved OK.

SEE ALSO:      udp_extopen, arpresolve_start, arpresolve_check,
               udp_waitopen, udp_sendto, udp_bypass_arp

END DESCRIPTION **********************************************************/

int sock_resolved(void * s);
/*** EndHeader */

_net_nodebug
int sock_resolved(void * s)
{

#ifdef USING_SSL
	if (_IS_SSL_SOCK(s))
		s = _TCP_SOCK_OF_SSL(s);
#endif
	if (!_TCP_FIELD(s, hisaddr))
		return 0;
   return arpresolve_check(_TCP_FIELD(s, sath), _TCP_FIELD(s, hisaddr)) > 0;
}

/*
 * _ip_delay0 called by macro sock_wait_established()
 * _ip_delay1 called by macro sock_wait_input()
 * _ip_delay2 called by macro sock_wait_closed();
 *
 */

/*** BeginHeader _ip_delay0 */
int _ip_delay0( sock_type *s, int timeoutseconds, sockfunct_t fn,
	int *statusptr);
/*** EndHeader */

_net_nodebug
int _ip_delay0( sock_type *s, int timeoutseconds,
	sockfunct_t fn, int *statusptr )
{
   auto int status;

   LOCK_SOCK(s);
   ip_timer_init( s , timeoutseconds );
   do {
#ifndef DISABLE_TCP
      if( s->tcp.ip_type == TCP_PROTO ) {
         if( tcp_established( &(s->tcp) )) {
            status = 0;
            break;
         }
      }
#endif
      if( !tcp_tick( s )) {
      	sock_msg(s, NETERR_HOST_REFUSED);
         status = -1; /* get an early reset */
         break;
      }
      if( ip_timer_expired( s )) {
      	sock_msg(s, NETERR_OPEN_TIMEOUT);
         sock_close( s );
         status = -1;
         break;
      }
      if( (fn != NULL) && ((status = fn(s)) != 0) ) break;
      if( s->tcp.usr_yield ) (*s->tcp.usr_yield)();
      if( s->tcp.ip_type == UDP_PROTO ) {
         status = 0;
         break;
      }
   } while( 1 );
   if(statusptr) *statusptr = status;

   UNLOCK_SOCK(s);
   return( status );
}

/*** BeginHeader _ip_delay1 */
int _ip_delay1( sock_type *s, int timeoutseconds, sockfunct_t fn,
	int *statusptr);
/*** EndHeader */

_net_nodebug
int _ip_delay1( sock_type *s, int timeoutseconds,
	sockfunct_t fn, int *statusptr)
{
   auto int status;

   LOCK_SOCK(s);

   ip_timer_init( s , timeoutseconds );

   do {
      if( sock_bytesready( s ) != -1 ) {
         status = 0;
         break;
      }
      //kbhit(); /* permit ^c */

      if( !tcp_tick( s )) {
         status = 1;
         break;
      }
      if( ip_timer_expired( s )) {
      	sock_msg(s, NETERR_CONN_TIMEOUT);
         sock_close( s );
         status = -1;
         break;
      }
      if(fn) {
         if((status = fn(s)) != 0)
            break;
      }
      if( s->tcp.usr_yield ) (*s->tcp.usr_yield)();
   } while( 1 );
   if(statusptr) *statusptr = status;
   UNLOCK_SOCK(s);
   return( status );
}

/*** BeginHeader ip_delay2 */
int ip_delay2( sock_type *s, int timeoutseconds, sockfunct_t fn,
	int *statusptr);
/*** EndHeader */

_net_nodebug
int ip_delay2( sock_type *s, int timeoutseconds,
	sockfunct_t fn, int *statusptr)
{
   auto int status;
   ip_timer_init( s , timeoutseconds );

   if(s->tcp.ip_type != TCP_PROTO ) {
      if( statusptr ) * statusptr = 1;
      return( 1 );
   }

   LOCK_SOCK(s);

   do {
      /* in this situation we KNOW user not planning to read rdbuffer */
      s->tcp.rd.len = 0;
      if( !tcp_tick( s )) {
         status = 1;
         break;
      }
      if( ip_timer_expired( s )) {
      	sock_msg(s, NETERR_CONN_TIMEOUT);
         sock_abort( s );
         status = -1;
         break;
      }
      if(fn) {
         if((status = fn(s)) != 0)
            break;
      }
      if( s->tcp.usr_yield ) (*s->tcp.usr_yield)();

   } while( 1 );
   if(statusptr) *statusptr = status;

   UNLOCK_SOCK(s);
   return( status );
}


/*
 *		### initialize global initialized variables ###
 */

/*** BeginHeader dcr_initdcr */
void dcr_initdcr();
#funcchain _GLOBAL_INIT dcr_initdcr
/*** EndHeader */


// Note that this table must have at least USING_ETHERNET entries in it.
// This defines the order in which interface numbers (IF_ETH0,IF_ETH1) are assigned
// to ethernet drivers.  The USE_ETHERNET macro (which is an application setting)
// specifies which, if any, ethernet interfaces to use.
// In the following table, DX stands for a driver (e.g. DMAETH).  DY stands
// for a different driver.  DX(n) stands for nth instance of driver DX.  It is
// assumed that DX < DY in the following ordering [DMAETH100, DMAETH, ASIX].
//
//    Available Drivers                USE_ETHERNET     IF_ETH0     IF_ETH1
//    ------------------------------   --------------   ---------   ----------
//    DX, with only one instance       0x01             DX(0)       N/A
//                                     0x02  - invalid
//                                     0x03  - invalid
//    DX, with 2 instances             0x01             DX(0)       N/A
//                                     0x02             DX(1)       N/A
//                                     0x03             DX(0)       DX(1)
//    DX, with 1 instance, + DY        0x01             DX(0)       N/A
//                                     0x02             DY(0)       N/A
//                                     0x03             DX(0)       DY(0)
//    DX, with 2 instances, + DY       0x01             DX(0)       N/A
//                                     0x02             DX(1)       N/A
//                                     0x03             DX(0)       DY(0)
// Note that in the last case, the 2nd instance of DX is not available,
// since a maximum of 2 ethernet-type interfaces is currently implemented.
// *CUSTOM*
//   For new libraries, make analogous changes.  You will need to decide
//   where the new driver lies in the ordering, and be consistent.
#if !USING_DMAETH100
	#define DMAETH100_TABLE1
	#define DMAETH100_TABLE2
#endif
#if !USING_DMAETH
	#define DMAETH_TABLE1
	#define DMAETH_TABLE2
#endif
#if !USING_ASIX
	#define ASIX_TABLE1
	#define ASIX_TABLE2
#endif
#if !USING_WIFIG
	#define WIFIG_TABLE1
   #define WIFIG_TABLE2
#endif
#if !USING_LOOPBACK
	#define LOOPBACK_TABLE1
	#define LOOPBACK_TABLE2
#endif
#if !USING_PPP_SERIAL
	#define PPP_SERIAL_TABLE1
	#define PPP_SERIAL_TABLE2
	#define PPP_SERIAL_TABLE3
	#define PPP_SERIAL_TABLE4
	#define PPP_SERIAL_TABLE5
	#define PPP_SERIAL_TABLE6
#endif
#if !USING_VSPD
	#define VSPD_TABLE1
	#define VSPD_TABLE2
	#define VSPD_TABLE3
	#define VSPD_TABLE4
	#define VSPD_TABLE5
	#define VSPD_TABLE6
#endif


static const struct {
	const NetControllerDevice * ncd;
   void * state;
   word	instance;
} _driver_table[] = {
#if USE_ETH_PRELOADED_DRIVER == 0
	#if USE_ETHERNET != 2
        DMAETH100_TABLE1
		DMAETH_TABLE1
		ASIX_TABLE1
		#if USE_ETHERNET == 3
      	DMAETH100_TABLE2
   		DMAETH_TABLE2
   		ASIX_TABLE2
   	#endif
	#endif
	#if USE_ETHERNET == 2
		// If 2nd instance: use it; otherwise use 1st instance (reverse normal order).
       DMAETH100_TABLE2
	   DMAETH_TABLE2
	   ASIX_TABLE2

		// Notice the backwards ordering here...
		ASIX_TABLE1
		DMAETH_TABLE1
        DMAETH100_TABLE1
	#endif
#endif
	// End of ethernet table marker (not used, but required syntactically)
   { NULL, NULL, 0 }
}

// Conditional compile logic here is analogous to that used in _driver_table above.
#if USING_WIFI
, _wifi_table[] = {
  #if USE_WIFI != 2
	// WIFI Driver entries
      WIFIG_TABLE1
	#if USE_WIFI == 3
      	WIFIG_TABLE2
   #endif
  	#endif
  	#if USE_WIFI == 2
		// If 2nd instance: use it; otherwise use 1st instance (reverse normal
      // order).
      WIFIG_TABLE2
      WIFIG_TABLE1
  #endif
	// End of table marker
   { NULL, NULL, 0 }
}
#endif

#if USING_LOOPBACK
, _loopback_table[] = {
	// Local loopback device
	LOOPBACK_TABLE1
	LOOPBACK_TABLE2

	// End of table marker
   { NULL, NULL, 0 }
}
#endif

#if USING_PPP_SERIAL
, _ppp_serial_table[] = {
	// PPP over async serial tables
	PPP_SERIAL_TABLE1
	PPP_SERIAL_TABLE2
	PPP_SERIAL_TABLE3
	PPP_SERIAL_TABLE4
	PPP_SERIAL_TABLE5
	PPP_SERIAL_TABLE6

	// End of table marker
   { NULL, NULL, 0 }
}
#endif

#if USING_VSPD
, _vspd_table[] = {
	// Virtual Serial Packet Driver (stream)
	VSPD_TABLE1
	VSPD_TABLE2
	VSPD_TABLE3
	VSPD_TABLE4
	VSPD_TABLE5
	VSPD_TABLE6

	// End of table marker
   { NULL, NULL, 0 }
}
#endif


#if USING_PPPOE
, _pppoe_table[] = {
	// PPP over Ethernet tables
	PPPOE_TABLE1
	PPPOE_TABLE2

	// End of table marker
   { NULL, NULL, 0 }
}
#endif


;

#ifdef NET_DEBUG_INIT
	__debug
#else
	__nodebug
#endif
void dcr_initdcr()
{
	static int i, numser, numvspd, numpppoe, numdhcp, numlo;
   static IFTEntry * ifte;
   auto unsigned long ethHWConfig;
   auto int ethnum, wifinum, retval, dtindex;

	sock_delay=30;
	sock_inactive=0;

	system_yield = NULL;
	dcrtcpd = NULL;
	sock_data_timeout = 120000uL;

	memset(_if_tab, 0, sizeof(_if_tab));
	_if_request = 0;
	_if_prequest = 0;
	_if_actual = 0;
	_if_dhcp = 0;
	_if_dhcp_lease = 0;

#ifndef DISABLE_DNS
	// Init the name server table
	_dns_server_table.num = 0;
	_dns_server_table.max = DNS_TABLE_SIZE;
	_dns_server_table.table = _dns_servers;
	_dns_server_table.sources = DNS_ALL_SOURCES;
	_dns_server_table.health = DNS_ALL_HEALTH;
	_dns_server_table.preference = DNS_ALL_SOURCES|DNS_ALL_HEALTH;
#endif

#ifdef USE_DHCP
	memset(_dhcp_info, 0, sizeof(_dhcp_info));
#endif
#if USING_PPP_SERIAL
	memset(_ppp_states, 0, sizeof(_ppp_states));
#endif
#if USING_PPPOE
	memset(_pppoe_states, 0, sizeof(_pppoe_states));
#endif
	numser = 0;
	numvspd = 0;
	numpppoe = 0;
   numdhcp = 0;
   ethnum = 0;
   wifinum = 0;
   numlo = 0;
	for (i = 0; i < IF_MAX; i++) {
   	ifte = _if_tab + i;
		// Set to narrowest mask.  This is done even for unused i/f slots,
		// so that functions which iterate through all slots don't get confused.
		ifte->mask = 0xFFFFFFFFuL;
		if (!(1u<<i & IF_SET))
			continue;

#if USING_ETHERNET
	#if !ETHERNET_ONBOARD
		#error "Ethernet interface specified, but no Ethernet hardware on this board."
		#fatal "To override this error for custom boards, #define ETHERNET_ONBOARD 1"
	#endif
		if (IF_PKT_ETH(i))
      	ifte->u.eth.riface = i;
		if (IF_PKT_ETH(i) && !IF_P2P(i))
      {
     		retval = _GetSysMacroValue((ethnum == 0)?"_DC_ETH0_":"_DC_ETH1_",
     		                           &ethHWConfig);
     		// The macro did exist, and this is an interface with multiple
     		// possible Ethernet chipsets
     		if ((retval == 0) &&
     		    ((ethHWConfig & _DC_ETH_COMPILETIME_MASK) >= _DC_ETH_MULTI)) {
            // Choose the appropriate chipset (at runtime)
            if ((ethHWConfig & _DC_ETH_RUNTIME_MASK) == 0x00000000) {
               dtindex = ethnum;
            }
            else {
               dtindex = ethnum + 1;
            }
            // Skip past the two possibilities for the next iteration
            ethnum += 2;
         }
         else {
            dtindex = ethnum;
            ethnum++;
         }

         ifte->mtu = ETH_MTU;
	#if USE_ETH_PRELOADED_DRIVER == 0
         // Dynamic state information for driver
         ifte->state = _driver_table[dtindex].state;
         // (const) information about driver
         ifte->ncd = _driver_table[dtindex].ncd;
         // Instance number of device in driver
         ifte->instance = _driver_table[dtindex].instance;
      #else
         pld_init_ethernet(ifte, dtindex);
      #endif

   #ifdef USE_DHCP
	      if (numdhcp < NUM_DHCP_IF) {
	         ifte->dhcp = _dhcp_info + numdhcp;
	         ifte->flags |= IFF_DHCP_QUALIFY;
	         numdhcp++;
	      }
   #endif
		}

#endif // USING_ETHERNET

#if USING_WIFI
	#if !WIFI_ONBOARD
		#error "WiFi interface specified, but no WiFi hardware on this board."
		#fatal "To override this error for custom boards, #define WIFI_ONBOARD 1"
	#endif
	    if(IF_PKT_REAL_WIFI(i))
	       ifte->u.eth.riface = i;
	    if(IF_PKT_REAL_WIFI(i) && !IF_P2P(i)) {

	      ifte->mtu = ETH_MTU;
	      // Dynamic state information for driver
	      ifte->state = _wifi_table[wifinum].state;
	      // (const) information about driver
	      ifte->ncd = _wifi_table[wifinum].ncd;
	      // Instance number of device in driver
	      ifte->instance = _wifi_table[wifinum].instance;

	      wifinum++;

	#ifdef USE_DHCP
	      if (numdhcp < NUM_DHCP_IF) {
	         ifte->dhcp = _dhcp_info + numdhcp;
	         ifte->flags |= IFF_DHCP_QUALIFY;
	         numdhcp++;
	      }
	#endif
	   }
#endif //USING_WIFI

#if USING_LOOPBACK
		if (i == IF_LOOPBACK) {
      	// There is no LL header, so set MTU = buffer size
	      ifte->mtu = NET_BUFSIZE;
	      // Dynamic state information for driver
	      ifte->state = _loopback_table[numlo].state;
	      // (const) information about driver
	      ifte->ncd = _loopback_table[numlo].ncd;
	      // Instance number of device in driver
	      ifte->instance = _loopback_table[numlo].instance;

         ifte->ipaddr = 0x7F000000;
         ifte->static_ip = 0x7F000000;
         ifte->mask = 0xFF000000;
         ifte->static_mask = 0xFF000000;

	      numlo++;
      }
#endif //USING_LOOPBACK

#if USING_PPP_SERIAL
		if (IF_PKT_SER(i) && IF_P2P(i)) {
         ifte->state = _ppp_serial_table[numser].state;  // Dynamic state information for driver
         ifte->ncd = _ppp_serial_table[numser].ncd;      // (const) information about driver
         ifte->instance = _ppp_serial_table[numser].instance;  // Instance number of device in driver
         ++numser;
			ifte->mtu = PPP_MTU;
      #ifdef USE_DHCP
         #ifdef DHCP_ON_PPP
         if (numdhcp < NUM_DHCP_IF) {
            ifte->dhcp = _dhcp_info + numdhcp;
            ifte->flags |= IFF_DHCP_QUALIFY;
            numdhcp++;
         }
         #endif
      #endif
		}
#endif	// USING_PPP_SERIAL
#if USING_VSPD
		if (IF_PKT_SER(i) && !IF_P2P(i)) {
         ifte->state = _vspd_table[numvspd].state;  // Dynamic state information for driver
         ifte->ncd = _vspd_table[numvspd].ncd;      // (const) information about driver
         ifte->instance = _vspd_table[numvspd].instance;  // Instance number of device in driver
         ++numvspd;
			ifte->mtu = 1500;
		}
#endif	// USING_VSPD
#if USING_PPPOE
	#if !ETHERNET_ONBOARD
		#error "PPPoE interface specified, but no Ethernet hardware on this board."
		#fatal "To override this error for custom boards, #define ETHERNET_ONBOARD 1"
	#endif
		if (IF_PKT_ETH(i) && IF_P2P(i)) {
         ifte->state = _pppoe_table[numpppoe].state;  // Dynamic state information for driver
         ifte->ncd = _pppoe_table[numpppoe].ncd;      // (const) information about driver
         ifte->instance = _pppoe_table[numpppoe].instance;  // Instance number of device in driver
         ++numpppoe;
			ifte->mtu = ETH_MTU - 8;	// Subtract 6 for PPPoE header, and 2 for PPP protocol field.
      	#ifdef USE_DHCP
         	#ifdef DHCP_ON_PPPOE
         	if (numdhcp < NUM_DHCP_IF) {
            	ifte->dhcp = _dhcp_info + numdhcp;
               ifte->flags |= IFF_DHCP_QUALIFY;
               numdhcp++;
            }
            #endif
         #endif
		}
#endif		//USING_PPPOE
	}
	ip_id = 0;

#asm
; V26902: randomize starting port to a value from 1024 to 17407.
; uses the RTC and rolls to a new port every 31ms, rolls over after 512 seconds
ioi	ld 	(RTC0R), a			; latch RTC registers
ioi	ld 	hl, (RTC1R)			; load bits 8-23 of RTC (1/128 second)
		ld		jk, 0
		srl	2, jkhl				; hl now contains bits 10-23 of RTC (1/32 second)
		ld		de, 1024				; add offset of 1024 to current range 0-16383
		add	hl, de				; final range is 1024-17407
	#ifndef DISABLE_TCP
		ld		(next_tcp_port), hl
	#endif
	#ifndef DISABLE_UDP
		ld		(next_udp_port), hl
	#endif
#endasm

#ifndef DISABLE_TCP
	tcp_allsocs = NULL;
#endif
#ifndef DISABLE_UDP
	udp_allsocs = NULL;
#endif
	debug_on = 0;

	_initialized = 0; 		/* If this var out-of-scope, you're not
										calling sock_init()! */
}

/*** BeginHeader ifstatus */
int ifstatus (int iface);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ifstatus                               <NET.LIB>

SYNTAX: word ifstatus(int iface);

KEYWORDS:		tcpip, socket

DESCRIPTION: 	This returns the status of the specified interface.

					This function deprecated.  Use ifpending() instead,
					since it provides better detail.

PARAMETER1: 	iface - interface number.  Use one of the definitions
                 IF_DEFAULT, IF_ETH0, IF_ETH1, IF_WIFI0,
                 IF_PPPOE0, IF_PPPOE1, IF_PPP0-5,
               If the interface does not exist, then you will get a
               compile time error.  IF_DEFAULT refers to the default
               interface, which will be equivalent to the first of
					the other interface identifiers in the above list which
					exists.

RETURN VALUE:  0 if interface is currently down,
               Non-zero if interface is currently up (active).

SEE ALSO:      ifconfig, ifdown, ifup, ifpending

END DESCRIPTION **********************************************************/

_net_nodebug
int ifstatus (int iface)
{
	if ( (iface<0) || (iface > (IF_MAX+VIRTUAL_ETH)) )
	{
		return 0;
	}
	return (_initialized && _if_tab[iface].up);
}

/*** BeginHeader */
#endif
/*** EndHeader */

