/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
//
// Embedded 802.11b/g wireless network interface
//
/*** BeginHeader */
#ifndef __WIFI_DRIVER_LIB
#define __WIFI_DRIVER_LIB

// If the user does #define WPA_EAP_BLOCKING then we do *not*
// use coprocesses, and TCP/IP will
// block for up to 12 seconds when using EAP-TLS.  Otherwise,
// the default is now to use a single co-process for handling
// EAPOL packets, since this is the place where TLS will be driven.
#ifndef WPA_EAP_BLOCKING
	#ifndef _COPROCESS_H
		#use "coprocess.lib"
	#endif
#endif

// WPA supplicant wants to add driver private data to all driver ops,
// so use _wifi_macParams
#define XXX_priv ((void __far *) &_wifi_macParams)



#define AUTH_ALG_OPEN_SYSTEM	0x01
#define AUTH_ALG_SHARED_KEY	0x02
#define AUTH_ALG_LEAP		0x04

#define SSID_MAX_WPA_IE_LEN 40
#define WPA_MAX_IE_LEN	80

#define WPA_PROTO_WPA		0x0001
#define WPA_PROTO_RSN		0x0002

#define MAX_SSID_LEN 32
#define PMK_LEN 32

#define BROADCAST_SSID_SCAN ((struct wpa_ssid __far *) 1)

#define WPA_KEY_INFO_TYPE_MASK 						0x0007
#define WPA_KEY_INFO_TYPE_HMAC_MD5_RC4					0x0001
#define WPA_KEY_INFO_TYPE_HMAC_SHA1_AES				0x0002
#define WPA_KEY_INFO_KEY_TYPE 						0x0008 /* 1 = Pairwise, 0 = Group key */
/* bit4..5 is used in WPA, but is reserved in IEEE 802.11i/RSN */
#define WPA_KEY_INFO_KEY_INDEX_MASK					0x0030
#define WPA_KEY_INFO_KEY_INDEX_SHIFT 					4
#define WPA_KEY_INFO_INSTALL 							0x0040 /* pairwise */
#define WPA_KEY_INFO_TXRX 								0x0040 /* group */
#define WPA_KEY_INFO_ACK								0x0080
#define WPA_KEY_INFO_MIC								0x0100
#define WPA_KEY_INFO_SECURE							0x0200
#define WPA_KEY_INFO_ERROR								0x0400
#define WPA_KEY_INFO_REQUEST							0x0800
#define WPA_KEY_INFO_ENCR_KEY_DATA					0x1000 /* IEEE 802.11i/RSN only */

#if 0
// NOTE: this code retained (but #ifdef out) for documentation on the
// required driver interface API.
struct wpa_driver_ops {
	/**
	 * get_bssid - get the current BSSID
	 * @ifname: interface name, e.g., wlan0
	 * @bssid: buffer for BSSID (ETH_ALEN = 6 bytes)
	 *
	 * Returns: 0 on success, -1 on failure
	 *
	 * Query kernel driver for the current BSSID and copy it to @bssid.
	 * Setting @bssid to 00:00:00:00:00:00 is recommended if the STA is not
	 * associated.
	 */
	int (*get_bssid)(const char *ifname, char *bssid);

	/**
	 * get_ssid - get the current SSID
	 * @ifname: interface name, e.g., wlan0
	 * @ssid: buffer for SSID (at least 32 bytes)
	 *
	 * Returns: length of the SSID on success, -1 on failure
	 *
	 * Query kernel driver for the current SSID and copy it to @ssid.
	 * Returning zero is recommended if the STA is not associated.
	 *
	 * Note: SSID is an array of octets, i.e., it is not nul terminated and
	 * can, at least in theory, contain control characters (including nul)
	 * and as such, should be processed as binary data, not a printable
	 * string.
	 */
	int (*get_ssid)(const char *ifname, char *ssid);

	/**
	 * set_wpa - enable/disable WPA support
	 * @ifname: interface name, e.g., wlan0
	 * @enabled: 1 = enable, 0 = disable
	 *
	 * Returns: 0 on success, -1 on failure
	 *
	 * Configure the kernel driver to enable/disable WPA support. This may
	 * be empty function, if WPA support is always enabled. Common
	 * configuration items are WPA IE (clearing it when WPA support is
	 * disabled), Privacy flag for capability field, roaming mode (need to
	 * allow wpa_supplicant to control roaming).
	 */
	int (*set_wpa)(const char *ifname, int enabled);

	/**
	 * set_key - configure encryption key
	 * @ifname: interface name, e.g., wlan0
	 * @alg: encryption algorithm (%WPA_ALG_NONE, %WPA_ALG_WEP,
	 *	%WPA_ALG_TKIP, %WPA_ALG_CCMP); %WPA_ALG_NONE clears the key.
	 * @addr: address of the peer STA or ff:ff:ff:ff:ff:ff for
	 *	broadcast/default keys
	 * @key_idx: key index (0..3), always 0 for unicast keys
	 * @set_tx: configure this key as the default Tx key (only used when
	 *	driver does not support separate unicast/individual key
	 * @seq: sequence number/packet number, @seq_len octets, the next
	 *	packet number to be used for in replay protection; configured
	 *	for Rx keys (in most cases, this is only used with broadcast
	 *	keys and set to zero for unicast keys)
	 * @seq_len: length of the @seq, depends on the algorithm:
	 *	TKIP: 6 octets, CCMP: 6 octets
	 * @key: key buffer; TKIP: 16-byte temporal key, 8-byte Tx Mic key,
	 *	8-byte Rx Mic Key
	 * @key_len: length of the key buffer in octets (WEP: 5 or 13,
	 *	TKIP: 32, CCMP: 16)
	 *
	 * Returns: 0 on success, -1 on failure
	 *
	 * Configure the given key for the kernel driver. If the driver
	 * supports separate individual keys (4 default keys + 1 individual),
	 * @addr can be used to determine whether the key is default or
	 * individual. If only 4 keys are supported, the default key with key
	 * index 0 is used as the individual key. STA must be configured to use
	 * it as the default Tx key (@set_tx is set) and accept Rx for all the
	 * key indexes. In most cases, WPA uses only key indexes 1 and 2 for
	 * broadcast keys, so key index 0 is available for this kind of
	 * configuration.
	 */
	int (*set_key)(const char *ifname, wpa_alg alg, uint8 *addr,
		       int key_idx, int set_tx, uint8 *seq, size_t seq_len,
		       uint8 *key, size_t key_len);

	/**
	 * events_init - initialize processing of driver events
	 * @ctx: context to be used when calling wpa_supplicant_event()
	 *
	 * Return: pointer to private data, %NULL on failure
	 *
	 * Initialize event processing for kernel driver events (e.g.,
	 * associated, scan results, Michael MIC failure). This function can
	 * allocate a private configuration data area for file descriptor etc.
	 * information. If this is not used, non-NULL value will need to be
	 * returned because %NULL is used to indicate failure.
	 *
	 * The main event loop (eloop.c) of wpa_supplicant can be used to
	 * register callback for read sockets (eloop_register_read_sock()).
	 *
	 * See wpa_supplicant.h for more information about events and
	 * wpa_supplicant_event() function.
	 */
	void * (*events_init)(void *ctx);

	/**
	 * events_deinit - deinitialize processing of driver events
	 * @ctx: context to be used when calling wpa_supplicant_event() (same
	 *	as in matching wpa_driver_events_init() call)
	 * @priv: pointer to private data (from matching
	 *	wpa_driver_events_init())
	 *
	 * Return: 0 on success, -1 on failure
	 *
	 * Stop receiving kernel events. Free private data buffer if one was
	 * allocated in wpa_driver_events_init().
	 */
	int (*events_deinit)(void *ctx, void *priv);

	/**
	 * set_countermeasures - enable/disable TKIP countermeasures
	 * @ifname: interface name, e.g., wlan0
	 * @enabled: 1 = countermeasures enabled, 0 = disabled
	 *
	 * Return: 0 on success, -1 on failure
	 *
	 * Configure TKIP countermeasures. When these are enabled, the driver
	 * should drop all received and queued frames that are using TKIP.
	 */
	int (*set_countermeasures)(const char *ifname, int enabled);

	/**
	 * set_drop_unencrypted - enable/disable unencrypted frame filtering
	 * @ifname: interface name, e.g., wlan0
	 * @enabled: 1 = unencrypted Tx/Rx frames will be dropped, 0 = disabled
	 *
	 * Return: 0 on success, -1 on failure
	 *
	 * Configure the driver to drop all non-EAPOL frames (both receive and
	 * transmit paths). Unencrypted EAPOL frames (ethertype 0x888e) must
	 * still be allowed for key negotiation.
	 */
	int (*set_drop_unencrypted)(const char *ifname, int enabled);

	/**
	 * scan - request the driver to initiate scan
	 * @ifname: interface name, e.g., wlan0
	 * @ctx: context to be used when calling wpa_supplicant_event()
	 * @ssid: specific SSID to scan for (ProbeReq) or %NULL to scan for
	 *	all SSIDs (either active scan with broadcast SSID or passive
	 *	scan
	 * @ssid_len: length of the SSID
	 *
	 * Return: 0 on success, -1 on failure
	 *
	 * Once the scan results are ready, the driver should report scan
	 * results event for wpa_supplicant which will eventually request the
	 * results with wpa_driver_get_scan_results().
	 */
	int (*scan)(const char *ifname, void *ctx, uint8 *ssid, size_t ssid_len);

	/**
	 * get_scan_results - fetch the latest scan results
	 * @ifname: interface name, e.g., wlan0
	 * @results: pointer to buffer for scan results
	 * @max_size: maximum number of entries (buffer size)
	 *
	 * Return: number of scan result entries used on success, -1 on failure
	 *
	 * If scan results include more than @max_size BSSes, @max_size will be
	 * returned and the remaining entries will not be included in the
	 * buffer.
	 */
	int (*get_scan_results)(const char *ifname,
				struct wpa_scan_result *results,
				size_t max_size);

	/**
	 * deauthenticate - request driver to deauthenticate
	 * @ifname: interface name, e.g., wlan0
	 * @addr: peer address (BSSID of the AP)
	 * @reason_code: 16-bit reason code to be sent in the deauthentication
	 *	frame
	 *
	 * Return: 0 on success, -1 on failure
	 */
	int (*deauthenticate)(const char *ifname, uint8 *addr, int reason_code);

	/**
	 * disassociate - request driver to disassociate
	 * @ifname: interface name, e.g., wlan0
	 * @addr: peer address (BSSID of the AP)
	 * @reason_code: 16-bit reason code to be sent in the disassociation
	 *	frame
	 *
	 * Return: 0 on success, -1 on failure
	 */
	int (*disassociate)(const char *ifname, uint8 *addr, int reason_code);

	/**
	 * associate - request driver to associate
	 * @ifname: interface name, e.g., wlan0
	 * @bssid: BSSID of the selected AP
	 * @ssid: the selected SSID
	 * @ssid_len: length of the SSID
	 * @freq: frequency that the selected AP is using (in MHz as reported
	 *	in the scan results)
	 * @wpa_ie: WPA information element to be included in (Re)Association
	 *	Request (including information element id and length). Use of
	 *	this WPA IE is optional. If the driver generates the WPA IE, it
	 *	can use @pairwise_suite, @group_suite, and @key_mgmt_suite
	 *	to select proper algorithms. In this case, the driver has to
	 *	notify wpa_supplicant about the used WPA IE by generating an
	 *	event that the interface code will convert into EVENT_ASSOCINFO
	 *	data (see wpa_supplicant.h). When using WPA2/IEEE 802.11i,
	 *	@wpa_ie is used for RSN IE instead. The driver can determine
	 *	which version is used by looking at the first byte of the IE
	 *	(0xdd for WPA, 0x30 for WPA2/RSN).
	 * @wpa_ie_len: length of the @wpa_ie
	 * @pairwise_suite: the selected pairwise cipher suite (this is usually
	 *	ignored if @wpa_ie is used)
	 * @group_suite: the selected group cipher suite (this is usually
	 *	ignored if @wpa_ie is used)
	 * @key_mgmt_suite: the selected key management suite (this is usually
	 *	ignored if @wpa_ie is used)
	 *
	 * Return: 0 on success, -1 on failure
	 */
	int (*associate)(const char *ifname, const char *bssid,
			 const char *ssid, size_t ssid_len, int freq,
			 const char *wpa_ie, size_t wpa_ie_len,
			 wpa_cipher pairwise_suite, wpa_cipher group_suite,
			 wpa_key_mgmt key_mgmt_suite);

	/**
	 * cleanup - cleanup driver state prior to exit
	 * @ifname: interface name, e.g., wlan0
	 *
	 * Return: nothing
	 */
	void (*cleanup)(const char *ifname);

	/**
	 * set_auth_alg - set IEEE 802.11 authentication algorithm
	 * @ifname: interface name, e.g., wlan0
	 * @auth_alg: bit field of AUTH_ALG_*
	 *
	 * If the driver supports more than one authentication algorithm at the
	 * same time, it should configure all supported algorithms. If not, one
	 * algorithm needs to be selected arbitrarily. Open System
	 * authentication should be ok for most cases and it is recommended to
	 * be used if other options are not supported. Static WEP configuration
	 * may also use Shared Key authentication and LEAP requires its own
	 * algorithm number. For LEAP, user can make sure that only one
	 * algorithm is used at a time by configuring LEAP as the only
	 * supported EAP method.
	 *
	 * Return: 0 on success, -1 on failure
	 */
	int (*set_auth_alg)(const char *ifname, int auth_alg);
};
#endif

/*** EndHeader */

/*** BeginHeader _eapol_cop, _eapol_cop_busy, _eapol_proc_cop, _eapol_cop_handle */
void _eapol_cop(void __far * p);
ll_prefix __far * _eapol_proc_cop(ll_prefix __far * L);
extern int _eapol_cop_busy;
extern void __far * _eapol_cop_handle;
/*** EndHeader */

int _eapol_cop_busy;
void __far * _eapol_cop_handle;

// This is the EAPOL coprocess entry function (never returns!).
_wifig_nodebug
void _eapol_cop(void __far * p)
{
	auto ll_prefix __far * L;
   auto ll_prefix __far * __far * Lp;		// The current EAPOL packet (initial parameter
   									// and parameter to cop_resume() calls from main
   									// app).

	for (;;) {
		// yield with NULL parm.  If caller resumes, it will be with new packet.  If above
		// call yields, any new packet will be ignored, but we can't to better than that
		// because we can only perform one operation at a time.  Normally, we should have
		// completed the above and be ready to service next packet.
		Lp = (ll_prefix __far * __far *)cop_yield(NULL);
		if (Lp) {
			L = *Lp;
			// Need to lock out other EAPOL calls with this semaphore
			_eapol_cop_busy = 1;
			wpaS_rx_eapol(wpa_s_static_pointer,
			              L->data1 + 30,	// 30 is offset to source MAC address
			              L->data1 + L->net_offs,
			              L->len - L->net_offs);
      	pkt_buf_release(L);
			_eapol_cop_busy = 0;
		}
	}
}

// This (in the context of main) initializes and runs the eapol co-process.
_wifig_nodebug
ll_prefix __far * _eapol_proc_cop(ll_prefix __far * L)
{
	#GLOBAL_INIT { _eapol_cop_busy = 0; _eapol_cop_handle = NULL; }
	if (!_eapol_cop_handle) {
		_eapol_cop_handle = cop_create(_eapol_cop, NULL);
		cop_resume(_eapol_cop_handle, NULL);	// Run to its first yield().
	}
	if (L && !_eapol_cop_busy) {
		cop_resume(_eapol_cop_handle, &L);
		// Setting the OUTBUF flag tells pkt_received to not re-handle the packet
		L->ll_flags |= LL_OUTBUF;
	   // Return NULL: currently, the coprocess is responsible for deleting the
	   // packet when it is finished.  Thus, returning null here causes pkt_received()
	   // to *not* delete the packet.
		L = NULL;
	}
	else {
		cop_resume(_eapol_cop_handle, NULL);
	}
	return L;	// Delete packet, could not be processed since busy.
}

/*** BeginHeader wln_send */
int wln_send (uint8 *data, int length);
/*** EndHeader */
//
// Send a packet to wireless network
// @param data packet containing ethernet header and payload
// @param length total length in bytes
//
_wifig_nodebug
int wln_send (uint8 *data, int length)
{
	ll_Gather g;

	memset(&g, 0, sizeof(g));
	g.iface = IF_WIFI0;
	g.len1 = length;
	g.data1 = (char __far *)paddr(data);
	return wifig_sendpacket(_wifig_conf, &g);

}


/*** BeginHeader wpa_driver_wln_get_bssid, wpa_driver_wln_get_ssid, wpa_driver_wln_set_key */
// NOTE: drv_priv parameter is unused, but mandated by API.
int wpa_driver_wln_get_bssid(void __far *drv_priv, char __far *bssid);
int wpa_driver_wln_get_ssid(void __far *drv_priv, char __far *ssid);
int wpa_driver_wln_set_key(void __far *drv_priv,
                 wpa_alg alg,
				     unsigned char __far *addr, int key_idx,
				     int set_tx, uint8 __far *seq, size_t seq_len,
				     uint8 __far *key, size_t key_len);
/*** EndHeader */


_wifig_nodebug
__static int wpa_driver_wln_get_bssid(void __far *drv_priv, char __far *bssid)
{

	if (_wifi_macStatus.state >= 	WLN_ST_ASSOC_ESS)
		_f_memcpy (bssid, _wifi_macStatus.bss_addr, WLN_ADDR_SIZE);
	else
		_f_memset (bssid, 0, WLN_ADDR_SIZE);

	return 0;
}

_wifig_nodebug
__static int wpa_driver_wln_get_ssid(void __far *drv_priv, char __far *ssid)
{

	if (_wifi_macStatus.state >= 	WLN_ST_ASSOC_ESS)
	{
		_f_memcpy (ssid, _wifi_macStatus.ssid, _wifi_macStatus.ssid_len);
		return _wifi_macStatus.ssid_len;
	}
	else
		return 0;
}

_wifig_nodebug
__static int wpa_driver_wln_set_key(void __far *drv_priv,
                 wpa_alg alg,
				     unsigned char __far *addr, int key_idx,
				     int set_tx, uint8 __far *seq, size_t seq_len,
				     uint8 __far *key, size_t key_len)
{
   // Must have near mac address, seq, key, etc. for _wifi_wln_set_key
   auto mac_addr near_addr;
   auto char near_seq[20]; // This is usually about 6.
   auto char near_key[64];
   auto int return_value;

   assert(seq_len <= sizeof(near_seq));
   assert(key_len <= sizeof(near_key));
   _f_memcpy(&near_addr, addr, ETH_ALEN);
   _f_memcpy(&near_seq, seq, seq_len);
   _f_memcpy(&near_key, key, key_len);
	_WPA_PRINTF((MSG_MSGDUMP, "wpa_driver_wln_set_key: alg=%d key_idx=%d "\
      "set_tx=%d seq_len=%d key_len=%d", alg, key_idx, set_tx, seq_len,key_len));
   _WPA_HEXDUMP((MSG_MSGDUMP, "wpa_driver_wln_set_key: key", key, key_len));

   // Need near mac address.
	//return _wifi_wln_set_key ((wln_key_type)alg, addr, key_idx, set_tx, key, key_len, seq);
	return_value = _wifi_wln_set_key ((wln_key_type)alg, near_addr,
         key_idx, set_tx, near_key, key_len, near_seq);
   return return_value;
}

/*** BeginHeader wpa_event_cb, associated */
// This used to be called via function ptr, but changed to direct call out of wln_send_event.
void wpa_event_cb (wln_event event, void __far *param);
extern BOOL associated;	//FIXME this name
/*** EndHeader */
BOOL associated;

_wifig_nodebug
void wpa_event_cb (wln_event event, void __far *param)
{
	auto union wpa_event_data data;
	auto union wpa_event_data __far * pdata;
	#GLOBAL_INIT { associated = 0; }

	pdata = (union wpa_event_data __far *)param;

	if (!wpa_s.wpa || !wpa_s.conf)
		return;

	// Temp define to use the new version
#define wpa_supplicant_event  wpaS_event
	switch (event)
	{
		case WLN_EVT_ASSOC:
			// Send scan event in case another application caused association
			associated = TRUE;
         // WLN_EVT_ASSOC - param is _wifi_macStatus.bs_addr, whereas
         //     wpa_supplicant_event is expecting a union with more info
			//     wpa_supplicant_event (&wpa_s, EVENT_SCAN_RESULTS, pdata);
         wpa_supplicant_event  (&wpa_s, EVENT_SCAN_RESULTS, NULL);

			// Send association event
			// wpa_supplicant_event (&wpa_s, EVENT_ASSOC, pdata);
			wpa_supplicant_event (&wpa_s, EVENT_ASSOC, NULL);

			// Create association info event data
			if (_wifi_macStatus.wpa_info[1] == 0)
			{
				data.assoc_info.req_ies = NULL;
				data.assoc_info.req_ies_len = 0;
			}
			else
			{
				data.assoc_info.req_ies = _wifi_macStatus.wpa_info;
				data.assoc_info.req_ies_len = _wifi_macStatus.wpa_info[1] + 2;
			}
         data.assoc_info.resp_ies = NULL;
         data.assoc_info.resp_ies_len = 0;
         data.assoc_info.beacon_ies = NULL;
         data.assoc_info.beacon_ies_len = 0;

			// Send association info event
			wpa_supplicant_event (&wpa_s, EVENT_ASSOCINFO, &data);
			break;

		case WLN_EVT_DISASSOC:
		case WLN_EVT_MIC_FAIL:
			// Send original event
			wpa_supplicant_event (&wpa_s,
				event == WLN_EVT_DISASSOC ? EVENT_DISASSOC : EVENT_MICHAEL_MIC_FAILURE,
				pdata);
			break;

		case WLN_EVT_JOIN:
			// Driver has selected a BSS.
			// Send scan event to let WPA choose whether to associate.
			associated = FALSE;
			wpa_s.reassociate = TRUE;
			wpa_supplicant_event (&wpa_s, EVENT_SCAN_RESULTS, pdata);
			break;
	}
#undef wpa_supplicant_event
}

/*** BeginHeader wpa_driver_wln_events_init */
void __far *wpa_driver_wln_events_init(void __far *ctx);
/*** EndHeader */
_wifig_nodebug
__static void __far *wpa_driver_wln_events_init(void __far *ctx)
{
	associated = FALSE;
	return ctx;
}

/*** BeginHeader wpa_driver_wln_events_deinit */
int wpa_driver_wln_events_deinit(void __far *ctx, void __far *priv);
/*** EndHeader */
_wifig_nodebug
__static int wpa_driver_wln_events_deinit(void __far *ctx, void __far *priv)
{
	return 0;
}

/*** BeginHeader wpa_driver_wln_get_scan_results */
int wpa_driver_wln_get_scan_results(
                 void __far *priv,
				     struct wpa_scan_result __far *results,
				     size_t max_size);
#define RSN_INFO_ELEM 									0x30
#define GENERIC_INFO_ELEM 								0xDD
/*** EndHeader */
_wifig_nodebug
__static int wpa_driver_wln_get_scan_results(
                 void __far *priv,
				     struct wpa_scan_result __far *results,
				     size_t max_size)
{

	_f_memcpy (results->bssid, _wifi_macStatus.bss_addr, WLN_ADDR_SIZE);
	_f_memcpy (results->ssid, _wifi_macStatus.ssid, _wifi_macStatus.ssid_len);
	results->ssid_len = _wifi_macStatus.ssid_len;

	if (_wifi_macStatus.wpa_info[1] == 0)
	{
		results->rsn_ie_len = 0;
		results->wpa_ie_len = 0;
	}
	else if (_wifi_macStatus.wpa_info[0] == RSN_INFO_ELEM)
	{
		_f_memcpy (results->rsn_ie, _wifi_macStatus.wpa_info, _wifi_macStatus.wpa_info[1] + 2);
		results->rsn_ie_len = _wifi_macStatus.wpa_info[1] + 2;
		results->wpa_ie_len = 0;
	}
	else
	{
		_f_memcpy (results->wpa_ie, _wifi_macStatus.wpa_info, _wifi_macStatus.wpa_info[1] + 2);
		results->wpa_ie_len = _wifi_macStatus.wpa_info[1] + 2;
		results->rsn_ie_len = 0;
	}

	if (_wifi_macStatus.channel < 14)
		results->freq = 2407 + 5*_wifi_macStatus.channel;
	else if (_wifi_macStatus.channel == 14)
		results->freq = 2484;
	else
		results->freq = 5180 + 20*(_wifi_macStatus.channel-15);

	results->caps = _wifi_macStatus.bss_caps;
	results->qual = 0;
	results->noise = 0;
	results->level = _wifi_macStatus.rx_signal;
	results->maxrate = _wifi_macStatus.tx_rate;

	return 1;
}

/*** BeginHeader wpa_driver_wln_disassociate */
int wpa_driver_wln_disassociate(void __far *priv, uint8 __far *addr,
					  int reason_code);
/*** EndHeader */
_wifig_nodebug
__static int wpa_driver_wln_disassociate(void __far *priv, uint8 __far *addr,
					  int reason_code)
{
   auto mac_addr near_addr;
   _f_memcpy(&near_addr, addr, ETH_ALEN);
	_WPA_PRINTF((MSG_DEBUG, "wpa_driver_wln_disassociate"));
   //  _wifi_wln_disassociate wants near addr
	//return _wifi_wln_disassociate (addr, reason_code);
	return _wifi_wln_disassociate (near_addr, reason_code);
}

/*** BeginHeader wpa_driver_wln_associate, __wpa_supplicant_associate */
int __wpa_supplicant_associate( void __far * priv,
                   struct wpa_driver_associate_params __far * params );
int wpa_driver_wln_associate(void __far * priv,
                   const char *bssid,
				       const char *ssid, size_t ssid_len,
				       int freq,
				       const char *wpa_ie, size_t wpa_ie_len,
				       wpa_cipher pairwise_suite,
				       wpa_cipher group_suite,
				       wpa_key_mgmt key_mgmt_suite);
/*** EndHeader */
_wifig_nodebug
__static int __wpa_supplicant_associate( void __far * priv,
                   struct wpa_driver_associate_params __far * params )
{
   auto int return_value;
   auto char ssid[MAX_SSID_LEN];
   auto mac_addr bssid;
   auto char wpa_ie[80];
   auto size_t wpa_ie_len;
   auto wpa_cipher pairwise_suite;
   auto wpa_cipher group_suite;
   auto wpa_key_mgmt key_mgmt_suite;

   // copy far struct to near auto
   _WPA_PRINTF((MSG_INFO, "Using __wpa_supplicant_associate"));
   _f_memcpy(&bssid, params->bssid, ETH_ALEN);
   _f_memcpy(&ssid, params->ssid, MAX_SSID_LEN);
   wpa_ie_len = params->wpa_ie_len;
   assert(wpa_ie_len <= sizeof(wpa_ie));
   _f_memcpy(&wpa_ie, params->wpa_ie, wpa_ie_len);
   pairwise_suite = params->pairwise_suite;
   group_suite = params->group_suite;
   key_mgmt_suite = params->key_mgmt_suite;

   return_value = wpa_driver_wln_associate(priv, bssid, ssid,
      params->ssid_len, params->freq, wpa_ie, wpa_ie_len, pairwise_suite,
      group_suite, key_mgmt_suite);
   // copy near values back to their far counterparts
   _f_memcpy(params->bssid, &bssid, ETH_ALEN);
   _f_memcpy(params->ssid, &ssid, MAX_SSID_LEN);
   _f_memcpy(params->wpa_ie, &wpa_ie, wpa_ie_len);
   return return_value;
}

_wifig_nodebug
__static int wpa_driver_wln_associate(void __far * priv,
                   const char *bssid,
				       const char *ssid, size_t ssid_len,
				       int freq,
				       const char *wpa_ie, size_t wpa_ie_len,
				       wpa_cipher pairwise_suite,
				       wpa_cipher group_suite,
				       wpa_key_mgmt key_mgmt_suite)
{
	auto int channel;
	// If already associated, ignore 2nd associate
	if (associated)
		return 1;

	_WPA_PRINTF((MSG_DEBUG, "wpa_driver_wln_associate"));


	if (freq < 2484)
		channel = (freq-2407)/5;
	else if (freq == 2484)
		channel = 14;
	else
		channel = (freq-5180)/20 + 15;

	if (wpa_ie_len == 0)
		wpa_ie = NULL;

	return _wifi_wln_associate ((uint8 *) ssid, ssid_len, channel, (uint8 *) bssid, (uint8 *) wpa_ie);
}

/*** BeginHeader wpa_supplicant_init */
void __far * wpa_supplicant_init(_WiFiGConfig __far * nic, wln_params __far * params);
/*** EndHeader */
_wifig_nodebug
void __far * wpa_supplicant_init(_WiFiGConfig __far * nic, wln_params __far * params)
{
	auto int ret;

   _WPA_PRINTF((MSG_DEBUG, "wpa_supplicant_init:"));
   __wpa_initStatics(); // Initialize the static globals in wpa supplicant

#ifdef WPA_USE_EAP
	ret = eap_peer_register_methods();
	if (ret) {
		_WPA_PRINTF((MSG_ERROR, "Failed to register EAP methods" ));
		if (ret== -2)
			_WPA_PRINTF((MSG_ERROR, "Two or more EAP methods used " \
			 "the same EAP type." ));
		return ((void  __far * )0);
	}
#endif

	eloop_init(&wpa_s);

	if (wpa_set_params (params) < 0) {
		_WPA_PRINTF((MSG_ERROR, "Failed to set config."));
		goto cleanup;
	}


	wpa_driver_wln_events_init(&wpa_s);

	if (wpa_supplicant_driver_init(&wpa_s, 0) < 0) {
		goto cleanup;
	}
	wpa_s.wpa->renew_snonce = 1;

	return &wpa_s;

cleanup:
	wpa_supplicant_terminate();
	return NULL;
}


/*** BeginHeader wpa_supplicant_terminate */
void wpa_supplicant_terminate(void);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_terminate(void)
{
	wpa_supplicant_deauthenticate(XXX_priv, &wpa_s, REASON_DEAUTH_LEAVING);
	wpa_driver_wln_events_deinit(&wpa_s, &wpa_s);
#ifdef WPA_USE_EAP
	eap_peer_unregister_methods();
#endif
	wpa_supplicant_cleanup(&wpa_s);

	eloop_terminate();
	eloop_destroy();
}

/*** BeginHeader wpa_supplicant_rx_eapol */
#define wpa_supplicant_rx_eapol(src_addr, buf, len) \
   wpaS_rx_eapol(wpa_s_static_pointer, (char __far *) (src_addr), \
                  (char __far *) (buf), (len));
/*** EndHeader */

/*** BeginHeader wpa_set_params */
int wpa_set_params (wln_params __far *params_in);
/*** EndHeader */
//
// Create wpa_config and wpa_ssid structures from wireless parameters
//
_wifig_nodebug
int wpa_set_params (wln_params __far *params)
{
	auto struct wpa_config * config;
	auto struct wpa_ssid * ssid;
	auto long oal;
	static struct eap_method_type ems[16];

	auto int i, cipher, pair_cipher, key_mgmt;
	auto struct eap_method_type __far *p;
	#GLOBAL_INIT {
		_f_memset(&wpa_s, 0, sizeof(wpa_s));
		_f_memset(&_wpa_s_config,0,sizeof(_wpa_s_config));
		_f_memset(&_wpa_s_ssid,0,sizeof(_wpa_s_ssid));
	   // Create config with one SSID
	   _wpa_s_config.ssid = &_wpa_s_ssid;
	   _wpa_s_config.pssid = &_wpa_s_config.ssid;
	   _wpa_s_config.num_prio = 1;
	   _wpa_s_config.ap_scan = 1;
	   _wpa_s_config.eapol_version = 1;
	   wpa_s.conf = &_wpa_s_config;
	   // Note that we assume a single static wln_params struct...
	   _wpa_s_ssid.ssid = _wifi_macParams.ssid;
		_wpa_s_ssid.wep_key = _wifi_macParams.wep_key;
		_wpa_s_ssid.psk = _wifi_macParams.wpa_psk;
		_wpa_s_ssid.wep_key_len = (size_t __far *)_wifi_macParams.wep_key_len;
#ifdef WPA_USE_EAP
		_wifi_macParams.eap_methods_i = ems;
	   _wpa_s_ssid.eap_methods = _wifi_macParams.eap_methods_i;
	   _wpa_s_ssid.identity = _wifi_macParams.identity;
	   _wpa_s_ssid.eappsk = _wifi_macParams.eappsk;
	   _wpa_s_ssid.eappsk_len = sizeof(_wifi_macParams.eappsk);
	   _wpa_s_ssid.password = _wifi_macParams.password;
	   _wpa_s_ssid.subject_match = _wifi_macParams.subject_match;
	   _wpa_s_ssid.altsubject_match = _wifi_macParams.altsubject_match;
	   _wpa_s_ssid.subject_match2 = _wifi_macParams.subject_match2;
	   _wpa_s_ssid.altsubject_match2 = _wifi_macParams.altsubject_match2;
		_wpa_s_ssid.proto = WPA_PROTO_WPA|WPA_PROTO_RSN;
		_wpa_s_ssid.fragment_size = 1398;
	      /* fragment_size: Maximum EAP fragment size in bytes (default 1398).
	         This value limits the fragment size for EAP methods that support
	         fragmentation (e.g., EAP-TLS and EAP-PEAP). This value should be set
	         small enough to make the EAP messages fit in MTU of the network
	         interface used for EAPOL. The default value is suitable for most
	         cases. */

#endif

	}

   _WPA_PRINTF((MSG_DEBUG, "wpa_set_params: setting up parameters"));
   config = &_wpa_s_config;
   ssid = &_wpa_s_ssid;

	cipher = 0;
	if (params->encrypt & WLN_ENCR_OPEN)
      cipher |= WPA_CIPHER_NONE;
	if (params->encrypt & WLN_ENCR_WEP)
      cipher |= WPA_CIPHER_WEP40 | WPA_CIPHER_WEP104;
	if (params->encrypt & WLN_ENCR_TKIP)
		cipher |= WPA_CIPHER_TKIP;
	if (params->encrypt & WLN_ENCR_CCMP)
      cipher |= WPA_CIPHER_CCMP;
#ifdef WPA_USE_EAP
	pair_cipher = 0;
	if (params->pairwise_encr & WLN_ENCR_OPEN)
      pair_cipher |= WPA_CIPHER_NONE;
	if (params->pairwise_encr & WLN_ENCR_WEP)
      pair_cipher |= WPA_CIPHER_WEP40 | WPA_CIPHER_WEP104;
	if (params->pairwise_encr & WLN_ENCR_TKIP)
		pair_cipher |= WPA_CIPHER_TKIP;
	if (params->pairwise_encr & WLN_ENCR_CCMP)
      pair_cipher |= WPA_CIPHER_CCMP;
#endif
	key_mgmt = 0;
	if (params->authen & (WLN_AUTH_OPEN|WLN_AUTH_SHAREDKEY))
		key_mgmt |= WPA_KEY_MGMT_NONE;
	if (params->authen & WLN_AUTH_WPA_PSK)
		key_mgmt |= WPA_KEY_MGMT_PSK;
	if (params->authen & (WLN_AUTH_WEP_8021X|WLN_AUTH_LEAP))
		key_mgmt |= WPA_KEY_MGMT_IEEE8021X_NO_WPA;
	if (params->authen & WLN_AUTH_WPA_8021X)
		key_mgmt |= WPA_KEY_MGMT_IEEE8021X;
	if (!key_mgmt)
		key_mgmt = WPA_KEY_MGMT_NONE;

	// Create SSID (BSS) parameters
	ssid->ssid_len = params->ssid_len;
	_f_memcpy (ssid->psk, params->wpa_psk, WLN_PSK_SIZE);
	ssid->psk_set = 1;
	// default to old behavior (i.e. use same cipher for group and pairwise)
	// but now also allow different pairwise (if not set to WPA_CIPHER_NONE/WLN_ENCR_OPEN)
#ifdef WPA_USE_EAP
	if (pair_cipher)
		ssid->pairwise_cipher = pair_cipher;
	else
#endif
		ssid->pairwise_cipher = cipher;
	ssid->group_cipher = cipher;
	ssid->key_mgmt = key_mgmt;
// removed following, since changed wpa_ssid to have pointers to
// static data (to avoid this copying)
/*
	for (i = 0; i < NUM_WEP_KEYS; i++) {
		_f_memcpy (ssid->wep_key[i], params->wep_key[i], params->wep_key_len[i]);
		ssid->wep_key_len[i] = params->wep_key_len[i];
	}
*/
	ssid->wep_tx_keyidx = params->wep_key_id;

#ifdef WPA_USE_EAP

	if (params->identity[0]) {
		ssid->identity_len = strlen (params->identity);
		ssid->identity = params->identity;
	}
	else {
		ssid->identity_len = 0;
		ssid->identity = NULL;
	}

	if (params->anonymous_identity[0]) {
		ssid->anonymous_identity_len = strlen (params->anonymous_identity);
		ssid->anonymous_identity = params->anonymous_identity;
	}
	else {
		ssid->anonymous_identity_len = 0;
		ssid->anonymous_identity = NULL;
	}

	if (params->password[0]) {
		ssid->password_len = strlen (params->password);
		ssid->password = params->password;
	}
	else {
		ssid->password_len = 0;
		ssid->password = NULL;
	}


	// note: blob lengths are not actually needed, they are passed to
	// tls_connection_set_params() which ignores them, since the cert structure
	// describes its own lengths etc.
	if (params->ca_cert)
		ssid->ca_cert_blob = params->ca_cert;
	else
		ssid->ca_cert_blob = params->ca_cert_managed;
	if (params->ca_cert2)
		ssid->ca_cert_blob2 = params->ca_cert2;
	else
		ssid->ca_cert_blob2 = params->ca_cert2_managed;
	if (params->client_cert)
		ssid->client_cert_blob = params->client_cert;
	else
		ssid->client_cert_blob = params->client_cert_managed;
	if (params->client_cert2)
		ssid->client_cert_blob2 = params->client_cert2;
	else
		ssid->client_cert_blob2 = params->client_cert2_managed;

	// Build list of allowed EAP methods
	p = ssid->eap_methods;
	if (params->eap_methods & WLN_EAP_LEAP)
		{ p->method = EAP_TYPE_LEAP; p->vendor = EAP_VENDOR_IETF; ++p; }
	if (params->eap_methods & WLN_EAP_PEAP)
		{ p->method = EAP_TYPE_PEAP; p->vendor = EAP_VENDOR_IETF; ++p; }
	if (params->eap_methods & WLN_EAP_TLS)
		{ p->method = EAP_TYPE_TLS; p->vendor = EAP_VENDOR_IETF; ++p; }
	if (params->eap_methods & WLN_EAP_TTLS)
		{ p->method = EAP_TYPE_TTLS; p->vendor = EAP_VENDOR_IETF; ++p; }

	// Only one phase 2 type allowed by EAP implementation.
	// Choose one in this order of perference.
	ssid->phase2 = NULL;
	if (params->eap_methods & WLN_EAP_MSCHAPV2) {
		{ p->method = EAP_TYPE_MSCHAPV2; p->vendor = EAP_VENDOR_IETF; ++p; }
		ssid->phase2 = "autheap=MSCHAPV2";
	}
	else if (params->eap_methods & WLN_EAP_MD5) {
		{ p->method = EAP_TYPE_MD5; p->vendor = EAP_VENDOR_IETF; ++p; }
		ssid->phase2 = "auth=MD5 autheap=MD5";
	}
	else if (params->eap_methods & WLN_EAP_GTC) {
		{ p->method = EAP_TYPE_GTC; p->vendor = EAP_VENDOR_IETF; ++p; }
		ssid->phase2 = "auth=GTC autheap=GTC";
	}
	else if (params->eap_methods & WLN_EAP_OTP) {
		{ p->method = EAP_TYPE_OTP; p->vendor = EAP_VENDOR_IETF; ++p; }
		ssid->phase2 = "auth=OTP autheap=OTP";
	}
	else if (params->eap_methods & WLN_EAP_TTLS_MSCHAPV2)
		ssid->phase2 = "auth=MSCHAPV2";
	else if (params->eap_methods & WLN_EAP_TTLS_MSCHAP)
		ssid->phase2 = "auth=MSCHAP";
	else if (params->eap_methods & WLN_EAP_TTLS_PAP)
		ssid->phase2 = "auth=PAP";
	else if (params->eap_methods & WLN_EAP_TTLS_CHAP)
		ssid->phase2 = "auth=CHAP";
	else if (params->eap_methods & WLN_EAP_TLS)
		ssid->phase2 = "auth=TLS autheap=TLS";

	// Terminate list...
	p->method = EAP_TYPE_NONE;
	p->vendor = EAP_VENDOR_IETF;

	// Require 802.1x keys if WEP with 802.1x and no default keys
	if ((key_mgmt & KEY_MGMT_802_1X_NO_WPA) &&
		!(key_mgmt & KEY_MGMT_NONE))
			ssid->eapol_flags |= EAPOL_FLAG_REQUIRE_KEY_BROADCAST;
#endif


	return 0;
}

/*** BeginHeader wpa_s, _wpa_s_config, _wpa_s_ssid */

// This stuff used to be in l2_packet.h.........................
#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"

#ifndef ETH_P_EAPOL
#define ETH_P_EAPOL 0x888e
#endif

#ifndef ETH_P_RSN_PREAUTH
#define ETH_P_RSN_PREAUTH 0x88c7
#endif

struct l2_ethhdr {
	uint8 h_dest[ETH_ALEN];
	uint8 h_source[ETH_ALEN];
	uint16 h_proto;
};
//................................................................

#define PMKID_LEN 16


extern struct wpa_supplicant wpa_s;
struct wpa_supplicant *const wpa_s_static_pointer = &wpa_s;

// These externally visible rather than private to wpa_set_params
extern struct wpa_config _wpa_s_config;
extern struct wpa_ssid _wpa_s_ssid;





/*** EndHeader */

struct wpa_supplicant wpa_s;
struct wpa_config _wpa_s_config;
struct wpa_ssid _wpa_s_ssid;


/*** BeginHeader wpa_supplicant_req_scan */
int wpa_supplicant_req_scan(void __far *priv, const char __far *ssid, size_t ssid_len);
/*** EndHeader */
_wifig_nodebug
int wpa_supplicant_req_scan(void __far *priv, const char __far *ssid, size_t ssid_len)
{
   static const unsigned int ms = 3000;
   if (ssid && ssid_len) {
      _WPA_PRINTF((MSG_WARNING, "wpa_supplicant_req_scan: Ignoring requested SSID '%ls'", ssid));
   }
	eloop_cancel_timeout(wpa_supplicant_scan, &wpa_s, NULL);
	eloop_register_timeout(ms, wpa_supplicant_scan, &wpa_s, NULL);
   return 0;
}


/*** BeginHeader wpa_supplicant_deauthenticate */
int wpa_supplicant_deauthenticate(void __far *priv,
               struct wpa_supplicant __far *wpa_s,
				   int reason_code);
/*** EndHeader */
_wifig_nodebug
int wpa_supplicant_deauthenticate(void __far *priv,
               struct wpa_supplicant __far *wpa_s,
				   int reason_code)
{
	auto uint8 __far *addr;
	addr = NULL;
	wpa_s->wpa_state = WPA_DISCONNECTED;
	if (memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0) {
		wpa_driver_wln_disassociate(XXX_priv, wpa_s->bssid,
					      reason_code);
		addr = wpa_s->bssid;
	}
	wpa_clear_keys(wpa_s, addr);
	wpa_s->current_ssid = NULL;
   return 0;
}

/*** BeginHeader wpa_supplicant_stop_countermeasures */
void wpa_supplicant_stop_countermeasures(void __far *eloop_ctx,
						void __far *sock_ctx);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_stop_countermeasures(void __far *eloop_ctx,
						void __far *sock_ctx)
{
	auto struct wpa_supplicant __far *wpa_s;
	wpa_s = eloop_ctx;

	if (wpa_s->countermeasures) {
		wpa_s->countermeasures = 0;

		_WPA_MSG((wpa_s, MSG_INFO, "WPA: TKIP countermeasures stopped"));
		wpa_supplicant_req_scan(XXX_priv, NULL, 0);
	}
}

/*** BeginHeader wpa_supplicant_scan_results */
void wpa_supplicant_scan_results(struct wpa_supplicant __far *wpa_s);
#define SCAN_AP_LIMIT 10
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_scan_results(struct wpa_supplicant __far *wpa_s)
{
	auto struct wpa_scan_result results[SCAN_AP_LIMIT];
	auto int num, prio;
	auto struct wpa_scan_result __far *selected;
	auto struct wpa_ssid __far *ssid;

	selected = NULL;
	num = wpa_driver_wln_get_scan_results(XXX_priv, results,
					      SCAN_AP_LIMIT);
	_WPA_PRINTF((MSG_DEBUG, "Scan results: %d", num));
	if (num < 0) {
		_WPA_PRINTF((MSG_DEBUG, "Failed to get scan results - try scanning again"));
		wpa_supplicant_req_scan(XXX_priv, NULL, 0);
		return;
	}
	if (num > SCAN_AP_LIMIT) {
		_WPA_PRINTF((MSG_INFO, "Not enough room for all APs (%d < %d)",
			   num, SCAN_AP_LIMIT));
		num = SCAN_AP_LIMIT;
	}

   assert(wpa_s->conf);
	for (prio = 0; prio < wpa_s->conf->num_prio; prio++) {
		selected = wpa_supplicant_select_bss(wpa_s,
						     wpa_s->conf->pssid[prio],
						     results, num, &ssid);
		if (selected)
			break;
	}

	if (selected) {
		if (wpa_s->reassociate ||
		    memcmp(selected->bssid, wpa_s->bssid, ETH_ALEN) != 0) {
			wpa_supplicant_associate(wpa_s, selected, ssid);
		} else {
			_WPA_PRINTF((MSG_DEBUG, "Already associated with the selected AP."));
		}
		//rsn_preauth_scan_results(wpa_s, results, num);
	} else {
		_WPA_PRINTF((MSG_DEBUG, "No suitable AP found."));
		wpa_supplicant_req_scan(XXX_priv, NULL, 0);
	}
}

/*** BeginHeader wpa_supplicant_timeout */
void wpa_supplicant_timeout(void __far *eloop_ctx, void __far *timeout_ctx);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_timeout(void __far *eloop_ctx, void __far *timeout_ctx)
{
	struct wpa_supplicant __far *wpa_s;
	wpa_s = eloop_ctx;
	_WPA_MSG((wpa_s, MSG_INFO, "Authentication with " MACSTR " timed out.",
		MAC2STR(wpa_s->bssid)));
	wpa_s->reassociate = 1;

	// Disconnect if not associated or authentication required
	if (wpa_s->wpa_state == WPA_ASSOCIATING ||
		wpa_s->key_mgmt == KEY_MGMT_PSK ||
		wpa_s->key_mgmt == KEY_MGMT_802_1X)
			wpa_supplicant_deauthenticate(XXX_priv, wpa_s, REASON_IEEE_802_1X_AUTH_FAILED);

	wpa_supplicant_req_scan(XXX_priv, NULL, 0);
}

/*** BeginHeader wpa_supplicant_select_bss */
struct wpa_scan_result __far *
wpa_supplicant_select_bss(struct wpa_supplicant __far *wpa_s,
           struct wpa_ssid __far *group,
			  struct wpa_scan_result __far *results, int num,
			  struct wpa_ssid __far **selected_ssid);
/*** EndHeader */
_wifig_nodebug
__static struct wpa_scan_result __far *
wpa_supplicant_select_bss(struct wpa_supplicant __far *wpa_s,
           struct wpa_ssid __far *group,
			  struct wpa_scan_result __far *results, int num,
			  struct wpa_ssid __far **selected_ssid)
{
	auto struct wpa_ie_data ie;
	auto struct wpa_ssid __far *ssid;
	auto struct wpa_scan_result __far *bss, *selected;
	auto int i;

	selected = NULL;
	_WPA_PRINTF((MSG_DEBUG, "Selecting BSS from priority group %d",
		   group->priority));

	bss = NULL;
	ssid = NULL;
	/* First, try to find WPA-enabled AP */
	for (i = 0; i < num && !selected; i++) {
		bss = &results[i];
		_WPA_PRINTF((MSG_DEBUG, "%d: " MACSTR " ssid='%s' wpa_ie_len=%d rsn_ie_len=%d",
			   i, MAC2STR(bss->bssid),
			   wpa_ssid_txt(bss->ssid, bss->ssid_len),
			   bss->wpa_ie_len, bss->rsn_ie_len));
		if (bss->wpa_ie_len == 0 && bss->rsn_ie_len == 0) {
			_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "no WPA/RSN IE"));
			continue;
		}

		for (ssid = group; ssid; ssid = ssid->pnext) {
			if (ssid->ssid_len != 0 && /* allow broadcast SSID */
				(bss->ssid_len != ssid->ssid_len ||
			    memcmp(bss->ssid, ssid->ssid,
				   bss->ssid_len) != 0)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "SSID mismatch"));
				continue;
			}
			if (ssid->bssid_set &&
			    memcmp(bss->bssid, ssid->bssid, ETH_ALEN) != 0) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "BSSID mismatch"));
				continue;
			}
			if (!(((ssid->proto & WPA_PROTO_RSN) &&
			       _wpa_s19_wpa_parse_wpa_ie_wpa(bss->rsn_ie,
						bss->rsn_ie_len, &ie) == 0) ||
			      ((ssid->proto & WPA_PROTO_WPA) &&
			       _wpa_s19_wpa_parse_wpa_ie_wpa(bss->wpa_ie,
						bss->wpa_ie_len, &ie) == 0))) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "could not parse WPA/RSN IE"));
				continue;
			}
			if (!(ie.proto & ssid->proto)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "proto mismatch"));
				continue;
			}
			if (!(ie.pairwise_cipher & ssid->pairwise_cipher)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "PTK cipher mismatch"));
				continue;
			}
			if (!(ie.group_cipher & ssid->group_cipher)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "GTK cipher mismatch"));
				continue;
			}
			if (!(ie.key_mgmt & ssid->key_mgmt)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "key mgmt mismatch"));
				continue;
			}

			selected = bss;
			*selected_ssid = ssid;
			_WPA_PRINTF((MSG_DEBUG, "   selected"));
			break;
		}
	}

	/* If no WPA-enabled AP found, try to find non-WPA AP, if configuration
	 * allows this. */
	for (i = 0; i < num && !selected; i++) {
		bss = &results[i];
		for (ssid = group; ssid; ssid = ssid->pnext) {
			if ((ssid->ssid_len == 0 || /* allow broadcast SSID */
				(bss->ssid_len == ssid->ssid_len &&
			    memcmp(bss->ssid, ssid->ssid, bss->ssid_len) == 0))
			    &&
			    (!ssid->bssid_set ||
			     memcmp(bss->bssid, ssid->bssid, ETH_ALEN) == 0) &&
			    ((ssid->key_mgmt & KEY_MGMT_NONE) ||
			     (ssid->key_mgmt & KEY_MGMT_802_1X_NO_WPA)))
			{
				selected = bss;
				*selected_ssid = ssid;
				_WPA_PRINTF((MSG_DEBUG, "   selected non-WPA AP " MACSTR " ssid='%s'",
					   MAC2STR(bss->bssid),
					   wpa_ssid_txt(bss->ssid,
							bss->ssid_len)));
				break;
			}
		}
	}

	return selected;
}

/*** BeginHeader wpa_supplicant_associate */
void wpa_supplicant_associate(struct wpa_supplicant __far *wpa_s,
				     struct wpa_scan_result __far *bss,
				     struct wpa_ssid __far *ssid);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_associate(struct wpa_supplicant __far *wpa_s,
				     struct wpa_scan_result __far *bss,
				     struct wpa_ssid __far *ssid)
{
	auto uint8 wpa_ie[80];
	auto int wpa_ie_len;
	auto int use_crypt;
	auto int algs;
	auto int cipher_pairwise, cipher_group;
	auto int i;

	algs = AUTH_ALG_OPEN_SYSTEM;
	wpa_s->reassociate = 0;
	_WPA_MSG((wpa_s, MSG_INFO, "Trying to associate with " MACSTR " (SSID='%s' freq=%d MHz)", MAC2STR(bss->bssid),
		wpa_ssid_txt(ssid->ssid, ssid->ssid_len), bss->freq));
	wpa_supplicant_cancel_scan(wpa_s);


	if ((bss->wpa_ie_len || bss->rsn_ie_len) &&
	    (ssid->key_mgmt & (KEY_MGMT_802_1X | KEY_MGMT_PSK))) {
		if (wpa_supplicant_set_suites(wpa_s,   bss,   ssid,
					      wpa_ie, &wpa_ie_len)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Failed to set WPA key management and encryption suites"));
			return;
		}
	} else {
		wpa_supplicant_set_non_wpa_policy(wpa_s, ssid);
		wpa_ie_len = 0;
	}

#define	CAP_PRIVACY		0x10

	wpa_clear_keys(wpa_s, bss->bssid);
	use_crypt = 1;
	cipher_pairwise = _wpa_s20_cipher_suite2driver(wpa_s->pairwise_cipher);
	cipher_group = _wpa_s20_cipher_suite2driver(wpa_s->group_cipher);
	if ((ssid->key_mgmt & KEY_MGMT_NONE) &&
		(bss->caps & CAP_PRIVACY) && wpa_ie_len == 0) {
		use_crypt = 0;
		for (i = 0; i < NUM_WEP_KEYS; i++) {
			if (ssid->wep_key_len[i]) {
				use_crypt = 1;
				_wpa_s20_wpa_eapol_set_wep_key(wpa_s,
						      i == ssid->wep_tx_keyidx,
						      i, ssid->wep_key[i],
						      ssid->wep_key_len[i]);
			}
		}
	}
	wpa_s->wpa_state = WPA_ASSOCIATING;
	wpa_driver_wln_associate(XXX_priv,
             bss->bssid,
				 bss->ssid, bss->ssid_len, bss->freq,
				 wpa_ie, wpa_ie_len,
				 cipher_pairwise, cipher_group,
				 _wpa_s20_key_mgmt2driver(wpa_s->key_mgmt));

	/* Timeout for IEEE 802.11 authentication and association */
	wpa_supplicant_req_auth_timeout(wpa_s, 5000);

	wpa_s->current_ssid = ssid;
	wpa_supplicant_initiate_eapol(wpa_s);
}

/*** BeginHeader wpa_supplicant_cancel_scan */
void wpa_supplicant_cancel_scan(struct wpa_supplicant __far *wpa_s);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_cancel_scan(struct wpa_supplicant __far *wpa_s)
{
	_WPA_MSG((wpa_s, MSG_DEBUG, "Cancelling scan request"));
	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
}

/*** BeginHeader wpa_supplicant_set_suites */
int wpa_supplicant_set_suites(struct wpa_supplicant __far *wpa_s,
				     struct wpa_scan_result __far *bss,
				     struct wpa_ssid __far *ssid,
				     uint8 __far *wpa_ie, int __far *wpa_ie_len);
/*** EndHeader */
_wifig_nodebug
__static int wpa_supplicant_set_suites(struct wpa_supplicant __far *wpa_s,
				     struct wpa_scan_result __far *bss,
				     struct wpa_ssid __far *ssid,
				     uint8 __far *wpa_ie, int __far *wpa_ie_len)
{
	auto struct wpa_ie_data ie;
	auto int sel, proto;
	auto uint8 *ap_ie;
	auto size_t ap_ie_len;

	if (bss->rsn_ie_len && (ssid->proto & WPA_PROTO_RSN)) {
		_WPA_MSG((wpa_s, MSG_DEBUG, "RSN: using IEEE 802.11i/D9.0"));
		proto = WPA_PROTO_RSN;
		ap_ie = bss->rsn_ie;
		ap_ie_len = bss->rsn_ie_len;
	} else {
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using IEEE 802.11i/D3.0"));
		proto = WPA_PROTO_WPA;
		ap_ie = bss->wpa_ie;
		ap_ie_len = bss->wpa_ie_len;
	}

	if (_wpa_s19_wpa_parse_wpa_ie_wpa(ap_ie, ap_ie_len, &ie)) {
		_WPA_MSG((wpa_s, MSG_WARNING, "WPA: Failed to parse WPA IE for the selected BSS."));
		return -1;
	}

	wpa_s->wpa->proto = proto;

	//free(wpa_s->ap_wpa_ie);
	//wpa_s->ap_wpa_ie = NULL;
	wpa_s->wpa->ap_wpa_ie_len = 0;
	if (bss->wpa_ie_len) {
		//wpa_s->ap_wpa_ie = malloc(bss->wpa_ie_len);
		//if (wpa_s->ap_wpa_ie == NULL) {
		//	_WPA_PRINTF((MSG_INFO, "WPA: malloc failed"));
		//	return -1;
		//}
		_f_memcpy(wpa_s->wpa->ap_wpa_ie, bss->wpa_ie, bss->wpa_ie_len);
		wpa_s->wpa->ap_wpa_ie_len = bss->wpa_ie_len;
	}

	//free(wpa_s->ap_rsn_ie);
	//wpa_s->ap_rsn_ie = NULL;
	wpa_s->wpa->ap_rsn_ie_len = 0;
	if (bss->rsn_ie_len) {
		//wpa_s->ap_rsn_ie = malloc(bss->rsn_ie_len);
		//if (wpa_s->ap_rsn_ie == NULL) {
		//	_WPA_PRINTF((MSG_INFO, "WPA: malloc failed"));
		//	return -1;
		//}
		_f_memcpy(wpa_s->wpa->ap_rsn_ie, bss->rsn_ie, bss->rsn_ie_len);
		wpa_s->wpa->ap_rsn_ie_len = bss->rsn_ie_len;
	}

	sel = ie.group_cipher & ssid->group_cipher;
	if (sel & CIPHER_CCMP) {
		wpa_s->group_cipher = CIPHER_CCMP;
	} else if (sel & CIPHER_TKIP) {
		wpa_s->group_cipher = CIPHER_TKIP;
	} else if (sel & CIPHER_WEP104) {
		wpa_s->group_cipher = CIPHER_WEP104;
	} else if (sel & CIPHER_WEP40) {
		wpa_s->group_cipher = CIPHER_WEP40;
	} else {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to select %s.", "group cipher"));
		return -1;
	}

	sel = ie.pairwise_cipher & ssid->pairwise_cipher;
	if (sel & CIPHER_CCMP) {
		wpa_s->pairwise_cipher = CIPHER_CCMP;
	} else if (sel & CIPHER_TKIP) {
		wpa_s->pairwise_cipher = CIPHER_TKIP;
	} else if (sel & CIPHER_NONE) {
		wpa_s->pairwise_cipher = CIPHER_NONE;
	} else {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to select %s.", "pairwise cipher"));
		return -1;
	}

	sel = ie.key_mgmt & ssid->key_mgmt;
	if (sel & KEY_MGMT_802_1X) {
		wpa_s->key_mgmt = KEY_MGMT_802_1X;
	} else if (sel & KEY_MGMT_PSK) {
		wpa_s->key_mgmt = KEY_MGMT_PSK;
	} else {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to select %s.", "authenticated key management type"));
		return -1;
	}


	/* Starting new association, so clear the possibly used WPA IE from the
	 * previous association. */
	//free(wpa_s->assoc_wpa_ie);
	//wpa_s->assoc_wpa_ie = NULL;
	wpa_s->wpa->assoc_wpa_ie_len = 0;

	*wpa_ie_len = wpa_gen_wpa_ie_wpa(wpa_s, wpa_ie);
	if (*wpa_ie_len < 0) {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to generate WPA IE."));
		return -1;
	}
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: Own WPA IE", wpa_ie, *wpa_ie_len));

	if (ssid->key_mgmt & KEY_MGMT_PSK) {
		wpa_s->wpa->pmk_len = PMK_LEN;
		_f_memcpy(wpa_s->wpa->pmk, ssid->psk, PMK_LEN);
	}
	return 0;
}

/*** BeginHeader wpa_supplicant_set_non_wpa_policy */
void wpa_supplicant_set_non_wpa_policy(struct wpa_supplicant __far *wpa_s,
					      struct wpa_ssid __far *ssid);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_set_non_wpa_policy(struct wpa_supplicant __far *wpa_s,
					      struct wpa_ssid __far *ssid)
{
	auto int i;

	if (ssid->key_mgmt & KEY_MGMT_802_1X_NO_WPA)
		wpa_s->key_mgmt = KEY_MGMT_802_1X_NO_WPA;
	else
		wpa_s->key_mgmt = KEY_MGMT_NONE;
	//free(wpa_s->ap_wpa_ie);
	//wpa_s->ap_wpa_ie = NULL;
	wpa_s->wpa->ap_wpa_ie_len = 0;
	//free(wpa_s->ap_rsn_ie);
	//wpa_s->ap_rsn_ie = NULL;
	wpa_s->wpa->ap_rsn_ie_len = 0;
	//free(wpa_s->assoc_wpa_ie);
	//wpa_s->assoc_wpa_ie = NULL;
	wpa_s->wpa->assoc_wpa_ie_len = 0;
	wpa_s->wpa->pairwise_cipher = CIPHER_NONE;
	wpa_s->wpa->group_cipher = CIPHER_NONE;

	for (i = 0; i < NUM_WEP_KEYS; i++) {
		if (ssid->wep_key_len[i] > 5) {
			wpa_s->wpa->pairwise_cipher = CIPHER_WEP104;
			wpa_s->wpa->group_cipher = CIPHER_WEP104;
			break;
		} else if (ssid->wep_key_len[i] > 0) {
			wpa_s->wpa->pairwise_cipher = CIPHER_WEP40;
			wpa_s->wpa->group_cipher = CIPHER_WEP40;
			break;
		}
	}

	//wpa_s->cur_pmksa = FALSE;
}

/*** BeginHeader wpa_supplicant_initiate_eapol */
void wpa_supplicant_initiate_eapol(struct wpa_supplicant __far *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_initiate_eapol(struct wpa_supplicant __far *wpa_s)
{
}

/*** BeginHeader wpa_supplicant_scan */
void wpa_supplicant_scan(void __far *eloop_ctx, void __far *timeout_ctx);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_scan(void __far *eloop_ctx, void __far *timeout_ctx)
{
	auto struct wpa_supplicant __far *wpa_s;
	auto struct wpa_ssid __far *ssid;
	wpa_s = eloop_ctx;
   assert(wpa_s->conf);
	if (!wpa_s->conf->ap_scan) {
      _wpa_s20_wpaS_gen_assoc_event(wpa_s);
		return;
	}

	if (wpa_s->wpa_state == WPA_DISCONNECTED)
		wpa_s->wpa_state = WPA_SCANNING;

   assert(wpa_s->conf);
	ssid = wpa_s->conf->ssid;
	if (wpa_s->prev_scan_ssid != BROADCAST_SSID_SCAN) {
		while (ssid) {
			if (ssid == wpa_s->prev_scan_ssid) {
				ssid = ssid->next;
				break;
			}
			ssid = ssid->next;
		}
	}
	while (ssid) {
		if (ssid->scan_ssid)
			break;
		ssid = ssid->next;
	}

	_WPA_PRINTF((MSG_DEBUG, "Starting AP scan (%s SSID)",
		   ssid ? "specific": "broadcast"));
	if (ssid) {
		_WPA_HEXDUMP((MSG_DEBUG, "Scan SSID", ssid->ssid, ssid->ssid_len));
		wpa_s->prev_scan_ssid = ssid;
	} else
		wpa_s->prev_scan_ssid = BROADCAST_SSID_SCAN;
}

/*** BeginHeader wpa_supplicant_gen_assoc_event */
void wpa_supplicant_gen_assoc_event(struct wpa_supplicant __far *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_gen_assoc_event(struct wpa_supplicant __far *wpa_s)
{
	auto struct wpa_ssid __far *ssid;
	auto union wpa_event_data data;

	ssid = wpa_supplicant_get_ssid(wpa_s);
	if (ssid == NULL)
		return;

	_WPA_PRINTF((MSG_DEBUG, "Already associated with a configured network - generating associated event"));
	memset(&data, 0, sizeof(data));
	wpaS_event(wpa_s, EVENT_ASSOC, &data);
}

/*** BeginHeader wpa_gen_wpa_ie_wpa */
int wpa_gen_wpa_ie_wpa(struct wpa_supplicant __far *wpa_s, uint8 __far *wpa_ie);
/*** EndHeader */
_wifig_nodebug
static int wpa_gen_wpa_ie_wpa(struct wpa_supplicant __far *wpa_s, uint8 __far *wpa_ie)
{
	uint8 *pos;
	struct wpa_ie_hdr *hdr;

	hdr = (struct wpa_ie_hdr *) wpa_ie;
	hdr->elem_id = GENERIC_INFO_ELEM;
	memcpy(&hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
	*(word *) hdr->version = WPA_VERSION;
	pos = (uint8 *) (hdr + 1);

	if (wpa_s->group_cipher == CIPHER_CCMP) {
		memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == CIPHER_TKIP) {
		memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == CIPHER_WEP104) {
		memcpy(pos, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == CIPHER_WEP40) {
		memcpy(pos, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN);
	} else {
		_WPA_PRINTF((MSG_WARNING, "Invalid %s (%d).", "group cipher",
			   wpa_s->group_cipher));
		return -1;
	}
	pos += WPA_SELECTOR_LEN;

	*pos++ = 1;
	*pos++ = 0;
	if (wpa_s->pairwise_cipher == CIPHER_CCMP) {
		memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
	} else if (wpa_s->pairwise_cipher == CIPHER_TKIP) {
		memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
	} else if (wpa_s->pairwise_cipher == CIPHER_NONE) {
		memcpy(pos, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN);
	} else {
		_WPA_PRINTF((MSG_WARNING, "Invalid %s (%d).", "pairwise cipher",
			   wpa_s->pairwise_cipher));
		return -1;
	}
	pos += WPA_SELECTOR_LEN;

	*pos++ = 1;
	*pos++ = 0;
	if (wpa_s->key_mgmt == KEY_MGMT_802_1X) {
		memcpy(pos, WPA_AUTH_KEY_MGMT_UNSPEC_802_1X, WPA_SELECTOR_LEN);
	} else if (wpa_s->key_mgmt == KEY_MGMT_PSK) {
		memcpy(pos, WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X,
		       WPA_SELECTOR_LEN);
	} else {
		_WPA_PRINTF((MSG_WARNING, "Invalid %s (%d).", "key management type",
			   wpa_s->key_mgmt));
		return -1;
	}
	pos += WPA_SELECTOR_LEN;

	/* WPA Capabilities; use defaults, so no need to include it */

	hdr->len = (pos - wpa_ie) - 2;

	return pos - wpa_ie;
}

/*** BeginHeader wpa_supplicant_get_ssid */
struct wpa_ssid __far * wpa_supplicant_get_ssid(struct wpa_supplicant __far *wpa_s);
/*** EndHeader */
_wifig_nodebug
struct wpa_ssid __far * wpa_supplicant_get_ssid(struct wpa_supplicant __far *wpa_s)
{
	struct wpa_ssid __far *entry;
	uint8 ssid[MAX_SSID_LEN];
	int ssid_len;
	uint8 bssid[ETH_ALEN];

	ssid_len = wpa_driver_wln_get_ssid(XXX_priv, ssid);
	if (ssid_len < 0) {
		_WPA_PRINTF((MSG_WARNING, "Could not read %s from driver.", "SSID"));
		return NULL;
	}

	if (wpa_driver_wln_get_bssid(XXX_priv, bssid) < 0) {
		_WPA_PRINTF((MSG_WARNING, "Could not read %s from driver.", "BSSID"));
		return NULL;
	}

	entry = wpa_s->conf->ssid;
	while (entry) {
		if (ssid_len == entry->ssid_len &&
		    memcmp(ssid, entry->ssid, ssid_len) == 0 &&
		    (!entry->bssid_set ||
		     memcmp(bssid, entry->bssid, ETH_ALEN) == 0))
			return entry;
		entry = entry->next;
	}

	return NULL;
}

/*** BeginHeader wpa_supplicant_driver_init */
int wpa_supplicant_driver_init(struct wpa_supplicant __far *wpa_s,
				      int wait_for_interface);
/*** EndHeader */
_wifig_nodebug
__static int wpa_supplicant_driver_init(struct wpa_supplicant __far *wpa_s,
				      int wait_for_interface)
{
   // Clear the wpa_s structure
   _f_memset(&_wifi_wpa_global, 0, sizeof(_wifi_wpa_global));
   _f_memset(&_wifi_wpa_interface, 0, sizeof(_wifi_wpa_interface));
   wpaS_add_iface(&_wifi_wpa_global, &_wifi_wpa_interface);
	wpa_clear_keys(wpa_s, NULL);

	wpa_s->prev_scan_ssid = BROADCAST_SSID_SCAN;
   wpaS_req_scan(wpa_s, 3, 0);

	return 0;
}

/*** BeginHeader wpa_supplicant_cleanup */
void wpa_supplicant_cleanup(struct wpa_supplicant __far *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_cleanup(struct wpa_supplicant __far *wpa_s)
{
   wpaS_remove_iface(&_wifi_wpa_global, wpa_s);
	eapol_sm_deinit(wpa_s->eapol);
	wpa_s->eapol = NULL;
}

/*** BeginHeader os_sleep */
void os_sleep(os_time_t sec, os_time_t usec);
/*** EndHeader */
_wifig_nodebug
void os_sleep(os_time_t sec, os_time_t usec)
{
   os_time_t msec;
#ifndef DONT_WARN_OS_SLEEP
   _WPA_PRINTF((MSG_WARNING, "!!!!!!! Using os_sleep() !!!!!!!!!"));
#endif
   msec = 0;
	if (sec)
      msec += sec * 1000;
	if (usec)
      msec += usec / 1024 + 1;
   msec += MS_TIMER;
   while (MS_TIMER - msec < 0);
}

/*** BeginHeader os_get_random */
int os_get_random(unsigned char __far *buf, size_t len);
/*** EndHeader */
_wifig_nodebug
int os_get_random(unsigned char __far *buf, size_t len)
{
   int i;
   unsigned long r;

   for (i = 0; i < len; i += 4) {
      r = seed_getbits(32);   // Get 32 random bits
      _f_memcpy(buf + i, &r, len - i >= 4 ? 4 : len - i);
   }

	return 0;   // Always succeeds.
}

/*** BeginHeader wpa_clear_keys */
void wpa_clear_keys(struct wpa_supplicant __far *wpa_s, uint8 __far *addr);
/*** EndHeader */
_wifig_nodebug
__static void wpa_clear_keys(struct wpa_supplicant __far *wpa_s, uint8 __far *addr)
{
	auto word i;

	for (i = 0; i < 4; ++i) {
	   wpa_driver_wln_set_key(XXX_priv, WPA_ALG_NONE,
	                "\xff\xff\xff\xff\xff\xff", i, 0, NULL,
	                0, NULL, 0);
	}
	if (addr) {
		wpa_driver_wln_set_key(XXX_priv, WPA_ALG_NONE, addr,
				       0, 0, NULL, 0, NULL, 0);
	}
}

/*** BeginHeader wpa_driver_init */
void __far *wpa_driver_init(void __far * ctx, char __far * ifname);
/*** EndHeader */
_wifig_nodebug
void __far *wpa_driver_init(void __far * ctx, char __far * ifname) {
// Returning &_wifi_macParams as the driver data.  This is okay, as long as no
// one makes assumptions about content.
   _WPA_PRINTF((MSG_INFO, "wpa_driver_init()"));
   return (void __far *) &_wifi_macParams;
}

/*** BeginHeader wpa_driver_send_eapol */
int wpa_driver_send_eapol(void __far * priv, char __far * dest, word proto, char __far * data, size_t data_len);
/*** EndHeader */
_wifig_nodebug
int wpa_driver_send_eapol(void __far * priv, char __far * dest, word proto, char __far * data, size_t data_len) {
   ll_Gather g;
   char buf[14];

	memset(&g, 0, sizeof(g));
   _f_memcpy(buf, dest, ETH_ALEN);
   memcpy(buf+ETH_ALEN, _wifig_conf[0].hwa, ETH_ALEN);
   *(int *) (buf+ETH_ALEN*2) = intel16(proto);
	g.iface = IF_WIFI0;
	g.len1 = sizeof(buf);
	g.data1 = (char __far *)paddr(buf);
	g.len2 = data_len;
   if ((0xFFFF0000 & (long)data) == 0xFFFF0000) {
      _WPA_PRINTF((MSG_WARNING, "wpa_driver_send_eapol: data has upcast logical address."));
   }
	g.data2 = data;
	return wifig_sendpacket(_wifig_conf, &g);

}

/*** BeginHeader wpa_driver_wln_get_mac_addr ***/
char __far * wpa_driver_wln_get_mac_addr( void __far * priv );
/*** EndHeader ***/
_wifig_nodebug
char __far * wpa_driver_wln_get_mac_addr( void __far * priv ) {
   return (char __far *) _wifi_macParams.sta_addr;
}

/*** BeginHeader _wifi_wpa_global, _wifi_wpa_interface */
extern __far struct wpa_global _wifi_wpa_global;
extern __far struct wpa_interface _wifi_wpa_interface;
/*** EndHeader */
__far struct wpa_global _wifi_wpa_global;
__far struct wpa_interface _wifi_wpa_interface;

/*** BeginHeader _wpa_printf, _wpa_debug_level, __wpa_msg */
void _wpa_printf(int level, char __far *fmt, ...);
extern int _wpa_debug_level;
void __wpa_msg(void __far *ctx, int level, char __far *fmt, ...);
enum { MSG_NONE = (MSG_ERROR+1) };
#ifdef WPA_VERBOSE
   #ifdef _WPA_MSG
      #undef _WPA_MSG
   #endif
   #define _WPA_MSG(x) __wpa_msg x
#endif
/*** EndHeader */
int _wpa_debug_level;
__nodebug
void _wpa_printf(int level, char __far *fmt, ...) {
   #GLOBAL_INIT { _wpa_debug_level =
#ifdef WPA_VERBOSE
   #if WPA_VERBOSE + 0 == 0
      // WPA_VERBOSE is 0, or blank
      0
   #else
      WPA_VERBOSE
   #endif
#else
      MSG_NONE
#endif
   ; }
   if (level < _wpa_debug_level) return;
   printf(">>> %d: ", level);
   vprintf(fmt, ((char *)&fmt + sizeof(fmt)));
   printf("\n");
}

__debug
void __wpa_msg(void __far *ctx, int level, char __far *fmt, ...) {
   if (level < _wpa_debug_level) return;
   printf(">>> %d: ", level);
   vprintf(fmt, ((char *)&fmt + sizeof(fmt)));
   printf("\n");
}

/*** BeginHeader _wpa_hexdump */
void _wpa_hexdump(int level, char __far *msg, char __far *data, size_t len);
/*** EndHeader */
__nodebug
void _wpa_hexdump(int level, char __far *msg, char __far *data, size_t len) {
   if (level < _wpa_debug_level) return;
   printf("WPA %d: %ls\n", level, msg);

	// This standard Rabbit function is in stdio.lib
	mem_dump(data, len);
}


/*** BeginHeader wpa_supplicant_drivers */
extern const struct wpa_driver_ops __far * const wpa_supplicant_drivers[]; 	// From "wpa_supplicant.c":107
/*** EndHeader */
const __far struct wpa_driver_ops _wifi_wpa_driver_ops = {
    //"Rabbit Driver", // char far * name;
    //"Driver for the RCM4400W, Rabbit5000, and Rabbit6000 based core modules", //char far * desc;
    "", "",		// Remove unneeded strings
    &wpa_driver_wln_get_bssid, //int (FUNCPTR get_bssid)( /* void far * priv, char far * bssid */ );
    &wpa_driver_wln_get_ssid, //int (FUNCPTR get_ssid)( /* void far * priv, char far * ssid */ );
    NULL, //int (FUNCPTR set_wpa)( /* void far * priv, int enabled */ );
    &wpa_driver_wln_set_key,//int (FUNCPTR set_key)( /* void far * priv, wpa_alg alg, char far * addr, int key_idx, int set_tx, char far * seq, size_t seq_len, char far * key, size_t key_len */ );
    &wpa_driver_init,//void far * (FUNCPTR init)( /* void far * ctx, char far * ifname */ );
    NULL,//void (FUNCPTR deinit)( /* void far * priv */ );
    NULL,// not &wpa_set_params,//int (FUNCPTR set_param)( /* void far * priv, char far * param */ );
    NULL,//int (FUNCPTR set_countermeasures)( /* void far * priv, int enabled */ );
    NULL,//int (FUNCPTR set_drop_unencrypted)( /* void far * priv, int enabled */ );
    &wpa_supplicant_req_scan,//int (FUNCPTR scan)( /* void far * priv, char far * ssid, size_t ssid_len */ );
    &wpa_driver_wln_get_scan_results,//int (FUNCPTR get_scan_results)( /* void far * priv, struct wpa_scan_result far * results, size_t max_size */ );
    &wpa_supplicant_deauthenticate,//int (FUNCPTR deauthenticate)( /* void far * priv, char far * addr, int reason_code */ );
    &wpa_driver_wln_disassociate,//int (FUNCPTR disassociate)( /* void far * priv, char far * addr, int reason_code */ );
    &__wpa_supplicant_associate,//int (FUNCPTR associate)( /* void far * priv, struct wpa_driver_associate_params far * params */ );
    NULL,//int (FUNCPTR set_auth_alg)( /* void far * priv, int auth_alg */ );
    NULL,//int (FUNCPTR add_pmkid)( /* void far * priv, char far * bssid, char far * pmkid */ );
    NULL,//int (FUNCPTR remove_pmkid)( /* void far * priv, char far * bssid, char far * pmkid */ );
    NULL,//int (FUNCPTR flush_pmkid)( /* void far * priv */ );
    NULL,//int (FUNCPTR get_capa)( /* void far * priv, struct wpa_driver_capa far * capa */ );
    NULL,//void (FUNCPTR poll)( /* void far * priv */ );
    NULL,//char far * (FUNCPTR get_ifname)( /* void far * priv */ );
    &wpa_driver_wln_get_mac_addr,//char far * (FUNCPTR get_mac_addr)( /* void far * priv */ );
    wpa_driver_send_eapol,//int (FUNCPTR send_eapol)( /* void far * priv, char far * dest, word proto, char far * data, size_t data_len */ );
    NULL,//int (FUNCPTR set_operstate)( /* void far * priv, int state */ );
    NULL,//int (FUNCPTR mlme_setprotection)( /* void far * priv, char far * addr, int protect_type, int key_type */ );
    NULL,//struct wpa_hw_modes far * (FUNCPTR get_hw_feature_data)( /* void far * priv, word far * num_modes, word far * flags */ );
    NULL,//int (FUNCPTR set_channel)( /* void far * priv, wpa_hw_mode phymode, int chan, int freq */ );
    NULL,//int (FUNCPTR set_ssid)( /* void far * priv, char far * ssid, size_t ssid_len */ );
    NULL,//int (FUNCPTR set_bssid)( /* void far * priv, char far * bssid */ );
    NULL,//int (FUNCPTR send_mlme)( /* void far * priv, char far * data, size_t data_len */ );
    NULL,//int (FUNCPTR mlme_add_sta)( /* void far * priv, char far * addr, char far * supp_rates, size_t supp_rates_len */ );
    NULL,//int (FUNCPTR mlme_remove_sta)( /* void far * priv, char far * addr */ );
};

const struct wpa_driver_ops __far * const wpa_supplicant_drivers[] = {
    &_wifi_wpa_driver_ops,
    NULL,
};

/*** BeginHeader */
#endif//ndef __WIFI_DRIVER_LIB
/*** EndHeader */