/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
	Embedded 802.11 wireless network interface
	WiFi library API
*/

/*** BeginHeader */
#ifndef _WIFI_WLN_API_LIB
#define _WIFI_WLN_API_LIB


// Overridable default beacon filtering intervals
// Allowable values are
//  0x80: 8.39s
//  0xC0: 4.20s
//  0xE0: 2.10s
//  0xF0: 1.05s
//  0xF8: 524ms
//  0xFC: 262ms
//  0xFE: 131ms
//  0xFF or 0x00: 102.4ms
#ifndef _NCBFR_NOT_ASSOC
	// Interval when not associated
	#define _NCBFR_NOT_ASSOC		0xFC
#endif
#ifndef _NCBFR_ASSOC_SESSILE
	// Interval when associated, but not in roaming mode
	#define _NCBFR_ASSOC_SESSILE	0x80
#endif
#ifndef _NCBFR_ASSOC_ROAMING
	// Interval when associated, and in roaming mode
	#define _NCBFR_ASSOC_ROAMING	0xFC
#endif
/*** EndHeader */

/*** BeginHeader _wifi_country_info, _wifi_region_current */
/*
 * Boolean type. This type is used for variables that can only be either TRUE or FALSE.
 *
 * @since 6.0
 * @external
 * @category wireless
 *
 */
typedef int BOOL;

/*ad*
 * The following are parameter size definitions for the wireless driver.
 *
 * @name WirelessParam "Wireless parameter sizes"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_ADDR_SIZE			MAC address size
 * @param WLN_SSID_SIZE			SSID max size
 * @param WLN_WPAIE_SIZE		WPA info element size
 * @param WLN_KEY_NUM			Number of keys (0-3)
 * @param WLN_WEP40_SIZE		WEP-40 key size
 * @param WLN_WEP104_SIZE		WEP-104 key size
 * @param WLN_PSK_SIZE			WPA pre-shared key size
 * @param WLN_IDENT_SIZE		User identity size
 * @param WLN_SUBJECT_SIZE		Certificate subject matching string size
 * @param WLN_PWD_SIZE			User password size
 * @param WLN_PHASE_SIZE		Phase1/2 string lengths for EAP
*ad*/
#define	WLN_ADDR_SIZE			6
#define	WLN_SSID_SIZE			32
#define	WLN_WPAIE_SIZE			40
#define	WLN_KEY_NUM				4
#define	WLN_WEP40_SIZE			5
#define	WLN_WEP104_SIZE		13
#define	WLN_PSK_SIZE			32
#define	WLN_IDENT_SIZE			32
#define	WLN_SUBJECT_SIZE		48
#define	WLN_PWD_SIZE			32
#define 	WLN_COUNTRY_STRLEN  	3
#define	WLN_PHASE_SIZE			24

/*ad*
 * Wireless channel number values.
 *
 * @name WirelessChanNum "Channel number values"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_CHAN_NUM			Number of channels (1-13)
 * @param WLN_CHAN_SCAN			Scan all channels
 * @param WLN_CHANMASK_ALL		Mask of all channels
*ad*/
#ifdef _WIFI_BONLY
	// 802.11b/g hardware can only go up to channel 13
	#define  WLN_CHAN_NUM         13
	#define  WLN_CHAN_SCAN        0
	#define  WLN_CHANMASK_ALL     0x001fffff
#else
	#define  WLN_CHAN_NUM         13
	#define  WLN_CHAN_SCAN        0
	#define  WLN_CHANMASK_ALL     0x001fffff
#endif

/*ad*
 * Wireless band number values.
 *
 * @name WirelessBandNum "Band number values"
 *
 * @since 6.1
 * @category wireless
 * @see @link wln_params
 *
 * @param WLN_BAND_DEFAULT      Use Default hardware behavior (usually search all bands)
 * @param WLN_BAND_A            Use 802.11a (5 GHz)
 * @param WLN_BAND_B            Use 802.11bg (2.4 Ghz)
 * @param WLN_BAND_MAX          add any bands before this
*ad*/
#define WLN_BAND_DEFAULT 0
#define WLN_BAND_A       1
#define WLN_BAND_B       2
#define WLN_BAND_MAX     3

/*ad*
 * Authentication parameter values.
 * Any combination of these values may be specified to indicate which
 * authentication methods are allowed.  The actual method used will be selected
 * based on the capabilities of the wireless network being joined.
 *
 * @name WirelessAuthenParam "Authentication parameter values."
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_AUTH_ANY			Any available authentication method
 * @param WLN_AUTH_OPEN			Open system
 * @param WLN_AUTH_SHAREDKEY	Shared Key
 * @param WLN_AUTH_WEP_8021X	WEP with 802.1x authentication
 * @param WLN_AUTH_WPA_PSK		WPA with pre-shared key
 * @param WLN_AUTH_WPA_8021X	WPA with 802.1x authentication
 * @param WLN_AUTH_LEAP			Cisco LEAP
 *
 * @note	WEP keys parameters must be set if WLN_AUTH_SHAREDKEY is used.
 *          wpa_psk parameter must be set if WLN_AUTH_WPA_PSK is used.
 *          identity and password parameters must be set if WLN_AUTH_WEP_8021X
 *			or WLN_AUTH_WPA_8021X is used.
*ad*/
#define	WLN_AUTH_ANY			0xffffffff
#define	WLN_AUTH_OPEN			0x00000001
#define	WLN_AUTH_SHAREDKEY	0x00000002
#define	WLN_AUTH_WEP_8021X	0x00000004
#define	WLN_AUTH_WPA_PSK		0x00000008
#define	WLN_AUTH_WPA_8021X	0x00000010
#define	WLN_AUTH_LEAP			0x00000020

/*ad*
 * Encryption parameter values.
 * Any combination of these values may be specified to indicate which
 * encryption methods are allowed.  The actual method used will be selected
 * based on the capabilities of the wireless network being joined.
 * This parameter only applies when WPA is being used.
 *
 * @name EncryptValues "Encryption parameter values."
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_ENCR_ANY			Any available encryption method
 * @param WLN_ENCR_OPEN			Open system (no encryption)
 * @param WLN_ENCR_WEP			WEP
 * @param WLN_ENCR_TKIP			TKIP
 * @param WLN_ENCR_CCMP			CCMP (AES)
 *
 * @note	WEP keys parameters must be set if WLN_ENCR_WEP is used
 *			without 802.1x authentication.
*ad*/
#define	WLN_ENCR_ANY			0xffffffff
#define	WLN_ENCR_OPEN			0x00000001
#define	WLN_ENCR_WEP			0x00000002
#define	WLN_ENCR_TKIP			0x00000004
#define	WLN_ENCR_CCMP			0x00000008

/*ad*
 * EAP authentication method parameter values.
 * Any combination of these values may be specified to indicate which
 * authentication methods are allowed.  The actual method used will be selected
 * based on the capabilities of the wireless network being joined.
 * This parameter only applies when WPA with 802.1x authenticaion is being used.
 *
 * @name EAPValues "EAP authentication parameter values."
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_EAP_ANY				Any available authentication method
 * @param WLN_EAP_INNER_ANY		Any available inner authentication method
 * @param WLN_EAP_LEAP				Cicso LEAP
 * @param WLN_EAP_PEAP				Protected EAP
 * @param WLN_EAP_TLS				TLS (requires client certificate)
 * @param WLN_EAP_TTLS				Tunnelled TLS
 * @param WLN_EAP_GTC				PEAP/TTLS inner protocol: Generic token card
 * @param WLN_EAP_MD5				PEAP/TTLS inner protocol: MD5
 * @param WLN_EAP_MSCHAPV2			PEAP/TTLS inner protocol: MSCHAP version 2
 * @param WLN_EAP_OTP				PEAP/TTLS inner protocol: One time password
 * @param WLN_EAP_TTLS_CHAP		TTLS inner protocol: Challenge handshake
 * @param WLN_EAP_TTLS_MSCHAP		TTLS inner protocol: Microsoft CHAP
 * @param WLN_EAP_TTLS_MSCHAPV2	TTLS inner protocol: Microsoft CHAP version 2
 * @param WLN_EAP_TTLS_PAP			TTLS inner protocol: Password
 *
 * @note	One or more of WLN_EAP_GTC, WLN_EAP_MD5, WLN_EAP_MSCHAPV2,
 *			WLN_EAP_OTP, and WLN_EAP_TLS may be combined with WLN_EAP_PEAP
 *			or WLN_EAP_TTLS to specify the inner protocols to allow.
 *			One or more of WLN_EAP_TTLS_xxx may also be combined with
 *			WLN_EAP_TTLS.
*ad*/
#define	WLN_EAP_ANY					0xffffffff
#define	WLN_EAP_INNER_ANY			0xffffff00
// The WPA_USE_EAP... macros are defined in tcp_config.lib.
#define	WLN_EAP_LEAP				WPA_USE_EAP_LEAP
#define	WLN_EAP_PEAP				WPA_USE_EAP_PEAP
#define	WLN_EAP_TLS					WPA_USE_EAP_TLS
#define	WLN_EAP_TTLS				WPA_USE_EAP_TTLS
#define	WLN_EAP_GTC					WPA_USE_EAP_GTC
#define	WLN_EAP_MD5					WPA_USE_EAP_MD5
#define	WLN_EAP_MSCHAPV2			WPA_USE_EAP_MSCHAPV2
#define	WLN_EAP_OTP					WPA_USE_EAP_OTP
#define	WLN_EAP_TTLS_CHAP			WPA_USE_EAP_TTLS_CHAP
#define	WLN_EAP_TTLS_MSCHAP		WPA_USE_EAP_TTLS_MSCHAP
#define	WLN_EAP_TTLS_MSCHAPV2	WPA_USE_EAP_TTLS_MSCHAPV2
#define	WLN_EAP_TTLS_PAP			WPA_USE_EAP_TTLS_PAP


/*ad*
 * Option parameter values.
 *
 * @name WirelessOptionValues "Wireless option parameter values"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_OPT_ANTDIV		Enable antenna diversity
 * @param WLN_OPT_SHORTPRE		Enable short preamble
 * @param WLN_OPT_VERIFYCERT	Enable server certificate verification
 * @param WLN_OPT_BONLY			Use only 802.11b rates in 2.4 GHz band
 * @param WLN_OPT_RTSPROT		Use RTS/CTS protection frames for 802.11g
 * @param WLN_OPT_FIXEDRATE	Use fixed transmit rate
*ad*/
#define	WLN_OPT_ANTDIV				0x00000001
#define	WLN_OPT_SHORTPRE			0x00000002
#define	WLN_OPT_VERIFYCERT		0x00000004
#define	WLN_OPT_BONLY				0x00000008
#define	WLN_OPT_RTSPROT			0x00000010
#define	WLN_OPT_FIXEDRATE			0x00000020
#define	WLN_OPT_MULTI_DOMAIN		0x00000040

/*ad*
 * Power saving mode parameter values.
 * A range of 0 to 5 is allowed.
 *
 * @name PowerModeParam "Power mode parameter"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_PWR_MAX			Max power use (always on)
 * @param WLN_PWR_MIN			Min power use
*ad*/
#define	WLN_PWR_MAX				0
#define	WLN_PWR_MIN				5

/*ad*
 * Transmit power parameter values.
 * A range of 0 to 15 is allowed.
 *
 * @name TxPowerParam "Transmit power parameter"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_TXPOWER_MAX		Max transmit power
 * @param WLN_TXPOWER_DEFAULT	Default transmit power
 * @param WLN_TXPOWER_MIN		Min transmit power
*ad*/
#define WLN_TXPOWER_MAX         15
#define WLN_TXPOWER_DEFAULT     8
#define WLN_TXPOWER_MIN         0

/*ad*
 * Capability field values.
 *
 * @name WirelessCapValues "Wireless capability field values"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_status
 *
 * @param WLN_CAP_ESS			Extended service set (infrastructure)
 * @param WLN_CAP_IBSS			Independent BSS (ad hoc)
 * @param WLN_CAP_POLLABLE		Contention free pollable
 * @param WLN_CAP_POLLREQ		Contention free poll request
 * @param WLN_CAP_PRIVACY		Privacy (WEP) required
 * @param WLN_CAP_SHORTPRE		Short preambles allowed
 * @param WLN_CAP_PBCC			PBCC modulation allowed
 * @param WLN_CAP_AGILITY		Channel agility in use
*ad*/
#define	WLN_CAP_ESS				0x0001
#define	WLN_CAP_IBSS			0x0002
#define	WLN_CAP_POLLABLE		0x0004
#define	WLN_CAP_POLLREQ		0x0008
#define	WLN_CAP_PRIVACY		0x0010
#define	WLN_CAP_SHORTPRE		0x0020
#define	WLN_CAP_PBCC			0x0040
#define	WLN_CAP_AGILITY		0x0080

/*ad*
 * Rate field values.
 *
 * @name WirelessRateValues "Wireless rate field values"
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link _wifi_wln_scan_bss
 *
 * @param WLN_RATE_1_MBPS		1 mbps
 * @param WLN_RATE_2_MBPS		2 mbps
 * @param WLN_RATE_5_5_MBPS	5.5 mbps
 * @param WLN_RATE_11_MBPS		11 mbps
 * @param WLN_RATE_6_MBPS		6 mbps
 * @param WLN_RATE_9_MBPS		9 mbps
 * @param WLN_RATE_12_MBPS		12 mbps
 * @param WLN_RATE_18_MBPS		18 mbps
 * @param WLN_RATE_24_MBPS		24 mbps
 * @param WLN_RATE_36_MBPS		36 mbps
 * @param WLN_RATE_48_MBPS		48 mbps
 * @param WLN_RATE_54_MBPS		54 mbps
*ad*/
#define	WLN_RATE_1_MBPS		0x0001
#define	WLN_RATE_2_MBPS		0x0002
#define	WLN_RATE_5_5_MBPS		0x0004
#define	WLN_RATE_11_MBPS		0x0008
#define	WLN_RATE_6_MBPS		0x0010
#define	WLN_RATE_9_MBPS		0x0020
#define	WLN_RATE_12_MBPS		0x0040
#define	WLN_RATE_18_MBPS		0x0080
#define	WLN_RATE_24_MBPS		0x0100
#define	WLN_RATE_36_MBPS		0x0200
#define	WLN_RATE_48_MBPS		0x0400
#define	WLN_RATE_54_MBPS		0x0800

/*ad*
 * MAC address type
 *
 * @since 6.0
 * @external
 * @category wireless
 *
*ad*/
typedef uint8 mac_addr[WLN_ADDR_SIZE];

/*ad*
 * BSS (wireless network) type values
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_params
 *
 * @param WLN_BSS_ESS					Join infrastructure (access point)
 * @param WLN_BSS_IBSS					Join or create independent (ad hoc)
 * @param WLN_BSS_IB_WIFI_SS_JOIN	Join only independent (ad hoc)
 * @param WLN_BSS_ANY					Join any type
 * @param WLN_BSS_NONE					Do not join a BSS
*ad*/
typedef enum {
	WLN_BSS_ESS,
	WLN_BSS_IBSS,
	WLN_BSS_IB_WIFI_SS_JOIN,
	WLN_BSS_ANY,
	WLN_BSS_NONE = 8	// This is ORed with above states to halt, while
							// being able to remember the normally desired value
} wln_bss;

/*ad*
 * Association state values
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_status
 *
 * @param WLN_ST_STOPPED		Driver not running
 * @param WLN_ST_SCANNING		Scanning for BSS
 * @param WLN_ST_ASSOC_ESS		Associated with ESS
 * @param WLN_ST_AUTH_ESS		Authenticated with ESS (using dynamic keys)
 * @param WLN_ST_JOIN_IBSS		Joined ad hoc IBSS
 * @param WLN_ST_START_IBSS	Started ad hoc IBSS
*ad*/
typedef enum {
	WLN_ST_STOPPED,
	WLN_ST_SCANNING,
	WLN_ST_ASSOC_ESS,
	WLN_ST_AUTH_ESS,
	WLN_ST_JOIN_IBSS,
	WLN_ST_START_IBSS
} wln_state;

/*ad*
 * Event types
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_event_cb
 *
 * @param WLN_EVT_ASSOC				Associated with BSS
 * @param WLN_EVT_LINKUP			Layer 2 link complete; layer 3 available
 * @param WLN_EVT_DISASSOC			Disassociated from BSS
 * @param WLN_EVT_MIC_FAIL			MIC failure
 * @param WLN_EVT_JOIN				Joined a BSS
 * @param WLN_EVT_SCAN_RESULTS	BSS scan results
 *
 * @note	Parameter associated with each event:
 *
 * WLN_EVT_ASSOC			BSS ID
 * WLN_EVT_LINKUP			BSS ID
 * WLN_EVT_DISASSOC		BSS ID
 * WLN_EVT_MIC_FAIL		pointer to BOOL, TRUE if pairwise key
 * WLN_EVT_JOIN			BSS ID
 * WLN_EVT_SCAN_RESULTS	pointer to _wifi_wln_scan_data
 *
 * After receiving a WLN_EVT_JOIN event, the application
 * should call _wifi_wln_associate() to associate with the BSS,
 * or _wifi_wln_disassociate() to reject it.  If WPA is enabled,
 * this is done by the WPA application.
*ad*/
typedef enum {
	WLN_EVT_ASSOC,
	WLN_EVT_LINKUP,
	WLN_EVT_DISASSOC,
	WLN_EVT_MIC_FAIL,
	WLN_EVT_JOIN,
	WLN_EVT_SCAN_RESULTS
} wln_event;

/*ad*
 * Key type values
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_set_key
 *
 * @param WLN_KEY_NONE			Delete current key
 * @param WLN_KEY_WEP			WEP
 * @param WLN_KEY_TKIP			TKIP
 * @param WLN_KEY_CCMP			CCMP (AES)
*ad*/
typedef enum {
	WLN_KEY_NONE,
	WLN_KEY_WEP,
	WLN_KEY_TKIP,
	WLN_KEY_CCMP
} wln_key_type;

/*ad*
 * Error codes
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_set_params
 *
 * @param WLN_SUCCESS			Successful
 * @param WLN_ERR_NULL			NULL parameter pointer
 * @param WLN_ERR_BSSTYPE		Bad BSS type value
 * @param WLN_ERR_SSID			Bad SSID value
 * @param WLN_ERR_CHANNEL		Bad channel number
 * @param WLN_ERR_STAADDR		Bad station MAC address
 * @param WLN_ERR_AUTH			Unsupported authentication type
 * @param WLN_ERR_ENCR			Unsupported encryption type
 * @param WLN_ERR_WEPID			Bad WEP key index
 * @param WLN_ERR_WEPKEY		Bad WEP key size
 * @param WLN_ERR_POWER			Bad power management value
 * @param WLN_ERR_TXPOWER		Bad transmit power value
*ad*/
typedef enum {
	WLN_SUCCESS			= 0,
	WLN_ERR_NULL		= -1,
	WLN_ERR_BSSTYPE	= -2,
	WLN_ERR_SSID		= -3,
	WLN_ERR_CHANNEL	= -4,
	WLN_ERR_STAADDR	= -5,
	WLN_ERR_AUTH		= -6,
	WLN_ERR_ENCR		= -7,
	WLN_ERR_WEPID		= -8,
	WLN_ERR_WEPKEY		= -9,
	WLN_ERR_POWER		= -10,
	WLN_ERR_TXPOWER	= -11
} wln_error;

/*
 * Wireless parameters structure.
 * Used by both wireless driver and WPA application.
 *
 */
typedef struct {		// wln_params (static instance is _wifi_macParams)
	wln_bss		bss_type;					// Network type: one of WLN_BSS_xxx
	uint8			ssid[WLN_SSID_SIZE];		// Service set ID
	int			ssid_len;					// SSID length in bytes
	int			channel;						// Channel: 1-WLN_CHAN_NUM
	mac_addr		sta_addr;					// Station MAC address
	uint32		authen;						// Authentication types allowed: one or more of WLN_AUTH_xxx
	uint32		encrypt;						// Encryption types allowed: one or more of WLN_ENCR_xxx
	int			wep_key_id;					// WEP key index: 0-3
	int			wep_key_len[WLN_KEY_NUM];	// WEP key lengths: array of 0, 5, or 13
	uint8			wep_key[WLN_KEY_NUM][WLN_WEP104_SIZE];	// WEP keys
	uint8			wpa_psk[WLN_PSK_SIZE];	// WPA pre-shared key
	uint32		options;						// Bitmap of options: one or more of WLN_OPT_xxx
	uint32		chan_mask;					// Bitmap of allowed channels: bit 0 is channel 1, etc.
	int			tx_rate;						// Max transmit rate (in 100 kbps), 0 to use any
	int			rts_thresh;					// RTS threshold, 0 to use default. Its range is from 0 to 2347
	int			frag_thresh;				// Fragmentation threshold, 0 to use default. The maximum value for this is 2346 bytes.
	int			power_mode;					// Desired Power management mode: 0-5.
	int         band;							// Wireless band to use (WLN_BAND_XXX)
	int         tx_power;					// Transmit power, 0-15
   int			tx_power_max;				// Transmit power maximum, 0-15
#ifdef WPA_USE_EAP
	uint16		protocol;
	uint16		pairwise_encr;
	uint16		tls_flags;					// flags passed to tls_set_flags()
	uint32		eap_methods; // 802.1x/EAP authentication methods allowed:
									 // one or more of WLN_EAP_xxx
									 // Bitmask, gets translated to list below
	struct eap_method_type * eap_methods_i;
	char			identity[WLN_IDENT_SIZE+1];	// User identity (login), ASCII NUL terminated
	char			anonymous_identity[WLN_IDENT_SIZE+1];
															// Outer user identity if inner/outer
	char			eappsk[WLN_PSK_SIZE];			// Pre-shared key for EAP
	char			password[WLN_PWD_SIZE+1];		// User password, ASCII NUL terminated
	struct SSL_Cert_t_t __far * ca_cert;			// Trusted certificate
	struct SSL_Cert_t_t __far * client_cert;		// Our certificate
	char 			subject_match[WLN_SUBJECT_SIZE];		// Validation for peer certificate
	char 			altsubject_match[WLN_SUBJECT_SIZE];	// Alternative validation
	struct SSL_Cert_t_t __far * ca_cert2;			// Parms as above, for inner method
	struct SSL_Cert_t_t __far * client_cert2;
	char 			subject_match2[WLN_SUBJECT_SIZE];
	char 			altsubject_match2[WLN_SUBJECT_SIZE];
	struct SSL_Cert_t_t __far * ca_cert_managed;	// Parms as above, when managed by Zserver
	struct SSL_Cert_t_t __far * client_cert_managed;
	struct SSL_Cert_t_t __far * ca_cert2_managed;
	struct SSL_Cert_t_t __far * client_cert2_managed;
#endif
#if CPU_ID_MASK(_CPU_ID_) >= R6000
	int			regionLock;					// unlocked: < 0, locked region ID: >= 0
#endif
} wln_params;

/*ad*
 * Wireless status information structure
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_get_status
 *
 * @param state			Associationn state: one of WLN_ST_xxx
 * @param ssid				Current service set ID
 * @param ssid_len		Service set ID length
 * @param channel			Current channel: 1-14
 * @param bss_addr		BSS ID (AP MAC address)
 * @param bss_caps		BSS capabilities, one of more of WLN_CAP_xxx
 * @param wpa_info		WPA/RSN information element
 * @param authen			Authentication used: one of WLN_AUTH_xxx
 * @param encrypt			Encryption types used: one or more of WLN_ENCR_xxx
 * @param tx_rate			Current transmit rate (in 100 kbps)
 * @param rx_rate			Last received rate (in 100 kbps)
 * @param rx_signal		Last received signal strength
 * @param country_info  holds Multi-Domain info from 802.11d access point
 * @param link				Status of Wi-Fi link
*ad*/
typedef struct {
	wln_state	state;
	uint8			ssid[WLN_SSID_SIZE];
	int			ssid_len;
	int			channel;
	mac_addr		bss_addr;
	uint16		bss_caps;
	uint8			wpa_info[WLN_WPAIE_SIZE];
	uint32		authen;
	uint32		encrypt;
	int			tx_rate;
	int			rx_rate;
	int			rx_signal;
	int			tx_power;
   uint8       country_info[WLN_COUNTRY_STRLEN];
	int			link;
} wln_status;

typedef wln_status wifi_status;

/*ad*
 * Wireless statistics structure.
 * This structure may constain additional driver-specific stats
 * following the listed items.  The wln_get_stats() function returns
 * the actual size of the available data.
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link wln_get_stats
 *
 * @param tx_bytes		Bytes transmitted
 * @param tx_frames		Directed frames transmitted
 * @param tx_bc_frames	Broadcast frames transmitted
 * @param rx_bytes		Bytes received
 * @param rx_frames		Directed frames received
 * @param rx_bc_frames	Broadcast frames received
*ad*/
typedef struct {
	int	tx_bytes;
	int	tx_frames;
	int 	tx_bc_frames;
	int	rx_bytes;
	int	rx_frames;
	int 	rx_bc_frames;
} wln_stats;

/*ad*
 * Wireless network (BSS) scan information structure.
 * This structure is part of the _wifi_wln_scan_data structure.
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link _wifi_wln_scan_data
 *
 * @param ssid				Service set ID
 * @param ssid_len		SSID length in bytes, 0 to search
 * @param channel			Channel: 1-WLN_CHAN_NUM, 0 to search
 * @param bss_addr		BSS ID (AP MAC address)
 * @param bss_caps		BSS capabilities, one of more of WLN_CAP_xxx
 * @param wpa_info		WPA/RSN information element
 * @param erp_info		802.11g extended rate PHY information
 * @param rates			Operational rates, one or more of WLN_RATE_xxx
 * @param rates_basic	Basic rates, one or more of WLN_RATE_xxx
 * @param atim				Ad hoc ATIM window size
 * @param tx_rate			Maximum transmit rate (in 100 kbps)
 * @param rx_signal		Received signal strength
*ad*/
typedef struct {
	uint8			ssid[WLN_SSID_SIZE];
	int			ssid_len;
	int			channel;
	mac_addr		bss_addr;
	uint16		bss_caps;
	uint8			wpa_info[WLN_WPAIE_SIZE];
	uint8			erp_info;
	uint16		rates;
	uint16		rates_basic;
	uint16		atim;
	int			tx_rate;
	int			rx_signal;
} _wifi_wln_scan_bss;

/*ad*
 * Wireless network (BSS) scan information structure.
 * This structure is returned with a WLN_EVT_SCAN_RESULTS event
 * after a network scan is initiated by _wifi_wln_scan().
 *
 * @since 6.0
 * @category wireless
 * @external
 * @see @link _wifi_wln_scan
 *
 * @param count			Number of networks found
 * @param bss				Array of network information
*ad*/
#ifndef _WIFI_SCAN_NUM
	#define	_WIFI_SCAN_NUM		16		// Number of scan results to allocate
#endif
typedef struct {
	int						count;
	_wifi_wln_scan_bss	bss[_WIFI_SCAN_NUM];
} _wifi_wln_scan_data;

typedef _wifi_wln_scan_data wifi_scan_data;

/*
 * Compatibility macros for Rabbit WiFi drivers
 */
//Default Config. Flags.
#define WIFI_SSID		0x0001				// SSID for desired connection
#define WIFI_MODE		0x0002				// WIFICONF_INFRASTRUCT or WIFICONF_ADHOC
#define WIFI_OWNCHAN	0x0003				// Channel for IBSS
#define WIFI_OWNSSID	0x0004				// SSID for IBSS

#define WIFI_AUTH          0x0005      // WIFICONF_AUTH_OPEN_SYS, -SHARED_KEY, -WPA_PSK or -ALL
#define WIFI_WEP_AUTH      0x0006      // same as WIFI_AUTH -- defined for backward compatibility
#define WIFI_WEP_FLAG		0x0007		// WIFICONF_WEP_ENABLE or WIFICONF_WEP_DISABLE
#define WIFI_ENCR_TYPE		0x0007		// Encryption type (same as "WIFI_WEP_FLAG", but better name since not just WEP)
#define WIFI_WEP_USEKEY    0x0008		// "1"-"4"
#define WIFI_WEP_KEY0      0x0009		// "12345678..."
#define WIFI_WEP_KEY1      (WIFI_WEP_KEY0 + 1)      // "12345678..."
#define WIFI_WEP_KEY2      (WIFI_WEP_KEY0 + 2)      // "12345678..."
#define WIFI_WEP_KEY3      (WIFI_WEP_KEY0 + 3)      // "12345678..."

#define WIFICONF_ADHOC              "IBSS" //config option for WIFI_MODE (Ad hoc mode)
#define WIFICONF_INFRASTRUCT        "BSS"  //config option for WIFI_MODE (Infrastructure mode)

#define WIFICONF_AUTH_OPEN_SYS		"1" //config option for WIFI_AUTH (connect to standard authentication AP's)
#define WIFICONF_AUTH_SHARED_KEY		"2" //config option for WIFI_AUTH (connect to shared key authentication AP's)
#define WIFICONF_AUTH_ALL     		"3" //config option for WIFI_AUTH (connect to both shared key and standard authentication AP's)
#define WIFICONF_AUTH_WPA_PSK			"4" //config option for WIFI_AUTH (WPA-PSK AP's)

#define WIFICONF_WEP_DISABLE        "0" //config option for WIFI_WEP_FLAG (no encryption)
#define WIFICONF_WEP_ENABLE			"1" //config option for WIFI_WEP_FLAG (enable shared key encryption)
#define WIFICONF_WEP_TKIP				"2" //config option for WIFI_WEP_FLAG (enable shared key encryption)
#define WIFICONF_WEP_CCMP				"4" //config option for WIFI_WEP_FLAG (enable shared key encryption)
// Renames of above...
#define WIFICONF_ENCR_DISABLE       "0" //config option for WIFI_ENCR_TYPE (no encryption)
#define WIFICONF_ENCR_WEP   			"1" //config option for WIFI_ENCR_TYPE (enable shared key encryption)
#define WIFICONF_ENCR_TKIP				"2" //config option for WIFI_ENCR_TYPE (enable shared key encryption)
#define WIFICONF_ENCR_CCMP				"4" //config option for WIFI_ENCR_TYPE (enable shared key encryption)

#define WIFI_STATUSGET		0x0013 		// read status

#define WIFI_MAC				0x0015		// enable MAC
#define WIFI_ROAM				0x0018		// roam mode

#define WIFI_TX_RATE			0x0019		// specifies data rate for message transmission

#define WIFI_SCANCB			0x0020		// set the callback function for scanning
#define WIFI_SCAN				0x0021		// start a scan
#define WIFI_FRAG_THRESH	0x0022		// Fragmentation threshhold (0-2346, 0 for default/none)
#define WIFI_RTS_THRESH		0x0023		// RTS threshhold (1-2347)
#define WIFI_TX_POWER		0x0024		// TX power (0-15)

#define WIFICONF_RATE_ANY		"0"		// Use any available rate
#define WIFICONF_RATE_1MBPS	"1"		// set WIFI_TX_RATE to 1 MB/s
#define WIFICONF_RATE_2MBPS	"2" 		// set WIFI_TX_RATE to 2 MB/s, falling back to lower if necessary.
#define WIFICONF_RATE_5_5MBPS	"5_5"   	// set WIFI_TX_RATE to 5.5 MB/s, falling back to lower if necessary.
#define WIFICONF_RATE_11MBPS	"11"  	// set WIFI_TX_RATE to 11 MB/s, falling back to lower if necessary.

#ifdef WIFI_USE_WPA
#define WIFI_WPA_PSK_HEX			0x0025	// Pre-shared key - 64 length hex string, giving 32-octed binary PSK.
													// Use 0-9 and A-F (or a-f) only.
#define WIFI_WPA_PSK_PASSPHRASE	0x0026	// Ascii pasphrase string, automatically converted to PSK using
													// the standard method (via pbkdf2_sha1 function).
#endif

#define WIFI_COUNTRY_SET	0x0027
#define WIFI_COUNTRY_GET	0x0028
#define WIFI_MULTI_DOMAIN	0x0029

// Americas, including the US (channels 1-11)
#define _AMERICAS_REGION			IFPARAM_WIFI_REGION_AMERICAS

// Mexico indoors (channels 1-11)
#define _MEXICO_REGION_INDOORS	IFPARAM_WIFI_REGION_MEXICO_INDOORS

// Mexico outdoors (channels 9-11)
#define _MEXICO_REGION_OUTDOORS	IFPARAM_WIFI_REGION_MEXICO_OUTDOORS

// Canada (channels 1-11)
#define _CANADA_REGION				IFPARAM_WIFI_REGION_CANADA

// Europe, Middle East, Africa (channels 1-13), except France
#define _EMEA_REGION					IFPARAM_WIFI_REGION_EMEA

// France (channels 10-13)
#define _FRANCE_REGION				IFPARAM_WIFI_REGION_FRANCE

// Israel (channels 3-11)
#define _ISRAEL_REGION				IFPARAM_WIFI_REGION_ISRAEL

// China (channels 1-11)
#define _CHINA_REGION				IFPARAM_WIFI_REGION_CHINA

// Japan (channels 1-13)
#define _JAPAN_REGION				IFPARAM_WIFI_REGION_JAPAN

// Australia (channels 1-11)
#define _AUSTRALIA_REGION			IFPARAM_WIFI_REGION_AUSTRALIA

#define _END_OF_REGIONS IFPARAM_WIFI_REGION_END_OF_LIST

// The following macros establish a channel mask

// Max channel range is 1-13 due to regulatory limitiations

// Allow all channels (1-14)
#ifdef _WIFI_BONLY
	#define WIFICONF_CHANMASK_ALL					0x1fff
#else
	#define WIFICONF_CHANMASK_ALL					0x3fff
#endif
// Americas, including the US, Canada and Mexico (indoors) (1-11)
#define WIFICONF_CHANMASK_AMERICAS			0x07ff
// Mexico outdoors (9-11)
#define WIFICONF_CHANMASK_MEXICO_OUTDOORS	0x0700
// Europe, Middle East, Africa (1-13), except France
#define WIFICONF_CHANMASK_EMEA				0x1fff
// France (10-13)
#define WIFICONF_CHANMASK_FRANCE				0x1e00
// Israel (3-11)
#define WIFICONF_CHANMASK_ISRAEL				0x07fc
// China (1-11)
#define WIFICONF_CHANMASK_CHINA				0x07ff
// Japan (1-13)
#define WIFICONF_CHANMASK_JAPAN				0x1fff
// Australia - basically follows US (FCC) rules
#define WIFICONF_CHANMASK_AUSTRALIA			0x07ff

typedef struct {
	char	id;						// ID (matches IFPARAM_WIFI_REGION_* values)
	char  country[16];			// description of region
	int   first_channel;       // First channel
   int   last_channel;	  		// Last channel
   unsigned int channel_mask; // Channel mask
   int   max_pwr_dBm;   		// Max power, dBm
   int   max_pwr_index;     	// Max Power index
} wifi_region;

// new name for _wifi_country is wifi_region, keep old name for legacy apps
typedef wifi_region _wifi_country;

extern wifi_region const _wifi_country_info[];
extern wifi_region const *_wifi_region_current;

/*** EndHeader */

#if RCM4400W_SERIES
// wifi country info for various regions, needs to be in the same order
// as the IFPARAM_WIFI_REGION entries in net.lib

wifi_region const _wifi_country_info[] = {
//   id, country,      minch, maxch, channel mask,             max pwr dBm, index
	{  0, "Americas",       1,  11, WIFICONF_CHANMASK_AMERICAS,				20, 14},
	{  1, "Mexico indoor",  1,  11, WIFICONF_CHANMASK_AMERICAS,				16, 12},
	{  2, "Mexico outdoor", 9,  11, WIFICONF_CHANMASK_MEXICO_OUTDOORS,	16, 12},
	{  3, "Canada",         1,  11, WIFICONF_CHANMASK_AMERICAS,				20, 14},
	{  4, "EMEA",           1,  13, WIFICONF_CHANMASK_EMEA,					16, 12},
	{  5, "France",        10,  13, WIFICONF_CHANMASK_FRANCE,				16, 12},
	{  6, "Israel",         3,  11, WIFICONF_CHANMASK_ISRAEL,				16, 12},
	{  7, "China",          1,  11, WIFICONF_CHANMASK_CHINA,					16, 12},
	{  8, "Japan",          1,  13, WIFICONF_CHANMASK_JAPAN,				   14, 10},
	{  9, "Australia",      1,  11, WIFICONF_CHANMASK_AUSTRALIA,			16, 12},
};

#elif RCM5400W_SERIES || (_BOARD_TYPE_ == R6000TESTW) || RCM6600W_SERIES
// wifi country info for various regions, needs to be in the same order
// as the IFPARAM_WIFI_REGION entries in net.lib

wifi_region const _wifi_country_info[] = {
//   id, country,      minch, maxch, channel mask,             max pwr dBm, index
	{  0, "Americas",       1,  11, WIFICONF_CHANMASK_AMERICAS,				20, 15},
	{  1, "Mexico indoor",  1,  11, WIFICONF_CHANMASK_AMERICAS,				16, 14},
	{  2, "Mexico outdoor", 9,  11, WIFICONF_CHANMASK_MEXICO_OUTDOORS,	20, 15},
	{  3, "Canada",         1,  11, WIFICONF_CHANMASK_AMERICAS,				20, 15},
	{  4, "EMEA",           1,  13, WIFICONF_CHANMASK_EMEA,					16, 14},
	{  5, "France",        10,  13, WIFICONF_CHANMASK_FRANCE,				16, 14},
	{  6, "Israel",         3,  11, WIFICONF_CHANMASK_ISRAEL,				16, 14},
	{  7, "China",          1,  11, WIFICONF_CHANMASK_CHINA,					16, 14},
	{  8, "Japan",          1,  13, WIFICONF_CHANMASK_JAPAN,				   20, 15},
	{  9, "Australia",      1,  11, WIFICONF_CHANMASK_AUSTRALIA,			16, 14},
};

#elif RCM5600W_SERIES
// wifi country info for various regions, needs to be in the same order
// as the IFPARAM_WIFI_REGION entries in net.lib

wifi_region const _wifi_country_info[] = {
//   id, country,      minch, maxch, channel mask,             max pwr dBm, index
	{  0, "Americas",       1,  11, WIFICONF_CHANMASK_AMERICAS,				20, 15},
	{  1, "Mexico indoor",  1,  11, WIFICONF_CHANMASK_AMERICAS,				16, 14},
	{  2, "Mexico outdoor", 9,  11, WIFICONF_CHANMASK_MEXICO_OUTDOORS,	20, 15},
	{  3, "Canada",         1,  11, WIFICONF_CHANMASK_AMERICAS,				20, 15},
	{  4, "EMEA",           1,  13, WIFICONF_CHANMASK_EMEA,					16, 14},
	{  5, "France",        10,  13, WIFICONF_CHANMASK_FRANCE,				16, 14},
	{  6, "Israel",         3,  11, WIFICONF_CHANMASK_ISRAEL,				16, 14},
	{  7, "China",          1,  11, WIFICONF_CHANMASK_CHINA,					16, 14},
	{  8, "Japan",          1,  13, WIFICONF_CHANMASK_JAPAN,				   20, 15},
	{  9, "Australia",      1,  11, WIFICONF_CHANMASK_AUSTRALIA,			16, 14},
};


#endif



// pointer into _wifi_country_info for the currently configured/selected country
wifi_region const *_wifi_region_current;

/*** BeginHeader wifi_ssid_to_str */
__far char * wifi_ssid_to_str (char __far *dest, char __far *ssid, int len);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
wifi_ssid_to_str                                         <WIFI_WLN_API.LIB>

SYNTAX: far char * wifi_ssid_to_str (char far *dest, char far *ssid, int len);

KEYWORDS:		WiFi, 802.11

DESCRIPTION:   This function creates a null-terminated string of printable
               characters from a given SSID.  Since the SSID can contain
               any byte (including nulls and characters > 0x7F), you can use
               wifi_ssid_to_str to create a printf-safe string.

PARAMETER1:		Pointer to a 33-byte buffer to receive the printable string.

PARAMETER2:    Pointer to a 0 to 32 byte SSID.

PARAMETER3:		Length of SSID in PARAMETER2.

RETURN VALUE:  returns PARAMETER1 (buffer with printf-safe string)

NOTE:          To perform the conversion in place (re-use the buffer):
                  int i;
                  char b[33];
                  ifconfig (IF_WIFI0, IFG_WIFI_SSID, &i, b, IFS_END);
                  printf ("SSID: [%ls]\n", wifi_ssid_to_str (b, b, i));

SEE ALSO:      IFG_WIFI_SSID option to ifconfig

END DESCRIPTION **********************************************************/

_wifig_nodebug
__far char * wifi_ssid_to_str (char __far *dest, char __far *ssid, int len)
{
	int i;
	char c;
   char __far *p;

   p = dest;
   for (i = 0; i < len; i++) {
   	c = *ssid++;
      // replace non-printable characters with '?'
		*p++ = isprint(c) ? c : '?';
   }
   *p = 0;	// null terminate

   return dest;
}

/*** BeginHeader wln_send_event */
BOOL wln_send_event (wln_event event, void __far *param);
/*** EndHeader */
/*
 * @param WLN_EVT_ASSOC			Associated with BSS
 * @param WLN_EVT_LINKUP		Layer 2 link complete; layer 3 available
 * @param WLN_EVT_DISASSOC		Disassociated from BSS
 * @param WLN_EVT_MIC_FAIL		MIC failure
 * @param WLN_EVT_JOIN			Joined a BSS
 * @param WLN_EVT_SCAN_RESULTS	BSS scan results
 *
 * @note	Parameter associated with each event:
 *
 * WLN_EVT_ASSOC			BSS ID
 * WLN_EVT_LINKUP			BSS ID
 * WLN_EVT_DISASSOC		BSS ID
 * WLN_EVT_MIC_FAIL		pointer to BOOL, TRUE if pairwise key
 * WLN_EVT_JOIN			BSS ID
 * WLN_EVT_SCAN_RESULTS	pointer to _wifi_wln_scan_data
*/
_wifig_nodebug
BOOL wln_send_event (wln_event evt, void __far *param)
{
	_wifi_wln_scan_data __far * sp;

   #GLOBAL_INIT { _wifi_scan.callback = NULL; }

	DPRINTF2("\nwln_send_event %s:\n",
		evt == WLN_EVT_ASSOC ? "ASSOC"  :
		evt == WLN_EVT_DISASSOC ? "DISASSOC"  :
		evt == WLN_EVT_MIC_FAIL ? "MICFAIL"  :
		evt == WLN_EVT_JOIN ? "JOIN"  :
		evt == WLN_EVT_SCAN_RESULTS ? "SCANRESULTS"  :
		evt == WLN_EVT_LINKUP ? "LINKUP"  :
		                               "Hopeless");

	if (evt == WLN_EVT_SCAN_RESULTS) {
		sp = (_wifi_wln_scan_data __far *)param;
		// In this case, we get a list of sp->count items of _wifi_wln_scan_bss
		DPRINTF2("... got %u results\n", sp->count);
		if (_wifi_scan.callback) _wifi_scan.callback(param);
	}

	if (evt == WLN_EVT_DISASSOC) {
	   _wc_write8(NCBFR, _NCBFR_NOT_ASSOC);
      _wifi_link_led(0);
      _wifi_macStatus.link = 0;
      _net_notify_link(IF_WIFI0, 0);
	}
	else if (evt == WLN_EVT_ASSOC) {
	   _wc_write8(NCBFR,
	   	_wifi_scan.roam_enabled ?
				_NCBFR_ASSOC_ROAMING :
	   		_NCBFR_ASSOC_SESSILE);
	}

	// Check if the layer 2 link is complete (layer 3 should now be operable)
	else if (evt == WLN_EVT_LINKUP) {
      _wifi_link_led(1);
      _wifi_macStatus.link = 1;

      // reset the ARP cache for this interface, in case we've roamed to a
      // different network
      arpcache_purge_iface (IF_WIFI0);

      // notify other hosts of the IP address we're using
      //SJH - no, this is not correct since we don't always know our IP
      // address at this point.  Don't mix layers!
      //_arp_send_gratuitous (IF_WIFI0);

      // Instead, make this upcall to network layer...
      _net_notify_link(IF_WIFI0, 1);
	}

#ifdef WIFI_USE_WPA
  #ifdef WPA_USE_EAP
	#ifndef WPA_EAP_BLOCKING
	if (!_eapol_cop_busy) {
		_eapol_cop_busy = 1;
	#endif
  #endif
	wpa_event_cb(evt, param);
  #ifdef WPA_USE_EAP
	#ifndef WPA_EAP_BLOCKING
		_eapol_cop_busy = 0;
	}
	#endif
  #endif
#endif

	return 0;
}

/*** BeginHeader _wifi_setchannelmask */
int _wifi_setchannelmask(uint32 channelmask);

#define WIFI_CHANMASK_ALL	0x3fff
/*** EndHeader */

/* _START FUNCTION DESCRIPTION ********************************************
_wifi_setchannelmask                          <WIFI_WLN_API.LIB>

SYNTAX: int _wifi_setchannelmask(uint32 channelmask);

KEYWORDS:		WiFi, 802.11

DESCRIPTION:	This function sets the allowed channels for the WiFi
					interface.  This is important because regulations differ
					depending on the end-user's locality which may prohibit
					certain channels from being used.  For example, in the
					US, FCC regulations only allow channel 1 through 11 to
					be used.

					The channelmask parameter specifies the requested channel
					set.  The lower channels are in the lower significant
					bits.  That is, channel 1 is in the least significant
					bit.

					To specify all channels, WIFI_CHANMASK_ALL can be used,
					which has a value of 0x1fff (channels 1-13).  To use
					only channels valid within the US, use the value 0x07ff.

					The following macros have been defined for covenience.
					Be sure to check any regulations for regions into
					which your wireless devices will be deployed.

	               // Allow all channels (1-13)
	               #define WIFICONF_CHANMASK_ALL             0x1fff

	               // Americas, including the US (1-11)
	               #define WIFICONF_CHANMASK_AMERICAS        0x07ff

	               // Mexico outdoors (9-11)
	               #define WIFICONF_CHANMASK_MEXICO_OUTDOORS 0x0700

	               // Europe, Middle East, Africa (1-13), except France
	               #define WIFICONF_CHANMASK_EMEA            0x1fff

	               // France (10-13)
	               #define WIFICONF_CHANMASK_FRANCE          0x1e00

	               // Israel (3-11)
	               #define WIFICONF_CHANMASK_ISRAEL          0x07fc

	               // China (1-11)
	               #define WIFICONF_CHANMASK_CHINA           0x07ff

	               // Japan (1-13)
	               #define WIFICONF_CHANMASK_JAPAN           0x1fff

	               // Australia (1-11)
						#define WIFICONF_CHANMASK_AUSTRALIA			0x07ff

PARAMETER1:		The set of allowable channels, in mask form.  Lower
					channel numbers are in the lower significant bits.

RETURN VALUE:  0		Success
					-1		Error (invalid channel set)

SEE ALSO:      wifi_ioctl

END DESCRIPTION **********************************************************/

_wifig_nodebug
int _wifi_setchannelmask(uint32 channelmask)
{
	if (channelmask & ~WIFI_CHANMASK_ALL) {
		// Invalid channels are specified
		return -1;
	}
	_wifi_macParams.chan_mask = channelmask;
	return 0;
}

/*** BeginHeader _wifi_setregion */
word _wifi_setregion(word regionID);
/*** EndHeader */

/* START_FUNCTION_DESCRIPTION *********************************************
_wifi_setregion               <WIFI_WLN_API.LIB>

SYNTAX:
   word _wifi_setregion(word regionID);

KEYWORDS:
   WiFi, 802.11

DESCRIPTION:
   This function sets a permitted region for the WiFi interface. This is
   important because regulations differ depending on the end-user's
   locality, which may prohibit certain channels from being used. For
   example, in the US, FCC regulations allow only channels 1 through 11 to
   be used.

PARAMETER1:
   The ID number of the desired region setting. Note that if the desired
   region ID setting is either invalid or not permitted, then a permitted
   region ID setting will be enforced.

RETURN VALUE:
   The region ID that has been set.

SEE ALSO:
   _wc_SetTxPower, _wifi_permittedregion, _wifi_setchannelmask

END DESCRIPTION **********************************************************/

_wifig_nodebug
word _wifi_setregion(word regionID)
{
	// ensure that regionID is valid and permitted
	regionID = _wifi_permittedregion(regionID);

	// point to current region
	_wifi_region_current = &_wifi_country_info[regionID];

	// Set Max allowable power level limit for selectable compile time region
	_wifi_macParams.tx_power_max = _wifi_region_current->max_pwr_index;

	// Set default power level to maximum allowable power - 2dBm (approximately)
	_wifi_macStatus.tx_power = WIFI_DEFAULT_TX_POWER_LEVEL;
	_wc_SetTxPower(_wifi_macStatus.tx_power);
	_wifi_waitUS (10);

	// Set allowable channel range for selectable compile time region
	_wifi_setchannelmask(_wifi_region_current->channel_mask);

	return regionID;
}

/*** BeginHeader _wifi_permittedregion */
word _wifi_permittedregion(word regionID);
/*** EndHeader */

/* START_FUNCTION_DESCRIPTION *********************************************
_wifi_permittedregion         <WIFI_WLN_API.LIB>

SYNTAX:
   word _wifi_permittedregion(word regionID);

KEYWORDS:
   WiFi, 802.11

DESCRIPTION:
   This function enforces permissibility of the specified region ID for the
   WiFi interface. This is important because regulations differ depending
   on the end-user's locality, which may prohibit certain channels from
   being used. For example, in the US, FCC regulations allow only channels
   1 through 11 to be used.

PARAMETER1:
   The region ID number to be verified or enforced as a permitted setting.

RETURN VALUE:
   Either the unaltered region ID number that was passed in, or an enforced
   permitted region ID number.

SEE ALSO:
   _wifi_setregion

END DESCRIPTION **********************************************************/

_wifig_nodebug
word _wifi_permittedregion(word regionID)
{
#if CPU_ID_MASK(_CPU_ID_) >= R6000
	if (0 <= _wifi_macParams.regionLock)
	{
		// if region locked, enforce locked regionID
		regionID = _wifi_macParams.regionLock;
	}
#endif
	if (IFPARAM_WIFI_REGION_END_OF_LIST <= regionID)
	{
		// if invalid regionID, enforce Americas region
		regionID = IFPARAM_WIFI_REGION_AMERICAS;
	}
	return regionID;
}

/*** BeginHeader __wifi_ioctl_setkey */
int __wifi_ioctl_setkey(int keynum, char* key, int len);
/*** EndHeader */

// Support routine for setting WEP key

_wifig_nodebug
int __wifi_ioctl_setkey(int keynum, char* key, int len)
{
	if ((keynum < 0) || (keynum > 3)) return -EINVAL;
	if (len == WLN_WEP40_SIZE || len == WLN_WEP104_SIZE || !len) {
		_wifi_macParams.wep_key_len[keynum] = len;
	}
	else
		return -EINVAL;
	memcpy(_wifi_macParams.wep_key[keynum], key, len);
	return 0;
}

/*** BeginHeader _wifi_ioctl_mode */
int _wifi_ioctl_mode (char *data);
/*** EndHeader */
// helper function to convert from old wifi_ioctl-style parameters to
// new ifconfig-style parameters
_wifig_nodebug
int _wifi_ioctl_mode (char *data)
{
   if (!strcmp(data, WIFICONF_ADHOC))
   	return IFPARAM_WIFI_ADHOC;
   else if (!strcmp(data, WIFICONF_INFRASTRUCT))
   	return IFPARAM_WIFI_INFRASTRUCTURE;
	else
   	return -1;
}

/*** BeginHeader _wifi_ioctl_tx_rate */
int _wifi_ioctl_tx_rate (char *data);
/*** EndHeader */
// helper function to convert from old wifi_ioctl-style parameters to
// new ifconfig-style parameters
_wifig_nodebug
int _wifi_ioctl_tx_rate (char *data)
{
   if (!strcmp(data, WIFICONF_RATE_ANY))           return 0;
   else if (!strcmp(data, WIFICONF_RATE_1MBPS))    return 10;
   else if (!strcmp(data, WIFICONF_RATE_2MBPS))    return 20;
   else if (!strcmp(data, WIFICONF_RATE_5_5MBPS))  return 55;
   else if (!strcmp(data, WIFICONF_RATE_11MBPS))   return 110;
   else return -1;
}

/*** BeginHeader _wifi_ioctl_encr_type */
int _wifi_ioctl_encr_type (char *data);
/*** EndHeader */
// helper function to convert from old wifi_ioctl-style parameters to
// new ifconfig-style parameters
int _wifi_ioctl_encr_type (char *data)
{
   if (!strcmp(data, WIFICONF_ENCR_WEP))           return WLN_ENCR_WEP;
   else if (!strcmp(data, WIFICONF_ENCR_DISABLE))  return WLN_ENCR_OPEN;
#ifdef WIFI_USE_WPA
   else if (!strcmp(data, WIFICONF_ENCR_TKIP))     return WLN_ENCR_TKIP;
   else if (!strcmp(data, WIFICONF_ENCR_CCMP))     return WLN_ENCR_CCMP;
#endif
   else return 0;
}

/*** BeginHeader _wifi_ioctl_auth_type */
int _wifi_ioctl_auth_type (char *data);
/*** EndHeader */
// helper function to convert from old wifi_ioctl-style parameters to
// new ifconfig-style parameters
int _wifi_ioctl_auth_type (char *data)
{
   if (!strcmp(data, WIFICONF_AUTH_OPEN_SYS))         return WLN_AUTH_OPEN;
   else if (!strcmp(data, WIFICONF_AUTH_SHARED_KEY))  return WLN_AUTH_SHAREDKEY;
#ifdef WIFI_USE_WPA
   else if (!strcmp(data, WIFICONF_AUTH_WPA_PSK))     return WLN_AUTH_WPA_PSK;
#endif
   else if (!strcmp(data, WIFICONF_AUTH_ALL))         return (int) WLN_AUTH_ANY;
   else return 0;
}
/*** BeginHeader wifi_ioctl */
int wifi_ioctl(int iface, int cmd, void* data, int len);

#define MAX_REGION_INDEX sizeof(_wifi_country_info[])/sizeof(_wifi_country_info[])
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
wifi_ioctl                                 <WIFI_WLN_API.LIB>

SYNTAX:	int wifi_ioctl(int iface, int cmd, char* data, int len);

					THIS FUNCTION HAS BEEN DEPRECATED, PLEASE USE THE IFS_WIFI_XXX
               OPTIONS OF ifconfig() INSTEAD.

DESCRIPTION:   This function is used to configure the WiFi interface,
					including setting the SSID, the mode, WEP keys, etc.  It
					can also be used to get status information and to request
					a WiFi scan.

					Note that the WiFi interface should be down for most of
					the commands which perform alterations of the driver state.
					Those commands are documented with the text "[requires
					interface to be down]".  If the interface must
					be down before calling this function, then the following
					code may be used to accomplish this objective:

	               if (ifpending(IF_WIFI0) != IF_DOWN) {
	                  printf("Bringing WiFi down (disassociating)...\n");
	                  ifdown(IF_WIFI0);
	                  while (ifpending(IF_WIFI0) != IF_DOWN)
	                     tcp_tick(NULL);
	                  printf("...Done.\n");
	               }

	               printf("Setting parameters...\n");
	               wifi_ioctl(IF_WIFI0, WIFI_WEP_KEY0, KEY0, sizeof(KEY0));
	               wifi_ioctl(IF_WIFI0, WIFI_SSID, "shiva-ap", 8);
	               printf("Bringing interface back up (associating)...\n");
	               ifup(IF_WIFI0);
	               while (ifpending(IF_WIFI0) == IF_COMING_UP)
	                  tcp_tick(NULL);
	               printf("...Done.\n");
	               if (ifpending(IF_WIFI0) != IF_UP) {
	                  printf("Unfortunately, it failed to associate :-(\n");
	                  // handle error
	               }

               Naturally, you can omit the printf's.

PARAMETER:     iface: Specifies the WiFi device interface number (either
					       IF_WIFI0 or IF_DEFAULT)

               The cmd, data, and len parameters will be described in
               detail below.  Each cmd (or command) has different
               requirements for the data and len parameters.  The cmd
               parameter is in all caps in the list below.


					WIFI_SSID                       [requires interface to be down]
               [replaced by IFS_WIFI_SSID option to ifconfig()]
						data:  char * ASCII string
						len:  length of string, or 0 to let driver compute it.
						      Can be up to 32.

						This command sets the SSID for the WiFi device.  For
						an infrastructure network (one that uses and Access
						Point), this is typically the name of the network.
						This name is typically configured on the Access Point.
						For an ad-hoc network, this is the name that you want
						to give the network you created.  All devices on the
						ad-hoc network must use the same SSID.

						This is only used for WiFi boards without an interposer
						card.  For those boards with an interposer card, use
						the WIFI_OWNSSID macro when using ad-hoc (IBSS) networks.

					WIFI_OWNSSID                    [requires interface to be down]
               [replaced by IFS_WIFI_SSID option to ifconfig()]
						data:  char * ASCII string
						len:  length of string, or 0 to let driver compute it.
						      Can be up to 32.

						This command sets the SSID only for boards with an
						interposer card, when joining an ad-hoc (IBSS) network.

               WIFI_MULTI_DOMAIN 				[requires interface to be down]
               [replaced by IFS_WIFI_MULTI_DOMAIN option to ifconfig()]
               	data:  char *
               	       Use "0" Disable 802.11d country info capability
                         Use "1" Enable 802.11d country info capability
               	len:  0

               	This command enables or disable your device to be configured
                  by an 802.11d multi-domain capable Access Point. When your
                  device is enabled, the Access Point will provide Country
                  Information for your device to identify the regulatory
                  domain in which it is located and to configure its PHY
                  for operation in that regulatory domain.

                  Note: The Access Point must have 802.11d option enabled with
                  the proper country selected where your wireless device is
                  deployed.


               WIFI_COUNTRY_SET              [requires interface to be down]
               [replaced by IFS_WIFI_REGION option to ifconfig()]
               	data:  int *
               	       Use 0 through 9
               	len:  0

                  This command sets the channel range and maximum power limit
                  for the country selected.

                  The region you select will automatically determine the
                  maximum power limit and channel range, recommend checking
                  the regulations which your wireless devices will be deployed
                  for any specfic requirements.

                  The following macros have been defined for covenience.


                  // Americas, including the US (channels 1-11)
	               _AMERICAS_REGION			0

                  // Mexico indoors (channels 1-11)
	               _MEXICO_REGION_INDOORS	1

	               // Mexico outdoors (channels 9-11)
	               _MEXICO_REGION_OUTDOORS	2

                  // Canada (channels 1-11)
						_CANADA_REGION				3

	               // Europe, Middle East, Africa (channels 1-13), except France
	               _EMEA_REGION            4

	               // France (channels 10-13)
	               _FRANCE_REGION          5

	               // Israel (channels 3-11)
	               _ISRAEL_REGION          6

	               // China (channels 1-11)
	               _CHINA_REGION           7

	               // Japan (channels 1-13)
	               _JAPAN_REGION           8

	               // Australia (channels 1-11)
						_AUSTRALIA_REGION			9


               EXAMPLE:

                  auto int country;

						country = _AUSTRALIA_REGION;
   					wifi_ioctl(IF_WIFI0, WIFI_COUNTRY_SET, &country, 0);


               WIFI_COUNTRY_GET
               [replaced by IFG_WIFI_REGION_INFO option to ifconfig()]
               	data:  _wifi_country *
               	       Caller must ensure there is enough space for the
               	       entire data structure.  Be sure the data pointer
               	       points to a buffer that is large enough to hold
               	       sizeof(_wifi_country).
               	len:  0

                  This command returns country specfic information into the
                  user-supplied buffer (or data structure) area.  The
                  _wifi_country structure has the following definition:

						typedef struct {
								char	id;                  // Country ID
								char  country[16];         // Country name
								int   first_channel;       // First channel
   							int   last_channel;	  		// Last channel
   							unsigned int channel_mask; // Channel mask
   							int   max_pwr_dBm;   		// Max power, dBm
   							int   max_pwr_index;     	// Max Power index
						}_wifi_country;

	            WIFI_MODE                       [requires interface to be down]
               [replaced by IFS_WIFI_MODE option to ifconfig()]
						data:  char *
						       Use either WIFICONF_INFRASTRUCT or WIFICONF_ADHOC
						len:  0

                  Sets whether the WiFi device should attach to an
                  infrastructure or ad-hoc network.  Infrastructure
                  networks are more common and use an Access Point (AP).
                  The AP coordinates communication among all associated
                  devices.  An ad-hoc network does not use an AP.  Instead,
                  all communication happens between peer devices.  Use
						WIFICONF_INFRASTRUCT for an infrastructure network, and
                  WIFICONF_ADHOC for an ad-hoc network.

	            WIFI_OWNCHAN                    [requires interface to be down]
               [replaced by IFS_WIFI_CHANNEL option to ifconfig()]
	            	data:  char*
	            	       Can be set to "0" through "13"
						len:  0

						Selects the channel that is used for this device.  For
						an infrastructure network, this should almost always be
						set to "0".  This allows the WiFi driver to automatically
						pick the channel for the given SSID.  For an ad-hoc
						network, this channel must be set to "1" through "13".
                  Use the wifi_ioctl command WIFI_COUNTRY_GET to get valid
                  range of wifi channels.

						Note that regional regulations may not allow some channels
						to be used.


	            WIFI_ENCR_TYPE                   [requires interface to be down]
               [replaced by IFS_WIFI_ENCRYPTION option to ifconfig()]
						data:  char *
						       Set to one of the following values:
						       WIFICONF_ENCR_DISABLE		Disable encryption
						       WIFICONF_ENCR_WEP			Enable WEP encryption
						       WIFICONF_ENCR_TKIP			Enable TKIP (for WPA)
						       									encryption
						len:  0

						Use to specify encryption type.  Use of TKIP requires
						that you specify WPA (WIFI_AUTH=WIFICONF_AUTH_WPA_PSK)
						and #define WIFI_USE_WPA

	            WIFI_WEP_USEKEY
               [replaced by IFS_WIFI_WEP_KEYNUM option to ifconfig()]
	            	data:  char*
                         Can be set to "0" through "3"
                  len:  0

                  Select the WEP key to use.  See how to set the WEP
                  keys below.

	            WIFI_WEP_KEY0                  [requires interface to be down]
	            WIFI_WEP_KEY1                  [requires interface to be down]
	            WIFI_WEP_KEY2                  [requires interface to be down]
	            WIFI_WEP_KEY3                  [requires interface to be down]
               [replaced by IFS_WIFI_WEP_KEY_BIN option to ifconfig()]
	            	data:  char[]
	            	len:  5 or 13 (40-bit or 104-bit key)

	            	Respectively set WEP keys 0, 1, 2 or 3.
	            	Data is an array of either 5 or 13
	            	hexadecimal bytes; i.e., it is NOT an ASCII string.
	            	Set the len to 5 if this is a 40-bit key, or 13 if this
	            	is a 104-bit key.  Note that in marketing literature,
	            	these are sometimes referred to as 64-bit or 128-bit
	            	keys.

	            WIFI_AUTH
               [replaced by IFS_WIFI_AUTHENTICATION option to ifconfig()]
	            	data:  char*
	            		  	 Use WIFICONF_AUTH_OPEN_SYS,
	            		  	 WIFICONF_AUTH_SHARED_KEY, or
	            		  	 WIFICONF_AUTH_WPA_PSK, or
	            		  	 WIFICONF_AUTH_ALL
						len:  0

						Set the authentication method for the WiFi driver.  Set
                  WIFICONF_AUTH_OPEN_SYS for open authentication,
                  WIFICONF_AUTH_SHARED_KEY for shared key authentication
                  (often known as WEP authentication), or
                  WIFICONF_AUTH_WPA_PSK for WPA PSK (pre-shared key/"personal")
                  WIFICONF_AUTH_ALL for all types of authentication.

               WIFI_WPA_PSK_PASSPHRASE
               [replaced by IFS_WIFI_WPA_PSK_PASSPHRASE option to ifconfig()]
               	data:  char*
               	       An ASCII string of 1 to 63 characters, null
               	       terminated.
               	len:   0

						This option is only available if using WPA i.e. the
						WIFI_USE_WPA macro is defined.

               	Sets a key for the previously specified WIFI_SSID value.
               	The key is computed as a hash of the passphrase and the
               	target SSID.  This is potentially long running.  See the
               	sample program samples\rcm4400W\tcpip\passphrase.c for
               	alternatives.

               	If your program (or TCP configuration) defines
               	_WIFI_PSK_PASSPHRASE to a quoted string, then that string
               	will be automatically used as a passphrase, unless
               	_WIFI_PSK_HEX is also defined (see next).

               WIFI_WPA_PSK_HEX
               [replaced by IFS_WIFI_WPA_PSK_HEXSTR option to ifconfig()]
               	data:  char*
               	       An ASCII string of exactly 64 characters, null
               	       terminated.
               	len:   0

						This option is only available if using WPA i.e. the
						WIFI_USE_WPA macro is defined.

               	Sets a hexadecimal WPA PSK master key.  The string must
               	be exactly 64 hexadecimal digits (using the characters
               	0-9, a-f or A-F).  This is interpreted as a byte string
               	and parsed into the appropriate 32-byte binary key.

               	If your program (or TCP configuration) defines _WIFI_PSK_HEX
               	to a quoted string of 64 hex digits, then that string will
               	be used automatically as the PSK master key.

               WIFI_TX_RATE
               [replaced by IFS_WIFI_TX_RATE option to ifconfig()]
               	data:  char*
               	       Use WIFICONF_RATE_1MBPS, WIFICONF_RATE_2MBPS,
               	       WIFICONF_RATE_5_5MBPS, WIFICONF_RATE_11MBPS, or
               	       WIFICONF_RATE_ANY
               	len:  0

               	Set the maximum transmission rate for the WiFi device.
               	For an 802.11b device, this can be 1 Mbps
               	(WIFICONF_RATE_1MBPS), 2 Mbps (WIFICONF_RATE_2MBPS),
               	5.5 Mbps (WIFICONF_RATE_5_5MBPS), or 11 Mbps
               	(WIFICONF_RATE_11MBPS).  Use WIFICONF_RATE_ANY to use the
               	highest data rate available.

               WIFI_TX_POWER
               [replaced by IFS_WIFI_TX_POWER option to ifconfig()]
               	data:  char *
               	       Use "0" through "15"
               	len:  0

               	Set the transmit power for the WiFi device.  Higher
               	transmit power will result in higher dBm. Use the
                  wifi_ioctl command WIFI_COUNTRY_GET to get the maximum
                  power limit setting.

                  Note that regional regulations may not allow full range
                  of possible power settings to be used.

               WIFI_FRAG_THRESH
               [replaced by IFS_WIFI_FRAG_THRESHOLD option to ifconfig()]
               	data:  char *
               	       Use "256" through "2346"
               	len:  0

               	Set the threshold (in bytes) beyond which a frame must
               	be fragmented when transmitted.  This can be useful on
               	a very busy or noisy network, since frame corruption will
               	be limited to the size of a fragment rather than the
               	whole frame.  This means that only the fragment will need
               	to be retransmitted.  To be effective, the fragmentation
               	threshold will need to be set on all wireless devices on
               	the network as well as on the Access Point.

					WIFI_RTS_THRESH
               [replaced by IFS_WIFI_RTS_THRESHOLD option to ifconfig()]
						data:  char *
						       Use "0" through "2347"
						len:  0

						Set the threshold (in bytes) beyond which an RTS
						(request-to-send) frame must be sent before the data
						frame can be sent.  This can sometimes help performance
						with busy networks, although it is not frequently used.

					WIFI_SCANCB
               [replaced by IFS_WIFI_SCAN option to ifconfig()]
						data:  void *
						       This must be a pointer to the scan callback
						       function.
						len:  0

                  This sets up a user callback function that will be called
                  when a user-requested scan has completed.  The callback
                  function must have the following function prototype:

                  root void scan_callback(far wifi_scan_data* data);

                  (the name of the function can be different).  The scan
                  data will be provided in the data parameter.  This
                  structure has the following definition:

                  #define	_WIFI_SCAN_NUM
	               typedef struct {
	                  int                  count;
	                  _wifi_wln_scan_bss   bss[_WIFI_SCAN_NUM];
	               } wifi_scan_data;

               	count will have the number of access points that were
               	detected.  bss is an array where each element
               	corresponds to a detected access point.
               	_wifi_wln_scan_bss is a structure that has the following
               	definition:

	               typedef struct {
	                  uint8       ssid[WLN_SSID_SIZE];
	                  int         ssid_len;
	                  int         channel;
	                  mac_addr    bss_addr;
	                  uint16      bss_caps;
	                  uint8       wpa_info[WLN_WPAIE_SIZE];
	                  uint8       erp_info;
	                  uint16      rates;
	                  uint16      rates_basic;
	                  uint16      atim;
	                  int         tx_rate;
	                  int         rx_signal;
	               } _wifi_wln_scan_bss;

						The structure elements have the following definitions:
	               * ssid          Service set ID (max length 32)
	               * ssid_len      SSID length in bytes
	               * channel       Channel: 1-13
	               * bss_addr      BSS ID (AP MAC address)
	               * bss_caps      reserved
	               * wpa_info      reserved
	               * erp_info      reserved
	               * rates         reserved
	               * rates_basic   reserved
	               * atim          reserved
	               * tx_rate       Maximum transmit rate (in 100 kbps)
	               * rx_signal     Received signal strength

               WIFI_SCAN	                    [requires interface to be down]
               [replaced by IFS_WIFI_SCAN option to ifconfig()]
               	data:  NULL (not used)
                  len:  0

                  Initiates a WiFi scan.  When the scan has been completed,
                  then the configured scan callback function (see above)
                  will be called.  The callback function must have already
                  been configured before using this command.  A WiFi scan
                  will briefly interrupt the network connectivity, since
                  the scan must iterate through the channels on the
                  wireless network.

               WIFI_STATUSGET
               [replaced by IFG_WIFI_STATUS option to ifconfig()]
               	data:  wifi_status *
               	       Caller must ensure there is enough space for the
               	       entire data structure.  Be sure the data pointer
               	       points to a buffer that is large enough to hold
               	       sizeof(wifi_status).
               	len:  0

                  This command returns status information into the user-
                  supplied buffer (or data structure) area.  The
                  wifi_status structure has the following definition:

	               typedef struct {
	                  wln_state   state;
	                  uint8       ssid[WLN_SSID_SIZE];
	                  int         ssid_len;
	                  int         channel;
	                  mac_addr    bss_addr;
	                  uint16      bss_caps;
	                  uint8       wpa_info[WLN_WPAIE_SIZE];
	                  uint32      authen;
	                  uint32      encrypt;
	                  int         tx_rate;
	                  int         rx_rate;
	                  int         rx_signal;
	                  int         tx_power;
	                  uint8       country_info[WLN_COUNTRY_STRLEN];
							int			link;
	               } wifi_status;

                  The structure elements have the following definitions:
	               * state     	Association state: one of WLN_ST_xxx
	               * ssid      	Current service set ID (SSID)
	               * ssid_len  	Service set ID length
	               * channel   	Current channel: 1-13
	               * bss_addr  	BSS ID (AP MAC address)
	               * bss_caps  	reserved
	               * wpa_info  	reserved
	               * authen    	reserved
	               * encrypt   	reserved
	               * tx_rate   	Current transmit rate (in 100 kbps)
	               * rx_rate   	Last received rate (in 100 kbps)
	               * rx_signal 	Last received signal strength (range 0-107)
	               * tx_power     reserved
	               * country_info	reserved
						* link			reserved

						Note the state element above.  This can provide more
						information on the current state of the WiFi driver.  In
						particular, it can have the following values:
						* WLN_ST_STOPPED		WiFi driver is stopped
                  * WLN_ST_SCANNING		Currently performing a scan
                  * WLN_ST_ASSOC_ESS	Associated with an AP
                  * WLN_ST_AUTH_ESS		Authenticated with an AP
                  * WLN_ST_JOIN_IBSS	Joined an existing ad-hoc network
                  * WLN_ST_START_IBSS	Started an ad-hoc network

RETURN VALUE:  0		Success
               -EPERM   Operation not permitted, possibly because you
                        supplied an interface other than IF_WIFI0.
					-EINVAL	Invalid command or parameter
					-EBUSY	The WiFi interface is currently active.  Bring
					      it down first using ifdown(); issue required
					      wifi_ioctl() command(s), then bring the interface up
					      using ifup().

END DESCRIPTION **********************************************************/

_wifig_nodebug
int wifi_ioctl(int iface, int cmd, void* data, int len)
{
	#warns "wifi_ioctl() has been deprecated, use ifconfig() instead"

	auto int i;
	auto int retval;

	// Make sure the WIFI interface has been selected
	if (iface != IF_WIFI0) {
   	return -EPERM;
   }

   retval = 0;		// Assume OK.

   switch (cmd) {
   // Set the SSID (for both infrastructure and adhoc networks)
   case WIFI_SSID:
   case WIFI_OWNSSID:
   	// Allow len == 0 for null-terminated strings
   	if (!len)
   		len = strlen(data);
      if (ifconfig (iface, IFS_WIFI_SSID, len, data, IFS_END))
      	goto _inval;
      break;

	// Specify the channel (can be 0 for auto-select for infrastructure network)
   case WIFI_OWNCHAN:
      if (ifconfig (iface, IFS_WIFI_CHANNEL, atoi(data), IFS_END))
      	goto _inval;
      break;

	// Set infrastructure or adhoc mode
   case WIFI_MODE:
      if (ifconfig (iface, IFS_WIFI_MODE, _wifi_ioctl_mode(data), IFS_END))
      	goto _inval;
      break;

	// Set the maximum TX rate
   case WIFI_TX_RATE:
      if (ifconfig (iface, IFS_WIFI_TX_RATE, _wifi_ioctl_tx_rate(data), IFS_END))
         goto _inval;
      break;

	// Configure a callback function for a completed scan
   case WIFI_SCANCB:
   	_wifi_scan.callback = data;
   	break;

	// Request a scan
   case WIFI_SCAN:
   	if (ifconfig (iface, IFS_WIFI_SCAN, _wifi_scan.callback, IFS_END))
      	goto _inval;
		break;

	// Get WiFi status information structure
	case WIFI_STATUSGET:
   	if (ifconfig (iface, IFG_WIFI_STATUS, data, IFS_END))
      	goto _inval;
		break;

   // Enable or disable WEP
   case WIFI_ENCR_TYPE:
		i = (int) (_wifi_macParams.encrypt | _wifi_ioctl_encr_type(data));
		if (ifconfig (iface, IFS_WIFI_ENCRYPTION, i, IFS_END))
      	goto _inval;
      break;

   // Specify a WEP key to use (0-3)
   case WIFI_WEP_USEKEY:
   	if (ifconfig (iface, IFS_WIFI_WEP_KEYNUM, atoi(data), IFS_END))
      	goto _inval;
      break;

   // Configure authentication (open, shared (WEP) or WPA-PSK)
	case WIFI_AUTH:
   case WIFI_WEP_AUTH:
      if (ifconfig (iface, IFS_WIFI_AUTHENTICATION, _wifi_ioctl_auth_type(data), IFS_END))
      	goto _inval;
      break;

   // Set WEP 0
   case WIFI_WEP_KEY0:
   case WIFI_WEP_KEY1:
   case WIFI_WEP_KEY2:
   case WIFI_WEP_KEY3:
   	if (ifconfig (iface, IFS_WIFI_WEP_KEY_BIN, cmd - WIFI_WEP_KEY0,
      	len, data, IFS_END)) goto _inval;
   	break;

   // Set the transmit power (0-15)
   case WIFI_TX_POWER:
   	if (ifconfig (iface, IFS_WIFI_TX_POWER, atoi(data), IFS_END))
      	goto _inval;
      break;

	// Set the fragmentation threshold (256-2346)
   case WIFI_FRAG_THRESH:
   	if (ifconfig (iface, IFS_WIFI_FRAG_THRESHOLD, atoi(data), IFS_END))
      	goto _inval;
   	break;

	// Set the RTS threshold (0-2347)
   case WIFI_RTS_THRESH:
   	if (ifconfig (iface, IFS_WIFI_RTS_THRESHOLD, atoi(data), IFS_END))
      	goto _inval;
		break;

#ifdef WIFI_USE_WPA
   case WIFI_WPA_PSK_PASSPHRASE:
      if (ifconfig (iface, IFS_WIFI_WPA_PSK_PASSPHRASE, data, IFS_END))
      	goto _inval;
		break;

   case WIFI_WPA_PSK_HEX:
      if (ifconfig (iface, IFS_WIFI_WPA_PSK_HEXSTR, data, IFS_END))
      	goto _inval;
		break;
#endif

   // Set WiFi country information structure
	case WIFI_COUNTRY_SET:
      if (ifconfig (iface, IFS_WIFI_REGION, *(int *)data, IFS_END)) goto _inval;
  		break;

   // Get WiFi country information structure
	case WIFI_COUNTRY_GET:
   	ifconfig (iface, IFG_WIFI_REGION_INFO, data, IFS_END);
		break;

   case WIFI_MULTI_DOMAIN:
      if (ifconfig (iface, IFS_WIFI_MULTI_DOMAIN, atoi(data), IFS_END)) goto _inval;
		break;

   default:
		retval = -EINVAL;
   }

   return retval;

_inval:
	return -EINVAL;
_busy:
	return -EBUSY;

}

/*** BeginHeader */
#endif /* _WIFI_WLN_API_LIB */
/*** EndHeader */


