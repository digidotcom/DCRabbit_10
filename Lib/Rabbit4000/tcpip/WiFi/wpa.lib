
/*** BeginHeader */
#ifndef _WPA_H
#define _WPA_H
/*******************************************************************
*  WARNING: this file is machine generated.  Do not edit directly. *
*******************************************************************/
#ifndef FUNCPTR
	#define FUNCPTR *
#endif
#ifdef WPA_DEBUG
	#define _wpa_debug __debug
#else
	#define _wpa_debug __nodebug
#endif

#ifdef WPA_VERBOSE
   #define _WPA_PRINTF(x) _wpa_printf x
	#ifndef WPA_NO_HEXDUMP
	   #define _WPA_HEXDUMP(x) _wpa_hexdump x
	#else
		#define _WPA_HEXDUMP(x)
	#endif
#else
	#define _WPA_PRINTF(x)
	#define _WPA_HEXDUMP(x)
#endif

// Define this by default, since required for RSN.
#define WPA_USE_PMKSA_CACHE



/*
"wpa_supplicant v" "0.5.8" "\n"
"Copyright (c) 2003-2007, Jouni Malinen <j@w1.fi> and contributors";

"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License version 2 as\n"
"published by the Free Software Foundation.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n";
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"Alternatively, this software may be distributed under the terms of the\n"
"BSD license.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions are\n"
"met:\n"
"\n";
"1. Redistributions of source code must retain the above copyright\n"
"   notice, this list of conditions and the following disclaimer.\n"
"\n"
"2. Redistributions in binary form must reproduce the above copyright\n"
"   notice, this list of conditions and the following disclaimer in the\n"
"   documentation and/or other materials provided with the distribution.\n"
"\n";
"3. Neither the name(s) of the above-listed copyright holder(s) nor the\n"
"   names of its contributors may be used to endorse or promote products\n"
"   derived from this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
"\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n";
"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
"\n";

*/

/* Need to include malloc support. We may remove this later */
#ifndef MALLOC_H_Incl
 #ifndef MSPACES
  #define MSPACES 1
 #endif
 #use "MALLOC.LIB"
#endif
#ifdef MSPACES
 #if !MSPACES
  #error "WPA library requires memory spaces to be enabled (#define MSPACES 1)"
 #endif
#endif

#ifndef _X509_H
 #use "X509.LIB"
#endif

#ifndef _SSL_TPORT_H
 #use "SSL_TPORT.LIB"
#endif



#ifdef WPA_MSG_CALLBACK
 #define _WPA_MSG(x) _wpa_msg x
#else
 #define _WPA_MSG(x)
#endif

#ifndef __MD4_LIB
	#use "md4.lib"
#endif

#ifndef __DES_LIB
	#use "des.lib"
#endif



/*** EndHeader */

// @ libraryPrefix[]  ; -- translator directive
// @ hdrStuff[]  ; -- translator directive
// @ parenthesizeArgs[_WPA_PRINTF]  ; -- translator directive
// @ parenthesizeArgs[_WPA_HEXDUMP]  ; -- translator directive
// @ parenthesizeArgs[_WPA_MSG]  ; -- translator directive
// @ typedefRename[u8]  ; -- translator directive
// @ typedefRename[u16]  ; -- translator directive
// @ typedefRename[u32]  ; -- translator directive
// @ pointerQualifier[]  ; -- translator directive
// @ ptrdiffType[]  ; -- translator directive
// @ switchType[]  ; -- translator directive
// @ printfFormat[_WPA_PRINTF]  ; -- translator directive
// @ printfFormat[printf]  ; -- translator directive
// @ printfFormat[sprintf]  ; -- translator directive
// @ printfFormat[snprintf]  ; -- translator directive
// @ printfFormat[_WPA_MSG]  ; -- translator directive
// @ TUName[]  ; -- translator directive
/*** BeginHeader */
#ifndef HAVE_OS_TIME

/* Rabbit note: os_time_t previously defined:
typedef long os_time_t;	// From "wpa_all.c":255

struct os_time {
	os_time_t sec;
	os_time_t usec;

} ;	// From "wpa_all.c":260
*/
#endif
// @ TUName[]  ; -- translator directive
/*** EndHeader */

/*** BeginHeader l2_packet_init */
// From "wpa_all.c":404
struct l2_packet_data __far * l2_packet_init(char __far * ifname, char __far * own_addr,
                                           unsigned short protocol, void (FUNCPTR rx_callback)( /*
                                                                                                   void far * ctx,
                                                                                                   char far * src_addr,
                                                                                                   char far * buf,
                                                                                                   size_t len */ ),
                                           void __far * rx_callback_ctx, int l2_hdr);
/*** EndHeader */
_wpa_debug
struct l2_packet_data __far * l2_packet_init(char __far * ifname, char __far * own_addr,
                                           unsigned short protocol, void (FUNCPTR rx_callback)( /*
                                                                                                   void far * ctx,
                                                                                                   char far * src_addr,
                                                                                                   char far * buf,
                                                                                                   size_t len */ ),
                                           void __far * rx_callback_ctx, int l2_hdr) {
}

/*** BeginHeader l2_packet_deinit */
// From "wpa_all.c":418
void l2_packet_deinit(struct l2_packet_data __far * l2);
/*** EndHeader */
_wpa_debug
void l2_packet_deinit(struct l2_packet_data __far * l2) {
}

/*** BeginHeader l2_packet_get_own_addr */
// From "wpa_all.c":428
int l2_packet_get_own_addr(struct l2_packet_data __far * l2, char __far * addr);
/*** EndHeader */
_wpa_debug
int l2_packet_get_own_addr(struct l2_packet_data __far * l2, char __far * addr) {
	return 0;
}

/*** BeginHeader l2_packet_send */
// From "wpa_all.c":445
int l2_packet_send(struct l2_packet_data __far * l2, char __far * dst_addr, word proto,
                   char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
int l2_packet_send(struct l2_packet_data __far * l2, char __far * dst_addr, word proto,
                   char __far * buf, size_t len) {
	return 0;
}

/*** BeginHeader l2_packet_get_ip_addr */
// From "wpa_all.c":467
int l2_packet_get_ip_addr(struct l2_packet_data __far * l2, char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
int l2_packet_get_ip_addr(struct l2_packet_data __far * l2, char __far * buf, size_t len) {
	return  -1;
}

/*** BeginHeader l2_packet_notify_auth_start */
// From "wpa_all.c":483
void l2_packet_notify_auth_start(struct l2_packet_data __far * l2);
/*** EndHeader */
_wpa_debug
void l2_packet_notify_auth_start(struct l2_packet_data __far * l2) {
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

/*
struct os_time {
	os_time_t sec;
	os_time_t usec;

} ;	// From "os.h":30

// Rabbit note: enum { MSG_MSGDUMP, ...} already defined in x509.lib
enum  {
	MSG_MSGDUMP,
	MSG_DEBUG,
	MSG_INFO,
	MSG_WARNING,
	MSG_ERROR
}  ;	// From "common.h":257
*/

typedef void (FUNCPTR wpa_msg_cb_func)( /* void far * ctx, int level, char far * txt,
                                           size_t len */ );	// From "common.h":383
/*** EndHeader */

/*** BeginHeader inc_byte_array */
// From "wpa_all.c":515
void inc_byte_array(char __far * counter, size_t len);
/*** EndHeader */
_wpa_debug
void inc_byte_array(char __far * counter, size_t len) {
	int pos /* = len-1 */; 	// From "wpa_all.c":517

	pos = len-1;

	while (pos>=0) {
		counter[pos]++;
		if (counter[pos]!=0)
			break;
		pos--;
	}
}

/*** BeginHeader wpa_snprintf_hex */
// From "wpa_all.c":537
int wpa_snprintf_hex(char __far * buf, size_t buf_size, char __far * data, size_t len);
/*** EndHeader */
_wpa_debug
int wpa_snprintf_hex(char __far * buf, size_t buf_size, char __far * data, size_t len) {
	int i; 	// From "wpa_all.c":539


	if (len>buf_size/2)
		len = buf_size/2;
	for (i = 0; i<len &&
	i<buf_size;  ++i) {
		sprintf(buf, "%02x" , data[i]);
	}
}
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader wpa_msg_register_cb */
// From "wpa_all.c":551
void wpa_msg_register_cb(wpa_msg_cb_func func);
/*** EndHeader */
_wpa_debug
void wpa_msg_register_cb(wpa_msg_cb_func func) {
	__wpa_globals.__s3.wpa_msg_cb = func;
}

/*** BeginHeader _wpa_msg */
// From "wpa_all.c":557
void _wpa_msg(void __far * ctx, int level, char __far * fmt,...);
/*** EndHeader */
_wpa_debug
void _wpa_msg(void __far * ctx, int level, char __far * fmt,...) {
	va_list ap; 	// From "wpa_all.c":559
	char buf[256]; 	// From "wpa_all.c":560
	int len; 	// From "wpa_all.c":561


	va_start(ap, fmt);
	len = vsnprintf(buf, sizeof (buf), fmt, ap);
	va_end(ap);
	_WPA_PRINTF((level, "%ls" , (char  __far * )(buf)));
	if (__wpa_globals.__s3.wpa_msg_cb)
		__wpa_globals.__s3.wpa_msg_cb((void  __far * )(ctx), (int  )(level), (char  __far * )(buf),
                                (size_t  )(len));
}

/*** BeginHeader wpa_ssid_txt */
// From "wpa_all.c":587
char __far * wpa_ssid_txt(char __far * ssid, size_t ssid_len);
/*** EndHeader */
_wpa_debug
char __far * wpa_ssid_txt(char __far * ssid, size_t ssid_len) {
	char __far * pos; 	// From "wpa_all.c":590


	if (ssid_len>32)
		ssid_len = 32;
	_f_memcpy(__wpa_globals.__s3.__s156.ssid_txt, ssid, ssid_len);
	__wpa_globals.__s3.__s156.ssid_txt[ssid_len] = '\0';
	for (pos = __wpa_globals.__s3.__s156.ssid_txt; *pos!='\0'; pos++) {
		if ((char  )*pos<32 ||
		(char  )*pos>=127)
			*pos = '_';
	}
	return __wpa_globals.__s3.__s156.ssid_txt;
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

typedef
/*
enum  {
	FALSE = 0,
	TRUE = 1
}*/
int  Boolean;	// From "defs.h":24

typedef
enum  {
	WPA_ALG_NONE,
	WPA_ALG_WEP,
	WPA_ALG_TKIP,
	WPA_ALG_CCMP,
	WPA_ALG_IGTK,
	WPA_ALG_DHV
}  wpa_alg;	// From "defs.h":28

typedef
enum  {
	CIPHER_NONE,
	CIPHER_WEP40,
	CIPHER_TKIP,
	CIPHER_CCMP,
	CIPHER_WEP104
}  wpa_cipher;	// From "defs.h":30

typedef
enum  {
	KEY_MGMT_802_1X,
	KEY_MGMT_PSK,
	KEY_MGMT_NONE,
	KEY_MGMT_802_1X_NO_WPA,
	KEY_MGMT_WPA_NONE
}  wpa_key_mgmt;	// From "defs.h":32

typedef
enum  {
	WPA_DISCONNECTED,
	WPA_INACTIVE,
	WPA_SCANNING,
	WPA_ASSOCIATING,
	WPA_ASSOCIATED,
	WPA_4WAY_HANDSHAKE,
	WPA_GROUP_HANDSHAKE,
	WPA_COMPLETED
}  wpa_states;	// From "defs.h":130

enum  {
	WPA_NONCE_LEN = 32
}  ;	// From "wpa_common.h":19

struct ieee802_1x_hdr {
	char version;
	char type;
	word length;

} ;	// From "wpa_common.h":34

enum  {
	IEEE802_1X_TYPE_EAP_PACKET = 0,
	IEEE802_1X_TYPE_EAPOL_START = 1,
	IEEE802_1X_TYPE_EAPOL_LOGOFF = 2,
	IEEE802_1X_TYPE_EAPOL_KEY = 3,
	IEEE802_1X_TYPE_EAPOL_ENCAPSULATED_ASF_ALERT = 4
}  ;	// From "wpa_common.h":47

enum  {
	EAPOL_KEY_TYPE_RC4 = 1,
	EAPOL_KEY_TYPE_RSN = 2,
	EAPOL_KEY_TYPE_WPA = 254
}  ;	// From "wpa_common.h":50

enum  {
	WPA_CAPABILITY_PREAUTH = (1<<(0))
}  ;	// From "wpa.h":25

enum  {
	WPA_CAPABILITY_PEERKEY_ENABLED = (1<<(9))
}  ;	// From "wpa.h":27

enum  {
	GENERIC_INFO_ELEM = 0xdd
}  ;	// From "wpa.h":29

enum  {
	RSN_INFO_ELEM = 0x30
}  ;	// From "wpa.h":30

enum  {
	REASON_UNSPECIFIED = 1,
	REASON_DEAUTH_LEAVING = 3,
	REASON_INVALID_IE = 13,
	REASON_MICHAEL_MIC_FAILURE = 14,
	REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,
	REASON_IE_IN_4WAY_DIFFERS = 17,
	REASON_GROUP_CIPHER_NOT_VALID = 18,
	REASON_PAIRWISE_CIPHER_NOT_VALID = 19,
	REASON_AKMP_NOT_VALID = 20,
	REASON_UNSUPPORTED_RSN_IE_VERSION = 21,
	REASON_INVALID_RSN_IE_CAPAB = 22,
	REASON_IEEE_802_1X_AUTH_FAILED = 23,
	REASON_CIPHER_SUITE_REJECTED = 24
}  ;	// From "wpa.h":47

enum  {
	PMKID_LEN = 16
}  ;	// From "wpa.h":49

struct wpa_sm_ctx {
	void __far * ctx;
	void (FUNCPTR set_state)( /* void far * ctx, wpa_states state */ );
	wpa_states (FUNCPTR get_state)( /* void far * ctx */ );
	void (FUNCPTR req_scan)( /* void far * ctx, os_time_t sec, os_time_t usec */ );
	void (FUNCPTR deauthenticate)( /* void far * ctx, int reason_code */ );
	void (FUNCPTR disassociate)( /* void far * ctx, int reason_code */ );
	int (FUNCPTR set_key)( /* void far * ctx, wpa_alg alg, char far * addr, int key_idx,
                           int set_tx, char far * seq, size_t seq_len, char far * key,
                           size_t key_len */ );
	void (FUNCPTR scan)( /* void far * eloop_ctx, void far * timeout_ctx */ );
	struct wpa_ssid __far * (FUNCPTR get_ssid)( /* void far * ctx */ );
	int (FUNCPTR get_bssid)( /* void far * ctx, char far * bssid */ );
	int (FUNCPTR ether_send)( /* void far * ctx, char far * dest, word proto, char far * buf,
                              size_t len */ );
	int (FUNCPTR get_beacon_ie)( /* void far * ctx */ );
	void (FUNCPTR cancel_auth_timeout)( /* void far * ctx */ );
	char __far * (FUNCPTR alloc_eapol)( /* void far * ctx, char type, void far * data,
                                      word data_len, size_t far * msg_len, void far * far * data_pos */ );
	int (FUNCPTR add_pmkid)( /* void far * ctx, char far * bssid, char far * pmkid */ );
	int (FUNCPTR remove_pmkid)( /* void far * ctx, char far * bssid, char far * pmkid */ );
	void (FUNCPTR set_config_blob)( /* void far * ctx, struct wpa_config_blob far * blob */ );
	struct wpa_config_blob __far * (FUNCPTR get_config_blob)( /* void far * ctx, char far * name */ );
	int (FUNCPTR mlme_setprotection)( /* void far * ctx, char far * addr, int protection_type,
                                      int key_type */ );

} ;	// From "wpa.h":85

enum wpa_sm_conf_params {
	RSNA_PMK_LIFETIME,
	RSNA_PMK_REAUTH_THRESHOLD,
	RSNA_SA_TIMEOUT,
	WPA_PARAM_PROTO,
	WPA_PARAM_PAIRWISE,
	WPA_PARAM_GROUP,
	WPA_PARAM_KEY_MGMT,
	WPA_PARAM_MGMT_GROUP
}  ;	// From "wpa.h":97

struct wpa_ie_data {
	int proto;
	int pairwise_cipher;
	int group_cipher;
	int key_mgmt;
	int capabilities;
	int num_pmkid;
	char __far * pmkid;
	int mgmt_group_cipher;

} ;	// From "wpa.h":108

enum  {
	SHA1_MAC_LEN = 20
}  ;	// From "sha1.h":18

typedef
enum  {
	Unauthorized,
	Authorized
}  PortStatus;	// From "eapol_sm.h":20

typedef
enum  {
	Auto,
	ForceUnauthorized,
	ForceAuthorized
}  PortControl;	// From "eapol_sm.h":21

	// Rabbit note: enumified defines in struct before required_keys
	enum  {
		EAPOL_REQUIRE_KEY_UNICAST = (1<<(0))
	}  ; // Anon union

	enum  {
		EAPOL_REQUIRE_KEY_BROADCAST = (1<<(1))
	}  ; // Anon union
struct eapol_config {
	int accept_802_1x_keys;
	int required_keys;
	int fast_reauth;
	unsigned int workaround;
	int eap_disabled;

} ;	// From "eapol_sm.h":62

struct eapol_ctx {
	void __far * ctx;
	int preauth;
	void (FUNCPTR cb)( /* struct eapol_sm far * eapol, int success, void far * ctx */ );
	void __far * cb_ctx;
	void __far * msg_ctx;
#ifdef WPA_USE_SCARD_GSIM
	void __far * scard_ctx;
#endif//def WPA_USE_SCARD_GSIM
	void __far * eapol_send_ctx;
	void (FUNCPTR eapol_done_cb)( /* void far * ctx */ );
	int (FUNCPTR eapol_send)( /* void far * ctx, int type, char far * buf, size_t len */ );
	int (FUNCPTR set_wep_key)( /* void far * ctx, int unicast, int keyidx, char far * key,
                               size_t keylen */ );
	void (FUNCPTR set_config_blob)( /* void far * ctx, struct wpa_config_blob far * blob */ );
	struct wpa_config_blob __far * (FUNCPTR get_config_blob)( /* void far * ctx, char far * name */ );
	void (FUNCPTR aborted_cached)( /* void far * ctx */ );
	char __far * opensc_engine_path;
	char __far * pkcs11_engine_path;
	char __far * pkcs11_module_path;

} ;	// From "eapol_sm.h":200

struct eap_hdr {
	char code;
	char identifier;
	word length;

} ;	// From "eap_defs.h":29

enum  {
	EAP_CODE_REQUEST = 1,
	EAP_CODE_RESPONSE = 2,
	EAP_CODE_SUCCESS = 3,
	EAP_CODE_FAILURE = 4
}  ;	// From "eap_defs.h":36

typedef
enum  {
	EAP_TYPE_NONE = 0,
	EAP_TYPE_IDENTITY = 1,
	EAP_TYPE_NOTIFICATION = 2,
	EAP_TYPE_NAK = 3,
	EAP_TYPE_MD5 = 4,
	EAP_TYPE_OTP = 5,
	EAP_TYPE_GTC = 6,
	EAP_TYPE_TLS = 13,
	EAP_TYPE_LEAP = 17,
	EAP_TYPE_SIM = 18,
	EAP_TYPE_TTLS = 21,
	EAP_TYPE_AKA = 23,
	EAP_TYPE_PEAP = 25,
	EAP_TYPE_MSCHAPV2 = 26,
	EAP_TYPE_TLV = 33,
	EAP_TYPE_FAST = 43,
	EAP_TYPE_PAX = 46,
	EAP_TYPE_PSK = 47,
	EAP_TYPE_SAKE = 48,
	EAP_TYPE_EXPANDED = 254,
	EAP_TYPE_GPSK = 255
}  EapType;	// From "eap_defs.h":64

enum  {
	EAP_VENDOR_IETF = 0
}  ;	// From "eap_defs.h":70

enum  {
	EAP_EMSK_LEN = 64
}  ;	// From "eap_defs.h":73
/*** EndHeader */

/*** BeginHeader */

struct eap_method_type {
	int vendor;
	longword method;

} ;	// From "eap.h":29

enum eapol_bool_var {
	EAPOL_eapSuccess,
	EAPOL_eapRestart,
	EAPOL_eapFail,
	EAPOL_eapResp,
	EAPOL_eapNoResp,
	EAPOL_eapReq,
	EAPOL_portEnabled,
	EAPOL_altAccept,
	EAPOL_altReject
}  ;	// From "eap.h":104

enum eapol_int_var {
	EAPOL_idleWhile
}  ;	// From "eap.h":125

struct eapol_callbacks {
	struct wpa_ssid __far * (FUNCPTR get_config)( /* void far * ctx */ );
	Boolean (FUNCPTR get_bool)( /* void far * ctx, enum eapol_bool_var variable */ );
	void (FUNCPTR set_bool)( /* void far * ctx, enum eapol_bool_var variable, Boolean value */ );
	unsigned int (FUNCPTR get_int)( /* void far * ctx, enum eapol_int_var variable */ );
	void (FUNCPTR set_int)( /* void far * ctx, enum eapol_int_var variable, unsigned int value */ );
	char __far * (FUNCPTR get_eapReqData)( /* void far * ctx, size_t far * len */ );
	void (FUNCPTR set_config_blob)( /* void far * ctx, struct wpa_config_blob far * blob */ );
	struct wpa_config_blob __far * (FUNCPTR get_config_blob)( /* void far * ctx, char far * name */ );
	void (FUNCPTR notify_pending)( /* void far * ctx */ );

} ;	// From "eap.h":214

struct eap_config {
	char __far * opensc_engine_path;
	char __far * pkcs11_engine_path;
	char __far * pkcs11_module_path;

} ;	// From "eap.h":238

enum  {
   // Rabbit note: enum initializer should be of type int.
	ETH_P_EAPOL = (int) 0x888e
}  ;	// From "l2_packet.h":28

enum  {
   // Rabbit note: enum initializer should be of type int.
	ETH_P_RSN_PREAUTH = (int) 0x88c7
}  ;	// From "l2_packet.h":32

enum  {
	WPA_CIPHER_NONE = (1<<(0))
}  ;	// From "config_ssid.h":22

enum  {
	WPA_CIPHER_WEP40 = (1<<(1))
}  ;	// From "config_ssid.h":23

enum  {
	WPA_CIPHER_WEP104 = (1<<(2))
}  ;	// From "config_ssid.h":24

enum  {
	WPA_CIPHER_TKIP = (1<<(3))
}  ;	// From "config_ssid.h":25

enum  {
	WPA_CIPHER_CCMP = (1<<(4))
}  ;	// From "config_ssid.h":26

enum  {
	WPA_KEY_MGMT_IEEE8021X = (1<<(0))
}  ;	// From "config_ssid.h":31

enum  {
	WPA_KEY_MGMT_PSK = (1<<(1))
}  ;	// From "config_ssid.h":32

enum  {
	WPA_KEY_MGMT_NONE = (1<<(2))
}  ;	// From "config_ssid.h":33

enum  {
	WPA_KEY_MGMT_IEEE8021X_NO_WPA = (1<<(3))
}  ;	// From "config_ssid.h":34

enum  {
	WPA_KEY_MGMT_WPA_NONE = (1<<(4))
}  ;	// From "config_ssid.h":35

enum  {
	WPA_PROTO_WPA = (1<<(0))
}  ;	// From "config_ssid.h":37

enum  {
	WPA_PROTO_RSN = (1<<(1))
}  ;	// From "config_ssid.h":38

enum  {
	WPA_AUTH_ALG_OPEN = (1<<(0))
}  ;	// From "config_ssid.h":40

enum  {
	WPA_AUTH_ALG_SHARED = (1<<(1))
}  ;	// From "config_ssid.h":41

enum  {
	WPA_AUTH_ALG_LEAP = (1<<(2))
}  ;	// From "config_ssid.h":42

enum  {
	MAX_SSID_LEN = 32
}  ;	// From "config_ssid.h":44

enum  {
	PMK_LEN = 32
}  ;	// From "config_ssid.h":45

	// Rabbit note: enumified defines in struct before eapol_flags
	enum  {
		EAPOL_FLAG_REQUIRE_KEY_UNICAST = (1<<(0))
	}  ; // Anon union

	enum  {
		EAPOL_FLAG_REQUIRE_KEY_BROADCAST = (1<<(1))
	}  ; // Anon union
	// Rabbit note: enumified define in struct before wep_tx_keyidx
	enum  {
		NUM_WEP_KEYS = 4
	}  ; // Anon union
	enum  {
		MAX_WEP_KEY_LEN = 16
	}  ; // Anon union

// Rabbit note: The following documentation copied from wpa_supplicant.conf in
// the distro.  It applies to the configuration file, but applies equally to
// the following struct wpa_ssid.
/*
# network block
#
# Each network (usually AP's sharing the same SSID) is configured as a separate
# block in this configuration file. The network blocks are in preference order
# (the first match is used).
#
# network block fields:
#
# disabled:
#	0 = this network can be used (default)
#	1 = this network block is disabled (can be enabled through ctrl_iface,
#	    e.g., with wpa_cli or wpa_gui)
#
# id_str: Network identifier string for external scripts. This value is passed
#	to external action script through wpa_cli as WPA_ID_STR environment
#	variable to make it easier to do network specific configuration.
#
# ssid: SSID (mandatory); either as an ASCII string with double quotation or
#	as hex string; network name
#
# scan_ssid:
#	0 = do not scan this SSID with specific Probe Request frames (default)
#	1 = scan with SSID-specific Probe Request frames (this can be used to
#	    find APs that do not accept broadcast SSID or use multiple SSIDs;
#	    this will add latency to scanning, so enable this only when needed)
#
# bssid: BSSID (optional); if set, this network block is used only when
#	associating with the AP using the configured BSSID
#
# priority: priority group (integer)
# By default, all networks will get same priority group (0). If some of the
# networks are more desirable, this field can be used to change the order in
# which wpa_supplicant goes through the networks when selecting a BSS. The
# priority groups will be iterated in decreasing priority (i.e., the larger the
# priority value, the sooner the network is matched against the scan results).
# Within each priority group, networks will be selected based on security
# policy, signal strength, etc.
# Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are not
# using this priority to select the order for scanning. Instead, they try the
# networks in the order that used in the configuration file.
#
# mode: IEEE 802.11 operation mode
# 0 = infrastructure (Managed) mode, i.e., associate with an AP (default)
# 1 = IBSS (ad-hoc, peer-to-peer)
# Note: IBSS can only be used with key_mgmt NONE (plaintext and static WEP)
# and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In addition, ap_scan has
# to be set to 2 for IBSS. WPA-None requires following network block options:
# proto=WPA, key_mgmt=WPA-NONE, pairwise=NONE, group=TKIP (or CCMP, but not
# both), and psk must also be set.
#
# proto: list of accepted protocols
# WPA = WPA/IEEE 802.11i/D3.0
# RSN = WPA2/IEEE 802.11i (also WPA2 can be used as an alias for RSN)
# If not set, this defaults to: WPA RSN
#
# key_mgmt: list of accepted authenticated key management protocols
# WPA-PSK = WPA pre-shared key (this requires 'psk' field)
# WPA-EAP = WPA using EAP authentication (this can use an external
#	program, e.g., Xsupplicant, for IEEE 802.1X EAP Authentication
# IEEE8021X = IEEE 802.1X using EAP authentication and (optionally) dynamically
#	generated WEP keys
# NONE = WPA is not used; plaintext or static WEP could be used
# If not set, this defaults to: WPA-PSK WPA-EAP
#
# auth_alg: list of allowed IEEE 802.11 authentication algorithms
# OPEN = Open System authentication (required for WPA/WPA2)
# SHARED = Shared Key authentication (requires static WEP keys)
# LEAP = LEAP/Network EAP (only used with LEAP)
# If not set, automatic selection is used (Open System with LEAP enabled if
# LEAP is allowed as one of the EAP methods).
#
# pairwise: list of accepted pairwise (unicast) ciphers for WPA
# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
# NONE = Use only Group Keys (deprecated, should not be included if APs support
#	pairwise keys)
# If not set, this defaults to: CCMP TKIP
#
# group: list of accepted group (broadcast/multicast) ciphers for WPA
# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
# WEP104 = WEP (Wired Equivalent Privacy) with 104-bit key
# WEP40 = WEP (Wired Equivalent Privacy) with 40-bit key [IEEE 802.11]
# If not set, this defaults to: CCMP TKIP WEP104 WEP40
#
# psk: WPA preshared key; 256-bit pre-shared key
# The key used in WPA-PSK mode can be entered either as 64 hex-digits, i.e.,
# 32 bytes or as an ASCII passphrase (in which case, the real PSK will be
# generated using the passphrase and SSID). ASCII passphrase must be between
# 8 and 63 characters (inclusive).
# This field is not needed, if WPA-EAP is used.
# Note: Separate tool, wpa_passphrase, can be used to generate 256-bit keys
# from ASCII passphrase. This process uses lot of CPU and wpa_supplicant
# startup and reconfiguration time can be optimized by generating the PSK only
# only when the passphrase or SSID has actually changed.
#
# eapol_flags: IEEE 802.1X/EAPOL options (bit field)
# Dynamic WEP key required for non-WPA mode
# bit0 (1): require dynamically generated unicast WEP key
# bit1 (2): require dynamically generated broadcast WEP key
# 	(3 = require both keys; default)
# Note: When using wired authentication, eapol_flags must be set to 0 for the
# authentication to be completed successfully.
#
# mixed_cell: This option can be used to configure whether so called mixed
# cells, i.e., networks that use both plaintext and encryption in the same
# SSID, are allowed when selecting a BSS form scan results.
# 0 = disabled (default)
# 1 = enabled
#
# proactive_key_caching:
# Enable/disable opportunistic PMKSA caching for WPA2.
# 0 = disabled (default)
# 1 = enabled
#
# wep_key0..3: Static WEP key (ASCII in double quotation, e.g. "abcde" or
# hex without quotation, e.g., 0102030405)
# wep_tx_keyidx: Default WEP key index (TX) (0..3)
#
# peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e DLS) is
# allowed. This is only used with RSN/WPA2.
# 0 = disabled (default)
# 1 = enabled
#peerkey=1
#
# Following fields are only used with internal EAP implementation.
# eap: space-separated list of accepted EAP methods
#	MD5 = EAP-MD5 (unsecure and does not generate keying material ->
#			cannot be used with WPA; to be used as a Phase 2 method
#			with EAP-PEAP or EAP-TTLS)
#  MSCHAPV2 = EAP-MSCHAPv2 (cannot be used separately with WPA; to be used
#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
#  OTP = EAP-OTP (cannot be used separately with WPA; to be used
#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
#  GTC = EAP-GTC (cannot be used separately with WPA; to be used
#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
#	TLS = EAP-TLS (client and server certificate)
#	PEAP = EAP-PEAP (with tunnelled EAP authentication)
#	TTLS = EAP-TTLS (with tunnelled EAP or PAP/CHAP/MSCHAP/MSCHAPV2
#			 authentication)
#	If not set, all compiled in methods are allowed.
#
# identity: Identity string for EAP
# anonymous_identity: Anonymous identity string for EAP (to be used as the
#	unencrypted identity with EAP types that support different tunnelled
#	identity, e.g., EAP-TTLS)
# password: Password string for EAP
# ca_cert: File path to CA certificate file (PEM/DER). This file can have one
#	or more trusted CA certificates. If ca_cert and ca_path are not
#	included, server certificate will not be verified. This is insecure and
#	a trusted CA certificate should always be configured when using
#	EAP-TLS/TTLS/PEAP. Full path should be used since working directory may
#	change when wpa_supplicant is run in the background.
#	On Windows, trusted CA certificates can be loaded from the system
#	certificate store by setting this to cert_store://<name>, e.g.,
#	ca_cert="cert_store://CA" or ca_cert="cert_store://ROOT".
#	Note that when running wpa_supplicant as an application, the user
#	certificate store (My user account) is used, whereas computer store
#	(Computer account) is used when running wpasvc as a service.
# ca_path: Directory path for CA certificate files (PEM). This path may
#	contain multiple CA certificates in OpenSSL format. Common use for this
#	is to point to system trusted CA list which is often installed into
#	directory like /etc/ssl/certs. If configured, these certificates are
#	added to the list of trusted CAs. ca_cert may also be included in that
#	case, but it is not required.
# client_cert: File path to client certificate file (PEM/DER)
#	Full path should be used since working directory may change when
#	wpa_supplicant is run in the background.
#	Alternatively, a named configuration blob can be used by setting this
#	to blob://<blob name>.
# private_key: File path to client private key file (PEM/DER/PFX)
#	When PKCS#12/PFX file (.p12/.pfx) is used, client_cert should be
#	commented out. Both the private key and certificate will be read from
#	the PKCS#12 file in this case. Full path should be used since working
#	directory may change when wpa_supplicant is run in the background.
#	Windows certificate store can be used by leaving client_cert out and
#	configuring private_key in one of the following formats:
#	cert://substring_to_match
#	hash://certificate_thumbprint_in_hex
#	for example: private_key="hash://63093aa9c47f56ae88334c7b65a4"
#	Note that when running wpa_supplicant as an application, the user
#	certificate store (My user account) is used, whereas computer store
#	(Computer account) is used when running wpasvc as a service.
#	Alternatively, a named configuration blob can be used by setting this
#	to blob://<blob name>.
# private_key_passwd: Password for private key file (if left out, this will be
#	asked through control interface)
# dh_file: File path to DH/DSA parameters file (in PEM format)
#	This is an optional configuration file for setting parameters for an
#	ephemeral DH key exchange. In most cases, the default RSA
#	authentication does not use this configuration. However, it is possible
#	setup RSA to use ephemeral DH key exchange. In addition, ciphers with
#	DSA keys always use ephemeral DH keys. This can be used to achieve
#	forward secrecy. If the file is in DSA parameters format, it will be
#	automatically converted into DH params.
# subject_match: Substring to be matched against the subject of the
#	authentication server certificate. If this string is set, the server
#	sertificate is only accepted if it contains this string in the subject.
#	The subject string is in following format:
#	/C=US/ST=CA/L=San Francisco/CN=Test AS/emailAddress=as@example.com
# altsubject_match: Semicolon separated string of entries to be matched against
#	the alternative subject name of the authentication server certificate.
#	If this string is set, the server sertificate is only accepted if it
#	contains one of the entries in an alternative subject name extension.
#	altSubjectName string is in following format: TYPE:VALUE
#	Example: EMAIL:server@example.com
#	Example: DNS:server.example.com;DNS:server2.example.com
#	Following types are supported: EMAIL, DNS, URI
# phase1: Phase1 (outer authentication, i.e., TLS tunnel) parameters
#	(string with field-value pairs, e.g., "peapver=0" or
#	"peapver=1 peaplabel=1")
#	'peapver' can be used to force which PEAP version (0 or 1) is used.
#	'peaplabel=1' can be used to force new label, "client PEAP encryption",
#	to be used during key derivation when PEAPv1 or newer. Most existing
#	PEAPv1 implementation seem to be using the old label, "client EAP
#	encryption", and wpa_supplicant is now using that as the default value.
#	Some servers, e.g., Radiator, may require peaplabel=1 configuration to
#	interoperate with PEAPv1; see eap_testing.txt for more details.
#	'peap_outer_success=0' can be used to terminate PEAP authentication on
#	tunneled EAP-Success. This is required with some RADIUS servers that
#	implement draft-josefsson-pppext-eap-tls-eap-05.txt (e.g.,
#	Lucent NavisRadius v4.4.0 with PEAP in "IETF Draft 5" mode)
#	include_tls_length=1 can be used to force wpa_supplicant to include
#	TLS Message Length field in all TLS messages even if they are not
#	fragmented.
#	sim_min_num_chal=3 can be used to configure EAP-SIM to require three
#	challenges (by default, it accepts 2 or 3)
# phase2: Phase2 (inner authentication with TLS tunnel) parameters
#	(string with field-value pairs, e.g., "auth=MSCHAPV2" for EAP-PEAP or
#	"autheap=MSCHAPV2 autheap=MD5" for EAP-TTLS)
# Following certificate/private key fields are used in inner Phase2
# authentication when using EAP-TTLS or EAP-PEAP.
# ca_cert2: File path to CA certificate file. This file can have one or more
#	trusted CA certificates. If ca_cert2 and ca_path2 are not included,
#	server certificate will not be verified. This is insecure and a trusted
#	CA certificate should always be configured.
# ca_path2: Directory path for CA certificate files (PEM)
# client_cert2: File path to client certificate file
# private_key2: File path to client private key file
# private_key2_passwd: Password for private key file
# dh_file2: File path to DH/DSA parameters file (in PEM format)
# subject_match2: Substring to be matched against the subject of the
#	authentication server certificate.
# altsubject_match2: Substring to be matched against the alternative subject
#	name of the authentication server certificate.
#
# fragment_size: Maximum EAP fragment size in bytes (default 1398).
#	This value limits the fragment size for EAP methods that support
#	fragmentation (e.g., EAP-TLS and EAP-PEAP). This value should be set
#	small enough to make the EAP messages fit in MTU of the network
#	interface used for EAPOL. The default value is suitable for most
#	cases.
#
# EAP-PSK variables:
# eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
# nai: user NAI
#
# EAP-PAX variables:
# eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
#
# EAP-SAKE variables:
# eappsk: 32-byte (256-bit, 64 hex digits) pre-shared key in hex format
#	(this is concatenation of Root-Secret-A and Root-Secret-B)
# nai: user NAI (PEERID)
#
# EAP-GPSK variables:
# eappsk: Pre-shared key in hex format (at least 128 bits, i.e., 32 hex digits)
# nai: user NAI (ID_Client)
#
# EAP-FAST variables:
# pac_file: File path for the PAC entries. wpa_supplicant will need to be able
#	to create this file and write updates to it when PAC is being
#	provisioned or refreshed. Full path to the file should be used since
#	working directory may change when wpa_supplicant is run in the
#	background. Alternatively, a named configuration blob can be used by
#	setting this to blob://<blob name>
# phase1: fast_provisioning=1 option enables in-line provisioning of EAP-FAST
#	credentials (PAC)
#
# wpa_supplicant supports number of "EAP workarounds" to work around
# interoperability issues with incorrectly behaving authentication servers.
# These are enabled by default because some of the issues are present in large
# number of authentication servers. Strict EAP conformance mode can be
# configured by disabling workarounds with eap_workaround=0.
*/

struct wpa_ssid {
	struct wpa_ssid __far * next;
	struct wpa_ssid __far * pnext;
	int id;
	int priority;
	char __far * ssid;
	size_t ssid_len;
	char bssid[6];
	int bssid_set;
	// Rabbit note: changing to a pointer so that we don't need to update it twice
	//char psk[PMK_LEN];
	char __far *psk;
	int psk_set;
	char __far * passphrase;
	int pairwise_cipher;
	int group_cipher;
	int key_mgmt;
	int proto;
	int auth_alg;
	int scan_ssid;
	char __far * identity;
	size_t identity_len;
	char __far * anonymous_identity;
	size_t anonymous_identity_len;
	char __far * eappsk;
	size_t eappsk_len;
	char __far * nai;
	size_t nai_len;
	char __far * password;
	size_t password_len;
// Rabbit note: changed to use "blob" (binary) form
	struct SSL_Cert_t_t __far * ca_cert_blob;
	size_t ca_cert_blob_len;
	struct SSL_Cert_t_t __far * client_cert_blob;	// this includes private key
	size_t client_cert_blob_len;
/*
	char far * ca_cert;
	char far * ca_path;
	char far * client_cert;
	char far * private_key;
	char far * private_key_passwd;
*/
	char __far * dh_file;
	char __far * subject_match;
	char __far * altsubject_match;
// Rabbit note: changed to use "blob" (binary) form
	SSL_Cert_t __far * ca_cert_blob2;
	size_t ca_cert_blob_len2;
	SSL_Cert_t __far * client_cert_blob2;	// this includes private key
	size_t client_cert_blob_len2;
/*
	char far * ca_cert2;
	char far * ca_path2;
	char far * client_cert2;
	char far * private_key2;
	char far * private_key2_passwd;
*/
	char __far * dh_file2;
	char __far * subject_match2;
	char __far * altsubject_match2;
	struct eap_method_type __far * eap_methods;
	char __far * phase1;
	char __far * phase2;
	char __far * pcsc;
	char __far * pin;
	int engine;
	char __far * engine_id;
	char __far * key_id;
	int eapol_flags;
// Rabbit note: changed to be pointers to static parm array
	char __far (* wep_key)[WLN_WEP104_SIZE];
	size_t __far * wep_key_len;
/*
	char wep_key[NUM_WEP_KEYS][MAX_WEP_KEY_LEN];
	size_t wep_key_len[NUM_WEP_KEYS];
*/
	int wep_tx_keyidx;
	int proactive_key_caching;
	int mixed_cell;
	char __far * otp;
	size_t otp_len;
	int pending_req_identity;
	int pending_req_password;
	int pending_req_pin;
	int pending_req_new_password;
	int pending_req_passphrase;
	char __far * pending_req_otp;
	size_t pending_req_otp_len;
	int leap;
	int non_leap;
	unsigned int eap_workaround;
	char __far * pac_file;
	int mode;
	int mschapv2_retry;
	char __far * new_password;
	size_t new_password_len;
	int disabled;
	int peerkey;
	int fragment_size;
	char __far * id_str;

} ;	// From "config_ssid.h":854

struct wpa_config_blob {
	char __far * name;
	char __far * data;
	size_t len;
	struct wpa_config_blob __far * next;

} ;	// From "config.h":51

struct wpa_config {
	struct wpa_ssid __far * ssid;
	struct wpa_ssid __far * __far * pssid;
	int num_prio;
	int eapol_version;
	int ap_scan;
	char __far * ctrl_interface;
	char __far * ctrl_interface_group;
	int fast_reauth;
	char __far * opensc_engine_path;
	char __far * pkcs11_engine_path;
	char __far * pkcs11_module_path;
	char __far * driver_param;
	unsigned int dot11RSNAConfigPMKLifetime;
	unsigned int dot11RSNAConfigPMKReauthThreshold;
	unsigned int dot11RSNAConfigSATimeout;
	int update_config;
	struct wpa_config_blob __far * blobs;

} ;	// From "config.h":273

// Rabbit note: define added
#define pmksa_cache_max_entries 8

/*** EndHeader */

/*** BeginHeader wpa_config_set_blob */
// From "wpa_all.c":625
void wpa_config_set_blob(struct wpa_config __far * config, struct wpa_config_blob __far * blob);
/*** EndHeader */
_wpa_debug
void wpa_config_set_blob(struct wpa_config __far * config, struct wpa_config_blob __far * blob) {
	wpa_config_remove_blob(config, blob->name);
	blob->next = config->blobs;
	config->blobs = blob;
}

/*** BeginHeader wpa_config_free_blob */
// From "wpa_all.c":638
void wpa_config_free_blob(struct wpa_config_blob __far * blob);
/*** EndHeader */
_wpa_debug
void wpa_config_free_blob(struct wpa_config_blob __far * blob) {
	if (blob) {
		_sys_free(blob->name);
		_sys_free(blob->data);
		_sys_free(blob);
	}
}

/*** BeginHeader wpa_config_remove_blob */
// From "wpa_all.c":654
int wpa_config_remove_blob(struct wpa_config __far * config, char __far * name);
/*** EndHeader */
_wpa_debug
int wpa_config_remove_blob(struct wpa_config __far * config, char __far * name) {
	struct wpa_config_blob __far * pos /* = config->blobs */; 	// From "wpa_all.c":656
	struct wpa_config_blob __far * prev /* = ((void  far * )0) */; 	// From "wpa_all.c":656

	pos = config->blobs;
	prev = ((void  __far * )0);

	while (pos) {
		if (strcmp(pos->name, name)==0) {
			if (prev)
				prev->next = pos->next;
			else
				config->blobs = pos->next;
			wpa_config_free_blob(pos);
			return 0;
		}
		prev = pos;
		pos = pos->next;
	}
	return  -1;
}

/*** BeginHeader wpa_config_get_blob */
// From "wpa_all.c":680
struct wpa_config_blob __far * wpa_config_get_blob(struct wpa_config __far * config,
                                                 char __far * name);
/*** EndHeader */
_wpa_debug
struct wpa_config_blob __far * wpa_config_get_blob(struct wpa_config __far * config,
                                                 char __far * name) {
	struct wpa_config_blob __far * blob /* = config->blobs */; 	// From "wpa_all.c":683

	blob = config->blobs;

	while (blob) {
		if (strcmp(blob->name, name)==0)
			return blob;
		blob = blob->next;
	}
	return ((void  __far * )0);
}

/*** BeginHeader wpa_config_alloc_empty */
// From "wpa_all.c":701
struct wpa_config __far * wpa_config_alloc_empty(char __far * ctrl_interface, char __far * driver_param);
/*** EndHeader */
_wpa_debug
struct wpa_config __far * wpa_config_alloc_empty(char __far * ctrl_interface, char __far * driver_param) {
	struct wpa_config __far * config; 	// From "wpa_all.c":704


	config = _sys_calloc(sizeof (*config));
	if (config==((void  __far * )0))
		return ((void  __far * )0);
	config->eapol_version = 1;
	config->ap_scan = 1;
	config->fast_reauth = 1;
	if (ctrl_interface)
		config->ctrl_interface = _sys_strdup(ctrl_interface);
	if (driver_param)
		config->driver_param = _sys_strdup(driver_param);
	return config;
}

/*** BeginHeader wpa_config_free_ssid */
// From "wpa_all.c":728
void wpa_config_free_ssid(struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
void wpa_config_free_ssid(struct wpa_ssid __far * ssid) {
	// Rabbit note: following not done since we have static parm struct
	/*
	_sys_free(ssid->ssid);
	_sys_free(ssid->passphrase);
	_sys_free(ssid->eap_methods);
	_sys_free(ssid->identity);
	_sys_free(ssid->anonymous_identity);
	_sys_free(ssid->eappsk);
	_sys_free(ssid->nai);
	_sys_free(ssid->password);
	_sys_free(ssid->ca_cert);
	_sys_free(ssid->ca_path);
	_sys_free(ssid->client_cert);
	_sys_free(ssid->private_key);
	_sys_free(ssid->private_key_passwd);
	_sys_free(ssid->dh_file);
	_sys_free(ssid->subject_match);
	_sys_free(ssid->altsubject_match);
	_sys_free(ssid->ca_cert2);
	_sys_free(ssid->ca_path2);
	_sys_free(ssid->client_cert2);
	_sys_free(ssid->private_key2);
	_sys_free(ssid->private_key2_passwd);
	_sys_free(ssid->dh_file2);
	_sys_free(ssid->subject_match2);
	_sys_free(ssid->altsubject_match2);
	_sys_free(ssid->phase1);
	_sys_free(ssid->phase2);
	_sys_free(ssid->pcsc);
	_sys_free(ssid->pin);
	_sys_free(ssid->engine_id);
	_sys_free(ssid->key_id);
	_sys_free(ssid->otp);
	_sys_free(ssid->pending_req_otp);
	_sys_free(ssid->pac_file);
	_sys_free(ssid->new_password);
	_sys_free(ssid->id_str);
	_sys_free(ssid);
	*/
}

/*** BeginHeader wpa_config_free */
// From "wpa_all.c":778
void wpa_config_free(struct wpa_config __far * config);
/*** EndHeader */
_wpa_debug
void wpa_config_free(struct wpa_config __far * config) {
	struct wpa_config_blob __far * blob; 	// From "wpa_all.c":780
	struct wpa_config_blob __far * prevblob; 	// From "wpa_all.c":780
	struct wpa_ssid __far * ssid; 	// From "wpa_all.c":781
	struct wpa_ssid __far * prev /* = ((void  far * )0) */; 	// From "wpa_all.c":781

	prev = ((void  __far * )0);

	ssid = config->ssid;
	while (ssid) {
		prev = ssid;
		ssid = ssid->next;
		wpa_config_free_ssid(prev);
	}
	blob = config->blobs;
	prevblob = ((void  __far * )0);
	while (blob) {
		prevblob = blob;
		blob = blob->next;
		wpa_config_free_blob(prevblob);
	}
	// Rabbit note: following not done since we have static parm struct
	/*
	_sys_free(config->ctrl_interface);
	_sys_free(config->ctrl_interface_group);
	_sys_free(config->opensc_engine_path);
	_sys_free(config->pkcs11_engine_path);
	_sys_free(config->pkcs11_module_path);
	_sys_free(config->driver_param);
	_sys_free(config->pssid);
	_sys_free(config);
	*/
}

/*** BeginHeader wpa_config_allowed_eap_method */
// From "wpa_all.c":815
int wpa_config_allowed_eap_method(struct wpa_ssid __far * ssid, int vendor, longword method);
/*** EndHeader */
_wpa_debug
int wpa_config_allowed_eap_method(struct wpa_ssid __far * ssid, int vendor, longword method) {
	int i; 	// From "wpa_all.c":818
	struct eap_method_type __far * m; 	// From "wpa_all.c":819


	if (ssid==((void  __far * )0) ||
	ssid->eap_methods==((void  __far * )0))
		return 1;
	m = ssid->eap_methods;
	for (i = 0; m[i].vendor!=EAP_VENDOR_IETF ||
	m[i].method!=EAP_TYPE_NONE; i++) {
		if (m[i].vendor==vendor &&
		m[i].method==method)
			return 1;
	}
	return 0;
}
// @ TUName[]  ; -- translator directive
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

typedef
enum  {
	DECISION_FAIL,
	DECISION_COND_SUCC,
	DECISION_UNCOND_SUCC
}  EapDecision;	// From "eap_i.h":24

typedef
enum  {
	METHOD_NONE,
	METHOD_INIT,
	METHOD_CONT,
	METHOD_MAY_CONT,
	METHOD_DONE
}  EapMethodState;	// From "eap_i.h":28

struct eap_method_ret {
	Boolean ignore;
	EapMethodState methodState;
	EapDecision decision;
	Boolean allowNotifications;

} ;	// From "eap_i.h":58

struct eap_method {
	int vendor;
	EapType method;
	char __far * name;
	void __far * (FUNCPTR init)( /* struct eap_sm far * sm */ );
	void (FUNCPTR deinit)( /* struct eap_sm far * sm, void far * priv */ );
	char __far * (FUNCPTR process)( /* struct eap_sm far * sm, void far * priv, struct eap_method_ret far * ret,
                                  char far * reqData, size_t reqDataLen, size_t far * respDataLen */ );
	Boolean (FUNCPTR isKeyAvailable)( /* struct eap_sm far * sm, void far * priv */ );
	char __far * (FUNCPTR getKey)( /* struct eap_sm far * sm, void far * priv, size_t far * len */ );
	int (FUNCPTR get_status)( /* struct eap_sm far * sm, void far * priv, char far * buf,
                              size_t buflen, int verbose */ );
	Boolean (FUNCPTR has_reauth_data)( /* struct eap_sm far * sm, void far * priv */ );
	void (FUNCPTR deinit_for_reauth)( /* struct eap_sm far * sm, void far * priv */ );
	void __far * (FUNCPTR init_for_reauth)( /* struct eap_sm far * sm, void far * priv */ );
	char __far * (FUNCPTR get_identity)( /* struct eap_sm far * sm, void far * priv,
                                       size_t far * len */ );
	void (FUNCPTR sys_free)( /* struct eap_method far * method */ );
	int version;
	struct eap_method __far * next;
	char __far * (FUNCPTR get_emsk)( /* struct eap_sm far * sm, void far * priv, size_t far * len */ );

} ;	// From "eap_i.h":271

struct eap_sm {

	enum  {
		EAP_INITIALIZE,
		EAP_DISABLED,
		EAP_IDLE,
		EAP_RECEIVED,
		EAP_GET_METHOD,
		EAP_METHOD,
		EAP_SEND_RESPONSE,
		EAP_DISCARD,
		EAP_IDENTITY,
		EAP_NOTIFICATION,
		EAP_RETRANSMIT,
		EAP_SUCCESS,
		EAP_FAILURE
	}  EAP_state;
	EapType selectedMethod;
	EapMethodState methodState;
	int lastId;
	char __far * lastRespData;
	size_t lastRespDataLen;
	EapDecision decision;
	Boolean rxReq;
	Boolean rxSuccess;
	Boolean rxFailure;
	int reqId;
	EapType reqMethod;
	int reqVendor;
	longword reqVendorMethod;
	Boolean ignore;
	int ClientTimeout;
	Boolean allowNotifications;
	char __far * eapRespData;
	size_t eapRespDataLen;
	Boolean eapKeyAvailable;
	char __far * eapKeyData;
	size_t eapKeyDataLen;
	struct eap_method __far * m;
	Boolean changed;
	void __far * eapol_ctx;
	struct eapol_callbacks __far * eapol_cb;
	void __far * eap_method_priv;
	int init_phase2;
	int fast_reauth;
	Boolean rxResp;
	Boolean leap_done;
	Boolean peap_done;
	char req_md5[16];
	char last_md5[16];
	void __far * msg_ctx;
#ifdef WPA_USE_SCARD_GSIM
	void __far * scard_ctx;
#endif//def WPA_USE_SCARD_GSIM
	void __far * ssl_ctx;
	unsigned int workaround;
	char __far * peer_challenge;
	char __far * auth_challenge;
	int mschapv2_full_key;
	int num_rounds;
	int force_disabled;

} ;	// From "eap_i.h":338

#ifdef WPA_USE_EAP
#if 0	// Rabbit note: already defined in SSL_TPORT.LIB
struct tls_keys {
	char __far * master_key;
	size_t master_key_len;
	char __far * client_random;
	size_t client_random_len;
	char __far * server_random;
	size_t server_random_len;
	char __far * inner_secret;
	size_t inner_secret_len;

} ;	// From "tls.h":29

struct tls_config {
	char __far * opensc_engine_path;
	char __far * pkcs11_engine_path;
	char __far * pkcs11_module_path;

} ;	// From "tls.h":35

struct tls_connection_params {
	char __far * ca_cert;
	char __far * ca_cert_blob;
	size_t ca_cert_blob_len;
	char __far * ca_path;
	char __far * subject_match;
	char __far * altsubject_match;
	char __far * client_cert;
	char __far * client_cert_blob;
	size_t client_cert_blob_len;
	char __far * private_key;
	char __far * private_key_blob;
	size_t private_key_blob_len;
	char __far * private_key_passwd;
	char __far * dh_file;
	char __far * dh_blob;
	size_t dh_blob_len;
	int tls_ia;
	int engine;
	char __far * engine_id;
	char __far * pin;
	char __far * key_id;

} ;	// From "tls.h":101

enum  {
	TLS_SET_PARAMS_ENGINE_PRV_VERIFY_FAILED =  -3,
	TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED =  -2
}  ;	// From "tls.h":179
#endif //
#endif//def WPA_USE_EAP

enum  {
	EAP_MAX_AUTH_ROUNDS = 50
}  ;	// From "eap.c":38
/*** EndHeader */

/*** BeginHeader _wpa_s6_eapol_get_bool */
// From "eap.c":55
Boolean _wpa_s6_eapol_get_bool(struct eap_sm __far * sm, enum eapol_bool_var var);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s6_eapol_get_bool(struct eap_sm __far * sm, enum eapol_bool_var var) {
	return sm->eapol_cb->get_bool((void  __far * )(sm->eapol_ctx), (enum eapol_bool_var  )(var));
}

/*** BeginHeader _wpa_s6_eapol_set_bool */
// From "eap.c":61
void _wpa_s6_eapol_set_bool(struct eap_sm __far * sm, enum eapol_bool_var var, Boolean value);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eapol_set_bool(struct eap_sm __far * sm, enum eapol_bool_var var, Boolean value) {
	sm->eapol_cb->set_bool((void  __far * )(sm->eapol_ctx), (enum eapol_bool_var  )(var),
                        (Boolean  )(value));
}

/*** BeginHeader _wpa_s6_eapol_get_int */
// From "eap.c":68
unsigned int _wpa_s6_eapol_get_int(struct eap_sm __far * sm, enum eapol_int_var var);
/*** EndHeader */
_wpa_debug
unsigned int _wpa_s6_eapol_get_int(struct eap_sm __far * sm, enum eapol_int_var var) {
	return sm->eapol_cb->get_int((void  __far * )(sm->eapol_ctx), (enum eapol_int_var  )(var));
}

/*** BeginHeader _wpa_s6_eapol_set_int */
// From "eap.c":74
void _wpa_s6_eapol_set_int(struct eap_sm __far * sm, enum eapol_int_var var, unsigned int value);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eapol_set_int(struct eap_sm __far * sm, enum eapol_int_var var, unsigned int value) {
	sm->eapol_cb->set_int((void  __far * )(sm->eapol_ctx), (enum eapol_int_var  )(var),
                       (unsigned int  )(value));
}

/*** BeginHeader _wpa_s6_eapol_get_eapReqData */
// From "eap.c":81
char __far * _wpa_s6_eapol_get_eapReqData(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s6_eapol_get_eapReqData(struct eap_sm __far * sm, size_t __far * len) {
	return sm->eapol_cb->get_eapReqData((void  __far * )(sm->eapol_ctx), (size_t  __far * )(len));
}

/*** BeginHeader _wpa_s6_eap_deinit_prev_method */
// From "eap.c":87
void _wpa_s6_eap_deinit_prev_method(struct eap_sm __far * sm, char __far * txt);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eap_deinit_prev_method(struct eap_sm __far * sm, char __far * txt) {
	if (sm->m==((void  __far * )0) ||
	sm->eap_method_priv==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "EAP: deinitialize previously used EAP method (%d, %ls) at %ls" ,
              sm->selectedMethod, (char  __far * )(sm->m->name), (char  __far * )(txt)));
	sm->m->deinit((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv));
	sm->eap_method_priv = ((void  __far * )0);
	sm->m = ((void  __far * )0);
}

/*** BeginHeader _wpa_s6_sm_EAP_INITIALIZE_Enter */
// From "eap.c":105
void _wpa_s6_sm_EAP_INITIALIZE_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_INITIALIZE_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_INITIALIZE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "INITIALIZE" ));
	}
	sm->EAP_state = EAP_INITIALIZE;
	;
	if (sm->fast_reauth &&
	sm->m &&
	sm->m->has_reauth_data &&
	sm->m->has_reauth_data((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv))) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: maintaining EAP method data for " \
		 "fast reauthentication" ));
		sm->m->deinit_for_reauth((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv));
	}
	else {
		_wpa_s6_eap_deinit_prev_method(sm, "INITIALIZE" );
	}
	sm->selectedMethod = EAP_TYPE_NONE;
	sm->methodState = METHOD_NONE;
	sm->allowNotifications = TRUE;
	sm->decision = DECISION_FAIL;
	_wpa_s6_eapol_set_int(sm, EAPOL_idleWhile, sm->ClientTimeout);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapSuccess, FALSE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapFail, FALSE);
	_sys_free(sm->eapKeyData);
	sm->eapKeyData = ((void  __far * )0);
	sm->eapKeyAvailable = FALSE;
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapRestart, FALSE);
	sm->lastId =  -1;
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapResp, FALSE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapNoResp, FALSE);
	sm->num_rounds = 0;
}

/*** BeginHeader _wpa_s6_sm_EAP_DISABLED_Enter */
// From "eap.c":148
void _wpa_s6_sm_EAP_DISABLED_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_DISABLED_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_DISABLED) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "DISABLED" ));
	}
	sm->EAP_state = EAP_DISABLED;
	;
	sm->num_rounds = 0;
}

/*** BeginHeader _wpa_s6_sm_EAP_IDLE_Enter */
// From "eap.c":160
void _wpa_s6_sm_EAP_IDLE_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_IDLE_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_IDLE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "IDLE" ));
	}
	sm->EAP_state = EAP_IDLE;
	;
}

/*** BeginHeader _wpa_s6_sm_EAP_RECEIVED_Enter */
// From "eap.c":170
void _wpa_s6_sm_EAP_RECEIVED_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_RECEIVED_Enter(struct eap_sm __far * sm, int global) {
	char __far * eapReqData; 	// From "eap.c":172
	size_t eapReqDataLen; 	// From "eap.c":173


	if (!global ||
	sm->EAP_state!=EAP_RECEIVED) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "RECEIVED" ));
	}
	sm->EAP_state = EAP_RECEIVED;
	;
	eapReqData = _wpa_s6_eapol_get_eapReqData(sm, &eapReqDataLen);
	_wpa_s6_eap_sm_parseEapReq(sm, eapReqData, eapReqDataLen);
	sm->num_rounds++;
}

/*** BeginHeader _wpa_s6_sm_EAP_GET_METHOD_Enter */
// From "eap.c":187
void _wpa_s6_sm_EAP_GET_METHOD_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_GET_METHOD_Enter(struct eap_sm __far * sm, int global) {
	int reinit; 	// From "eap.c":189
	EapType method; 	// From "eap.c":190

	union  {

		struct  {
			struct wpa_ssid __far * config /* = eap_get_config(sm) */;

		} __s6;

	} __u; 	// From "eap.c":188


	if (!global ||
	sm->EAP_state!=EAP_GET_METHOD) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "GET_METHOD" ));
	}
	sm->EAP_state = EAP_GET_METHOD;
	;
	if (sm->reqMethod==EAP_TYPE_EXPANDED)
		method = (EapType)sm->reqVendorMethod;	// Rabbit mod
	else
		method = sm->reqMethod;
	if (!_wpa_s6_eap_sm_allowMethod(sm, sm->reqVendor, method)) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: vendor %u method %u not allowed" , sm->reqVendor,
               method));
		goto nak;
	}
	if (sm->fast_reauth &&
	sm->m &&
	sm->m->vendor==sm->reqVendor &&
	sm->m->method==method &&
	sm->m->has_reauth_data &&
	sm->m->has_reauth_data((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv))) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: Using previous method data" \
		 " for fast re-authentication" ));
		reinit = 1;
	}
	else {
		_wpa_s6_eap_deinit_prev_method(sm, "GET_METHOD" );
		reinit = 0;
	}
	sm->selectedMethod = sm->reqMethod;
	if (sm->m==((void  __far * )0))
		sm->m = eap_sm_get_eap_methods(sm->reqVendor, method);
	if (!sm->m) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: Could not find selected method: " \
		 "vendor %d method %d" , sm->reqVendor, method));
		goto nak;
	}
	_WPA_PRINTF((MSG_DEBUG, "EAP: Initialize selected EAP method: vendor %u method %u (%ls)" ,
              sm->reqVendor, method, (char  __far * )(sm->m->name)));
	if (reinit)
		sm->eap_method_priv = sm->m->init_for_reauth((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv));
	else
		sm->eap_method_priv = sm->m->init((struct eap_sm  __far * )(sm));
	if (sm->eap_method_priv==((void  __far * )0)) {
		__u.__s6.config = eap_get_config(sm);

		_WPA_MSG((sm->msg_ctx, MSG_INFO, "EAP: Failed to initialize EAP method: vendor %u method %u (%ls)" ,
            sm->reqVendor, method, (char  __far * )(sm->m->name)));
		sm->m = ((void  __far * )0);
		sm->methodState = METHOD_NONE;
		sm->selectedMethod = EAP_TYPE_NONE;
		if (sm->reqMethod==EAP_TYPE_TLS &&
		__u.__s6.config &&
		(__u.__s6.config->pending_req_pin ||
		__u.__s6.config->pending_req_passphrase)) {
			_WPA_PRINTF((MSG_DEBUG, "EAP: Pending PIN/passphrase " \
			 "request - skip Nak" ));
			return /*void*/;
		}
		goto nak;
	}
	sm->methodState = METHOD_INIT;
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "CTRL-EVENT-EAP-METHOD EAP vendor %u method %u (%ls) selected" ,
           sm->reqVendor, method, (char  __far * )(sm->m->name)));
	return /*void*/;
	nak:
	_sys_free(sm->eapRespData);
	sm->eapRespData = ((void  __far * )0);
	sm->eapRespData = _wpa_s6_eap_sm_buildNak(sm, sm->reqId, &sm->eapRespDataLen);
}

/*** BeginHeader _wpa_s6_sm_EAP_METHOD_Enter */
// From "eap.c":287
void _wpa_s6_sm_EAP_METHOD_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_METHOD_Enter(struct eap_sm __far * sm, int global) {
	char __far * eapReqData; 	// From "eap.c":289
	size_t eapReqDataLen; 	// From "eap.c":290
	struct eap_method_ret ret; 	// From "eap.c":291


	if (!global ||
	sm->EAP_state!=EAP_METHOD) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "METHOD" ));
	}
	sm->EAP_state = EAP_METHOD;
	;
	if (sm->m==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "EAP::METHOD - method not selected" ));
		return /*void*/;
	}
	eapReqData = _wpa_s6_eapol_get_eapReqData(sm, &eapReqDataLen);
	_f_memset(&ret, 0, sizeof (ret));
	ret.ignore = sm->ignore;
	ret.methodState = sm->methodState;
	ret.decision = sm->decision;
	ret.allowNotifications = sm->allowNotifications;
	_sys_free(sm->eapRespData);
	sm->eapRespData = ((void  __far * )0);
	sm->eapRespData = sm->m->process((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv),
                                  (struct eap_method_ret  __far * )(&ret), (char  __far * )(eapReqData),
                                  (size_t  )(eapReqDataLen), (size_t  __far * )(&sm->eapRespDataLen));
	_WPA_PRINTF((MSG_DEBUG, "EAP: method process -> ignore=%ls methodState=%ls decision=%ls" ,
              (char  __far * )(ret.ignore ?
	  "TRUE"  :
	  "FALSE" ), (char  __far * )(_wpa_s6_eap_sm_method_state_txt(ret.methodState)),
              (char  __far * )(_wpa_s6_eap_sm_decision_txt(ret.decision))));
   //SJH - because we have non-blocking RSA, application may have brought interface down.
   // Thus, need to check method still set.
   if (!sm->m)
   	return;

	sm->ignore = ret.ignore;
	if (sm->ignore)
		return /*void*/;
	sm->methodState = ret.methodState;
	sm->decision = ret.decision;
	sm->allowNotifications = ret.allowNotifications;
	if (sm->m->isKeyAvailable &&
	sm->m->getKey &&
	sm->m->isKeyAvailable((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv))) {
		_sys_free(sm->eapKeyData);
		sm->eapKeyData = sm->m->getKey((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv),
                                 (size_t  __far * )(&sm->eapKeyDataLen));
	}
}

/*** BeginHeader _wpa_s6_sm_EAP_SEND_RESPONSE_Enter */
// From "eap.c":351
void _wpa_s6_sm_EAP_SEND_RESPONSE_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_SEND_RESPONSE_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_SEND_RESPONSE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "SEND_RESPONSE" ));
	}
	sm->EAP_state = EAP_SEND_RESPONSE;
	;
	_sys_free(sm->lastRespData);
	if (sm->eapRespData) {
		if (sm->workaround)
			_f_memcpy(sm->last_md5, sm->req_md5, 16);
		sm->lastId = sm->reqId;
		sm->lastRespData = _sys_malloc(sm->eapRespDataLen);
		if (sm->lastRespData) {
			_f_memcpy(sm->lastRespData, sm->eapRespData, sm->eapRespDataLen);
			sm->lastRespDataLen = sm->eapRespDataLen;
		}
		_wpa_s6_eapol_set_bool(sm, EAPOL_eapResp, TRUE);
	}
	else
		sm->lastRespData = ((void  __far * )0);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapReq, FALSE);
	_wpa_s6_eapol_set_int(sm, EAPOL_idleWhile, sm->ClientTimeout);
}

/*** BeginHeader _wpa_s6_sm_EAP_DISCARD_Enter */
// From "eap.c":377
void _wpa_s6_sm_EAP_DISCARD_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_DISCARD_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_DISCARD) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "DISCARD" ));
	}
	sm->EAP_state = EAP_DISCARD;
	;
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapReq, FALSE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapNoResp, TRUE);
}

/*** BeginHeader _wpa_s6_sm_EAP_IDENTITY_Enter */
// From "eap.c":388
void _wpa_s6_sm_EAP_IDENTITY_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_IDENTITY_Enter(struct eap_sm __far * sm, int global) {
	char __far * eapReqData; 	// From "eap.c":390
	size_t eapReqDataLen; 	// From "eap.c":391


	if (!global ||
	sm->EAP_state!=EAP_IDENTITY) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "IDENTITY" ));
	}
	sm->EAP_state = EAP_IDENTITY;
	;
	eapReqData = _wpa_s6_eapol_get_eapReqData(sm, &eapReqDataLen);
	_wpa_s6_eap_sm_processIdentity(sm, eapReqData);
	_sys_free(sm->eapRespData);
	sm->eapRespData = ((void  __far * )0);
	sm->eapRespData = eap_sm_buildIdentity(sm, sm->reqId, &sm->eapRespDataLen, 0);
}

/*** BeginHeader _wpa_s6_sm_EAP_NOTIFICATION_Enter */
// From "eap.c":406
void _wpa_s6_sm_EAP_NOTIFICATION_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_NOTIFICATION_Enter(struct eap_sm __far * sm, int global) {
	char __far * eapReqData; 	// From "eap.c":408
	size_t eapReqDataLen; 	// From "eap.c":409


	if (!global ||
	sm->EAP_state!=EAP_NOTIFICATION) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "NOTIFICATION" ));
	}
	sm->EAP_state = EAP_NOTIFICATION;
	;
	eapReqData = _wpa_s6_eapol_get_eapReqData(sm, &eapReqDataLen);
	_wpa_s6_eap_sm_processNotify(sm, eapReqData);
	_sys_free(sm->eapRespData);
	sm->eapRespData = ((void  __far * )0);
	sm->eapRespData = _wpa_s6_eap_sm_buildNotify(sm->reqId, &sm->eapRespDataLen);
}

/*** BeginHeader _wpa_s6_sm_EAP_RETRANSMIT_Enter */
// From "eap.c":423
void _wpa_s6_sm_EAP_RETRANSMIT_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_RETRANSMIT_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_RETRANSMIT) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "RETRANSMIT" ));
	}
	sm->EAP_state = EAP_RETRANSMIT;
	;
	_sys_free(sm->eapRespData);
	if (sm->lastRespData) {
		sm->eapRespData = _sys_malloc(sm->lastRespDataLen);
		if (sm->eapRespData) {
			_f_memcpy(sm->eapRespData, sm->lastRespData, sm->lastRespDataLen);
			sm->eapRespDataLen = sm->lastRespDataLen;
		}
	}
	else
		sm->eapRespData = ((void  __far * )0);
}

/*** BeginHeader _wpa_s6_sm_EAP_SUCCESS_Enter */
// From "eap.c":444
void _wpa_s6_sm_EAP_SUCCESS_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_SUCCESS_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_SUCCESS) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "SUCCESS" ));
	}
	sm->EAP_state = EAP_SUCCESS;
	;
	if (sm->eapKeyData!=((void  __far * )0))
		sm->eapKeyAvailable = TRUE;
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapSuccess, TRUE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapReq, FALSE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapNoResp, TRUE);
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "CTRL-EVENT-EAP-SUCCESS " \
	 "EAP authentication completed successfully" ));
}

/*** BeginHeader _wpa_s6_sm_EAP_FAILURE_Enter */
// From "eap.c":475
void _wpa_s6_sm_EAP_FAILURE_Enter(struct eap_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_FAILURE_Enter(struct eap_sm __far * sm, int global) {
	if (!global ||
	sm->EAP_state!=EAP_FAILURE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAP", "EAP",
		 "FAILURE" ));
	}
	sm->EAP_state = EAP_FAILURE;
	;
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapFail, TRUE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapReq, FALSE);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapNoResp, TRUE);
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "CTRL-EVENT-EAP-FAILURE " \
	 "EAP authentication failed" ));
}

/*** BeginHeader _wpa_s6_eap_success_workaround */
// From "eap.c":499
int _wpa_s6_eap_success_workaround(struct eap_sm __far * sm, int reqId, int lastId);
/*** EndHeader */
_wpa_debug
int _wpa_s6_eap_success_workaround(struct eap_sm __far * sm, int reqId, int lastId) {
	if (sm->workaround &&
	(reqId==((lastId+1)&0xff) ||
	reqId==((lastId+2)&0xff))) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: Workaround for unexpected " \
		 "identifier field in EAP Success: " \
		 "reqId=%d lastId=%d (these are supposed to be " \
		 "same)" , reqId, lastId));
		return 1;
	}
	_WPA_PRINTF((MSG_DEBUG, "EAP: EAP-Success Id mismatch - reqId=%d " \
	 "lastId=%d" , reqId, lastId));
	return 0;
}

/*** BeginHeader _wpa_s6_sm_EAP_Step */
// From "eap.c":528
void _wpa_s6_sm_EAP_Step(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s6_sm_EAP_Step(struct eap_sm __far * sm) {
	int duplicate; 	// From "eap.c":530


	if (_wpa_s6_eapol_get_bool(sm, EAPOL_eapRestart) &&
	_wpa_s6_eapol_get_bool(sm, EAPOL_portEnabled))
		_wpa_s6_sm_EAP_INITIALIZE_Enter(sm, 1);
	else if (!_wpa_s6_eapol_get_bool(sm, EAPOL_portEnabled) ||
	sm->force_disabled)
		_wpa_s6_sm_EAP_DISABLED_Enter(sm, 1);
	else if (sm->num_rounds>EAP_MAX_AUTH_ROUNDS) {
		if (sm->num_rounds==EAP_MAX_AUTH_ROUNDS+1) {
			_WPA_MSG((sm->msg_ctx, MSG_INFO, "EAP: more than %d " \
			 "authentication rounds - abort" , EAP_MAX_AUTH_ROUNDS));
			sm->num_rounds++;
			_wpa_s6_sm_EAP_FAILURE_Enter(sm, 1);
		}
	}
	else
		switch ((int)(sm->EAP_state)) {
			case EAP_INITIALIZE:
			_wpa_s6_sm_EAP_IDLE_Enter(sm, 0);
			break;
			case EAP_DISABLED:
			if (_wpa_s6_eapol_get_bool(sm, EAPOL_portEnabled) &&
			!sm->force_disabled)
				_wpa_s6_sm_EAP_INITIALIZE_Enter(sm, 0);
			break;
			case EAP_IDLE:
			if (_wpa_s6_eapol_get_bool(sm, EAPOL_eapReq))
				_wpa_s6_sm_EAP_RECEIVED_Enter(sm, 0);
			else if ((_wpa_s6_eapol_get_bool(sm, EAPOL_altAccept) &&
			sm->decision!=DECISION_FAIL) ||
			(_wpa_s6_eapol_get_int(sm, EAPOL_idleWhile)==0 &&
			sm->decision==DECISION_UNCOND_SUCC))
				_wpa_s6_sm_EAP_SUCCESS_Enter(sm, 0);
			else if (_wpa_s6_eapol_get_bool(sm, EAPOL_altReject) ||
			(_wpa_s6_eapol_get_int(sm, EAPOL_idleWhile)==0 &&
			sm->decision!=DECISION_UNCOND_SUCC) ||
			(_wpa_s6_eapol_get_bool(sm, EAPOL_altAccept) &&
			sm->methodState!=METHOD_CONT &&
			sm->decision==DECISION_FAIL))
				_wpa_s6_sm_EAP_FAILURE_Enter(sm, 0);
			else if (sm->selectedMethod==EAP_TYPE_LEAP &&
			sm->leap_done &&
			sm->decision!=DECISION_FAIL &&
			sm->methodState==METHOD_DONE)
				_wpa_s6_sm_EAP_SUCCESS_Enter(sm, 0);
			else if (sm->selectedMethod==EAP_TYPE_PEAP &&
			sm->peap_done &&
			sm->decision!=DECISION_FAIL &&
			sm->methodState==METHOD_DONE)
				_wpa_s6_sm_EAP_SUCCESS_Enter(sm, 0);
			break;
			case EAP_RECEIVED:
			duplicate = (sm->reqId==sm->lastId) &&
			sm->rxReq;
			if (sm->workaround &&
			duplicate &&
			memcmp(sm->req_md5, sm->last_md5, 16)!=0) {
				_WPA_PRINTF((MSG_DEBUG, "EAP: AS used the same Id again," \
				 " but EAP packets were not identical" ));
				_WPA_PRINTF((MSG_DEBUG, "EAP: workaround - assume this " \
				 "is not a duplicate packet" ));
				duplicate = 0;
			}
			if (sm->rxSuccess &&
			sm->decision!=DECISION_FAIL &&
			(sm->reqId==sm->lastId ||
			_wpa_s6_eap_success_workaround(sm, sm->reqId, sm->lastId)))
				_wpa_s6_sm_EAP_SUCCESS_Enter(sm, 0);
			else if (sm->methodState!=METHOD_CONT &&
			((sm->rxFailure &&
			sm->decision!=DECISION_UNCOND_SUCC) ||
			(sm->rxSuccess &&
			sm->decision==DECISION_FAIL &&
			(sm->selectedMethod!=EAP_TYPE_LEAP ||
			sm->methodState!=METHOD_MAY_CONT))) &&
			(sm->reqId==sm->lastId ||
			_wpa_s6_eap_success_workaround(sm, sm->reqId, sm->lastId)))
				_wpa_s6_sm_EAP_FAILURE_Enter(sm, 0);
			else if (sm->rxReq &&
			duplicate)
				_wpa_s6_sm_EAP_RETRANSMIT_Enter(sm, 0);
			else if (sm->rxReq &&
			!duplicate &&
			sm->reqMethod==EAP_TYPE_NOTIFICATION &&
			sm->allowNotifications)
				_wpa_s6_sm_EAP_NOTIFICATION_Enter(sm, 0);
			else if (sm->rxReq &&
			!duplicate &&
			sm->selectedMethod==EAP_TYPE_NONE &&
			sm->reqMethod==EAP_TYPE_IDENTITY)
				_wpa_s6_sm_EAP_IDENTITY_Enter(sm, 0);
			else if (sm->rxReq &&
			!duplicate &&
			sm->selectedMethod==EAP_TYPE_NONE &&
			sm->reqMethod!=EAP_TYPE_IDENTITY &&
			sm->reqMethod!=EAP_TYPE_NOTIFICATION)
				_wpa_s6_sm_EAP_GET_METHOD_Enter(sm, 0);
			else if (sm->rxReq &&
			!duplicate &&
			sm->reqMethod==sm->selectedMethod &&
			sm->methodState!=METHOD_DONE)
				_wpa_s6_sm_EAP_METHOD_Enter(sm, 0);
			else if (sm->selectedMethod==EAP_TYPE_LEAP &&
			(sm->rxSuccess ||
			sm->rxResp))
				_wpa_s6_sm_EAP_METHOD_Enter(sm, 0);
			else
				_wpa_s6_sm_EAP_DISCARD_Enter(sm, 0);
			break;
			case EAP_GET_METHOD:
			if (sm->selectedMethod==sm->reqMethod)
				_wpa_s6_sm_EAP_METHOD_Enter(sm, 0);
			else
				_wpa_s6_sm_EAP_SEND_RESPONSE_Enter(sm, 0);
			break;
			case EAP_METHOD:
			if (sm->ignore)
				_wpa_s6_sm_EAP_DISCARD_Enter(sm, 0);
			else
				_wpa_s6_sm_EAP_SEND_RESPONSE_Enter(sm, 0);
			break;
			case EAP_SEND_RESPONSE:
			_wpa_s6_sm_EAP_IDLE_Enter(sm, 0);
			break;
			case EAP_DISCARD:
			_wpa_s6_sm_EAP_IDLE_Enter(sm, 0);
			break;
			case EAP_IDENTITY:
			_wpa_s6_sm_EAP_SEND_RESPONSE_Enter(sm, 0);
			break;
			case EAP_NOTIFICATION:
			_wpa_s6_sm_EAP_SEND_RESPONSE_Enter(sm, 0);
			break;
			case EAP_RETRANSMIT:
			_wpa_s6_sm_EAP_SEND_RESPONSE_Enter(sm, 0);
			break;
			case EAP_SUCCESS:
			break;
			case EAP_FAILURE:
			break;
		}
}

/*** BeginHeader _wpa_s6_eap_sm_allowMethod */
// From "eap.c":690
Boolean _wpa_s6_eap_sm_allowMethod(struct eap_sm __far * sm, int vendor, EapType method);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s6_eap_sm_allowMethod(struct eap_sm __far * sm, int vendor, EapType method) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":693

	config = eap_get_config(sm);

	if (!wpa_config_allowed_eap_method(config, vendor, method)) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: configuration does not allow: " \
		 "vendor %u method %u" , vendor, method));
		return FALSE;
	}
	if (eap_sm_get_eap_methods(vendor, method))
		return TRUE;
	_WPA_PRINTF((MSG_DEBUG, "EAP: not included in build: " \
	 "vendor %u method %u" , vendor, method));
	return FALSE;
}

/*** BeginHeader _wpa_s6_eap_sm_build_expanded_nak */
// From "eap.c":708
char __far * _wpa_s6_eap_sm_build_expanded_nak(struct eap_sm __far * sm, int id, size_t __far * len,
                                             struct eap_method __far * methods, size_t count);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s6_eap_sm_build_expanded_nak(struct eap_sm __far * sm, int id, size_t __far * len,
                                             struct eap_method __far * methods, size_t count) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":712
	struct eap_hdr __far * resp; 	// From "eap.c":713
	char __far * pos; 	// From "eap.c":714
	int found /* = 0 */; 	// From "eap.c":715
	struct eap_method __far * m; 	// From "eap.c":716

	config = eap_get_config(sm);
	found = 0;

	_WPA_PRINTF((MSG_DEBUG, "EAP: Building expanded EAP-Nak" ));
	*len = sizeof(struct eap_hdr  )+8;
	resp = _sys_malloc(*len+8*(count+1));
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	resp->code = EAP_CODE_RESPONSE;
	resp->identifier = id;
	pos = (char  __far * )(resp+1);
	*pos++ = EAP_TYPE_EXPANDED;
	do {
		(pos)[0] = (char  )(((longword  )(EAP_VENDOR_IETF))>>16);
		(pos)[1] = (char  )(((longword  )(EAP_VENDOR_IETF))>>8);
		(pos)[2] = (char  )(((longword  )(EAP_VENDOR_IETF))&0xff);
	} while (0);
	pos += 3;
	do {
		(pos)[0] = (char  )(((longword  )(EAP_TYPE_NAK))>>24);
		(pos)[1] = (char  )(((longword  )(EAP_TYPE_NAK))>>16);
		(pos)[2] = (char  )(((longword  )(EAP_TYPE_NAK))>>8);
		(pos)[3] = (char  )(((longword  )(EAP_TYPE_NAK))&0xff);
	} while (0);
	pos += 4;
	for (m = methods; m; m = m->next) {
		if (sm->reqVendor==m->vendor &&
		sm->reqVendorMethod==m->method)
			continue;
		if (wpa_config_allowed_eap_method(config, m->vendor, m->method)) {
			_WPA_PRINTF((MSG_DEBUG, "EAP: allowed type: " \
			 "vendor=%u method=%u" , m->vendor, m->method));
			*pos++ = EAP_TYPE_EXPANDED;
			do {
				(pos)[0] = (char  )(((longword  )(m->vendor))>>16);
				(pos)[1] = (char  )(((longword  )(m->vendor))>>8);
				(pos)[2] = (char  )(((longword  )(m->vendor))&0xff);
			} while (0);
			pos += 3;
			do {
				(pos)[0] = (char  )(((longword  )(m->method))>>24);
				(pos)[1] = (char  )(((longword  )(m->method))>>16);
				(pos)[2] = (char  )(((longword  )(m->method))>>8);
				(pos)[3] = (char  )(((longword  )(m->method))&0xff);
			} while (0);
			pos += 4;
			(*len) += 8;
			found++;
		}
	}
	if (!found) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: no more allowed methods" ));
		*pos++ = EAP_TYPE_EXPANDED;
		do {
			(pos)[0] = (char  )(((longword  )(EAP_VENDOR_IETF))>>16);
			(pos)[1] = (char  )(((longword  )(EAP_VENDOR_IETF))>>8);
			(pos)[2] = (char  )(((longword  )(EAP_VENDOR_IETF))&0xff);
		} while (0);
		pos += 3;
		do {
			(pos)[0] = (char  )(((longword  )(EAP_TYPE_NONE))>>24);
			(pos)[1] = (char  )(((longword  )(EAP_TYPE_NONE))>>16);
			(pos)[2] = (char  )(((longword  )(EAP_TYPE_NONE))>>8);
			(pos)[3] = (char  )(((longword  )(EAP_TYPE_NONE))&0xff);
		} while (0);
		pos += 4;
		(*len) += 8;
	}
	resp->length = intel16(*len);
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s6_eap_sm_buildNak */
// From "eap.c":771
char __far * _wpa_s6_eap_sm_buildNak(struct eap_sm __far * sm, int id, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s6_eap_sm_buildNak(struct eap_sm __far * sm, int id, size_t __far * len) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":773
	struct eap_hdr __far * resp; 	// From "eap.c":774
	char __far * pos; 	// From "eap.c":775
	int found /* = 0 */; 	// From "eap.c":776
	int expanded_found /* = 0 */; 	// From "eap.c":776
	size_t count; 	// From "eap.c":777
	struct eap_method __far * methods; 	// From "eap.c":778
	struct eap_method __far * m; 	// From "eap.c":778

	config = eap_get_config(sm);
	found = 0;
	expanded_found = 0;

	_WPA_PRINTF((MSG_DEBUG, "EAP: Building EAP-Nak (requested type %u " \
	 "vendor=%u method=%u not allowed)" , sm->reqMethod, sm->reqVendor, sm->reqVendorMethod));
	methods = eap_peer_get_methods(&count);
	if (methods==((void  __far * )0))
		return ((void  __far * )0);
	if (sm->reqMethod==EAP_TYPE_EXPANDED)
		return _wpa_s6_eap_sm_build_expanded_nak(sm, id, len, methods, count);
	*len = sizeof(struct eap_hdr  )+1;
	resp = _sys_malloc(*len+count+1);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	resp->code = EAP_CODE_RESPONSE;
	resp->identifier = id;
	pos = (char  __far * )(resp+1);
	*pos++ = EAP_TYPE_NAK;
	for (m = methods; m; m = m->next) {
		if (m->vendor==EAP_VENDOR_IETF &&
		m->method==sm->reqMethod)
			continue;
		if (wpa_config_allowed_eap_method(config, m->vendor, m->method)) {
			if (m->vendor!=EAP_VENDOR_IETF) {
				if (expanded_found)
					continue;
				expanded_found = 1;
				*pos++ = EAP_TYPE_EXPANDED;
			}
			else
				*pos++ = m->method;
			(*len)++;
			found++;
		}
	}
	if (!found) {
		*pos = EAP_TYPE_NONE;
		(*len)++;
	}
	_WPA_HEXDUMP((MSG_DEBUG, "EAP: allowed methods" , ((char  __far * )(resp+1))+1, found));
	resp->length = intel16(*len);
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s6_eap_sm_processIdentity */
// From "eap.c":829
void _wpa_s6_eap_sm_processIdentity(struct eap_sm __far * sm, char __far * req);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eap_sm_processIdentity(struct eap_sm __far * sm, char __far * req) {
	struct eap_hdr __far * hdr /* = (struct eap_hdr  far * )req */; 	// From "eap.c":831
	char __far * pos /* = (char  far * )(hdr+1) */; 	// From "eap.c":832

	hdr = (struct eap_hdr  __far * )req;
	pos = (char  __far * )(hdr+1);

	pos++;
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "CTRL-EVENT-EAP-STARTED " \
	 "EAP authentication started" ));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP: EAP-Request Identity data" , pos, intel16(hdr->length)
                                                                  -5));
}

/*** BeginHeader _wpa_s6_eap_sm_get_scard_identity */
// From "eap.c":895
int _wpa_s6_eap_sm_get_scard_identity(struct eap_sm __far * sm, struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
int _wpa_s6_eap_sm_get_scard_identity(struct eap_sm __far * sm, struct wpa_ssid __far * ssid) {
	return  -1;
}

/*** BeginHeader eap_sm_buildIdentity */
// From "eap.c":930
char __far * eap_sm_buildIdentity(struct eap_sm __far * sm, int id, size_t __far * len,
                                int encrypted);
/*** EndHeader */
_wpa_debug
char __far * eap_sm_buildIdentity(struct eap_sm __far * sm, int id, size_t __far * len,
                                int encrypted) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":933
	struct eap_hdr __far * resp; 	// From "eap.c":934
	char __far * pos; 	// From "eap.c":935
	char __far * identity; 	// From "eap.c":936
	size_t identity_len; 	// From "eap.c":937

	config = eap_get_config(sm);

	if (config==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "EAP: buildIdentity: configuration " \
		 "was not available" ));
		return ((void  __far * )0);
	}
	if (sm->m &&
	sm->m->get_identity &&
	(identity = sm->m->get_identity((struct eap_sm  __far * )(sm), (void  __far * )(sm->eap_method_priv),
                                 (size_t  __far * )(&identity_len)))!=((void  __far * )0)) {
		_WPA_HEXDUMP((MSG_DEBUG, "EAP: using method re-auth " \
		 "identity" , identity, identity_len));
	}
	else if (!encrypted &&
	config->anonymous_identity) {
		identity = config->anonymous_identity;
		identity_len = config->anonymous_identity_len;
		_WPA_HEXDUMP((MSG_DEBUG, "EAP: using anonymous identity" , identity, identity_len));
	}
	else {
		identity = config->identity;
		identity_len = config->identity_len;
		_WPA_HEXDUMP((MSG_DEBUG, "EAP: using real identity" , identity, identity_len));
	}
	if (identity==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "EAP: buildIdentity: identity " \
		 "configuration was not available" ));
		if (config->pcsc) {
#ifdef WPA_USE_SCARD_GSIM
			if (_wpa_s6_eap_sm_get_scard_identity(sm, config)<0)
				return ((void  __far * )0);
#endif//def WPA_USE_SCARD_GSIM
			identity = config->identity;
			identity_len = config->identity_len;
			_WPA_HEXDUMP((MSG_DEBUG, "permanent identity from " \
			 "IMSI" , identity, identity_len));
		}
		else {
			eap_sm_request_identity(sm);
			return ((void  __far * )0);
		}
	}
	*len = sizeof(struct eap_hdr  )+1+identity_len;
	resp = _sys_malloc(*len);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	resp->code = EAP_CODE_RESPONSE;
	resp->identifier = id;
	resp->length = intel16(*len);
	pos = (char  __far * )(resp+1);
	*pos++ = EAP_TYPE_IDENTITY;
	_f_memcpy(pos, identity, identity_len);
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s6_eap_sm_processNotify */
// From "eap.c":994
void _wpa_s6_eap_sm_processNotify(struct eap_sm __far * sm, char __far * req);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eap_sm_processNotify(struct eap_sm __far * sm, char __far * req) {
	struct eap_hdr __far * hdr /* = (struct eap_hdr  far * )req */; 	// From "eap.c":996
	char __far * pos; 	// From "eap.c":997
	char __far * msg; 	// From "eap.c":998
	size_t i; 	// From "eap.c":999
	size_t msg_len; 	// From "eap.c":999

	hdr = (struct eap_hdr  __far * )req;

	pos = (char  __far * )(hdr+1);
	pos++;
	msg_len = intel16(hdr->length);
	if (msg_len<5)
		return /*void*/;
	msg_len -= 5;
	_WPA_HEXDUMP((MSG_DEBUG, "EAP: EAP-Request Notification data" , pos, msg_len));
	msg = _sys_malloc(msg_len+1);
	if (msg==((void  __far * )0))
		return /*void*/;
	for (i = 0; i<msg_len; i++)
		msg[i] = isprint(pos[i]) ?
		  (char  )pos[i] :
		  '_';
	msg[msg_len] = '\0';
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "%ls%ls" , (char  __far * )("CTRL-EVENT-EAP-NOTIFICATION " ),
           (char  __far * )(msg)));
	_sys_free(msg);
}

/*** BeginHeader _wpa_s6_eap_sm_buildNotify */
// From "eap.c":1023
char __far * _wpa_s6_eap_sm_buildNotify(int id, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s6_eap_sm_buildNotify(int id, size_t __far * len) {
	struct eap_hdr __far * resp; 	// From "eap.c":1025
	char __far * pos; 	// From "eap.c":1026


	_WPA_PRINTF((MSG_DEBUG, "EAP: Generating EAP-Response Notification" ));
	*len = sizeof(struct eap_hdr  )+1;
	resp = _sys_malloc(*len);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	resp->code = EAP_CODE_RESPONSE;
	resp->identifier = id;
	resp->length = intel16(*len);
	pos = (char  __far * )(resp+1);
	*pos = EAP_TYPE_NOTIFICATION;
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s6_eap_sm_parseEapReq */
// From "eap.c":1044
void _wpa_s6_eap_sm_parseEapReq(struct eap_sm __far * sm, const char __far * req, size_t len);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eap_sm_parseEapReq(struct eap_sm __far * sm, const char __far * req, size_t len) {
	struct eap_hdr __far * hdr; 	// From "eap.c":1046
	size_t plen; 	// From "eap.c":1047
	char __far * pos; 	// From "eap.c":1048


	sm->rxReq = sm->rxResp = sm->rxSuccess = sm->rxFailure = FALSE;
	sm->reqId = 0;
	sm->reqMethod = EAP_TYPE_NONE;
	sm->reqVendor = EAP_VENDOR_IETF;
	sm->reqVendorMethod = EAP_TYPE_NONE;
	if (req==((void  __far * )0) ||
	len<sizeof (*hdr))
		return /*void*/;
	hdr = (struct eap_hdr  __far * )req;
	plen = intel16(hdr->length);
	if (plen>len) {
		_WPA_PRINTF((MSG_DEBUG, "EAP: Ignored truncated EAP-Packet " \
		 "(len=%lu plen=%lu)" , (unsigned long  )len, (unsigned long  )plen));
		return /*void*/;
	}
	sm->reqId = hdr->identifier;
	if (sm->workaround) {
		md5_vector(1, &req, &plen, sm->req_md5);
	}
	switch ((int)(hdr->code)) {
		case EAP_CODE_REQUEST:
		if (plen<sizeof (*hdr)+1) {
			_WPA_PRINTF((MSG_DEBUG, "EAP: Too short EAP-Request - " \
			 "no Type field" ));
			return /*void*/;
		}
		sm->rxReq = TRUE;
		pos = (char  __far * )(hdr+1);
		sm->reqMethod = *pos++;
		if (sm->reqMethod==EAP_TYPE_EXPANDED) {
			if (plen<sizeof (*hdr)+8) {
				_WPA_PRINTF((MSG_DEBUG, "EAP: Ignored truncated " \
				 "expanded EAP-Packet (plen=%lu)" , (unsigned long  )plen));
				return /*void*/;
			}
			// Rabbit note: hopefully the vendor won't have non-zero in MSB, since we are truncating to 16 bits here.
			// can't change field to long, since it has too many dependencies in function parms.
			sm->reqVendor = ( /* (((longword  )(pos)[0])<<16)| */ (((word  )(pos)[1])<<8)|((word  )(pos)[2]));
			pos += 3;
			sm->reqVendorMethod = ((((longword  )(pos)[0])<<24)|(((longword  )(pos)[1])<<16)|(((longword  )(pos)[2])
                                                                           <<8)|((longword  )(pos)[3]));
		}
		_WPA_PRINTF((MSG_DEBUG, "EAP: Received EAP-Request id=%d " \
		 "method=%u vendor=%u vendorMethod=%u" , sm->reqId, sm->reqMethod, sm->reqVendor,
               sm->reqVendorMethod));
		break;
		case EAP_CODE_RESPONSE:
		if (sm->selectedMethod==EAP_TYPE_LEAP) {
			if (plen<sizeof (*hdr)+1) {
				_WPA_PRINTF((MSG_DEBUG, "EAP: Too short " \
				 "EAP-Response - no Type field" ));
				return /*void*/;
			}
			sm->rxResp = TRUE;
			pos = (char  __far * )(hdr+1);
			sm->reqMethod = *pos;
			_WPA_PRINTF((MSG_DEBUG, "EAP: Received EAP-Response for " \
			 "LEAP method=%d id=%d" , sm->reqMethod, sm->reqId));
			break;
		}
		_WPA_PRINTF((MSG_DEBUG, "EAP: Ignored EAP-Response" ));
		break;
		case EAP_CODE_SUCCESS:
		_WPA_PRINTF((MSG_DEBUG, "EAP: Received EAP-Success" ));
		sm->rxSuccess = TRUE;
		break;
		case EAP_CODE_FAILURE:
		_WPA_PRINTF((MSG_DEBUG, "EAP: Received EAP-Failure" ));
		sm->rxFailure = TRUE;
		break;
		default:
		_WPA_PRINTF((MSG_DEBUG, "EAP: Ignored EAP-Packet with unknown " \
		 "code %d" , hdr->code));
		break;
	}
}

/*** BeginHeader eap_sm_init */
// From "eap.c":1152
struct eap_sm __far * eap_sm_init(void __far * eapol_ctx, struct eapol_callbacks __far * eapol_cb,
                                void __far * msg_ctx, struct eap_config __far * conf);
/*** EndHeader */
_wpa_debug
struct eap_sm __far * eap_sm_init(void __far * eapol_ctx, struct eapol_callbacks __far * eapol_cb,
                                void __far * msg_ctx, struct eap_config __far * conf) {
	struct eap_sm __far * sm; 	// From "eap.c":1155
	struct tls_config tlsconf; 	// From "eap.c":1156


	sm = _sys_calloc(sizeof (*sm));
	if (sm==((void  __far * )0))
		return ((void  __far * )0);
	sm->eapol_ctx = eapol_ctx;
	sm->eapol_cb = eapol_cb;
	sm->msg_ctx = msg_ctx;
	sm->ClientTimeout = 60;
	_f_memset(&tlsconf, 0, sizeof (tlsconf));
	tlsconf.opensc_engine_path = conf->opensc_engine_path;
	tlsconf.pkcs11_engine_path = conf->pkcs11_engine_path;
	tlsconf.pkcs11_module_path = conf->pkcs11_module_path;
	sm->ssl_ctx = tls_init(&tlsconf);
	if (sm->ssl_ctx==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "SSL: Failed to initialize TLS " \
		 "context." ));
		_sys_free(sm);
		return ((void  __far * )0);
	}
	return sm;
}

/*** BeginHeader eap_sm_deinit */
// From "eap.c":1189
void eap_sm_deinit(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_deinit(struct eap_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_wpa_s6_eap_deinit_prev_method(sm, "EAP deinit" );
	eap_sm_abort(sm);
	tls_deinit(sm->ssl_ctx);
	_sys_free(sm);
}

/*** BeginHeader eap_sm_step */
// From "eap.c":1209
int eap_sm_step(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
int eap_sm_step(struct eap_sm __far * sm) {
	int res /* = 0 */; 	// From "eap.c":1211

	res = 0;

	do {
		sm->changed = FALSE;
		_wpa_s6_sm_EAP_Step(sm);
		if (sm->changed)
			res = 1;
	} while (sm->changed);
	return res;
}

/*** BeginHeader eap_sm_abort */
// From "eap.c":1229
void eap_sm_abort(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_abort(struct eap_sm __far * sm) {
	_sys_free(sm->lastRespData);
	sm->lastRespData = ((void  __far * )0);
	_sys_free(sm->eapRespData);
	sm->eapRespData = ((void  __far * )0);
	_sys_free(sm->eapKeyData);
	sm->eapKeyData = ((void  __far * )0);
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapSuccess, FALSE);
}

/*** BeginHeader _wpa_s6_eap_sm_method_state_txt */
// From "eap.c":1283
char __far * _wpa_s6_eap_sm_method_state_txt(EapMethodState state);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s6_eap_sm_method_state_txt(EapMethodState state) {
	switch ((int)(state)) {
		case METHOD_NONE:
		return "NONE" ;
		case METHOD_INIT:
		return "INIT" ;
		case METHOD_CONT:
		return "CONT" ;
		case METHOD_MAY_CONT:
		return "MAY_CONT" ;
		case METHOD_DONE:
		return "DONE" ;
		default:
		return "UNKNOWN" ;
	}
}

/*** BeginHeader _wpa_s6_eap_sm_decision_txt */
// From "eap.c":1302
char __far * _wpa_s6_eap_sm_decision_txt(EapDecision decision);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s6_eap_sm_decision_txt(EapDecision decision) {
	switch ((int)(decision)) {
		case DECISION_FAIL:
		return "FAIL" ;
		case DECISION_COND_SUCC:
		return "COND_SUCC" ;
		case DECISION_UNCOND_SUCC:
		return "UNCOND_SUCC" ;
		default:
		return "UNKNOWN" ;
	}
}
/*** BeginHeader */

typedef
enum  {
	TYPE_IDENTITY,
	TYPE_PASSWORD,
	TYPE_OTP,
	TYPE_PIN,
	TYPE_NEW_PASSWORD,
	TYPE_PASSPHRASE
}  eap_ctrl_req_type;	// From "eap.c":1397
/*** EndHeader */

/*** BeginHeader _wpa_s6_eap_sm_request */
// From "eap.c":1399
void _wpa_s6_eap_sm_request(struct eap_sm __far * sm, eap_ctrl_req_type type, char __far * msg,
                            size_t msglen);
/*** EndHeader */
_wpa_debug
void _wpa_s6_eap_sm_request(struct eap_sm __far * sm, eap_ctrl_req_type type, char __far * msg,
                            size_t msglen) {
	struct wpa_ssid __far * config; 	// From "eap.c":1402
	char __far * buf; 	// From "eap.c":1403
	size_t buflen; 	// From "eap.c":1404
	int len; 	// From "eap.c":1405
	char __far * field; 	// From "eap.c":1406
	char __far * txt; 	// From "eap.c":1407
	char __far * tmp; 	// From "eap.c":1407


	if (sm==((void  __far * )0))
		return /*void*/;
	config = eap_get_config(sm);
	if (config==((void  __far * )0))
		return /*void*/;
	switch ((int)(type)) {
		case TYPE_IDENTITY:
		field = "IDENTITY" ;
		txt = "Identity" ;
		config->pending_req_identity++;
		break;
		case TYPE_PASSWORD:
		field = "PASSWORD" ;
		txt = "Password" ;
		config->pending_req_password++;
		break;
		case TYPE_NEW_PASSWORD:
		field = "NEW_PASSWORD" ;
		txt = "New Password" ;
		config->pending_req_new_password++;
		break;
		case TYPE_PIN:
		field = "PIN" ;
		txt = "PIN" ;
		config->pending_req_pin++;
		break;
		case TYPE_OTP:
		field = "OTP" ;
		if (msg) {
			tmp = _sys_malloc(msglen+3);
			if (tmp==((void  __far * )0))
				return /*void*/;
			tmp[0] = '[';
			_f_memcpy(tmp+1, msg, msglen);
			tmp[msglen+1] = ']';
			tmp[msglen+2] = '\0';
			txt = tmp;
			_sys_free(config->pending_req_otp);
			config->pending_req_otp = tmp;
			config->pending_req_otp_len = msglen+3;
		}
		else {
			if (config->pending_req_otp==((void  __far * )0))
				return /*void*/;
			txt = config->pending_req_otp;
		}
		break;
		case TYPE_PASSPHRASE:
		field = "PASSPHRASE" ;
		txt = "Private key passphrase" ;
		config->pending_req_passphrase++;
		break;
		default:
		return /*void*/;
	}
	buflen = 100+strlen(txt)+config->ssid_len;
	buf = _sys_malloc(buflen);
	if (buf==((void  __far * )0))
		return /*void*/;
	len = snprintf(buf, buflen, "CTRL-REQ-%ls-%d:%ls needed for SSID " , (char  __far * )(field),
                config->id, (char  __far * )(txt));
	if (len<0 ||
	(size_t  )len>=buflen) {
		_sys_free(buf);
		return /*void*/;
	}
	if (config->ssid &&
	buflen>len+config->ssid_len) {
		_f_memcpy(buf+len, config->ssid, config->ssid_len);
		len += config->ssid_len;
		buf[len] = '\0';
	}
	buf[buflen-1] = '\0';
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "%ls" , (char  __far * )(buf)));
	_sys_free(buf);
}

/*** BeginHeader eap_sm_request_identity */
// From "eap.c":1499
void eap_sm_request_identity(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_request_identity(struct eap_sm __far * sm) {
	_wpa_s6_eap_sm_request(sm, TYPE_IDENTITY, ((void  __far * )0), 0);
}

/*** BeginHeader eap_sm_request_password */
// From "eap.c":1514
void eap_sm_request_password(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_request_password(struct eap_sm __far * sm) {
	_wpa_s6_eap_sm_request(sm, TYPE_PASSWORD, ((void  __far * )0), 0);
}

/*** BeginHeader eap_sm_request_new_password */
// From "eap.c":1529
void eap_sm_request_new_password(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_request_new_password(struct eap_sm __far * sm) {
	_wpa_s6_eap_sm_request(sm, TYPE_NEW_PASSWORD, ((void  __far * )0), 0);
}

/*** BeginHeader eap_sm_request_pin */
// From "eap.c":1544
void eap_sm_request_pin(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_request_pin(struct eap_sm __far * sm) {
	_wpa_s6_eap_sm_request(sm, TYPE_PIN, ((void  __far * )0), 0);
}

/*** BeginHeader eap_sm_request_otp */
// From "eap.c":1560
void eap_sm_request_otp(struct eap_sm __far * sm, char __far * msg, size_t msg_len);
/*** EndHeader */
_wpa_debug
void eap_sm_request_otp(struct eap_sm __far * sm, char __far * msg, size_t msg_len) {
	_wpa_s6_eap_sm_request(sm, TYPE_OTP, msg, msg_len);
}

/*** BeginHeader eap_sm_request_passphrase */
// From "eap.c":1575
void eap_sm_request_passphrase(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_request_passphrase(struct eap_sm __far * sm) {
	_wpa_s6_eap_sm_request(sm, TYPE_PASSPHRASE, ((void  __far * )0), 0);
}

/*** BeginHeader eap_sm_notify_ctrl_attached */
// From "eap.c":1588
void eap_sm_notify_ctrl_attached(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_sm_notify_ctrl_attached(struct eap_sm __far * sm) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":1590

	config = eap_get_config(sm);

	if (config==((void  __far * )0))
		return /*void*/;
	if (config->pending_req_identity)
		eap_sm_request_identity(sm);
	if (config->pending_req_password)
		eap_sm_request_password(sm);
	if (config->pending_req_new_password)
		eap_sm_request_new_password(sm);
	if (config->pending_req_otp)
		eap_sm_request_otp(sm, ((void  __far * )0), 0);
	if (config->pending_req_pin)
		eap_sm_request_pin(sm);
	if (config->pending_req_passphrase)
		eap_sm_request_passphrase(sm);
}

/*** BeginHeader _wpa_s6_eap_allowed_phase2_type */
// From "eap.c":1614
int _wpa_s6_eap_allowed_phase2_type(int vendor, int type);
/*** EndHeader */
_wpa_debug
int _wpa_s6_eap_allowed_phase2_type(int vendor, int type) {
	if (vendor!=EAP_VENDOR_IETF)
		return 0;
	return type!=EAP_TYPE_PEAP &&
	type!=EAP_TYPE_TTLS &&
	type!=EAP_TYPE_FAST;
}

/*** BeginHeader eap_get_phase2_type */
// From "eap.c":1633
longword eap_get_phase2_type(char __far * name, int __far * vendor);
/*** EndHeader */
_wpa_debug
longword eap_get_phase2_type(char __far * name, int __far * vendor) {
	int v; 	// From "eap.c":1635
	char type /* = eap_get_type(name, &v) */; 	// From "eap.c":1636

	type = eap_get_type(name, &v);

	if (_wpa_s6_eap_allowed_phase2_type(v, type)) {
		*vendor = v;
		return type;
	}
	*vendor = EAP_VENDOR_IETF;
	return EAP_TYPE_NONE;
}

/*** BeginHeader eap_get_phase2_types */
// From "eap.c":1655
struct eap_method_type __far * eap_get_phase2_types(struct wpa_ssid __far * config,
                                                  size_t __far * count);
/*** EndHeader */
_wpa_debug
struct eap_method_type __far * eap_get_phase2_types(struct wpa_ssid __far * config,
                                                  size_t __far * count) {
	struct eap_method_type __far * buf; 	// From "eap.c":1658
	longword method; 	// From "eap.c":1659
	int vendor; 	// From "eap.c":1660
	size_t mcount; 	// From "eap.c":1661
	struct eap_method __far * methods; 	// From "eap.c":1662
	struct eap_method __far * m; 	// From "eap.c":1662


	methods = eap_peer_get_methods(&mcount);
	if (methods==((void  __far * )0))
		return ((void  __far * )0);
	*count = 0;
	buf = _sys_malloc(mcount*sizeof(struct eap_method_type  ));
	if (buf==((void  __far * )0))
		return ((void  __far * )0);
	for (m = methods; m; m = m->next) {
		vendor = m->vendor;
		method = m->method;
		if (_wpa_s6_eap_allowed_phase2_type(vendor, (int)method)) {		// Rabbit note: cast to int
			if (vendor==EAP_VENDOR_IETF &&
			method==EAP_TYPE_TLS &&
			config &&
			config->client_cert_blob2->rsa_key==((void  __far * )0))	// Rabbit note: pkey in cert struct
				continue;
			buf[*count].vendor = vendor;
			buf[*count].method = method;
			(*count)++;
		}
	}
	return buf;
}

/*** BeginHeader eap_set_fast_reauth */
// From "eap.c":1695
void eap_set_fast_reauth(struct eap_sm __far * sm, int enabled);
/*** EndHeader */
_wpa_debug
void eap_set_fast_reauth(struct eap_sm __far * sm, int enabled) {
	sm->fast_reauth = enabled;
}

/*** BeginHeader eap_set_workaround */
// From "eap.c":1706
void eap_set_workaround(struct eap_sm __far * sm, unsigned int workaround);
/*** EndHeader */
_wpa_debug
void eap_set_workaround(struct eap_sm __far * sm, unsigned int workaround) {
	sm->workaround = workaround;
}

/*** BeginHeader eap_get_config */
// From "eap.c":1722
struct wpa_ssid __far * eap_get_config(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
struct wpa_ssid __far * eap_get_config(struct eap_sm __far * sm) {
	// Rabbit mod Internal Error: Expression temporary stack usage.
	//return sm->eapol_cb->get_config((void  far * )(sm->eapol_ctx));
	void __far * temp;
	temp = ((void __far * (*)())sm->eapol_cb->get_config)((void  __far * )(sm->eapol_ctx));
	return (struct wpa_ssid __far *)temp;
}

/*** BeginHeader eap_get_config_identity */
// From "eap.c":1734
char __far * eap_get_config_identity(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * eap_get_config_identity(struct eap_sm __far * sm, size_t __far * len) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":1736

	config = eap_get_config(sm);

	if (config==((void  __far * )0))
		return ((void  __far * )0);
	*len = config->identity_len;
	return config->identity;
}

/*** BeginHeader eap_get_config_password */
// From "eap.c":1750
char __far * eap_get_config_password(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * eap_get_config_password(struct eap_sm __far * sm, size_t __far * len) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":1752

	config = eap_get_config(sm);

	if (config==((void  __far * )0))
		return ((void  __far * )0);
	*len = config->password_len;
	return config->password;
}

/*** BeginHeader eap_get_config_new_password */
// From "eap.c":1766
char __far * eap_get_config_new_password(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * eap_get_config_new_password(struct eap_sm __far * sm, size_t __far * len) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":1768

	config = eap_get_config(sm);

	if (config==((void  __far * )0))
		return ((void  __far * )0);
	*len = config->new_password_len;
	return config->new_password;
}

/*** BeginHeader eap_get_config_otp */
// From "eap.c":1782
char __far * eap_get_config_otp(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * eap_get_config_otp(struct eap_sm __far * sm, size_t __far * len) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":1784

	config = eap_get_config(sm);

	if (config==((void  __far * )0))
		return ((void  __far * )0);
	*len = config->otp_len;
	return config->otp;
}

/*** BeginHeader eap_clear_config_otp */
// From "eap.c":1800
void eap_clear_config_otp(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_clear_config_otp(struct eap_sm __far * sm) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap.c":1802

	config = eap_get_config(sm);

	if (config==((void  __far * )0))
		return /*void*/;
	_f_memset(config->otp, 0, config->otp_len);
	_sys_free(config->otp);
	config->otp = ((void  __far * )0);
	config->otp_len = 0;
}

/*** BeginHeader eap_key_available */
// From "eap.c":1817
int eap_key_available(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
int eap_key_available(struct eap_sm __far * sm) {
	return sm ?
	  sm->eapKeyAvailable :
	  0;
}

/*** BeginHeader eap_notify_success */
// From "eap.c":1832
void eap_notify_success(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_notify_success(struct eap_sm __far * sm) {
	if (sm) {
		sm->decision = DECISION_COND_SUCC;
		sm->EAP_state = EAP_SUCCESS;
	}
}

/*** BeginHeader eap_notify_lower_layer_success */
// From "eap.c":1848
void eap_notify_lower_layer_success(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_notify_lower_layer_success(struct eap_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	if (_wpa_s6_eapol_get_bool(sm, EAPOL_eapSuccess) ||
	sm->decision==DECISION_FAIL ||
	(sm->methodState!=METHOD_MAY_CONT &&
	sm->methodState!=METHOD_DONE))
		return /*void*/;
	if (sm->eapKeyData!=((void  __far * )0))
		sm->eapKeyAvailable = TRUE;
	_wpa_s6_eapol_set_bool(sm, EAPOL_eapSuccess, TRUE);
	_WPA_MSG((sm->msg_ctx, MSG_INFO, "CTRL-EVENT-EAP-SUCCESS " \
	 "EAP authentication completed successfully (based on lower " \
	 "layer success)" ));
}

/*** BeginHeader eap_get_eapKeyData */
// From "eap.c":1879
char __far * eap_get_eapKeyData(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * eap_get_eapKeyData(struct eap_sm __far * sm, size_t __far * len) {
	if (sm==((void  __far * )0) ||
	sm->eapKeyData==((void  __far * )0)) {
		*len = 0;
		return ((void  __far * )0);
	}
	*len = sm->eapKeyDataLen;
	return sm->eapKeyData;
}

/*** BeginHeader eap_get_eapRespData */
// From "eap.c":1902
char __far * eap_get_eapRespData(struct eap_sm __far * sm, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * eap_get_eapRespData(struct eap_sm __far * sm, size_t __far * len) {
	char __far * resp; 	// From "eap.c":1904


	if (sm==((void  __far * )0) ||
	sm->eapRespData==((void  __far * )0)) {
		*len = 0;
		return ((void  __far * )0);
	}
	resp = sm->eapRespData;
	*len = sm->eapRespDataLen;
	sm->eapRespData = ((void  __far * )0);
	sm->eapRespDataLen = 0;
	return resp;
}

/*** BeginHeader eap_register_scard_ctx */
// From "eap.c":1928
void eap_register_scard_ctx(struct eap_sm __far * sm, void __far * ctx);
/*** EndHeader */
_wpa_debug
void eap_register_scard_ctx(struct eap_sm __far * sm, void __far * ctx) {
	if (sm)
		sm->scard_ctx = ctx;
}

/*** BeginHeader eap_hdr_validate */
// From "eap.c":1952
char __far * eap_hdr_validate(int vendor, EapType eap_type, char __far * msg, size_t msglen,
                            size_t __far * plen);
/*** EndHeader */
_wpa_debug
char __far * eap_hdr_validate(int vendor, EapType eap_type, char __far * msg, size_t msglen,
                            size_t __far * plen) {
	struct eap_hdr __far * hdr; 	// From "eap.c":1955
	char __far * pos; 	// From "eap.c":1956
	size_t len; 	// From "eap.c":1957

	union  {

		struct  {
			int exp_vendor;
			longword exp_type;

		} __s3;

	} __u; 	// From "eap.c":1954


	hdr = (struct eap_hdr  __far * )msg;
	if (msglen<sizeof (*hdr)) {
		_WPA_PRINTF((MSG_INFO, "EAP: Too short EAP frame" ));
		return ((void  __far * )0);
	}
	len = intel16(hdr->length);
	if (len<sizeof (*hdr)+1 ||
	len>msglen) {
		_WPA_PRINTF((MSG_INFO, "EAP: Invalid %s", "EAP length" ));
		return ((void  __far * )0);
	}
	pos = (char  __far * )(hdr+1);
	if (*pos==EAP_TYPE_EXPANDED) {
		if (len<sizeof (*hdr)+8) {
			_WPA_PRINTF((MSG_INFO, "EAP: Invalid %s", "expanded EAP " \
			 "length" ));
			return ((void  __far * )0);
		}
		pos++;
		// Rabbit note: changed to wordtype, assume MSBs are zero
		__u.__s3.exp_vendor = (/*(((longword  )(pos)[0])<<16)|*/(((word  )(pos)[1])<<8)|((word  )(pos)[2]));
		pos += 3;
		__u.__s3.exp_type = ((((longword  )(pos)[0])<<24)|(((longword  )(pos)[1])<<16)|(((longword  )(pos)[2])
                                                                        <<8)|((longword  )(pos)[3]));
		pos += 4;
		if (__u.__s3.exp_vendor!=vendor ||
		__u.__s3.exp_type!=(longword  )eap_type) {
			_WPA_PRINTF((MSG_INFO, "EAP: Invalid %s", "expanded frame " \
			 "type" ));
			return ((void  __far * )0);
		}
		*plen = len-sizeof (*hdr)-8;
		return pos;
	}
	else {
		if (vendor!=EAP_VENDOR_IETF ||
		*pos!=eap_type) {
			_WPA_PRINTF((MSG_INFO, "EAP: Invalid %s", "frame type" ));
			return ((void  __far * )0);
		}
		*plen = len-sizeof (*hdr)-1;
		return pos+1;
	}
}

/*** BeginHeader eap_set_config_blob */
// From "eap.c":2014
void eap_set_config_blob(struct eap_sm __far * sm, struct wpa_config_blob __far * blob);
/*** EndHeader */
_wpa_debug
void eap_set_config_blob(struct eap_sm __far * sm, struct wpa_config_blob __far * blob) {
	sm->eapol_cb->set_config_blob((void  __far * )(sm->eapol_ctx), (struct wpa_config_blob  __far * )(blob));
}

/*** BeginHeader eap_get_config_blob */
// From "eap.c":2026
struct wpa_config_blob __far * eap_get_config_blob(struct eap_sm __far * sm, char __far * name);
/*** EndHeader */
_wpa_debug
struct wpa_config_blob __far * eap_get_config_blob(struct eap_sm __far * sm, char __far * name) {
	// Rabbit mod Internal Error: Expression temporary stack usage.
	//return sm->eapol_cb->get_config_blob((void  far * )(sm->eapol_ctx), (char  far * )(name));
	auto void __far * temp;
	temp = ((void __far * (*)())sm->eapol_cb->get_config_blob)((void  __far * )(sm->eapol_ctx), (char  __far * )(name));
	return (struct wpa_config_blob __far *)temp;
}

/*** BeginHeader eap_set_force_disabled */
// From "eap.c":2041
void eap_set_force_disabled(struct eap_sm __far * sm, int disabled);
/*** EndHeader */
_wpa_debug
void eap_set_force_disabled(struct eap_sm __far * sm, int disabled) {
	sm->force_disabled = disabled;
}

/*** BeginHeader eap_msg_alloc */
// From "eap.c":2065
struct eap_hdr __far * eap_msg_alloc(int vendor, EapType type, size_t __far * len, size_t payload_len,
                                   char code, char identifier, char __far * __far * payload);
/*** EndHeader */
_wpa_debug
struct eap_hdr __far * eap_msg_alloc(int vendor, EapType type, size_t __far * len, size_t payload_len,
                                   char code, char identifier, char __far * __far * payload) {
	struct eap_hdr __far * hdr; 	// From "eap.c":2069
	char __far * pos; 	// From "eap.c":2070


	*len = sizeof(struct eap_hdr  )+(vendor==EAP_VENDOR_IETF ?
	  1 :
	  8)+payload_len;
	hdr = _sys_malloc(*len);
	if (hdr) {
		hdr->code = code;
		hdr->identifier = identifier;
		hdr->length = intel16(*len);
		pos = (char  __far * )(hdr+1);
		if (vendor==EAP_VENDOR_IETF) {
			*pos++ = type;
		}
		else {
			*pos++ = EAP_TYPE_EXPANDED;
			do {
				(pos)[0] = (char  )(((longword  )(vendor))>>16);
				(pos)[1] = (char  )(((longword  )(vendor))>>8);
				(pos)[2] = (char  )(((longword  )(vendor))&0xff);
			} while (0);
			pos += 3;
			do {
				(pos)[0] = (char  )(((longword  )(type))>>24);
				(pos)[1] = (char  )(((longword  )(type))>>16);
				(pos)[2] = (char  )(((longword  )(type))>>8);
				(pos)[3] = (char  )(((longword  )(type))&0xff);
			} while (0);
			pos += 4;
		}
		if (payload)
			*payload = pos;
	}
	return hdr;
}

/*** BeginHeader eap_notify_pending */
// From "eap.c":2106
void eap_notify_pending(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_notify_pending(struct eap_sm __far * sm) {
	sm->eapol_cb->notify_pending((void  __far * )(sm->eapol_ctx));
}

/*** BeginHeader eap_invalidate_cached_session */
// From "eap.c":2116
void eap_invalidate_cached_session(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eap_invalidate_cached_session(struct eap_sm __far * sm) {
	if (sm)
		_wpa_s6_eap_deinit_prev_method(sm, "invalidate" );
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader eap_sm_get_eap_methods */
// From "eap_methods.c":34
struct eap_method __far * eap_sm_get_eap_methods(int vendor, EapType method);
/*** EndHeader */
_wpa_debug
struct eap_method __far * eap_sm_get_eap_methods(int vendor, EapType method) {
	struct eap_method __far * m; 	// From "eap_methods.c":36


	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next) {
		if (m->vendor==vendor &&
		m->method==method)
			return m;
	}
	return ((void  __far * )0);
}

/*** BeginHeader eap_get_type */
// From "eap_methods.c":54
EapType eap_get_type(char __far * name, int __far * vendor);
/*** EndHeader */
_wpa_debug
EapType eap_get_type(char __far * name, int __far * vendor) {
	struct eap_method __far * m; 	// From "eap_methods.c":56


	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next) {
		if (strcmp(m->name, name)==0) {
			*vendor = m->vendor;
			return m->method;
		}
	}
	*vendor = EAP_VENDOR_IETF;
	return EAP_TYPE_NONE;
}

/*** BeginHeader eap_get_name */
// From "eap_methods.c":77
char __far * eap_get_name(int vendor, EapType type);
/*** EndHeader */
_wpa_debug
char __far * eap_get_name(int vendor, EapType type) {
	struct eap_method __far * m; 	// From "eap_methods.c":79


	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next) {
		if (m->vendor==vendor &&
		m->method==type)
			return m->name;
	}
	return ((void  __far * )0);
}

/*** BeginHeader eap_get_names */
// From "eap_methods.c":95
size_t eap_get_names(char __far * buf, size_t buflen);
/*** EndHeader */
_wpa_debug
size_t eap_get_names(char __far * buf, size_t buflen) {
	char __far * pos; 	// From "eap_methods.c":97
	char __far * end; 	// From "eap_methods.c":97
	struct eap_method __far * m; 	// From "eap_methods.c":98
	int ret; 	// From "eap_methods.c":99


	if (buflen==0)
		return 0;
	pos = buf;
	end = pos+buflen;
	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next) {
		ret = snprintf(pos, (_x509_ptrdiff_t)(end-pos), "%ls%ls" , (char  __far * )(m==__wpa_globals.__s7.eap_methods ?
		  ""  :
		  " " ), (char  __far * )(m->name));
		if (ret<0 ||
		ret>=(_x509_ptrdiff_t)(end-pos))
			break;
		pos += ret;
	}
	buf[buflen-1] = '\0';
	return (_x509_ptrdiff_t)(pos-buf);
}

/*** BeginHeader eap_get_names_as_string_array */
// From "eap_methods.c":130
char __far * __far * eap_get_names_as_string_array(size_t __far * num);
/*** EndHeader */
_wpa_debug
char __far * __far * eap_get_names_as_string_array(size_t __far * num) {
	struct eap_method __far * m; 	// From "eap_methods.c":132
	size_t array_len /* = 0 */; 	// From "eap_methods.c":133
	char __far * __far * array; 	// From "eap_methods.c":134
	int i /* = 0 */; 	// From "eap_methods.c":135
	int j; 	// From "eap_methods.c":135

	array_len = 0;
	i = 0;

	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next)
		array_len++;
	array = _sys_calloc(sizeof(char  __far * )*(array_len+1));
	if (array==((void  __far * )0))
		return ((void  __far * )0);
	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next) {
		array[i++] = _sys_strdup(m->name);
		if (array[i-1]==((void  __far * )0)) {
			for (j = 0; j<i; j++)
				_sys_free(array[j]);
			_sys_free(array);
			return ((void  __far * )0);
		}
	}
	array[i] = ((void  __far * )0);
	if (num)
		*num = array_len;
	return array;
}

/*** BeginHeader eap_peer_get_methods */
// From "eap_methods.c":167
struct eap_method __far * eap_peer_get_methods(size_t __far * count);
/*** EndHeader */
_wpa_debug
struct eap_method __far * eap_peer_get_methods(size_t __far * count) {
	int c /* = 0 */; 	// From "eap_methods.c":169
	struct eap_method __far * m; 	// From "eap_methods.c":170

	c = 0;

	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next)
		c++;
	*count = c;
	return __wpa_globals.__s7.eap_methods;
}

/*** BeginHeader eap_peer_method_alloc */
// From "eap_methods.c":283
struct eap_method __far * eap_peer_method_alloc(int version, int vendor, EapType method,
                                              char __far * name);
/*** EndHeader */
_wpa_debug
struct eap_method __far * eap_peer_method_alloc(int version, int vendor, EapType method,
                                              char __far * name) {
	struct eap_method __far * eap; 	// From "eap_methods.c":286


	eap = _sys_calloc(sizeof (*eap));
	if (eap==((void  __far * )0))
		return ((void  __far * )0);
	eap->version = version;
	eap->vendor = vendor;
	eap->method = method;
	eap->name = name;
	return eap;
}

/*** BeginHeader eap_peer_method_free */
// From "eap_methods.c":302
void eap_peer_method_free(struct eap_method __far * method);
/*** EndHeader */
_wpa_debug
void eap_peer_method_free(struct eap_method __far * method) {
	_sys_free(method);
}

/*** BeginHeader eap_peer_method_register */
// From "eap_methods.c":317
int eap_peer_method_register(struct eap_method __far * method);
/*** EndHeader */
_wpa_debug
int eap_peer_method_register(struct eap_method __far * method) {
	struct eap_method __far * m; 	// From "eap_methods.c":319
	struct eap_method __far * last /* = ((void  far * )0) */; 	// From "eap_methods.c":319

	last = ((void  __far * )0);

	if (method==((void  __far * )0) ||
	method->name==((void  __far * )0) ||
	method->version!=1)
		return  -1;
	for (m = __wpa_globals.__s7.eap_methods; m; m = m->next) {
		if ((m->vendor==method->vendor &&
		m->method==method->method) ||
		strcmp(m->name, method->name)==0)
			return  -2;
		last = m;
	}
	if (last)
		last->next = method;
	else
		__wpa_globals.__s7.eap_methods = method;
	return 0;
}

/*** BeginHeader eap_peer_register_methods */
// From "eap_methods.c":349
int eap_peer_register_methods(void );
/*** EndHeader */
_wpa_debug
int eap_peer_register_methods(void ) {
	int ret /* = 0 */; 	// From "eap_methods.c":351

	ret = 0;

// Rabbit note: added conditionals
#if WPA_USE_EAP & WPA_USE_EAP_TLS
	if (ret==0) {
		ret = eap_peer_tls_register();
	}
#endif
#if WPA_USE_EAP & WPA_USE_EAP_PEAP
	if (ret==0) {
		ret = eap_peer_mschapv2_register();
	}
	if (ret==0) {
		ret = eap_peer_peap_register();
	}
#endif
	return ret;
}

/*** BeginHeader eap_peer_unregister_methods */
// From "eap_methods.c":475
void eap_peer_unregister_methods(void );
/*** EndHeader */
_wpa_debug
void eap_peer_unregister_methods(void ) {
	struct eap_method __far * m; 	// From "eap_methods.c":477


	while (__wpa_globals.__s7.eap_methods) {
		m = __wpa_globals.__s7.eap_methods;
		__wpa_globals.__s7.eap_methods = __wpa_globals.__s7.eap_methods->next;
		if (m->sys_free)
			m->sys_free((struct eap_method  __far * )(m));
		else
			eap_peer_method_free(m);
	}
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

enum  {
	MD5_MAC_LEN = 16
}  ;	// From "md5.h":18

struct eapol_sm {
	unsigned int authWhile;
	unsigned int heldWhile;
	unsigned int startWhen;
	unsigned int idleWhile;
	Boolean eapFail;
	Boolean eapolEap;
	Boolean eapSuccess;
	Boolean initialize;
	Boolean keyDone;
	Boolean keyRun;
	PortControl portControl;
	Boolean portEnabled;
	PortStatus suppPortStatus;
	Boolean portValid;
	Boolean suppAbort;
	Boolean suppFail;
	Boolean suppStart;
	Boolean suppSuccess;
	Boolean suppTimeout;

	enum  {
		SUPP_PAE_UNKNOWN = 0,
		SUPP_PAE_DISCONNECTED = 1,
		SUPP_PAE_LOGOFF = 2,
		SUPP_PAE_CONNECTING = 3,
		SUPP_PAE_AUTHENTICATING = 4,
		SUPP_PAE_AUTHENTICATED = 5,
		SUPP_PAE_HELD = 7,
		SUPP_PAE_RESTART = 8,
		SUPP_PAE_S_FORCE_AUTH = 9,
		SUPP_PAE_S_FORCE_UNAUTH = 10
	}  SUPP_PAE_state;
	Boolean userLogoff;
	Boolean logoffSent;
	unsigned int startCount;
	Boolean eapRestart;
	PortControl sPortMode;
	unsigned int heldPeriod;
	unsigned int startPeriod;
	unsigned int maxStart;

	enum  {
		KEY_RX_UNKNOWN = 0,
		KEY_RX_NO_KEY_RECEIVE,
		KEY_RX_KEY_RECEIVE
	}  KEY_RX_state;
	Boolean rxKey;

	enum  {
		SUPP_BE_UNKNOWN = 0,
		SUPP_BE_INITIALIZE = 1,
		SUPP_BE_IDLE = 2,
		SUPP_BE_REQUEST = 3,
		SUPP_BE_RECEIVE = 4,
		SUPP_BE_RESPONSE = 5,
		SUPP_BE_FAIL = 6,
		SUPP_BE_TIMEOUT = 7,
		SUPP_BE_SUCCESS = 8
	}  SUPP_BE_state;
	Boolean eapNoResp;
	Boolean eapReq;
	Boolean eapResp;
	unsigned int authPeriod;
	unsigned int dot1xSuppEapolFramesRx;
	unsigned int dot1xSuppEapolFramesTx;
	unsigned int dot1xSuppEapolStartFramesTx;
	unsigned int dot1xSuppEapolLogoffFramesTx;
	unsigned int dot1xSuppEapolRespFramesTx;
	unsigned int dot1xSuppEapolReqIdFramesRx;
	unsigned int dot1xSuppEapolReqFramesRx;
	unsigned int dot1xSuppInvalidEapolFramesRx;
	unsigned int dot1xSuppEapLengthErrorFramesRx;
	unsigned int dot1xSuppLastEapolFrameVersion;
	unsigned char dot1xSuppLastEapolFrameSource[6];
	Boolean changed;
	struct eap_sm __far * eap;
	struct wpa_ssid __far * config;
	Boolean initial_req;
	char __far * last_rx_key;
	size_t last_rx_key_len;
	char __far * eapReqData;
	size_t eapReqDataLen;
	Boolean altAccept;
	Boolean altReject;
	Boolean replay_counter_valid;
	char last_replay_counter[16];
	struct eapol_config conf;
	struct eapol_ctx __far * ctx;

	enum  {
		EAPOL_CB_IN_PROGRESS = 0,
		EAPOL_CB_SUCCESS,
		EAPOL_CB_FAILURE
	}  cb_status;
	Boolean cached_pmk;
	Boolean unicast_key_received;
	Boolean broadcast_key_received;

} ;	// From "eapol_sm.c":145

enum  {
	IEEE8021X_KEY_SIGN_LEN = 16
}  ;	// From "eapol_sm.c":149

enum  {
	IEEE8021X_KEY_IV_LEN = 16
}  ;	// From "eapol_sm.c":150

enum  {
	IEEE8021X_KEY_INDEX_FLAG = 0x80
}  ;	// From "eapol_sm.c":152

enum  {
	IEEE8021X_KEY_INDEX_MASK = 0x03
}  ;	// From "eapol_sm.c":153

struct ieee802_1x_eapol_key {
	char type;
	char key_length[2];
	char replay_counter[8];
	char key_iv[IEEE8021X_KEY_IV_LEN];
	char key_index;
	char key_signature[IEEE8021X_KEY_SIGN_LEN];

} ;	// From "eapol_sm.c":181
/*** EndHeader */

/*** BeginHeader _wpa_s8_eapol_port_timers_tick */
// From "eapol_sm.c":200
void _wpa_s8_eapol_port_timers_tick(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_port_timers_tick(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct eapol_sm __far * sm /* = timeout_ctx */; 	// From "eapol_sm.c":202

	sm = timeout_ctx;

	if (sm->authWhile>0) {
		sm->authWhile--;
		if (sm->authWhile==0)
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: authWhile --> 0" ));
	}
	if (sm->heldWhile>0) {
		sm->heldWhile--;
		if (sm->heldWhile==0)
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: heldWhile --> 0" ));
	}
	if (sm->startWhen>0) {
		sm->startWhen--;
		if (sm->startWhen==0)
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: startWhen --> 0" ));
	}
	if (sm->idleWhile>0) {
		sm->idleWhile--;
		if (sm->idleWhile==0)
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: idleWhile --> 0" ));
	}
	eloop_register_timeout(1000, _wpa_s8_eapol_port_timers_tick, eloop_ctx, sm);
	eapol_sm_step(sm);
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_LOGOFF_Enter */
// From "eapol_sm.c":230
void _wpa_s8_sm_SUPP_PAE_LOGOFF_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_LOGOFF_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_LOGOFF) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "LOGOFF" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_LOGOFF;
	;
	_wpa_s8_eapol_sm_txLogoff(sm);
	sm->logoffSent = TRUE;
	sm->suppPortStatus = Unauthorized;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_DISCONNECTED_Enter */
// From "eapol_sm.c":239
void _wpa_s8_sm_SUPP_PAE_DISCONNECTED_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_DISCONNECTED_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_DISCONNECTED) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "DISCONNECTED" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_DISCONNECTED;
	;
	sm->sPortMode = Auto;
	sm->startCount = 0;
	sm->logoffSent = FALSE;
	sm->suppPortStatus = Unauthorized;
	sm->suppAbort = TRUE;
	sm->unicast_key_received = FALSE;
	sm->broadcast_key_received = FALSE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_CONNECTING_Enter */
// From "eapol_sm.c":253
void _wpa_s8_sm_SUPP_PAE_CONNECTING_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_CONNECTING_Enter(struct eapol_sm __far * sm, int global) {
	int send_start /* = sm->SUPP_PAE_state==SUPP_PAE_CONNECTING */; 	// From "eapol_sm.c":255

	send_start = sm->SUPP_PAE_state==SUPP_PAE_CONNECTING;

	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_CONNECTING) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "CONNECTING" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_CONNECTING;
	;
	if (send_start) {
		sm->startWhen = sm->startPeriod;
		sm->startCount++;
	}
	else {
		sm->startWhen = 3;
	}
	sm->eapolEap = FALSE;
	if (send_start)
		_wpa_s8_eapol_sm_txStart(sm);
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_AUTHING_Enter */
// From "eapol_sm.c":276
void _wpa_s8_sm_SUPP_PAE_AUTHING_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_AUTHING_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_AUTHENTICATING) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "AUTHENTICATING" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_AUTHENTICATING;
	;
	sm->startCount = 0;
	sm->suppSuccess = FALSE;
	sm->suppFail = FALSE;
	sm->suppTimeout = FALSE;
	sm->keyRun = FALSE;
	sm->keyDone = FALSE;
	sm->suppStart = TRUE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_HELD_Enter */
// From "eapol_sm.c":289
void _wpa_s8_sm_SUPP_PAE_HELD_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_HELD_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_HELD) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "HELD" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_HELD;
	;
	sm->heldWhile = sm->heldPeriod;
	sm->suppPortStatus = Unauthorized;
	sm->cb_status = EAPOL_CB_FAILURE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_AUTHED_Enter */
// From "eapol_sm.c":298
void _wpa_s8_sm_SUPP_PAE_AUTHED_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_AUTHED_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_AUTHENTICATED) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "AUTHENTICATED" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_AUTHENTICATED;
	;
	sm->suppPortStatus = Authorized;
	sm->cb_status = EAPOL_CB_SUCCESS;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_RESTART_Enter */
// From "eapol_sm.c":306
void _wpa_s8_sm_SUPP_PAE_RESTART_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_RESTART_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_RESTART) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "RESTART" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_RESTART;
	;
	sm->eapRestart = TRUE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_S_FORCE_AUTH_Enter */
// From "eapol_sm.c":313
void _wpa_s8_sm_SUPP_PAE_S_FORCE_AUTH_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_S_FORCE_AUTH_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_S_FORCE_AUTH) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "S_FORCE_AUTH" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_S_FORCE_AUTH;
	;
	sm->suppPortStatus = Authorized;
	sm->sPortMode = ForceAuthorized;
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_S_FORCE_UNAUTH_Enter */
// From "eapol_sm.c":321
void _wpa_s8_sm_SUPP_PAE_S_FORCE_UNAUTH_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_S_FORCE_UNAUTH_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_PAE_state!=SUPP_PAE_S_FORCE_UNAUTH) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_PAE",
		 "S_FORCE_UNAUTH" ));
	}
	sm->SUPP_PAE_state = SUPP_PAE_S_FORCE_UNAUTH;
	;
	sm->suppPortStatus = Unauthorized;
	sm->sPortMode = ForceUnauthorized;
	_wpa_s8_eapol_sm_txLogoff(sm);
}

/*** BeginHeader _wpa_s8_sm_SUPP_PAE_Step */
// From "eapol_sm.c":330
void _wpa_s8_sm_SUPP_PAE_Step(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_PAE_Step(struct eapol_sm __far * sm) {
	if ((sm->userLogoff &&
	!sm->logoffSent) &&
	!(sm->initialize ||
	!sm->portEnabled))
		_wpa_s8_sm_SUPP_PAE_LOGOFF_Enter(sm, 1);
	else if (((sm->portControl==Auto) &&
	(sm->sPortMode!=sm->portControl)) ||
	sm->initialize ||
	!sm->portEnabled)
		_wpa_s8_sm_SUPP_PAE_DISCONNECTED_Enter(sm, 1);
	else if ((sm->portControl==ForceAuthorized) &&
	(sm->sPortMode!=sm->portControl) &&
	!(sm->initialize ||
	!sm->portEnabled))
		_wpa_s8_sm_SUPP_PAE_S_FORCE_AUTH_Enter(sm, 1);
	else if ((sm->portControl==ForceUnauthorized) &&
	(sm->sPortMode!=sm->portControl) &&
	!(sm->initialize ||
	!sm->portEnabled))
		_wpa_s8_sm_SUPP_PAE_S_FORCE_UNAUTH_Enter(sm, 1);
	else
		switch ((int)(sm->SUPP_PAE_state)) {
			case SUPP_PAE_UNKNOWN:
			break;
			case SUPP_PAE_LOGOFF:
			if (!sm->userLogoff)
				_wpa_s8_sm_SUPP_PAE_DISCONNECTED_Enter(sm, 0);
			break;
			case SUPP_PAE_DISCONNECTED:
			_wpa_s8_sm_SUPP_PAE_CONNECTING_Enter(sm, 0);
			break;
			case SUPP_PAE_CONNECTING:
			if (sm->startWhen==0 &&
			sm->startCount<sm->maxStart)
				_wpa_s8_sm_SUPP_PAE_CONNECTING_Enter(sm, 0);
			else if (sm->startWhen==0 &&
			sm->startCount>=sm->maxStart &&
			sm->portValid)
				_wpa_s8_sm_SUPP_PAE_AUTHED_Enter(sm, 0);
			else if (sm->eapSuccess ||
			sm->eapFail)
				_wpa_s8_sm_SUPP_PAE_AUTHING_Enter(sm, 0);
			else if (sm->eapolEap)
				_wpa_s8_sm_SUPP_PAE_RESTART_Enter(sm, 0);
			else if (sm->startWhen==0 &&
			sm->startCount>=sm->maxStart &&
			!sm->portValid)
				_wpa_s8_sm_SUPP_PAE_HELD_Enter(sm, 0);
			break;
			case SUPP_PAE_AUTHENTICATING:
			if (sm->eapSuccess &&
			!sm->portValid &&
			sm->conf.accept_802_1x_keys &&
			sm->conf.required_keys==0) {
				_WPA_PRINTF((MSG_DEBUG, "EAPOL: IEEE 802.1X for " \
				 "plaintext connection; no EAPOL-Key frames " \
				 "required" ));
				sm->portValid = TRUE;
				if (sm->ctx->eapol_done_cb)
					sm->ctx->eapol_done_cb((void  __far * )(sm->ctx->ctx));
			}
			if (sm->eapSuccess &&
			sm->portValid)
				_wpa_s8_sm_SUPP_PAE_AUTHED_Enter(sm, 0);
			else if (sm->eapFail ||
			(sm->keyDone &&
			!sm->portValid))
				_wpa_s8_sm_SUPP_PAE_HELD_Enter(sm, 0);
			else if (sm->suppTimeout)
				_wpa_s8_sm_SUPP_PAE_CONNECTING_Enter(sm, 0);
			break;
			case SUPP_PAE_HELD:
			if (sm->heldWhile==0)
				_wpa_s8_sm_SUPP_PAE_CONNECTING_Enter(sm, 0);
			else if (sm->eapolEap)
				_wpa_s8_sm_SUPP_PAE_RESTART_Enter(sm, 0);
			break;
			case SUPP_PAE_AUTHENTICATED:
			if (sm->eapolEap &&
			sm->portValid)
				_wpa_s8_sm_SUPP_PAE_RESTART_Enter(sm, 0);
			else if (!sm->portValid)
				_wpa_s8_sm_SUPP_PAE_DISCONNECTED_Enter(sm, 0);
			break;
			case SUPP_PAE_RESTART:
			if (!sm->eapRestart)
				_wpa_s8_sm_SUPP_PAE_AUTHING_Enter(sm, 0);
			break;
			case SUPP_PAE_S_FORCE_AUTH:
			break;
			case SUPP_PAE_S_FORCE_UNAUTH:
			break;
		}
}

/*** BeginHeader _wpa_s8_sm_KEY_RX_NO_KEY_RECEIVE_Enter */
// From "eapol_sm.c":415
void _wpa_s8_sm_KEY_RX_NO_KEY_RECEIVE_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_KEY_RX_NO_KEY_RECEIVE_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->KEY_RX_state!=KEY_RX_NO_KEY_RECEIVE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "KEY_RX",
		 "NO_KEY_RECEIVE" ));
	}
	sm->KEY_RX_state = KEY_RX_NO_KEY_RECEIVE;
	;
}

/*** BeginHeader _wpa_s8_sm_KEY_RX_KEY_RECEIVE_Enter */
// From "eapol_sm.c":421
void _wpa_s8_sm_KEY_RX_KEY_RECEIVE_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_KEY_RX_KEY_RECEIVE_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->KEY_RX_state!=KEY_RX_KEY_RECEIVE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "KEY_RX",
		 "KEY_RECEIVE" ));
	}
	sm->KEY_RX_state = KEY_RX_KEY_RECEIVE;
	;
	_wpa_s8_eapol_sm_processKey(sm);
	sm->rxKey = FALSE;
}

/*** BeginHeader _wpa_s8_sm_KEY_RX_Step */
// From "eapol_sm.c":429
void _wpa_s8_sm_KEY_RX_Step(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_KEY_RX_Step(struct eapol_sm __far * sm) {
	if (sm->initialize ||
	!sm->portEnabled)
		_wpa_s8_sm_KEY_RX_NO_KEY_RECEIVE_Enter(sm, 1);
	switch ((int)(sm->KEY_RX_state)) {
		case KEY_RX_UNKNOWN:
		break;
		case KEY_RX_NO_KEY_RECEIVE:
		if (sm->rxKey)
			_wpa_s8_sm_KEY_RX_KEY_RECEIVE_Enter(sm, 0);
		break;
		case KEY_RX_KEY_RECEIVE:
		if (sm->rxKey)
			_wpa_s8_sm_KEY_RX_KEY_RECEIVE_Enter(sm, 0);
		break;
	}
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_REQUEST_Enter */
// From "eapol_sm.c":448
void _wpa_s8_sm_SUPP_BE_REQUEST_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_REQUEST_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_REQUEST) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "REQUEST" ));
	}
	sm->SUPP_BE_state = SUPP_BE_REQUEST;
	;
	sm->authWhile = 0;
	sm->eapReq = TRUE;
	_wpa_s8_eapol_sm_getSuppRsp(sm);
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_RESPONSE_Enter */
// From "eapol_sm.c":457
void _wpa_s8_sm_SUPP_BE_RESPONSE_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_RESPONSE_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_RESPONSE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "RESPONSE" ));
	}
	sm->SUPP_BE_state = SUPP_BE_RESPONSE;
	;
	_wpa_s8_eapol_sm_txSuppRsp(sm);
	sm->eapResp = FALSE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_SUCCESS_Enter */
// From "eapol_sm.c":465
void _wpa_s8_sm_SUPP_BE_SUCCESS_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_SUCCESS_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_SUCCESS) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "SUCCESS" ));
	}
	sm->SUPP_BE_state = SUPP_BE_SUCCESS;
	;
	sm->keyRun = TRUE;
	sm->suppSuccess = TRUE;
	if (eap_key_available(sm->eap)) {
		sm->replay_counter_valid = FALSE;
	}
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_FAIL_Enter */
// From "eapol_sm.c":479
void _wpa_s8_sm_SUPP_BE_FAIL_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_FAIL_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_FAIL) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "FAIL" ));
	}
	sm->SUPP_BE_state = SUPP_BE_FAIL;
	;
	sm->suppFail = TRUE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_TIMEOUT_Enter */
// From "eapol_sm.c":486
void _wpa_s8_sm_SUPP_BE_TIMEOUT_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_TIMEOUT_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_TIMEOUT) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "TIMEOUT" ));
	}
	sm->SUPP_BE_state = SUPP_BE_TIMEOUT;
	;
	sm->suppTimeout = TRUE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_IDLE_Enter */
// From "eapol_sm.c":493
void _wpa_s8_sm_SUPP_BE_IDLE_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_IDLE_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_IDLE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "IDLE" ));
	}
	sm->SUPP_BE_state = SUPP_BE_IDLE;
	;
	sm->suppStart = FALSE;
	sm->initial_req = TRUE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_INITIALIZE_Enter */
// From "eapol_sm.c":501
void _wpa_s8_sm_SUPP_BE_INITIALIZE_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_INITIALIZE_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_INITIALIZE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "INITIALIZE" ));
	}
	sm->SUPP_BE_state = SUPP_BE_INITIALIZE;
	;
	_wpa_s8_eapol_sm_abortSupp(sm);
	sm->suppAbort = FALSE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_RECEIVE_Enter */
// From "eapol_sm.c":509
void _wpa_s8_sm_SUPP_BE_RECEIVE_Enter(struct eapol_sm __far * sm, int global);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_RECEIVE_Enter(struct eapol_sm __far * sm, int global) {
	if (!global ||
	sm->SUPP_BE_state!=SUPP_BE_RECEIVE) {
		sm->changed = TRUE;
		_WPA_PRINTF((MSG_DEBUG, "%s: %s entering state %s", "EAPOL", "SUPP_BE",
		 "RECEIVE" ));
	}
	sm->SUPP_BE_state = SUPP_BE_RECEIVE;
	;
	sm->authWhile = sm->authPeriod;
	sm->eapolEap = FALSE;
	sm->eapNoResp = FALSE;
	sm->initial_req = FALSE;
}

/*** BeginHeader _wpa_s8_sm_SUPP_BE_Step */
// From "eapol_sm.c":519
void _wpa_s8_sm_SUPP_BE_Step(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_sm_SUPP_BE_Step(struct eapol_sm __far * sm) {
	if (sm->initialize ||
	sm->suppAbort)
		_wpa_s8_sm_SUPP_BE_INITIALIZE_Enter(sm, 1);
	else
		switch ((int)(sm->SUPP_BE_state)) {
			case SUPP_BE_UNKNOWN:
			break;
			case SUPP_BE_REQUEST:
			if (sm->eapResp &&
			sm->eapNoResp) {
				_WPA_PRINTF((MSG_DEBUG, "EAPOL: SUPP_BE REQUEST: both " \
				 "eapResp and eapNoResp set?!" ));
			}
			if (sm->eapResp)
				_wpa_s8_sm_SUPP_BE_RESPONSE_Enter(sm, 0);
			else if (sm->eapNoResp)
				_wpa_s8_sm_SUPP_BE_RECEIVE_Enter(sm, 0);
			else if (sm->eapFail)
				_wpa_s8_sm_SUPP_BE_FAIL_Enter(sm, 0);
			else if (sm->eapSuccess)
				_wpa_s8_sm_SUPP_BE_SUCCESS_Enter(sm, 0);
			break;
			case SUPP_BE_RESPONSE:
			_wpa_s8_sm_SUPP_BE_RECEIVE_Enter(sm, 0);
			break;
			case SUPP_BE_SUCCESS:
			_wpa_s8_sm_SUPP_BE_IDLE_Enter(sm, 0);
			break;
			case SUPP_BE_FAIL:
			_wpa_s8_sm_SUPP_BE_IDLE_Enter(sm, 0);
			break;
			case SUPP_BE_TIMEOUT:
			_wpa_s8_sm_SUPP_BE_IDLE_Enter(sm, 0);
			break;
			case SUPP_BE_IDLE:
			if (sm->eapFail &&
			sm->suppStart)
				_wpa_s8_sm_SUPP_BE_FAIL_Enter(sm, 0);
			else if (sm->eapolEap &&
			sm->suppStart)
				_wpa_s8_sm_SUPP_BE_REQUEST_Enter(sm, 0);
			else if (sm->eapSuccess &&
			sm->suppStart)
				_wpa_s8_sm_SUPP_BE_SUCCESS_Enter(sm, 0);
			break;
			case SUPP_BE_INITIALIZE:
			_wpa_s8_sm_SUPP_BE_IDLE_Enter(sm, 0);
			break;
			case SUPP_BE_RECEIVE:
			if (sm->eapolEap)
				_wpa_s8_sm_SUPP_BE_REQUEST_Enter(sm, 0);
			else if (sm->eapFail)
				_wpa_s8_sm_SUPP_BE_FAIL_Enter(sm, 0);
			else if (sm->authWhile==0)
				_wpa_s8_sm_SUPP_BE_TIMEOUT_Enter(sm, 0);
			else if (sm->eapSuccess)
				_wpa_s8_sm_SUPP_BE_SUCCESS_Enter(sm, 0);
			break;
		}
}

/*** BeginHeader _wpa_s8_eapol_sm_txLogoff */
// From "eapol_sm.c":591
void _wpa_s8_eapol_sm_txLogoff(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_txLogoff(struct eapol_sm __far * sm) {
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: txLogoff" ));
	sm->ctx->eapol_send((void  __far * )(sm->ctx->eapol_send_ctx), (int  )(IEEE802_1X_TYPE_EAPOL_LOGOFF),
                     (char  __far * )((char  __far * )"" ), (size_t  )(0));
	sm->dot1xSuppEapolLogoffFramesTx++;
	sm->dot1xSuppEapolFramesTx++;
}

/*** BeginHeader _wpa_s8_eapol_sm_txStart */
// From "eapol_sm.c":601
void _wpa_s8_eapol_sm_txStart(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_txStart(struct eapol_sm __far * sm) {
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: txStart" ));
	sm->ctx->eapol_send((void  __far * )(sm->ctx->eapol_send_ctx), (int  )(IEEE802_1X_TYPE_EAPOL_START),
                     (char  __far * )((char  __far * )"" ), (size_t  )(0));
	sm->dot1xSuppEapolStartFramesTx++;
	sm->dot1xSuppEapolFramesTx++;
}
/*** BeginHeader */

enum  {
	IEEE8021X_ENCR_KEY_LEN = 32
}  ;	// From "eapol_sm.c":611

enum  {
	IEEE8021X_SIGN_KEY_LEN = 32
}  ;	// From "eapol_sm.c":612

struct eap_key_data {
	char encr_key[IEEE8021X_ENCR_KEY_LEN];
	char sign_key[IEEE8021X_SIGN_KEY_LEN];

} ;	// From "eapol_sm.c":617
/*** EndHeader */

/*** BeginHeader _wpa_s8_eapol_sm_processKey */
// From "eapol_sm.c":620
void _wpa_s8_eapol_sm_processKey(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_processKey(struct eapol_sm __far * sm) {
	struct ieee802_1x_hdr __far * hdr; 	// From "eapol_sm.c":622
	struct ieee802_1x_eapol_key __far * key; 	// From "eapol_sm.c":623
	struct eap_key_data keydata; 	// From "eapol_sm.c":624
	char orig_key_sign[IEEE8021X_KEY_SIGN_LEN]; 	// From "eapol_sm.c":625
	char datakey[32]; 	// From "eapol_sm.c":625
	char ekey[IEEE8021X_KEY_IV_LEN+IEEE8021X_ENCR_KEY_LEN]; 	// From "eapol_sm.c":626
	int key_len; 	// From "eapol_sm.c":627
	int res; 	// From "eapol_sm.c":627
	int sign_key_len; 	// From "eapol_sm.c":627
	int encr_key_len; 	// From "eapol_sm.c":627
	word rx_key_length; 	// From "eapol_sm.c":628


	_WPA_PRINTF((MSG_DEBUG, "EAPOL: processKey" ));
	if (sm->last_rx_key==((void  __far * )0))
		return /*void*/;
	if (!sm->conf.accept_802_1x_keys) {
		_WPA_PRINTF((MSG_WARNING, "EAPOL: Received IEEE 802.1X EAPOL-Key" \
		 " even though this was not accepted - " \
		 "ignoring this packet" ));
		return /*void*/;
	}
	hdr = (struct ieee802_1x_hdr  __far * )sm->last_rx_key;
	key = (struct ieee802_1x_eapol_key  __far * )(hdr+1);
	if (sizeof (*hdr)+intel16(hdr->length)>sm->last_rx_key_len) {
		_WPA_PRINTF((MSG_WARNING, "EAPOL: Too short EAPOL-Key frame" ));
		return /*void*/;
	}
	rx_key_length = ((word  )(((key->key_length)[0]<<8)|(key->key_length)[1]));
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: RX IEEE 802.1X ver=%d type=%d len=%d " \
	 "EAPOL-Key: type=%d key_length=%d key_index=0x%x" , hdr->version, hdr->type, intel16(
                                                                                       hdr->length),
              key->type, rx_key_length, key->key_index));
	eapol_sm_notify_lower_layer_success(sm);
	sign_key_len = IEEE8021X_SIGN_KEY_LEN;
	encr_key_len = IEEE8021X_ENCR_KEY_LEN;
	res = eapol_sm_get_key(sm, (char  __far * )&keydata, sizeof (keydata));
	if (res<0) {
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: Could not get master key for " \
		 "decrypting EAPOL-Key keys" ));
		return /*void*/;
	}
	if (res==16) {
		res = eapol_sm_get_key(sm, (char  __far * )&keydata, 16);
		if (res) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: Could not get LEAP " \
			 "master key for decrypting EAPOL-Key keys" ));
			return /*void*/;
		}
		sign_key_len = 16;
		encr_key_len = 16;
		_f_memcpy(keydata.sign_key, keydata.encr_key, 16);
	}
	else if (res) {
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: Could not get enough master key " \
		 "data for decrypting EAPOL-Key keys (res=%d)" , res));
		return /*void*/;
	}
	if (sm->replay_counter_valid &&
	memcmp(sm->last_replay_counter, key->replay_counter, 8)>=0) {
		_WPA_PRINTF((MSG_WARNING, "EAPOL: EAPOL-Key replay counter did " \
		 "not increase - ignoring key" ));
		_WPA_HEXDUMP((MSG_DEBUG, "EAPOL: last replay counter" , sm->last_replay_counter,
                8));
		_WPA_HEXDUMP((MSG_DEBUG, "EAPOL: received replay counter" , key->replay_counter,
                8));
		return /*void*/;
	}
	_f_memcpy(orig_key_sign, key->key_signature, IEEE8021X_KEY_SIGN_LEN);
	_f_memset(key->key_signature, 0, IEEE8021X_KEY_SIGN_LEN);
	hmac_md5(keydata.sign_key, sign_key_len, sm->last_rx_key, sizeof (*hdr)+intel16(
                                                                                 hdr->length),
          key->key_signature);
	if (memcmp(orig_key_sign, key->key_signature, IEEE8021X_KEY_SIGN_LEN)!=0) {
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: Invalid key signature in " \
		 "EAPOL-Key packet" ));
		_f_memcpy(key->key_signature, orig_key_sign, IEEE8021X_KEY_SIGN_LEN);
		return /*void*/;
	}
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: EAPOL-Key key signature verified" ));
	key_len = intel16(hdr->length)-sizeof (*key);
	if (key_len>32 ||
	rx_key_length>32) {
		_WPA_PRINTF((MSG_WARNING, "EAPOL: Too long key data length %d" , key_len ?
		  key_len :
		  rx_key_length));
		return /*void*/;
	}
	if (key_len==rx_key_length) {
		_f_memcpy(ekey, key->key_iv, IEEE8021X_KEY_IV_LEN);
		_f_memcpy(ekey+IEEE8021X_KEY_IV_LEN, keydata.encr_key, encr_key_len);
		_f_memcpy(datakey, key+1, key_len);
		// Rabbit note: use RC4Skip
		RC4Skip(ekey, IEEE8021X_KEY_IV_LEN+encr_key_len, 0, datakey, key_len);
		//rc4(datakey, key_len, ekey, IEEE8021X_KEY_IV_LEN+encr_key_len);
		_WPA_HEXDUMP((MSG_DEBUG, "EAPOL: Decrypted(RC4) key" , datakey, key_len));
	}
	else if (key_len==0) {
		key_len = rx_key_length;
		_f_memcpy(datakey, keydata.encr_key, key_len);
		_WPA_HEXDUMP((MSG_DEBUG, "EAPOL: using part of EAP keying " \
		 "material data encryption key" , datakey, key_len));
	}
	else {
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: Invalid key data length %d " \
		 "(key_length=%d)" , key_len, rx_key_length));
		return /*void*/;
	}
	sm->replay_counter_valid = TRUE;
	_f_memcpy(sm->last_replay_counter, key->replay_counter, 8);
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: Setting dynamic WEP key: %ls keyidx %d len %d" ,
              (char  __far * )(key->key_index&IEEE8021X_KEY_INDEX_FLAG ?
	  "unicast"  :
	  "broadcast" ), key->key_index&IEEE8021X_KEY_INDEX_MASK, key_len));
	if (sm->ctx->set_wep_key &&
	sm->ctx->set_wep_key((void  __far * )(sm->ctx->ctx), (int  )(key->key_index&IEEE8021X_KEY_INDEX_FLAG),
                      (int  )(key->key_index&IEEE8021X_KEY_INDEX_MASK), (char  __far * )(datakey),
                      (size_t  )(key_len))<0) {
		_WPA_PRINTF((MSG_WARNING, "EAPOL: Failed to set WEP key to the " \
		 " driver." ));
	}
	else {
		if (key->key_index&IEEE8021X_KEY_INDEX_FLAG)
			sm->unicast_key_received = TRUE;
		else
			sm->broadcast_key_received = TRUE;
		if ((sm->unicast_key_received ||
		!(sm->conf.required_keys&EAPOL_REQUIRE_KEY_UNICAST)) &&
		(sm->broadcast_key_received ||
		!(sm->conf.required_keys&EAPOL_REQUIRE_KEY_BROADCAST))) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: all required EAPOL-Key " \
			 "frames received" ));
			sm->portValid = TRUE;
			if (sm->ctx->eapol_done_cb)
				sm->ctx->eapol_done_cb((void  __far * )(sm->ctx->ctx));
		}
	}
}

/*** BeginHeader _wpa_s8_eapol_sm_getSuppRsp */
// From "eapol_sm.c":783
void _wpa_s8_eapol_sm_getSuppRsp(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_getSuppRsp(struct eapol_sm __far * sm) {
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: getSuppRsp" ));
}

/*** BeginHeader _wpa_s8_eapol_sm_txSuppRsp */
// From "eapol_sm.c":793
void _wpa_s8_eapol_sm_txSuppRsp(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_txSuppRsp(struct eapol_sm __far * sm) {
	char __far * resp; 	// From "eapol_sm.c":795
	size_t resp_len; 	// From "eapol_sm.c":796


	_WPA_PRINTF((MSG_DEBUG, "EAPOL: txSuppRsp" ));
	resp = eap_get_eapRespData(sm->eap, &resp_len);
	if (resp==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "EAPOL: txSuppRsp - EAP response data " \
		 "not available" ));
		return /*void*/;
	}
	sm->ctx->eapol_send((void  __far * )(sm->ctx->eapol_send_ctx), (int  )(IEEE802_1X_TYPE_EAP_PACKET),
                     (char  __far * )(resp), (size_t  )(resp_len));
	_sys_free(resp);
	if (sm->initial_req)
		sm->dot1xSuppEapolReqIdFramesRx++;
	else
		sm->dot1xSuppEapolReqFramesRx++;
	sm->dot1xSuppEapolRespFramesTx++;
	sm->dot1xSuppEapolFramesTx++;
}

/*** BeginHeader _wpa_s8_eapol_sm_abortSupp */
// From "eapol_sm.c":822
void _wpa_s8_eapol_sm_abortSupp(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_abortSupp(struct eapol_sm __far * sm) {
	_sys_free(sm->last_rx_key);
	sm->last_rx_key = ((void  __far * )0);
	_sys_free(sm->eapReqData);
	sm->eapReqData = ((void  __far * )0);
	eap_sm_abort(sm->eap);
}

/*** BeginHeader _wpa_s8_eapol_sm_step_timeout */
// From "eapol_sm.c":834
void _wpa_s8_eapol_sm_step_timeout(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_step_timeout(void __far * eloop_ctx, void __far * timeout_ctx) {
	eapol_sm_step(timeout_ctx);
}

/*** BeginHeader eapol_sm_step */
// From "eapol_sm.c":848
void eapol_sm_step(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_step(struct eapol_sm __far * sm) {
	int i; 	// From "eapol_sm.c":850

	union  {

		struct  {
			int success /* = sm->cb_status==EAPOL_CB_SUCCESS ?
			  1 :
			  0 */;

		} __s3;

	} __u; 	// From "eapol_sm.c":849


	for (i = 0; i<100; i++) {
		sm->changed = FALSE;
		_wpa_s8_sm_SUPP_PAE_Step(sm);
		_wpa_s8_sm_KEY_RX_Step(sm);
		_wpa_s8_sm_SUPP_BE_Step(sm);
		if (eap_sm_step(sm->eap))
			sm->changed = TRUE;
		if (!sm->changed)
			break;
	}
	if (sm->changed) {
		eloop_cancel_timeout(_wpa_s8_eapol_sm_step_timeout, ((void  __far * )0), sm);
		eloop_register_timeout(0, _wpa_s8_eapol_sm_step_timeout, ((void  __far * )0),
                         sm);
	}
	if (sm->ctx->cb &&
	sm->cb_status!=EAPOL_CB_IN_PROGRESS) {
		__u.__s3.success = sm->cb_status==EAPOL_CB_SUCCESS ?
		  1 :
		  0;

		sm->cb_status = EAPOL_CB_IN_PROGRESS;
		sm->ctx->cb((struct eapol_sm  __far * )(sm), (int  )(__u.__s3.success), (void  __far * )(sm->ctx->cb_ctx));
	}
}

/*** BeginHeader _wpa_s8_eapol_port_control */
// From "eapol_sm.c":942
char __far * _wpa_s8_eapol_port_control(PortControl ctrl);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s8_eapol_port_control(PortControl ctrl) {
	switch ((int)(ctrl)) {
		case Auto:
		return "Auto" ;
		case ForceUnauthorized:
		return "ForceUnauthorized" ;
		case ForceAuthorized:
		return "ForceAuthorized" ;
		default:
		return "Unknown" ;
	}
}

/*** BeginHeader eapol_sm_configure */
// From "eapol_sm.c":969
void eapol_sm_configure(struct eapol_sm __far * sm, int heldPeriod, int authPeriod,
                        int startPeriod, int maxStart);
/*** EndHeader */
_wpa_debug
void eapol_sm_configure(struct eapol_sm __far * sm, int heldPeriod, int authPeriod,
                        int startPeriod, int maxStart) {
	if (sm==((void  __far * )0))
		return /*void*/;
	if (heldPeriod>=0)
		sm->heldPeriod = heldPeriod;
	if (authPeriod>=0)
		sm->authPeriod = authPeriod;
	if (startPeriod>=0)
		sm->startPeriod = startPeriod;
	if (maxStart>=0)
		sm->maxStart = maxStart;
}

/*** BeginHeader eapol_sm_rx_eapol */
// From "eapol_sm.c":1121
int eapol_sm_rx_eapol(struct eapol_sm __far * sm, char __far * src, char __far * buf,
                      size_t len);
/*** EndHeader */
_wpa_debug
int eapol_sm_rx_eapol(struct eapol_sm __far * sm, char __far * src, char __far * buf,
                      size_t len) {
	struct ieee802_1x_hdr __far * hdr; 	// From "eapol_sm.c":1124
	struct ieee802_1x_eapol_key __far * key; 	// From "eapol_sm.c":1125
	int data_len; 	// From "eapol_sm.c":1126
	int res /* = 1 */; 	// From "eapol_sm.c":1127
	size_t plen; 	// From "eapol_sm.c":1128

	res = 1;
	if (sm==((void  __far * )0))
		return 0;
	sm->dot1xSuppEapolFramesRx++;
	if (len<sizeof (*hdr)) {
		sm->dot1xSuppInvalidEapolFramesRx++;
		return 0;
	}
	hdr = (struct ieee802_1x_hdr  __far * )buf;
	sm->dot1xSuppLastEapolFrameVersion = hdr->version;
	_f_memcpy(sm->dot1xSuppLastEapolFrameSource, src, 6);
	if (hdr->version<2) {
	}
	plen = intel16(hdr->length);
	if (plen>len-sizeof (*hdr)) {
		sm->dot1xSuppEapLengthErrorFramesRx++;
		return 0;
	}
	data_len = plen+sizeof (*hdr);
	switch ((int)(hdr->type)) {
		case IEEE802_1X_TYPE_EAP_PACKET:
#ifdef WPA_USE_PMKSA_CACHE
		if (sm->cached_pmk) {
			_wpa_s8_eapol_sm_abort_cached(sm);
		}
#else
   _WPA_PRINTF((MSG_WARNING, "eapol_sm_rx_eapol: Skipping check for cached PMK"));
#endif//def WPA_USE_PMKSA_CACHE
		_sys_free(sm->eapReqData);
		sm->eapReqDataLen = plen;
		sm->eapReqData = _sys_malloc(sm->eapReqDataLen);
		if (sm->eapReqData) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: Received EAP-Packet " \
			 "frame" ));
			_f_memcpy(sm->eapReqData, (char  __far * )(hdr+1), sm->eapReqDataLen);
			sm->eapolEap = TRUE;
			eapol_sm_step(sm);
		}
		break;
		case IEEE802_1X_TYPE_EAPOL_KEY:
		if (plen<sizeof (*key)) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: Too short EAPOL-Key " \
			 "frame received" ));
			break;
		}
		key = (struct ieee802_1x_eapol_key  __far * )(hdr+1);
		if (key->type==EAPOL_KEY_TYPE_WPA ||
		key->type==EAPOL_KEY_TYPE_RSN) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: Ignoring WPA EAPOL-Key " \
			 "frame in EAPOL state machines" ));
			res = 0;
			break;
		}
		if (key->type!=EAPOL_KEY_TYPE_RC4) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: Ignored unknown " \
			 "EAPOL-Key type %d" , key->type));
			break;
		}
		_sys_free(sm->last_rx_key);
		sm->last_rx_key = _sys_malloc(data_len);
		if (sm->last_rx_key) {
			_WPA_PRINTF((MSG_DEBUG, "EAPOL: Received EAPOL-Key " \
			 "frame" ));
			_f_memcpy(sm->last_rx_key, buf, data_len);
			sm->last_rx_key_len = data_len;
			sm->rxKey = TRUE;
			eapol_sm_step(sm);
		}
		break;
		default:
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: Received unknown EAPOL type %d" , hdr->type));
		sm->dot1xSuppInvalidEapolFramesRx++;
		break;
	}
	return res;
}

/*** BeginHeader eapol_sm_notify_tx_eapol_key */
// From "eapol_sm.c":1220
void eapol_sm_notify_tx_eapol_key(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_tx_eapol_key(struct eapol_sm __far * sm) {
	if (sm)
		sm->dot1xSuppEapolFramesTx++;
}

/*** BeginHeader eapol_sm_notify_portEnabled */
// From "eapol_sm.c":1234
void eapol_sm_notify_portEnabled(struct eapol_sm __far * sm, Boolean enabled);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_portEnabled(struct eapol_sm __far * sm, Boolean enabled) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: External notification - " \
	 "%s=%d" , "portEnabled", enabled));
	sm->portEnabled = enabled;
	eapol_sm_step(sm);
}

/*** BeginHeader eapol_sm_notify_portValid */
// From "eapol_sm.c":1252
void eapol_sm_notify_portValid(struct eapol_sm __far * sm, Boolean valid);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_portValid(struct eapol_sm __far * sm, Boolean valid) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: External notification - " \
	 "%s=%d" , "portValid", valid));
	sm->portValid = valid;
	eapol_sm_step(sm);
}

/*** BeginHeader eapol_sm_notify_eap_success */
// From "eapol_sm.c":1274
void eapol_sm_notify_eap_success(struct eapol_sm __far * sm, Boolean success);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_eap_success(struct eapol_sm __far * sm, Boolean success) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: External notification - " \
	 "%s=%d" , "EAP success", success));
	sm->eapSuccess = success;
	sm->altAccept = success;
	if (success)
		eap_notify_success(sm->eap);
	eapol_sm_step(sm);
}

/*** BeginHeader eapol_sm_notify_eap_fail */
// From "eapol_sm.c":1296
void eapol_sm_notify_eap_fail(struct eapol_sm __far * sm, Boolean fail);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_eap_fail(struct eapol_sm __far * sm, Boolean fail) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: External notification - " \
	 "%s=%d" , "EAP fail", fail));
	sm->eapFail = fail;
	sm->altReject = fail;
	eapol_sm_step(sm);
}

/*** BeginHeader eapol_sm_notify_config */
// From "eapol_sm.c":1320
void eapol_sm_notify_config(struct eapol_sm __far * sm, struct wpa_ssid __far * config,
                            struct eapol_config __far * conf);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_config(struct eapol_sm __far * sm, struct wpa_ssid __far * config,
                            struct eapol_config __far * conf) {
	if (sm==((void  __far * )0))
		return /*void*/;
	sm->config = config;
	if (conf==((void  __far * )0))
		return /*void*/;
	sm->conf.accept_802_1x_keys = conf->accept_802_1x_keys;
	sm->conf.required_keys = conf->required_keys;
	sm->conf.fast_reauth = conf->fast_reauth;
	if (sm->eap) {
		eap_set_fast_reauth(sm->eap, conf->fast_reauth);
		eap_set_workaround(sm->eap, conf->workaround);
		eap_set_force_disabled(sm->eap, conf->eap_disabled);
	}
}

/*** BeginHeader eapol_sm_get_key */
// From "eapol_sm.c":1353
int eapol_sm_get_key(struct eapol_sm __far * sm, char __far * key, size_t len);
/*** EndHeader */
_wpa_debug
int eapol_sm_get_key(struct eapol_sm __far * sm, char __far * key, size_t len) {
	char __far * eap_key; 	// From "eapol_sm.c":1355
	size_t eap_len; 	// From "eapol_sm.c":1356


	if (sm==((void  __far * )0) ||
	!eap_key_available(sm->eap))
		return  -1;
	eap_key = eap_get_eapKeyData(sm->eap, &eap_len);
	if (eap_key==((void  __far * )0))
		return  -1;
	if (len>eap_len)
		return eap_len;
	_f_memcpy(key, eap_key, len);
	return 0;
}

/*** BeginHeader eapol_sm_notify_logoff */
// From "eapol_sm.c":1377
void eapol_sm_notify_logoff(struct eapol_sm __far * sm, Boolean logoff);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_logoff(struct eapol_sm __far * sm, Boolean logoff) {
	if (sm) {
		sm->userLogoff = logoff;
		eapol_sm_step(sm);
	}
}

/*** BeginHeader eapol_sm_notify_cached */
// From "eapol_sm.c":1393
void eapol_sm_notify_cached(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_cached(struct eapol_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	sm->SUPP_PAE_state = SUPP_PAE_AUTHENTICATED;
	sm->suppPortStatus = Authorized;
	eap_notify_success(sm->eap);
}

/*** BeginHeader eapol_sm_notify_pmkid_attempt */
// From "eapol_sm.c":1410
void eapol_sm_notify_pmkid_attempt(struct eapol_sm __far * sm, int attempt);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_pmkid_attempt(struct eapol_sm __far * sm, int attempt) {
	if (sm==((void  __far * )0))
		return /*void*/;
	if (attempt) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Trying to use cached PMKSA" ));
		sm->cached_pmk = TRUE;
	}
	else {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Do not try to use cached PMKSA" ));
		sm->cached_pmk = FALSE;
	}
}

/*** BeginHeader _wpa_s8_eapol_sm_abort_cached */
// From "eapol_sm.c":1424
void _wpa_s8_eapol_sm_abort_cached(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_abort_cached(struct eapol_sm __far * sm) {
	_WPA_PRINTF((MSG_DEBUG, "RSN: Authenticator did not accept PMKID, " \
	 "doing full EAP authentication" ));
	if (sm==((void  __far * )0))
		return /*void*/;
	sm->cached_pmk = FALSE;
	sm->SUPP_PAE_state = SUPP_PAE_CONNECTING;
	sm->suppPortStatus = Unauthorized;
	sm->startWhen = 3;
	if (sm->ctx->aborted_cached)
		sm->ctx->aborted_cached((void  __far * )(sm->ctx->ctx));
}

/*** BeginHeader eapol_sm_register_scard_ctx */
// From "eapol_sm.c":1451
void eapol_sm_register_scard_ctx(struct eapol_sm __far * sm, void __far * ctx);
/*** EndHeader */
_wpa_debug
void eapol_sm_register_scard_ctx(struct eapol_sm __far * sm, void __far * ctx) {
	if (sm) {
		sm->ctx->scard_ctx = ctx;
		eap_register_scard_ctx(sm->eap, ctx);
	}
}

/*** BeginHeader eapol_sm_notify_portControl */
// From "eapol_sm.c":1467
void eapol_sm_notify_portControl(struct eapol_sm __far * sm, PortControl portControl);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_portControl(struct eapol_sm __far * sm, PortControl portControl) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "EAPOL: External notification - %s=%ls" , "portControl", (char  __far * )(_wpa_s8_eapol_port_control(
                                                                                                                      portControl))));
	sm->portControl = portControl;
	eapol_sm_step(sm);
}

/*** BeginHeader eapol_sm_notify_ctrl_attached */
// From "eapol_sm.c":1485
void eapol_sm_notify_ctrl_attached(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_ctrl_attached(struct eapol_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	eap_sm_notify_ctrl_attached(sm->eap);
}

/*** BeginHeader eapol_sm_notify_ctrl_response */
// From "eapol_sm.c":1500
void eapol_sm_notify_ctrl_response(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_ctrl_response(struct eapol_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	if (sm->eapReqData &&
	!sm->eapReq) {
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: received control response (user " \
		 "input) notification - retrying pending EAP " \
		 "Request" ));
		sm->eapolEap = TRUE;
		sm->eapReq = TRUE;
		eapol_sm_step(sm);
	}
}

/*** BeginHeader eapol_sm_request_reauth */
// From "eapol_sm.c":1522
void eapol_sm_request_reauth(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_request_reauth(struct eapol_sm __far * sm) {
	if (sm==((void  __far * )0) ||
	sm->SUPP_PAE_state!=SUPP_PAE_AUTHENTICATED)
		return /*void*/;
	_wpa_s8_eapol_sm_txStart(sm);
}

/*** BeginHeader eapol_sm_notify_lower_layer_success */
// From "eapol_sm.c":1538
void eapol_sm_notify_lower_layer_success(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_notify_lower_layer_success(struct eapol_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	eap_notify_lower_layer_success(sm->eap);
}

/*** BeginHeader eapol_sm_invalidate_cached_session */
// From "eapol_sm.c":1550
void eapol_sm_invalidate_cached_session(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_invalidate_cached_session(struct eapol_sm __far * sm) {
	if (sm)
		eap_invalidate_cached_session(sm->eap);
}

/*** BeginHeader _wpa_s8_eapol_sm_get_config */
// From "eapol_sm.c":1557
struct wpa_ssid __far * _wpa_s8_eapol_sm_get_config(void __far * ctx);
/*** EndHeader */
_wpa_debug
struct wpa_ssid __far * _wpa_s8_eapol_sm_get_config(void __far * ctx) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1559

	sm = ctx;

	return sm ?
	  sm->config :
	  ((void  __far * )0);
}

/*** BeginHeader _wpa_s8_eapol_sm_get_eapReqData */
// From "eapol_sm.c":1564
char __far * _wpa_s8_eapol_sm_get_eapReqData(void __far * ctx, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s8_eapol_sm_get_eapReqData(void __far * ctx, size_t __far * len) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1566

	sm = ctx;

	if (sm==((void  __far * )0) ||
	sm->eapReqData==((void  __far * )0)) {
		*len = 0;
		return ((void  __far * )0);
	}
	*len = sm->eapReqDataLen;
	return sm->eapReqData;
}

/*** BeginHeader _wpa_s8_eapol_sm_get_bool */
// From "eapol_sm.c":1577
Boolean _wpa_s8_eapol_sm_get_bool(void __far * ctx, enum eapol_bool_var variable);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s8_eapol_sm_get_bool(void __far * ctx, enum eapol_bool_var variable) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1579

	sm = ctx;

	if (sm==((void  __far * )0))
		return FALSE;
	switch ((int)(variable)) {
		case EAPOL_eapSuccess:
		return sm->eapSuccess;
		case EAPOL_eapRestart:
		return sm->eapRestart;
		case EAPOL_eapFail:
		return sm->eapFail;
		case EAPOL_eapResp:
		return sm->eapResp;
		case EAPOL_eapNoResp:
		return sm->eapNoResp;
		case EAPOL_eapReq:
		return sm->eapReq;
		case EAPOL_portEnabled:
		return sm->portEnabled;
		case EAPOL_altAccept:
		return sm->altAccept;
		case EAPOL_altReject:
		return sm->altReject;
	}
	return FALSE;
}

/*** BeginHeader _wpa_s8_eapol_sm_set_bool */
// From "eapol_sm.c":1606
void _wpa_s8_eapol_sm_set_bool(void __far * ctx, enum eapol_bool_var variable, Boolean value);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_set_bool(void __far * ctx, enum eapol_bool_var variable, Boolean value) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1609

	sm = ctx;

	if (sm==((void  __far * )0))
		return /*void*/;
	switch ((int)(variable)) {
		case EAPOL_eapSuccess:
		sm->eapSuccess = value;
		break;
		case EAPOL_eapRestart:
		sm->eapRestart = value;
		break;
		case EAPOL_eapFail:
		sm->eapFail = value;
		break;
		case EAPOL_eapResp:
		sm->eapResp = value;
		break;
		case EAPOL_eapNoResp:
		sm->eapNoResp = value;
		break;
		case EAPOL_eapReq:
		sm->eapReq = value;
		break;
		case EAPOL_portEnabled:
		sm->portEnabled = value;
		break;
		case EAPOL_altAccept:
		sm->altAccept = value;
		break;
		case EAPOL_altReject:
		sm->altReject = value;
		break;
	}
}

/*** BeginHeader _wpa_s8_eapol_sm_get_int */
// From "eapol_sm.c":1644
unsigned int _wpa_s8_eapol_sm_get_int(void __far * ctx, enum eapol_int_var variable);
/*** EndHeader */
_wpa_debug
unsigned int _wpa_s8_eapol_sm_get_int(void __far * ctx, enum eapol_int_var variable) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1646

	sm = ctx;

	if (sm==((void  __far * )0))
		return 0;
	switch ((int)(variable)) {
		case EAPOL_idleWhile:
		return sm->idleWhile;
	}
	return 0;
}

/*** BeginHeader _wpa_s8_eapol_sm_set_int */
// From "eapol_sm.c":1657
void _wpa_s8_eapol_sm_set_int(void __far * ctx, enum eapol_int_var variable, unsigned int value);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_set_int(void __far * ctx, enum eapol_int_var variable, unsigned int value) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1660

	sm = ctx;

	if (sm==((void  __far * )0))
		return /*void*/;
	switch ((int)(variable)) {
		case EAPOL_idleWhile:
		sm->idleWhile = value;
		break;
	}
}

/*** BeginHeader _wpa_s8_eapol_sm_set_config_blob */
// From "eapol_sm.c":1671
void _wpa_s8_eapol_sm_set_config_blob(void __far * ctx, struct wpa_config_blob __far * blob);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_set_config_blob(void __far * ctx, struct wpa_config_blob __far * blob) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1673

	sm = ctx;

	if (sm &&
	sm->ctx &&
	sm->ctx->set_config_blob)
		sm->ctx->set_config_blob((void  __far * )(sm->ctx->ctx), (struct wpa_config_blob  __far * )(blob));
}

/*** BeginHeader _wpa_s8_eapol_sm_get_config_blob */
// From "eapol_sm.c":1680
struct wpa_config_blob __far * _wpa_s8_eapol_sm_get_config_blob(void __far * ctx, char __far * name);
/*** EndHeader */
_wpa_debug
struct wpa_config_blob __far * _wpa_s8_eapol_sm_get_config_blob(void __far * ctx, char __far * name) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1682
   // Rabbit note: Internal error: Expression temporary stack usage, adding tmp vars
   struct wpa_config_blob __far * tmp_retval;
	struct wpa_config_blob __far * (FUNCPTR tmp_get_config_blob)( /* void far * ctx, char far * name */ );
   void __far * tmp_ctx;

	sm = ctx;

	if (sm &&
	sm->ctx &&
	sm->ctx->get_config_blob)
      // Rabbit note: Internal error: Expression temporary stack usage
		// Rabbit note: return sm->ctx->get_config_blob((void  far * )(sm->ctx->ctx), (char  far * )(name));
   {
      tmp_get_config_blob = sm->ctx->get_config_blob;
      tmp_ctx = sm->ctx->ctx;
      tmp_retval = (void __far *) tmp_get_config_blob(tmp_ctx, name);
      return tmp_retval;
   }
	else
		return ((void  __far * )0);
}

/*** BeginHeader _wpa_s8_eapol_sm_notify_pending */
// From "eapol_sm.c":1690
void _wpa_s8_eapol_sm_notify_pending(void __far * ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s8_eapol_sm_notify_pending(void __far * ctx) {
	struct eapol_sm __far * sm /* = ctx */; 	// From "eapol_sm.c":1692

	sm = ctx;

	if (sm==((void  __far * )0))
		return /*void*/;
	if (sm->eapReqData &&
	!sm->eapReq) {
		_WPA_PRINTF((MSG_DEBUG, "EAPOL: received notification from EAP " \
		 "state machine - retrying pending EAP Request" ));
		sm->eapolEap = TRUE;
		sm->eapReq = TRUE;
		eapol_sm_step(sm);
	}
}
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader eapol_sm_init */
// From "eapol_sm.c":1727
struct eapol_sm __far * eapol_sm_init(struct eapol_ctx __far * ctx);
/*** EndHeader */
_wpa_debug
struct eapol_sm __far * eapol_sm_init(struct eapol_ctx __far * ctx) {
	struct eapol_sm __far * sm; 	// From "eapol_sm.c":1729
	struct eap_config conf; 	// From "eapol_sm.c":1730


	sm = _sys_calloc(sizeof (*sm));
	if (sm==((void  __far * )0))
		return ((void  __far * )0);
	sm->ctx = ctx;
	sm->portControl = Auto;
	sm->heldPeriod = 60;
	sm->startPeriod = 30;
	sm->maxStart = 3;
	sm->authPeriod = 30;
	_f_memset(&conf, 0, sizeof (conf));
	conf.opensc_engine_path = ctx->opensc_engine_path;
	conf.pkcs11_engine_path = ctx->pkcs11_engine_path;
	conf.pkcs11_module_path = ctx->pkcs11_module_path;
	sm->eap = eap_sm_init(sm, &__wpa_globals.__s8.eapol_cb, sm->ctx->msg_ctx, &conf);
	if (sm->eap==((void  __far * )0)) {
		_sys_free(sm);
		return ((void  __far * )0);
	}
	sm->initialize = TRUE;
	eapol_sm_step(sm);
	sm->initialize = FALSE;
	eapol_sm_step(sm);
	eloop_register_timeout(1000, _wpa_s8_eapol_port_timers_tick, ((void  __far * )0),
                        sm);
	return sm;
}

/*** BeginHeader eapol_sm_deinit */
// From "eapol_sm.c":1775
void eapol_sm_deinit(struct eapol_sm __far * sm);
/*** EndHeader */
_wpa_debug
void eapol_sm_deinit(struct eapol_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	eloop_cancel_timeout(_wpa_s8_eapol_sm_step_timeout, ((void  __far * )0), sm);
	eloop_cancel_timeout(_wpa_s8_eapol_port_timers_tick, ((void  __far * )0), sm);
	eap_sm_deinit(sm->eap);
	_sys_free(sm->last_rx_key);
	_sys_free(sm->eapReqData);
	_sys_free(sm->ctx);
	_sys_free(sm);
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

struct eap_ssl_data {
	struct tls_connection __far * conn;
	char __far * tls_out;
	size_t tls_out_len;
	size_t tls_out_pos;
	size_t tls_out_limit;
	char __far * tls_in;
	size_t tls_in_len;
	size_t tls_in_left;
	size_t tls_in_total;
	int phase2;
	int include_tls_length;
	int tls_ia;
	struct eap_sm __far * eap;

} ;	// From "eap_tls_common.h":36

enum  {
	EAP_TLS_FLAGS_LENGTH_INCLUDED = 0x80
}  ;	// From "eap_tls_common.h":40

enum  {
	EAP_TLS_FLAGS_MORE_FRAGMENTS = 0x40
}  ;	// From "eap_tls_common.h":41

enum  {
	EAP_TLS_FLAGS_START = 0x20
}  ;	// From "eap_tls_common.h":42

enum  {
	EAP_PEAP_VERSION_MASK = 0x07
}  ;	// From "eap_tls_common.h":43

enum  {
	EAP_TLS_KEY_LEN = 64
}  ;	// From "eap_tls_common.h":46

struct eap_peap_data {
	struct eap_ssl_data ssl;
	int peap_version;
	int force_peap_version;
	int force_new_label;
	struct eap_method __far * phase2_method;
	void __far * phase2_priv;
	int phase2_success;
	struct eap_method_type phase2_type;
	struct eap_method_type __far * phase2_types;
	size_t num_phase2_types;
	int peap_outer_success;
	int resuming;
	char __far * key_data;
	char __far * pending_phase2_req;
	size_t pending_phase2_req_len;

} ;	// From "eap_peap.c":62
/*** EndHeader */

/*** BeginHeader _wpa_s9_eap_peap_init */
// From "eap_peap.c":65
void __far * _wpa_s9_eap_peap_init(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void __far * _wpa_s9_eap_peap_init(struct eap_sm __far * sm) {
	struct eap_peap_data __far * data; 	// From "eap_peap.c":67
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap_peap.c":68

	union  {

		struct  {
			char __far * pos /* = _f_strstr(config->phase1, "peapver=" ) */;

		} __s1;

		struct  {
			char __far * start;
			char __far * pos;
			char __far * buf;
			struct eap_method_type __far * methods /* = ((void  far * )0) */;
			struct eap_method_type __far * _methods;
			char method;
			size_t num_methods /* = 0 */;

			union  {

				struct  {
					int vendor;

				} __s2;

			} __u;

		} __s2;

	} __u; 	// From "eap_peap.c":66

	config = eap_get_config(sm);

	data = _sys_calloc(sizeof (*data));
	if (data==((void  __far * )0))
		return ((void  __far * )0);
	sm->peap_done = FALSE;
	data->peap_version = 1;
	data->force_peap_version =  -1;
	data->peap_outer_success = 2;
	// Rabbit note: don't have config file
	/*
	if (config &&
	config->phase1) {
		__u.__s1.pos = _f_strstr(config->phase1, "peapver=" );

		if (__u.__s1.pos) {
			data->force_peap_version = atoi(__u.__s1.pos+8);
			data->peap_version = data->force_peap_version;
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Forced PEAP version " \
			 "%d" , data->force_peap_version));
		}
		if (_f_strstr(config->phase1, "peaplabel=1" )) {
			data->force_new_label = 1;
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Force new label for " \
			 "key derivation" ));
		}
		if (_f_strstr(config->phase1, "peap_outer_success=0" )) {
			data->peap_outer_success = 0;
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: terminate " \
			 "authentication on tunneled EAP-Success" ));
		}
		else if (_f_strstr(config->phase1, "peap_outer_success=1" )) {
			data->peap_outer_success = 1;
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: send tunneled " \
			 "EAP-Success after receiving tunneled " \
			 "EAP-Success" ));
		}
		else if (_f_strstr(config->phase1, "peap_outer_success=2" )) {
			data->peap_outer_success = 2;
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: send PEAP/TLS ACK " \
			 "after receiving tunneled EAP-Success" ));
		}
	}
	if (config &&
	config->phase2) {
		__u.__s2.methods = ((void  far * )0);
		__u.__s2.num_methods = 0;

		__u.__s2.start = __u.__s2.buf = _sys_strdup(config->phase2);
		if (__u.__s2.buf==((void  far * )0)) {
			_wpa_s9_eap_peap_deinit(sm, data);
			return ((void  far * )0);
		}
		while (__u.__s2.start &&
		*__u.__s2.start!='\0') {
			__u.__s2.pos = _f_strstr(__u.__s2.start, "auth=" );
			if (__u.__s2.pos==((void  far * )0))
				break;
			if (__u.__s2.start!=__u.__s2.pos &&
			*(__u.__s2.pos-1)!=' ') {
				__u.__s2.start = __u.__s2.pos+5;
				continue;
			}
			__u.__s2.start = __u.__s2.pos+5;
			__u.__s2.pos = _f_strchr(__u.__s2.start, ' ');
			if (__u.__s2.pos)
				*__u.__s2.pos++ = '\0';
			__u.__s2.method = eap_get_phase2_type(__u.__s2.start, &__u.__s2.__u.__s2.vendor);
			if (__u.__s2.__u.__s2.vendor==EAP_VENDOR_IETF &&
			__u.__s2.method==EAP_TYPE_NONE) {
				_WPA_PRINTF((MSG_ERROR, "EAP-PEAP: Unsupported Phase2 method '%ls'" , (char  far * )(__u.__s2.start)));
			}
			else {
				__u.__s2.num_methods++;
				__u.__s2._methods = _sys_realloc(__u.__s2.methods, __u.__s2.num_methods*sizeof (*__u.__s2.methods));
				if (__u.__s2._methods==((void  far * )0)) {
					_sys_free(__u.__s2.methods);
					_sys_free(__u.__s2.buf);
					_wpa_s9_eap_peap_deinit(sm, data);
					return ((void  far * )0);
				}
				__u.__s2.methods = __u.__s2._methods;
				__u.__s2.methods[__u.__s2.num_methods-1].vendor = __u.__s2.__u.__s2.vendor;
				__u.__s2.methods[__u.__s2.num_methods-1].method = __u.__s2.method;
			}
			__u.__s2.start = __u.__s2.pos;
		}
		_sys_free(__u.__s2.buf);
		data->phase2_types = __u.__s2.methods;
		data->num_phase2_types = __u.__s2.num_methods;
	}
	*/
	if (data->phase2_types==((void  __far * )0)) {
		data->phase2_types = eap_get_phase2_types(config, &data->num_phase2_types);
	}
	if (data->phase2_types==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "EAP-PEAP: No Phase2 method available" ));
		_wpa_s9_eap_peap_deinit(sm, data);
		return ((void  __far * )0);
	}
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-PEAP: Phase2 EAP types" , (char  __far * )data->phase2_types,
               data->num_phase2_types*sizeof(struct eap_method_type  )));
	data->phase2_type.vendor = EAP_VENDOR_IETF;
	data->phase2_type.method = EAP_TYPE_NONE;
	if (eap_tls_ssl_init(sm, &data->ssl, config)) {
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Failed to initialize SSL." ));
		_wpa_s9_eap_peap_deinit(sm, data);
		return ((void  __far * )0);
	}
	return data;
}

/*** BeginHeader _wpa_s9_eap_peap_deinit */
// From "eap_peap.c":185
void _wpa_s9_eap_peap_deinit(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s9_eap_peap_deinit(struct eap_sm __far * sm, void __far * priv) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":187

	data = priv;

	if (data==((void  __far * )0))
		return /*void*/;
	if (data->phase2_priv &&
	data->phase2_method)
		data->phase2_method->deinit((struct eap_sm  __far * )(sm), (void  __far * )(data->phase2_priv));
	_sys_free(data->phase2_types);
	eap_tls_ssl_deinit(sm, &data->ssl);
	_sys_free(data->key_data);
	_sys_free(data->pending_phase2_req);
	_sys_free(data);
}

/*** BeginHeader _wpa_s9_eap_peap_encrypt */
// From "eap_peap.c":200
int _wpa_s9_eap_peap_encrypt(struct eap_sm __far * sm, struct eap_peap_data __far * data,
                             int id, char __far * plain, size_t plain_len, char __far * __far * out_data,
                             size_t __far * out_len);
/*** EndHeader */
_wpa_debug
int _wpa_s9_eap_peap_encrypt(struct eap_sm __far * sm, struct eap_peap_data __far * data,
                             int id, char __far * plain, size_t plain_len, char __far * __far * out_data,
                             size_t __far * out_len) {
	int res; 	// From "eap_peap.c":204
	char __far * pos; 	// From "eap_peap.c":205
	struct eap_hdr __far * resp; 	// From "eap_peap.c":206


	resp = _sys_malloc(sizeof(struct eap_hdr  )+2+data->ssl.tls_out_limit);
	if (resp==((void  __far * )0))
		return  -1;
	resp->code = EAP_CODE_RESPONSE;
	resp->identifier = id;
	pos = (char  __far * )(resp+1);
	*pos++ = EAP_TYPE_PEAP;
	*pos++ = data->peap_version;
	res = tls_connection_encrypt(sm->ssl_ctx, data->ssl.conn, plain, plain_len, pos,
                              data->ssl.tls_out_limit);
	if (res<0) {
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Failed to encrypt Phase 2 " \
		 "data" ));
		_sys_free(resp);
		return  -1;
	}
	*out_len = sizeof(struct eap_hdr  )+2+res;
	resp->length = intel16(*out_len);
	*out_data = (char  __far * )resp;
	return 0;
}

/*** BeginHeader _wpa_s9_eap_peap_phase2_nak */
// From "eap_peap.c":240
int _wpa_s9_eap_peap_phase2_nak(struct eap_peap_data __far * data, struct eap_hdr __far * hdr,
                                char __far * __far * resp, size_t __far * resp_len);
/*** EndHeader */
_wpa_debug
int _wpa_s9_eap_peap_phase2_nak(struct eap_peap_data __far * data, struct eap_hdr __far * hdr,
                                char __far * __far * resp, size_t __far * resp_len) {
	struct eap_hdr __far * resp_hdr; 	// From "eap_peap.c":243
	char __far * pos /* = (char  far * )(hdr+1) */; 	// From "eap_peap.c":244
	size_t i; 	// From "eap_peap.c":245

	pos = (char  __far * )(hdr+1);

	_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Phase 2 Request: Nak type=%d" , *pos));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-PEAP: Allowed Phase2 EAP types" , (char  __far * )data->phase2_types,
               data->num_phase2_types*sizeof(struct eap_method_type  )));
	*resp_len = sizeof(struct eap_hdr  )+1;
	*resp = _sys_malloc(*resp_len+data->num_phase2_types);
	if (*resp==((void  __far * )0))
		return  -1;
	resp_hdr = (struct eap_hdr  __far * )(*resp);
	resp_hdr->code = EAP_CODE_RESPONSE;
	resp_hdr->identifier = hdr->identifier;
	pos = (char  __far * )(resp_hdr+1);
	*pos++ = EAP_TYPE_NAK;
	for (i = 0; i<data->num_phase2_types; i++) {
		if (data->phase2_types[i].vendor==EAP_VENDOR_IETF &&
		data->phase2_types[i].method<256) {
			(*resp_len)++;
			*pos++ = (char)data->phase2_types[i].method;
		}
	}
	resp_hdr->length = intel16(*resp_len);
	return 0;
}

/*** BeginHeader _wpa_s9_eap_peap_phase2_request */
// From "eap_peap.c":275
int _wpa_s9_eap_peap_phase2_request(struct eap_sm __far * sm, struct eap_peap_data __far * data,
                                    struct eap_method_ret __far * ret, struct eap_hdr __far * hdr,
                                    char __far * __far * resp, size_t __far * resp_len);
/*** EndHeader */
_wpa_debug
int _wpa_s9_eap_peap_phase2_request(struct eap_sm __far * sm, struct eap_peap_data __far * data,
                                    struct eap_method_ret __far * ret, struct eap_hdr __far * hdr,
                                    char __far * __far * resp, size_t __far * resp_len) {
	size_t len /* = intel16(hdr->length) */; 	// From "eap_peap.c":281
	char __far * pos; 	// From "eap_peap.c":282
	struct eap_method_ret iret; 	// From "eap_peap.c":283
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap_peap.c":284

	union  {

		struct  {

			union  {

				struct  {
					size_t i;

				} __s3;

			} __u;

		} __s2;

	} __u; 	// From "eap_peap.c":280

	len = intel16(hdr->length);
	config = eap_get_config(sm);

	if (len<=sizeof(struct eap_hdr  )) {
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: too short " \
		 "Phase 2 request (len=%lu)" , (unsigned long  )len));
		return  -1;
	}
	pos = (char  __far * )(hdr+1);
	_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Phase 2 Request: type=%d" , *pos));
	switch ((int)(*pos)) {
		case EAP_TYPE_IDENTITY:
		*resp = eap_sm_buildIdentity(sm, hdr->identifier, resp_len, 1);
		break;
		case EAP_TYPE_TLV:
		_f_memset(&iret, 0, sizeof (iret));
		if (eap_tlv_process(sm, &iret, hdr, resp, resp_len)) {
			ret->methodState = METHOD_DONE;
			ret->decision = DECISION_FAIL;
			return  -1;
		}
		if (iret.methodState==METHOD_DONE ||
		iret.methodState==METHOD_MAY_CONT) {
			ret->methodState = iret.methodState;
			ret->decision = iret.decision;
			data->phase2_success = 1;
		}
		break;
		default:
		if (data->phase2_type.vendor==EAP_VENDOR_IETF &&
		data->phase2_type.method==EAP_TYPE_NONE) {
			for (__u.__s2.__u.__s3.i = 0; __u.__s2.__u.__s3.i<data->num_phase2_types; __u.__s2.__u.__s3.i++) {
				if (data->phase2_types[__u.__s2.__u.__s3.i].vendor!=EAP_VENDOR_IETF ||
				data->phase2_types[__u.__s2.__u.__s3.i].method!=*pos)
					continue;
				data->phase2_type.vendor = data->phase2_types[__u.__s2.__u.__s3.i].vendor;
				data->phase2_type.method = data->phase2_types[__u.__s2.__u.__s3.i].method;
				_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Selected " \
				 "Phase 2 EAP vendor %d method %d" , data->phase2_type.vendor, data->phase2_type.method));
				break;
			}
		}
		if (*pos!=data->phase2_type.method ||
		*pos==EAP_TYPE_NONE) {
			if (_wpa_s9_eap_peap_phase2_nak(data, hdr, resp, resp_len))
				return  -1;
			return 0;
		}
		if (data->phase2_priv==((void  __far * )0)) {
			data->phase2_method = eap_sm_get_eap_methods((int)data->phase2_type.vendor, (EapType)data->phase2_type.method);
			if (data->phase2_method) {
				sm->init_phase2 = 1;
				data->phase2_priv = data->phase2_method->init((struct eap_sm  __far * )(sm));
				sm->init_phase2 = 0;
			}
		}
		if (data->phase2_priv==((void  __far * )0) ||
		data->phase2_method==((void  __far * )0)) {
			_WPA_PRINTF((MSG_INFO, "EAP-PEAP: failed to initialize " \
			 "Phase 2 EAP method %d" , *pos));
			ret->methodState = METHOD_DONE;
			ret->decision = DECISION_FAIL;
			return  -1;
		}
		_f_memset(&iret, 0, sizeof (iret));
		*resp = data->phase2_method->process((struct eap_sm  __far * )(sm), (void  __far * )(data->phase2_priv),
                                       (struct eap_method_ret  __far * )(&iret), (char  __far * )((char  __far * )hdr),
                                       (size_t  )(len), (size_t  __far * )(resp_len));
		if ((iret.methodState==METHOD_DONE ||
		iret.methodState==METHOD_MAY_CONT) &&
		(iret.decision==DECISION_UNCOND_SUCC ||
		iret.decision==DECISION_COND_SUCC)) {
			data->phase2_success = 1;
		}
		break;
	}
	if (*resp==((void  __far * )0) &&
	(config->pending_req_identity ||
	config->pending_req_password ||
	config->pending_req_otp ||
	config->pending_req_new_password)) {
		_sys_free(data->pending_phase2_req);
		data->pending_phase2_req = _sys_malloc(len);
		if (data->pending_phase2_req) {
			_f_memcpy(data->pending_phase2_req, hdr, len);
			data->pending_phase2_req_len = len;
		}
	}
	return 0;
}

/*** BeginHeader _wpa_s9_eap_peap_decrypt */
// From "eap_peap.c":385
int _wpa_s9_eap_peap_decrypt(struct eap_sm __far * sm, struct eap_peap_data __far * data,
                             struct eap_method_ret __far * ret, struct eap_hdr __far * req,
                             char __far * in_data, size_t in_len, char __far * __far * out_data,
                             size_t __far * out_len);
/*** EndHeader */
_wpa_debug
int _wpa_s9_eap_peap_decrypt(struct eap_sm __far * sm, struct eap_peap_data __far * data,
                             struct eap_method_ret __far * ret, struct eap_hdr __far * req,
                             char __far * in_data, size_t in_len, char __far * __far * out_data,
                             size_t __far * out_len) {
	char __far * in_decrypted; 	// From "eap_peap.c":391
	int res; 	// From "eap_peap.c":392
	int skip_change /* = 0 */; 	// From "eap_peap.c":392
	struct eap_hdr __far * hdr; 	// From "eap_peap.c":393
	struct eap_hdr __far * rhdr; 	// From "eap_peap.c":393
	char __far * resp /* = ((void  far * )0) */; 	// From "eap_peap.c":394
	size_t resp_len; 	// From "eap_peap.c":395
	size_t len_decrypted; 	// From "eap_peap.c":395
	size_t len; 	// From "eap_peap.c":395
	size_t buf_len; 	// From "eap_peap.c":395
	char __far * msg; 	// From "eap_peap.c":396
	size_t msg_len; 	// From "eap_peap.c":397
	int need_more_input; 	// From "eap_peap.c":398

	union  {

		struct  {
			struct eap_hdr __far * nhdr /* = _sys_malloc(sizeof(struct eap_hdr  )+len_decrypted) */;

		} __s7;

		struct  {
			char __far * resp_pos;
			size_t resp_send_len;
			int skip_change2 /* = 0 */;

		} __s12;

	} __u; 	// From "eap_peap.c":390

	skip_change = 0;
	resp = ((void  __far * )0);

	_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: received %lu bytes encrypted data for" \
	 " Phase 2" , (unsigned long  )in_len));
	if (data->pending_phase2_req) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Pending Phase 2 request - " \
		 "skip decryption and use old data" ));
		_sys_free(data->ssl.tls_in);
		data->ssl.tls_in = ((void  __far * )0);
		data->ssl.tls_in_len = 0;
		data->ssl.tls_in_left = 0;
		data->ssl.tls_in_total = 0;
		in_decrypted = data->pending_phase2_req;
		data->pending_phase2_req = ((void  __far * )0);
		len_decrypted = data->pending_phase2_req_len;
		skip_change = 1;
		goto continue_req;
	}
	msg = eap_tls_data_reassemble(sm, &data->ssl, in_data, in_len, &msg_len, &need_more_input);
	if (msg==((void  __far * )0))
		return need_more_input ?
		  1 :
		   -1;
	if (in_len==0 &&
	sm->workaround &&
	data->phase2_success) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Received TLS ACK, but " \
		 "expected data - acknowledge with TLS ACK since " \
		 "Phase 2 has been completed" ));
		ret->decision = DECISION_COND_SUCC;
		ret->methodState = METHOD_DONE;
		return 1;
	}
	buf_len = in_len;
	if (data->ssl.tls_in_total>buf_len)
		buf_len = data->ssl.tls_in_total;
	in_decrypted = _sys_malloc(buf_len);
	if (in_decrypted==((void  __far * )0)) {
		_sys_free(data->ssl.tls_in);
		data->ssl.tls_in = ((void  __far * )0);
		data->ssl.tls_in_len = 0;
		_WPA_PRINTF((MSG_WARNING, "EAP-PEAP: failed to allocate memory " \
		 "for decryption" ));
		return  -1;
	}
	res = tls_connection_decrypt(sm->ssl_ctx, data->ssl.conn, msg, msg_len, in_decrypted,
                              buf_len);
	_sys_free(data->ssl.tls_in);
	data->ssl.tls_in = ((void  __far * )0);
	data->ssl.tls_in_len = 0;
	if (res<0) {
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Failed to decrypt Phase 2 " \
		 "data" ));
		_sys_free(in_decrypted);
		return 0;
	}
	len_decrypted = res;
	continue_req:
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-PEAP: Decrypted Phase 2 EAP" , in_decrypted, len_decrypted));
	hdr = (struct eap_hdr  __far * )in_decrypted;
	if (len_decrypted==5 &&
	hdr->code==EAP_CODE_REQUEST &&
	intel16(hdr->length)==5 &&
	in_decrypted[4]==EAP_TYPE_IDENTITY) {
		skip_change = 1;
	}
	if (len_decrypted>=5 &&
	hdr->code==EAP_CODE_REQUEST &&
	in_decrypted[4]==EAP_TYPE_TLV) {
		skip_change = 1;
	}
	if (data->peap_version==0 &&
	!skip_change) {
		__u.__s7.nhdr = _sys_malloc(sizeof(struct eap_hdr  )+len_decrypted);

		if (__u.__s7.nhdr==((void  __far * )0)) {
			_sys_free(in_decrypted);
			return 0;
		}
		_f_memcpy((char  __far * )(__u.__s7.nhdr+1), in_decrypted, len_decrypted);
		_sys_free(in_decrypted);
		__u.__s7.nhdr->code = req->code;
		__u.__s7.nhdr->identifier = req->identifier;
		__u.__s7.nhdr->length = intel16(sizeof(struct eap_hdr  )+len_decrypted);
		len_decrypted += sizeof(struct eap_hdr  );
		in_decrypted = (char  __far * )__u.__s7.nhdr;
	}
	hdr = (struct eap_hdr  __far * )in_decrypted;
	if (len_decrypted<sizeof (*hdr)) {
		_sys_free(in_decrypted);
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Too short Phase 2 " \
		 "EAP frame (len=%lu)" , (unsigned long  )len_decrypted));
		return 0;
	}
	len = intel16(hdr->length);
	if (len>len_decrypted) {
		_sys_free(in_decrypted);
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Length mismatch in " \
		 "Phase 2 EAP frame (len=%lu hdr->length=%lu)" , (unsigned long  )len_decrypted,
               (unsigned long  )len));
		return 0;
	}
	if (len<len_decrypted) {
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Odd.. Phase 2 EAP header has " \
		 "shorter length than full decrypted data " \
		 "(%lu < %lu)" , (unsigned long  )len, (unsigned long  )len_decrypted));
		if (sm->workaround &&
		len==4 &&
		len_decrypted==5 &&
		in_decrypted[4]==EAP_TYPE_IDENTITY) {
			_WPA_PRINTF((MSG_INFO, "EAP-PEAP: workaround -> replace " \
			 "Phase 2 EAP header len (%lu) with real " \
			 "decrypted len (%lu)" , (unsigned long  )len, (unsigned long  )len_decrypted));
			len = len_decrypted;
			hdr->length = intel16(len);
		}
	}
	_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: received Phase 2: code=%d " \
	 "identifier=%d length=%lu" , hdr->code, hdr->identifier, (unsigned long  )len));
	switch ((int)(hdr->code)) {
		case EAP_CODE_REQUEST:
		if (_wpa_s9_eap_peap_phase2_request(sm, data, ret, hdr, &resp, &resp_len)) {
			_sys_free(in_decrypted);
			_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Phase2 Request " \
			 "processing failed" ));
			return 0;
		}
		break;
		case EAP_CODE_SUCCESS:
		_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Phase 2 Success" ));
		if (data->peap_version==1) {
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Version 1 - " \
			 "EAP-Success within TLS tunnel - " \
			 "authentication completed" ));
			ret->decision = DECISION_UNCOND_SUCC;
			ret->methodState = METHOD_DONE;
			data->phase2_success = 1;
			if (data->peap_outer_success==2) {
				_sys_free(in_decrypted);
				_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Use TLS ACK " \
				 "to finish authentication" ));
				return 1;
			}
			else if (data->peap_outer_success==1) {
				resp_len = sizeof(struct eap_hdr  );
				resp = _sys_calloc(resp_len);
				if (resp) {
					rhdr = (struct eap_hdr  __far * )resp;
					rhdr->code = EAP_CODE_SUCCESS;
					rhdr->identifier = hdr->identifier;
					rhdr->length = intel16(resp_len);
				}
			}
			else {
				sm->peap_done = TRUE;
			}
		}
		else {
		}
		break;
		case EAP_CODE_FAILURE:
		_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Phase 2 Failure" ));
		ret->decision = DECISION_FAIL;
		ret->methodState = METHOD_MAY_CONT;
		ret->allowNotifications = FALSE;
		resp_len = sizeof(struct eap_hdr  );
		resp = _sys_calloc(resp_len);
		if (resp) {
			rhdr = (struct eap_hdr  __far * )resp;
			rhdr->code = EAP_CODE_FAILURE;
			rhdr->identifier = hdr->identifier;
			rhdr->length = intel16(resp_len);
		}
		break;
		default:
		_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Unexpected code=%d in " \
		 "Phase 2 EAP header" , hdr->code));
		break;
	}
	_sys_free(in_decrypted);
	if (resp) {
		__u.__s12.skip_change2 = 0;

		_WPA_HEXDUMP((MSG_DEBUG, "EAP-PEAP: Encrypting Phase 2 data" , resp, resp_len));
		if (resp_len>=5 &&
		resp[0]==EAP_CODE_RESPONSE &&
		resp[4]==EAP_TYPE_TLV)
			__u.__s12.skip_change2 = 1;
		if (data->peap_version==0 &&
		!__u.__s12.skip_change2) {
			__u.__s12.resp_pos = resp+sizeof(struct eap_hdr  );
			__u.__s12.resp_send_len = resp_len-sizeof(struct eap_hdr  );
		}
		else {
			__u.__s12.resp_pos = resp;
			__u.__s12.resp_send_len = resp_len;
		}
		if (_wpa_s9_eap_peap_encrypt(sm, data, req->identifier, __u.__s12.resp_pos, __u.__s12.resp_send_len,
                               out_data, out_len)) {
			_WPA_PRINTF((MSG_INFO, "EAP-PEAP: Failed to encrypt " \
			 "a Phase 2 frame" ));
		}
		_sys_free(resp);
	}
	return 0;
}

/*** BeginHeader _wpa_s9_eap_peap_process */
// From "eap_peap.c":641
char __far * _wpa_s9_eap_peap_process(struct eap_sm __far * sm, void __far * priv, struct eap_method_ret __far * ret,
                                    char __far * reqData, size_t reqDataLen, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s9_eap_peap_process(struct eap_sm __far * sm, void __far * priv, struct eap_method_ret __far * ret,
                                    char __far * reqData, size_t reqDataLen, size_t __far * respDataLen) {
	struct eap_hdr __far * req; 	// From "eap_peap.c":646
	size_t left; 	// From "eap_peap.c":647
	int res; 	// From "eap_peap.c":648
	char flags; 	// From "eap_peap.c":649
	char __far * resp; 	// From "eap_peap.c":649
	char id; 	// From "eap_peap.c":649
	char __far * pos; 	// From "eap_peap.c":650
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":651

	union  {

		struct  {

			union  {

				struct  {
					char __far * label;

				} __s1;

			} __u;

		} __s3;

	} __u; 	// From "eap_peap.c":645

	data = priv;

	pos = eap_tls_process_init(sm, &data->ssl, EAP_TYPE_PEAP, ret, reqData, reqDataLen,
                            &left, &flags);
	if (pos==((void  __far * )0))
		return ((void  __far * )0);
	req = (struct eap_hdr  __far * )reqData;
	id = req->identifier;
	if (flags&EAP_TLS_FLAGS_START) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Start (server ver=%d, own " \
		 "ver=%d)" , flags&EAP_PEAP_VERSION_MASK, data->peap_version));
		if ((flags&EAP_PEAP_VERSION_MASK)<data->peap_version)
			data->peap_version = flags&EAP_PEAP_VERSION_MASK;
		if (data->force_peap_version>=0 &&
		data->force_peap_version!=data->peap_version) {
			_WPA_PRINTF((MSG_WARNING, "EAP-PEAP: Failed to select " \
			 "forced PEAP version %d" , data->force_peap_version));
			ret->methodState = METHOD_DONE;
			ret->decision = DECISION_FAIL;
			ret->allowNotifications = FALSE;
			return ((void  __far * )0);
		}
		_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Using PEAP version %d" , data->peap_version));
		left = 0;
	}
	resp = ((void  __far * )0);
	if (tls_connection_established(sm->ssl_ctx, data->ssl.conn) &&
	!data->resuming) {
		res = _wpa_s9_eap_peap_decrypt(sm, data, ret, req, pos, left, &resp, respDataLen);
	}
	else {
		res = eap_tls_process_helper(sm, &data->ssl, EAP_TYPE_PEAP, data->peap_version,
                               id, pos, left, &resp, respDataLen);
		if (tls_connection_established(sm->ssl_ctx, data->ssl.conn)) {
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: TLS done, proceed to Phase 2" ));
			_sys_free(data->key_data);
			if (data->peap_version>1 ||
			data->force_new_label)
				__u.__s3.__u.__s1.label = "client PEAP encryption" ;
			else
				__u.__s3.__u.__s1.label = "client EAP encryption" ;
			_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: using label '%ls' in key derivation" , (char  __far * )(__u.__s3.__u.__s1.label)));
			data->key_data = eap_tls_derive_key(sm, &data->ssl, __u.__s3.__u.__s1.label,
                                       EAP_TLS_KEY_LEN);
			if (data->key_data) {
				_WPA_HEXDUMP((MSG_DEBUG, "EAP-PEAP: Derived key" , data->key_data, EAP_TLS_KEY_LEN));
			}
			else {
				_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Failed to " \
				 "derive key" ));
			}
			if (sm->workaround &&
			data->resuming) {
				_WPA_PRINTF((MSG_DEBUG, "EAP-PEAP: Workaround - " \
				 "allow outer EAP-Success to " \
				 "terminate PEAP resumption" ));
				ret->decision = DECISION_COND_SUCC;
				data->phase2_success = 1;
			}
			data->resuming = 0;
		}
		if (res==2) {
			_sys_free(data->pending_phase2_req);
			data->pending_phase2_req = resp;
			data->pending_phase2_req_len = *respDataLen;
			resp = ((void  __far * )0);
			*respDataLen = 0;
			res = _wpa_s9_eap_peap_decrypt(sm, data, ret, req, pos, left, &resp, respDataLen);
		}
	}
	if (ret->methodState==METHOD_DONE) {
		ret->allowNotifications = FALSE;
	}
	if (res==1) {
		return eap_tls_build_ack(&data->ssl, respDataLen, id, EAP_TYPE_PEAP, data->peap_version);
	}
	return resp;
}

/*** BeginHeader _wpa_s9_eap_peap_has_reauth_data */
// From "eap_peap.c":771
Boolean _wpa_s9_eap_peap_has_reauth_data(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s9_eap_peap_has_reauth_data(struct eap_sm __far * sm, void __far * priv) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":773

	data = priv;

	return tls_connection_established(sm->ssl_ctx, data->ssl.conn) &&
	data->phase2_success;
}

/*** BeginHeader _wpa_s9_eap_peap_deinit_for_reauth */
// From "eap_peap.c":779
void _wpa_s9_eap_peap_deinit_for_reauth(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s9_eap_peap_deinit_for_reauth(struct eap_sm __far * sm, void __far * priv) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":781

	data = priv;

	_sys_free(data->pending_phase2_req);
	data->pending_phase2_req = ((void  __far * )0);
}

/*** BeginHeader _wpa_s9_eap_peap_init_for_reauth */
// From "eap_peap.c":787
void __far * _wpa_s9_eap_peap_init_for_reauth(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void __far * _wpa_s9_eap_peap_init_for_reauth(struct eap_sm __far * sm, void __far * priv) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":789

	data = priv;

	_sys_free(data->key_data);
	data->key_data = ((void  __far * )0);
	if (eap_tls_reauth_init(sm, &data->ssl)) {
		_sys_free(data);
		return ((void  __far * )0);
	}
	if (data->phase2_priv &&
	data->phase2_method &&
	data->phase2_method->init_for_reauth)
		data->phase2_method->init_for_reauth((struct eap_sm  __far * )(sm), (void  __far * )(data->phase2_priv));
	data->phase2_success = 0;
	data->resuming = 1;
	sm->peap_done = FALSE;
	return priv;
}

/*** BeginHeader _wpa_s9_eap_peap_get_status */
// From "eap_peap.c":806
int _wpa_s9_eap_peap_get_status(struct eap_sm __far * sm, void __far * priv, char __far * buf,
                                size_t buflen, int verbose);
/*** EndHeader */
_wpa_debug
int _wpa_s9_eap_peap_get_status(struct eap_sm __far * sm, void __far * priv, char __far * buf,
                                size_t buflen, int verbose) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":809
	int len; 	// From "eap_peap.c":810
	int ret; 	// From "eap_peap.c":810

	data = priv;

	len = eap_tls_status(sm, &data->ssl, buf, buflen, verbose);
	if (data->phase2_method) {
		ret = snprintf(buf+len, buflen-len, "EAP-PEAPv%d Phase2 method=%ls\n" , data->peap_version,
                 (char  __far * )(data->phase2_method->name));
		if (ret<0 ||
		(size_t  )ret>=buflen-len)
			return len;
		len += ret;
	}
	return len;
}

/*** BeginHeader _wpa_s9_eap_peap_isKeyAvailable */
// From "eap_peap.c":826
Boolean _wpa_s9_eap_peap_isKeyAvailable(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s9_eap_peap_isKeyAvailable(struct eap_sm __far * sm, void __far * priv) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":828

	data = priv;

	return data->key_data!=((void  __far * )0) &&
	data->phase2_success;
}

/*** BeginHeader _wpa_s9_eap_peap_getKey */
// From "eap_peap.c":833
char __far * _wpa_s9_eap_peap_getKey(struct eap_sm __far * sm, void __far * priv, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s9_eap_peap_getKey(struct eap_sm __far * sm, void __far * priv, size_t __far * len) {
	struct eap_peap_data __far * data /* = priv */; 	// From "eap_peap.c":835
	char __far * key; 	// From "eap_peap.c":836

	data = priv;

	if (data->key_data==((void  __far * )0) ||
	!data->phase2_success)
		return ((void  __far * )0);
	key = _sys_malloc(EAP_TLS_KEY_LEN);
	if (key==((void  __far * )0))
		return ((void  __far * )0);
	*len = EAP_TLS_KEY_LEN;
	_f_memcpy(key, data->key_data, EAP_TLS_KEY_LEN);
	return key;
}

/*** BeginHeader eap_peer_peap_register */
// From "eap_peap.c":852
int eap_peer_peap_register(void );
/*** EndHeader */
_wpa_debug
int eap_peer_peap_register(void ) {
	struct eap_method __far * eap; 	// From "eap_peap.c":854
	int ret; 	// From "eap_peap.c":855


	eap = eap_peer_method_alloc(1, EAP_VENDOR_IETF, EAP_TYPE_PEAP, "PEAP" );
	if (eap==((void  __far * )0))
		return  -1;
	eap->init = _wpa_s9_eap_peap_init;
	eap->deinit = _wpa_s9_eap_peap_deinit;
	eap->process = _wpa_s9_eap_peap_process;
	eap->isKeyAvailable = _wpa_s9_eap_peap_isKeyAvailable;
	eap->getKey = _wpa_s9_eap_peap_getKey;
	eap->get_status = _wpa_s9_eap_peap_get_status;
	eap->has_reauth_data = _wpa_s9_eap_peap_has_reauth_data;
	eap->deinit_for_reauth = _wpa_s9_eap_peap_deinit_for_reauth;
	eap->init_for_reauth = _wpa_s9_eap_peap_init_for_reauth;
	ret = eap_peer_method_register(eap);
	if (ret)
		eap_peer_method_free(eap);
	return ret;
}
// @ TUName[]  ; -- translator directive

/*** BeginHeader _wpa_s10_eap_tls_check_blob */
// From "eap_tls_common.c":27
int _wpa_s10_eap_tls_check_blob(struct eap_sm __far * sm, char __far * __far * name, char __far * __far * data,
                                size_t __far * data_len);
/*** EndHeader */
_wpa_debug
int _wpa_s10_eap_tls_check_blob(struct eap_sm __far * sm, char __far * __far * name, char __far * __far * data,
                                size_t __far * data_len) {
	struct wpa_config_blob __far * blob; 	// From "eap_tls_common.c":30


	if (*name==((void  __far * )0) ||
	strncmp(*name, "blob://" , 7)!=0)
		return 0;
	blob = eap_get_config_blob(sm, *name+7);
	if (blob==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "%ls: Named configuration blob '%ls' not found" , (char  __far * )("eap_tls_check_blob" ),
               (char  __far * )(*name+7)));
		return  -1;
	}
	*name = ((void  __far * )0);
	*data = blob->data;
	*data_len = blob->len;
	return 0;
}

/*** BeginHeader _wpa_s10_EapTlsParamsFromConf1 */
// From "eap_tls_common.c":50
void _wpa_s10_EapTlsParamsFromConf1(struct tls_connection_params __far * params,
                                        struct wpa_ssid __far * config);
/*** EndHeader */
_wpa_debug
void _wpa_s10_EapTlsParamsFromConf1(struct tls_connection_params __far * params,
                                        struct wpa_ssid __far * config) {
// Rabbit note: chage to set blob field directly, since we deal with binary structs
	params->ca_cert_blob = config->ca_cert_blob;
	params->ca_cert_blob_len = config->ca_cert_blob_len;
	params->client_cert_blob = config->client_cert_blob;
	params->client_cert_blob_len = config->client_cert_blob_len;
/*
	params->ca_cert = (char  far * )config->ca_cert;
	params->ca_path = (char  far * )config->ca_path;
	params->client_cert = (char  far * )config->client_cert;
	params->private_key = (char  far * )config->private_key;
	params->private_key_passwd = (char  far * )config->private_key_passwd;
*/
	params->dh_file = (char  __far * )config->dh_file;
	params->subject_match = (char  __far * )config->subject_match;
	params->altsubject_match = (char  __far * )config->altsubject_match;
	// Rabbit note: no such fields
	//params->engine_id = config->engine_id;
	//params->pin = config->pin;
	//params->key_id = config->key_id;
}

/*** BeginHeader _wpa_s10_EapTlsParamsFromConf2 */
// From "eap_tls_common.c":67
void _wpa_s10_EapTlsParamsFromConf2(struct tls_connection_params __far * params,
                                        struct wpa_ssid __far * config);
/*** EndHeader */
_wpa_debug
void _wpa_s10_EapTlsParamsFromConf2(struct tls_connection_params __far * params,
                                        struct wpa_ssid __far * config) {
// Rabbit note: chage to set blob field directly, since we deal with binary structs
	params->ca_cert_blob = config->ca_cert_blob2;
	params->ca_cert_blob_len = config->ca_cert_blob_len2;
	params->client_cert_blob = config->client_cert_blob2;
	params->client_cert_blob_len = config->client_cert_blob_len2;
/*
	params->ca_cert = (char  far * )config->ca_cert2;
	params->ca_path = (char  far * )config->ca_path2;
	params->client_cert = (char  far * )config->client_cert2;
	params->private_key = (char  far * )config->private_key2;
	params->private_key_passwd = (char  far * )config->private_key2_passwd;
*/
	params->dh_file = (char  __far * )config->dh_file2;
	params->subject_match = (char  __far * )config->subject_match2;
	params->altsubject_match = (char  __far * )config->altsubject_match2;
}

/*** BeginHeader _wpa_s10_EapTlsParamsFromConf */
// From "eap_tls_common.c":81
int _wpa_s10_EapTlsParamsFromConf(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                      struct tls_connection_params __far * params,
                                      struct wpa_ssid __far * config, int phase2);
/*** EndHeader */
_wpa_debug
int _wpa_s10_EapTlsParamsFromConf(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                      struct tls_connection_params __far * params,
                                      struct wpa_ssid __far * config, int phase2) {
	_f_memset(params, 0, sizeof (*params));
	//params->engine = config->engine;	 Rabbit note: no such field
	if (phase2)
		_wpa_s10_EapTlsParamsFromConf2(params, config);
	else
		_wpa_s10_EapTlsParamsFromConf1(params, config);
	params->tls_ia = data->tls_ia;
// Rabbit note: parms already in "blob" form
#if 0
	if (_wpa_s10_eap_tls_check_blob(sm, &params->ca_cert, &params->ca_cert_blob, &params->ca_cert_blob_len)
      ||
	_wpa_s10_eap_tls_check_blob(sm, &params->client_cert, &params->client_cert_blob,
                             &params->client_cert_blob_len) ||
	_wpa_s10_eap_tls_check_blob(sm, &params->private_key, &params->private_key_blob,
                             &params->private_key_blob_len) ||
	_wpa_s10_eap_tls_check_blob(sm, &params->dh_file, &params->dh_blob, &params->dh_blob_len)) {
		_WPA_PRINTF((MSG_INFO, "SSL: Failed to get configuration blobs" ));
		return  -1;
	}
#endif
	return 0;
}

/*** BeginHeader _wpa_s10_eap_tls_init_connection */
// From "eap_tls_common.c":113
int _wpa_s10_eap_tls_init_connection(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                     struct wpa_ssid __far * config, struct tls_connection_params __far * params);
/*** EndHeader */
_wpa_debug
int _wpa_s10_eap_tls_init_connection(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                     struct wpa_ssid __far * config, struct tls_connection_params __far * params) {
	int res; 	// From "eap_tls_common.c":118


	data->conn = tls_connection_init(sm->ssl_ctx);
	if (data->conn==((void  __far * )0)) {
		_WPA_PRINTF((MSG_INFO, "SSL: Failed to initialize new TLS " \
		 "connection" ));
		return  -1;
	}
	#ifndef WPA_EAP_BLOCKING
	tls_set_flags(data->conn, SSL_F_COP_YIELD, SSL_F_COP_YIELD);
	#endif
	res = tls_connection_set_params(sm->ssl_ctx, data->conn, params);
	if (res==TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED) {
		_sys_free(config->pin);
		config->pin = ((void  __far * )0);
	}
	else if (res==TLS_SET_PARAMS_ENGINE_PRV_VERIFY_FAILED) {
		_WPA_PRINTF((MSG_INFO, "TLS: Failed to load private key" ));
		_sys_free(config->pin);
		config->pin = ((void  __far * )0);
		eap_sm_request_pin(sm);
		sm->ignore = TRUE;
		return  -1;
	}
	else if (res) {
		_WPA_PRINTF((MSG_INFO, "TLS: Failed to set TLS connection " \
		 "parameters" ));
		return  -1;
	}
	return 0;
}

/*** BeginHeader eap_tls_ssl_init */
// From "eap_tls_common.c":163
int eap_tls_ssl_init(struct eap_sm __far * sm, struct eap_ssl_data __far * data, struct wpa_ssid __far * config);
/*** EndHeader */
_wpa_debug
int eap_tls_ssl_init(struct eap_sm __far * sm, struct eap_ssl_data __far * data, struct wpa_ssid __far * config) {
	int ret /* =  -1 */; 	// From "eap_tls_common.c":166
	struct tls_connection_params params; 	// From "eap_tls_common.c":167

	ret =  -1;

	if (config==((void  __far * )0))
		return  -1;
	data->eap = sm;
	data->phase2 = sm->init_phase2;
	if (_wpa_s10_EapTlsParamsFromConf(sm, data, &params, config, data->phase2)<0)
		goto done;
	if (_wpa_s10_eap_tls_init_connection(sm, data, config, &params)<0)
		goto done;
	data->tls_out_limit = config->fragment_size;
	if (data->phase2) {
		if (data->tls_out_limit>100)
			data->tls_out_limit -= 100;
	}
	if (config->phase1 &&
	_f_strstr(config->phase1, "include_tls_length=1" )) {
		_WPA_PRINTF((MSG_DEBUG, "TLS: Include TLS Message Length in " \
		 "unfragmented packets" ));
		data->include_tls_length = 1;
	}
	ret = 0;
	done:
	return ret;
}

/*** BeginHeader eap_tls_ssl_deinit */
// From "eap_tls_common.c":212
void eap_tls_ssl_deinit(struct eap_sm __far * sm, struct eap_ssl_data __far * data);
/*** EndHeader */
_wpa_debug
void eap_tls_ssl_deinit(struct eap_sm __far * sm, struct eap_ssl_data __far * data) {
	tls_connection_deinit(sm->ssl_ctx, data->conn);
	_sys_free(data->tls_in);
	data->tls_in = ((void  __far * )0);
	_sys_free(data->tls_out);
	data->tls_out = ((void  __far * )0);
}

/*** BeginHeader eap_tls_derive_key */
// From "eap_tls_common.c":234
char __far * eap_tls_derive_key(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                              char __far * label, size_t len);
/*** EndHeader */
_wpa_debug
char __far * eap_tls_derive_key(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                              char __far * label, size_t len) {
	struct tls_keys keys; 	// From "eap_tls_common.c":237
	char __far * rnd /* = ((void  far * )0) */; 	// From "eap_tls_common.c":238
	char __far * out; 	// From "eap_tls_common.c":238

	rnd = ((void  __far * )0);

	out = _sys_malloc(len);
	if (out==((void  __far * )0))
		return ((void  __far * )0);
	if (tls_connection_prf(sm->ssl_ctx, data->conn, label, 0, out, len)==0)
		return out;
	// Rabbit note: following not required, since we implement tls_connection_prf().
	/*
	if (tls_connection_get_keys(sm->ssl_ctx, data->conn, &keys))
		goto fail;
	if (keys.client_random==((void  far * )0) ||
	keys.server_random==((void  far * )0) ||
	keys.master_key==((void  far * )0))
		goto fail;
	rnd = _sys_malloc(keys.client_random_len+keys.server_random_len);
	if (rnd==((void  far * )0))
		goto fail;
	_f_memcpy(rnd, keys.client_random, keys.client_random_len);
	_f_memcpy(rnd+keys.client_random_len, keys.server_random, keys.server_random_len);
	if (tls_prf(keys.master_key, keys.master_key_len, label, rnd, keys.client_random_len
                                                               +keys.server_random_len,
             out, len))
		goto fail;
	_sys_free(rnd);
	return out;
	fail:
	_sys_free(rnd);
	*/
	_sys_free(out);
	return ((void  __far * )0);
}

/*** BeginHeader eap_tls_data_reassemble */
// From "eap_tls_common.c":298
char __far * eap_tls_data_reassemble(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                   char __far * in_data, size_t in_len, size_t __far * out_len,
                                   int __far * need_more_input);
/*** EndHeader */
_wpa_debug
char __far * eap_tls_data_reassemble(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                   char __far * in_data, size_t in_len, size_t __far * out_len,
                                   int __far * need_more_input) {
	char __far * buf; 	// From "eap_tls_common.c":302


	*need_more_input = 0;
	if (data->tls_in_left>in_len ||
	data->tls_in) {
		if (data->tls_in_len+in_len==0) {
			_sys_free(data->tls_in);
			data->tls_in = ((void  __far * )0);
			data->tls_in_len = 0;
			_WPA_PRINTF((MSG_WARNING, "SSL: Invalid reassembly " \
			 "state: tls_in_left=%lu tls_in_len=%lu " \
			 "in_len=%lu" , (unsigned long  )data->tls_in_left, (unsigned long  )data->tls_in_len,
                (unsigned long  )in_len));
			return ((void  __far * )0);
		}
		if (data->tls_in_len+in_len>65536) {
			_sys_free(data->tls_in);
			data->tls_in = ((void  __far * )0);
			data->tls_in_len = 0;
			_WPA_PRINTF((MSG_INFO, "SSL: Too long TLS fragment (size" \
			 " over 64 kB)" ));
			return ((void  __far * )0);
		}
		buf = _sys_realloc(data->tls_in, data->tls_in_len+in_len);
		if (buf==((void  __far * )0)) {
			_sys_free(data->tls_in);
			data->tls_in = ((void  __far * )0);
			data->tls_in_len = 0;
			_WPA_PRINTF((MSG_INFO, "SSL: Could not allocate memory " \
			 "for TLS data" ));
			return ((void  __far * )0);
		}
		_f_memcpy(buf+data->tls_in_len, in_data, in_len);
		data->tls_in = buf;
		data->tls_in_len += in_len;
		if (in_len>data->tls_in_left) {
			_WPA_PRINTF((MSG_INFO, "SSL: more data than TLS message " \
			 "length indicated" ));
			data->tls_in_left = 0;
			return ((void  __far * )0);
		}
		data->tls_in_left -= in_len;
		if (data->tls_in_left>0) {
			_WPA_PRINTF((MSG_DEBUG, "SSL: Need %lu bytes more input " \
			 "data" , (unsigned long  )data->tls_in_left));
			*need_more_input = 1;
			return ((void  __far * )0);
		}
	}
	else {
		data->tls_in_left = 0;
		data->tls_in = _sys_malloc(in_len ?
		  in_len :
		  1);
		if (data->tls_in==((void  __far * )0))
			return ((void  __far * )0);
		_f_memcpy(data->tls_in, in_data, in_len);
		data->tls_in_len = in_len;
	}
	*out_len = data->tls_in_len;
	return data->tls_in;
}

/*** BeginHeader _wpa_s10_eap_tls_process_input */
// From "eap_tls_common.c":368
int _wpa_s10_eap_tls_process_input(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                   char __far * in_data, size_t in_len, char __far * __far * out_data,
                                   size_t __far * out_len);
/*** EndHeader */
_wpa_debug
int _wpa_s10_eap_tls_process_input(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                   char __far * in_data, size_t in_len, char __far * __far * out_data,
                                   size_t __far * out_len) {
	char __far * msg; 	// From "eap_tls_common.c":372
	size_t msg_len; 	// From "eap_tls_common.c":373
	int need_more_input; 	// From "eap_tls_common.c":374
	char __far * appl_data; 	// From "eap_tls_common.c":375
	size_t appl_data_len; 	// From "eap_tls_common.c":376


	msg = eap_tls_data_reassemble(sm, data, in_data, in_len, &msg_len, &need_more_input);
	if (msg==((void  __far * )0))
		return need_more_input ?
		  1 :
		   -1;
	if (data->tls_out) {
		_WPA_PRINTF((MSG_INFO, "SSL: eap_tls_process_helper - pending " \
		 "tls_out data even though tls_out_len = 0" ));
		_sys_free(data->tls_out);
		do {
		} while (0);
	}
	appl_data = ((void  __far * )0);
	data->tls_out = tls_connection_handshake(sm->ssl_ctx, data->conn, msg, msg_len,
                                          &data->tls_out_len, &appl_data, &appl_data_len);
	data->tls_in_left = data->tls_in_total = data->tls_in_len = 0;
	_sys_free(data->tls_in);
	data->tls_in = ((void  __far * )0);
	if (appl_data &&
	tls_connection_established(sm->ssl_ctx, data->conn) &&
	!tls_connection_get_failed(sm->ssl_ctx, data->conn)) {
		_WPA_HEXDUMP((MSG_MSGDUMP, "SSL: Application data" , appl_data, appl_data_len));
		*out_data = appl_data;
		*out_len = appl_data_len;
		return 2;
	}
	_sys_free(appl_data);
	return 0;
}

/*** BeginHeader _wpa_s10_eap_tls_process_output */
// From "eap_tls_common.c":418
int _wpa_s10_eap_tls_process_output(struct eap_ssl_data __far * data, EapType eap_type,
                                    int peap_version, char id, int ret, char __far * __far * out_data,
                                    size_t __far * out_len);
/*** EndHeader */
_wpa_debug
int _wpa_s10_eap_tls_process_output(struct eap_ssl_data __far * data, EapType eap_type,
                                    int peap_version, char id, int ret, char __far * __far * out_data,
                                    size_t __far * out_len) {
	size_t len; 	// From "eap_tls_common.c":422
	char __far * pos; 	// From "eap_tls_common.c":423
	char __far * flags; 	// From "eap_tls_common.c":423
	int more_fragments; 	// From "eap_tls_common.c":424
	int length_included; 	// From "eap_tls_common.c":424


	_WPA_PRINTF((MSG_DEBUG, "SSL: %lu bytes left to be sent out (of total " \
	 "%lu bytes)" , (unsigned long  )data->tls_out_len-data->tls_out_pos, (unsigned long  )data->tls_out_len));
	len = data->tls_out_len-data->tls_out_pos;
	if (len>data->tls_out_limit) {
		more_fragments = 1;
		len = data->tls_out_limit;
		_WPA_PRINTF((MSG_DEBUG, "SSL: sending %lu bytes, more fragments " \
		 "will follow" , (unsigned long  )len));
	}
	else
		more_fragments = 0;
	length_included = data->tls_out_pos==0 &&
	(data->tls_out_len>data->tls_out_limit ||
	data->include_tls_length);
	*out_data = (char  __far * )eap_msg_alloc(EAP_VENDOR_IETF, eap_type, out_len, 1+length_included
                                                                               *4
                                                                             +len,
                                         EAP_CODE_RESPONSE, id, &pos);
	if (*out_data==((void  __far * )0))
		return  -1;
	flags = pos++;
	*flags = peap_version;
	if (more_fragments)
		*flags |= EAP_TLS_FLAGS_MORE_FRAGMENTS;
	if (length_included) {
		*flags |= EAP_TLS_FLAGS_LENGTH_INCLUDED;
		do {
			(pos)[0] = (char  )(((longword  )(data->tls_out_len))>>24);
			(pos)[1] = (char  )(((longword  )(data->tls_out_len))>>16);
			(pos)[2] = (char  )(((longword  )(data->tls_out_len))>>8);
			(pos)[3] = (char  )(((longword  )(data->tls_out_len))&0xff);
		} while (0);
		pos += 4;
	}
	_f_memcpy(pos, &data->tls_out[data->tls_out_pos], len);
	data->tls_out_pos += len;
	if (!more_fragments) {
		data->tls_out_len = 0;
		data->tls_out_pos = 0;
		_sys_free(data->tls_out);
		data->tls_out = ((void  __far * )0);
	}
	return ret;
}

/*** BeginHeader eap_tls_process_helper */
// From "eap_tls_common.c":498
int eap_tls_process_helper(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                           EapType eap_type, int peap_version, char id, char __far * in_data,
                           size_t in_len, char __far * __far * out_data, size_t __far * out_len);
/*** EndHeader */
_wpa_debug
int eap_tls_process_helper(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                           EapType eap_type, int peap_version, char id, char __far * in_data,
                           size_t in_len, char __far * __far * out_data, size_t __far * out_len) {
	int ret /* = 0 */; 	// From "eap_tls_common.c":503

	union  {

		struct  {
			int res /* = _wpa_s10_eap_tls_process_input(sm, data, in_data, in_len, out_data,
                                               out_len) */;

		} __s2;

	} __u; 	// From "eap_tls_common.c":502

	ret = 0;

	do {
	} while (0);
	*out_len = 0;
	*out_data = ((void  __far * )0);
	if (data->tls_out_len==0) {
		__u.__s2.res = _wpa_s10_eap_tls_process_input(sm, data, in_data, in_len, out_data,
                                                out_len);

		if (__u.__s2.res)
			return __u.__s2.res;
	}
	if (data->tls_out==((void  __far * )0)) {
		data->tls_out_len = 0;
		return  -1;
	}
	if (tls_connection_get_failed(sm->ssl_ctx, data->conn)) {
		_WPA_PRINTF((MSG_DEBUG, "SSL: Failed - tls_out available to " \
		 "report error" ));
		ret =  -1;
	}
	if (data->tls_out_len==0) {
		_WPA_PRINTF((MSG_DEBUG, "SSL: No data to be sent out" ));
		_sys_free(data->tls_out);
		data->tls_out = ((void  __far * )0);
		return 1;
	}
	return _wpa_s10_eap_tls_process_output(data, eap_type, peap_version, id, ret, out_data,
                                        out_len);
}

/*** BeginHeader eap_tls_build_ack */
// From "eap_tls_common.c":554
char __far * eap_tls_build_ack(struct eap_ssl_data __far * data, size_t __far * respDataLen,
                             char id, EapType eap_type, int peap_version);
/*** EndHeader */
_wpa_debug
char __far * eap_tls_build_ack(struct eap_ssl_data __far * data, size_t __far * respDataLen,
                             char id, EapType eap_type, int peap_version) {
	struct eap_hdr __far * resp; 	// From "eap_tls_common.c":557
	char __far * pos; 	// From "eap_tls_common.c":558


	resp = eap_msg_alloc(EAP_VENDOR_IETF, eap_type, respDataLen, 1, EAP_CODE_RESPONSE,
                      id, &pos);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	_WPA_PRINTF((MSG_DEBUG, "SSL: Building ACK" ));
	*pos = peap_version;
	return (char  __far * )resp;
}

/*** BeginHeader eap_tls_reauth_init */
// From "eap_tls_common.c":576
int eap_tls_reauth_init(struct eap_sm __far * sm, struct eap_ssl_data __far * data);
/*** EndHeader */
_wpa_debug
int eap_tls_reauth_init(struct eap_sm __far * sm, struct eap_ssl_data __far * data) {
	_sys_free(data->tls_in);
	data->tls_in = ((void  __far * )0);
	data->tls_in_len = data->tls_in_left = data->tls_in_total = 0;
	_sys_free(data->tls_out);
	data->tls_out = ((void  __far * )0);
	data->tls_out_len = data->tls_out_pos = 0;
	return tls_connection_shutdown(sm->ssl_ctx, data->conn);
}

/*** BeginHeader eap_tls_status */
// From "eap_tls_common.c":598
int eap_tls_status(struct eap_sm __far * sm, struct eap_ssl_data __far * data, char __far * buf,
                   size_t buflen, int verbose);
/*** EndHeader */
_wpa_debug
int eap_tls_status(struct eap_sm __far * sm, struct eap_ssl_data __far * data, char __far * buf,
                   size_t buflen, int verbose) {
	char name[128]; 	// From "eap_tls_common.c":601
	int len /* = 0 */; 	// From "eap_tls_common.c":602
	int ret; 	// From "eap_tls_common.c":602

	len = 0;

	if (tls_get_cipher(sm->ssl_ctx, data->conn, name, sizeof (name))==0) {
		ret = snprintf(buf+len, buflen-len, "EAP TLS cipher=%ls\n" , (char  __far * )(name));
		if (ret<0 ||
		(size_t  )ret>=buflen-len)
			return len;
		len += ret;
	}
	return len;
}

/*** BeginHeader eap_tls_process_init */
// From "eap_tls_common.c":628
char __far * eap_tls_process_init(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                EapType eap_type, struct eap_method_ret __far * ret,
                                char __far * reqData, size_t reqDataLen, size_t __far * len,
                                char __far * flags);
/*** EndHeader */
_wpa_debug
char __far * eap_tls_process_init(struct eap_sm __far * sm, struct eap_ssl_data __far * data,
                                EapType eap_type, struct eap_method_ret __far * ret,
                                char __far * reqData, size_t reqDataLen, size_t __far * len,
                                char __far * flags) {
	char __far * pos; 	// From "eap_tls_common.c":633
	size_t left; 	// From "eap_tls_common.c":634
	unsigned int tls_msg_len; 	// From "eap_tls_common.c":635


	if (tls_get_errors(sm->ssl_ctx)) {
		_WPA_PRINTF((MSG_INFO, "SSL: TLS errors detected" ));
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	pos = eap_hdr_validate(EAP_VENDOR_IETF, eap_type, reqData, reqDataLen, &left);
	if (pos==((void  __far * )0)) {
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	*flags = *pos++;
	left--;
	_WPA_PRINTF((MSG_DEBUG, "SSL: Received packet(len=%lu) - " \
	 "Flags 0x%02x" , (unsigned long  )reqDataLen, *flags));
	if (*flags&EAP_TLS_FLAGS_LENGTH_INCLUDED) {
		if (left<4) {
			_WPA_PRINTF((MSG_INFO, "SSL: Short frame with TLS " \
			 "length" ));
			ret->ignore = TRUE;
			return ((void  __far * )0);
		}
		// Rabbit mod  - reduce to word size
		tls_msg_len = (/*(((longword  )(pos)[0])<<24)|(((longword  )(pos)[1])<<16)|*/(((word  )(pos)[2])
                                                                  <<8)|((word  )(pos)[3]));
		_WPA_PRINTF((MSG_DEBUG, "SSL: TLS Message Length: %u" , tls_msg_len));
		if (data->tls_in_left==0) {
			data->tls_in_total = tls_msg_len;
			data->tls_in_left = tls_msg_len;
			_sys_free(data->tls_in);
			data->tls_in = ((void  __far * )0);
			data->tls_in_len = 0;
		}
		pos += 4;
		left -= 4;
	}
	ret->ignore = FALSE;
	ret->methodState = METHOD_MAY_CONT;
	ret->decision = DECISION_FAIL;
	ret->allowNotifications = TRUE;
	*len = (size_t  )left;
	return pos;
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

struct eap_tls_data {
	struct eap_ssl_data ssl;
	char __far * key_data;

} ;	// From "eap_tls.c":30
/*** EndHeader */

/*** BeginHeader _wpa_s11_eap_tls_init */
// From "eap_tls.c":33
void __far * _wpa_s11_eap_tls_init(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void __far * _wpa_s11_eap_tls_init(struct eap_sm __far * sm) {
	struct eap_tls_data __far * data; 	// From "eap_tls.c":35
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap_tls.c":36

	config = eap_get_config(sm);

	if (config==((void  __far * )0) ||
	((sm->init_phase2 ?
		// Rabbit note: pkey in cert struct
	  config->client_cert_blob2->rsa_key :
	  config->client_cert_blob->rsa_key)==((void  __far * )0) &&
	config->engine==0)) {
		_WPA_PRINTF((MSG_INFO, "EAP-TLS: Private key not configured" ));
		return ((void  __far * )0);
	}
	data = _sys_calloc(sizeof (*data));
	if (data==((void  __far * )0))
		return ((void  __far * )0);
	if (eap_tls_ssl_init(sm, &data->ssl, config)) {
		_WPA_PRINTF((MSG_INFO, "EAP-TLS: Failed to initialize SSL." ));
		_wpa_s11_eap_tls_deinit(sm, data);
	#if 0		// Rabbit note: not applicable
		if (config->engine) {
			_WPA_PRINTF((MSG_DEBUG, "EAP-TLS: Requesting Smartcard " \
			 "PIN" ));
			eap_sm_request_pin(sm);
			sm->ignore = TRUE;
		}
		else if (config->private_key &&
		!config->private_key_passwd) {
			_WPA_PRINTF((MSG_DEBUG, "EAP-TLS: Requesting private " \
			 "key passphrase" ));
			eap_sm_request_passphrase(sm);
			sm->ignore = TRUE;
		}
	#endif
		return ((void  __far * )0);
	}
	return data;
}

/*** BeginHeader _wpa_s11_eap_tls_deinit */
// From "eap_tls.c":70
void _wpa_s11_eap_tls_deinit(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s11_eap_tls_deinit(struct eap_sm __far * sm, void __far * priv) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":72

	data = priv;

	if (data==((void  __far * )0))
		return /*void*/;
	eap_tls_ssl_deinit(sm, &data->ssl);
	_sys_free(data->key_data);
	_sys_free(data);
}

/*** BeginHeader _wpa_s11_eap_tls_failure */
// From "eap_tls.c":81
char __far * _wpa_s11_eap_tls_failure(struct eap_sm __far * sm, struct eap_tls_data __far * data,
                                    struct eap_method_ret __far * ret, int res, char __far * resp,
                                    char id, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s11_eap_tls_failure(struct eap_sm __far * sm, struct eap_tls_data __far * data,
                                    struct eap_method_ret __far * ret, int res, char __far * resp,
                                    char id, size_t __far * respDataLen) {

	union  {

		struct  {
			struct wpa_ssid __far * config /* = eap_get_config(sm) */;

		} __s1;

	} __u; 	// From "eap_tls.c":84


	_WPA_PRINTF((MSG_DEBUG, "EAP-TLS: TLS processing failed" ));
	ret->methodState = METHOD_DONE;
	ret->decision = DECISION_FAIL;
	if (res== -1) {
		__u.__s1.config = eap_get_config(sm);

		if (__u.__s1.config) {
			_sys_free(__u.__s1.config->pin);
			__u.__s1.config->pin = ((void  __far * )0);
		}
	}
	if (resp) {
		return resp;
	}
	return eap_tls_build_ack(&data->ssl, respDataLen, id, EAP_TYPE_TLS, 0);
}

/*** BeginHeader _wpa_s11_eap_tls_success */
// From "eap_tls.c":116
void _wpa_s11_eap_tls_success(struct eap_sm __far * sm, struct eap_tls_data __far * data,
                              struct eap_method_ret __far * ret);
/*** EndHeader */
_wpa_debug
void _wpa_s11_eap_tls_success(struct eap_sm __far * sm, struct eap_tls_data __far * data,
                              struct eap_method_ret __far * ret) {
	_WPA_PRINTF((MSG_DEBUG, "EAP-TLS: Done" ));
	ret->methodState = METHOD_DONE;
	ret->decision = DECISION_UNCOND_SUCC;
	_sys_free(data->key_data);
	data->key_data = eap_tls_derive_key(sm, &data->ssl, "client EAP encryption" , EAP_TLS_KEY_LEN
                                                                               +EAP_EMSK_LEN);
	if (data->key_data) {
		_WPA_HEXDUMP((MSG_DEBUG, "EAP-TLS: Derived key" , data->key_data, EAP_TLS_KEY_LEN));
		_WPA_HEXDUMP((MSG_DEBUG, "EAP-TLS: Derived EMSK" , data->key_data+EAP_TLS_KEY_LEN,
                EAP_EMSK_LEN));
	}
	else {
		_WPA_PRINTF((MSG_INFO, "EAP-TLS: Failed to derive key" ));
	}
}

/*** BeginHeader _wpa_s11_eap_tls_process */
// From "eap_tls.c":140
char __far * _wpa_s11_eap_tls_process(struct eap_sm __far * sm, void __far * priv, struct eap_method_ret __far * ret,
                                    char __far * reqData, size_t reqDataLen, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s11_eap_tls_process(struct eap_sm __far * sm, void __far * priv, struct eap_method_ret __far * ret,
                                    char __far * reqData, size_t reqDataLen, size_t __far * respDataLen) {
	struct eap_hdr __far * req; 	// From "eap_tls.c":145
	size_t left; 	// From "eap_tls.c":146
	int res; 	// From "eap_tls.c":147
	char flags; 	// From "eap_tls.c":148
	char __far * resp; 	// From "eap_tls.c":148
	char id; 	// From "eap_tls.c":148
	char __far * pos; 	// From "eap_tls.c":149
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":150

	data = priv;

	pos = eap_tls_process_init(sm, &data->ssl, EAP_TYPE_TLS, ret, reqData, reqDataLen,
                            &left, &flags);
	if (pos==((void  __far * )0))
		return ((void  __far * )0);
	req = (struct eap_hdr  __far * )reqData;
	id = req->identifier;
	if (flags&EAP_TLS_FLAGS_START) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-TLS: Start" ));
		left = 0;
	}
	resp = ((void  __far * )0);
	res = eap_tls_process_helper(sm, &data->ssl, EAP_TYPE_TLS, 0, id, pos, left, &resp,
                              respDataLen);
	if (res<0) {
		return _wpa_s11_eap_tls_failure(sm, data, ret, res, resp, id, respDataLen);
	}
	if (tls_connection_established(sm->ssl_ctx, data->ssl.conn))
		_wpa_s11_eap_tls_success(sm, data, ret);
	if (res==1) {
		return eap_tls_build_ack(&data->ssl, respDataLen, id, EAP_TYPE_TLS, 0);
	}
	return resp;
}

/*** BeginHeader _wpa_s11_eap_tls_has_reauth_data */
// From "eap_tls.c":186
Boolean _wpa_s11_eap_tls_has_reauth_data(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s11_eap_tls_has_reauth_data(struct eap_sm __far * sm, void __far * priv) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":188

	data = priv;

	return tls_connection_established(sm->ssl_ctx, data->ssl.conn);
}

/*** BeginHeader _wpa_s11_eap_tls_deinit_for_reauth */
// From "eap_tls.c":193
void _wpa_s11_eap_tls_deinit_for_reauth(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s11_eap_tls_deinit_for_reauth(struct eap_sm __far * sm, void __far * priv) {
}

/*** BeginHeader _wpa_s11_eap_tls_init_for_reauth */
// From "eap_tls.c":198
void __far * _wpa_s11_eap_tls_init_for_reauth(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void __far * _wpa_s11_eap_tls_init_for_reauth(struct eap_sm __far * sm, void __far * priv) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":200

	data = priv;

	_sys_free(data->key_data);
	data->key_data = ((void  __far * )0);
	if (eap_tls_reauth_init(sm, &data->ssl)) {
		_sys_free(data);
		return ((void  __far * )0);
	}
	return priv;
}

/*** BeginHeader _wpa_s11_eap_tls_get_status */
// From "eap_tls.c":211
int _wpa_s11_eap_tls_get_status(struct eap_sm __far * sm, void __far * priv, char __far * buf,
                                size_t buflen, int verbose);
/*** EndHeader */
_wpa_debug
int _wpa_s11_eap_tls_get_status(struct eap_sm __far * sm, void __far * priv, char __far * buf,
                                size_t buflen, int verbose) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":214

	data = priv;

	return eap_tls_status(sm, &data->ssl, buf, buflen, verbose);
}

/*** BeginHeader _wpa_s11_eap_tls_isKeyAvailable */
// From "eap_tls.c":219
Boolean _wpa_s11_eap_tls_isKeyAvailable(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s11_eap_tls_isKeyAvailable(struct eap_sm __far * sm, void __far * priv) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":221

	data = priv;

	return data->key_data!=((void  __far * )0);
}

/*** BeginHeader _wpa_s11_eap_tls_getKey */
// From "eap_tls.c":226
char __far * _wpa_s11_eap_tls_getKey(struct eap_sm __far * sm, void __far * priv, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s11_eap_tls_getKey(struct eap_sm __far * sm, void __far * priv, size_t __far * len) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":228
	char __far * key; 	// From "eap_tls.c":229

	data = priv;

	if (data->key_data==((void  __far * )0))
		return ((void  __far * )0);
	key = _sys_malloc(EAP_TLS_KEY_LEN);
	if (key==((void  __far * )0))
		return ((void  __far * )0);
	*len = EAP_TLS_KEY_LEN;
	_f_memcpy(key, data->key_data, EAP_TLS_KEY_LEN);
	return key;
}

/*** BeginHeader _wpa_s11_eap_tls_get_emsk */
// From "eap_tls.c":245
char __far * _wpa_s11_eap_tls_get_emsk(struct eap_sm __far * sm, void __far * priv, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s11_eap_tls_get_emsk(struct eap_sm __far * sm, void __far * priv, size_t __far * len) {
	struct eap_tls_data __far * data /* = priv */; 	// From "eap_tls.c":247
	char __far * key; 	// From "eap_tls.c":248

	data = priv;

	if (data->key_data==((void  __far * )0))
		return ((void  __far * )0);
	key = _sys_malloc(EAP_EMSK_LEN);
	if (key==((void  __far * )0))
		return ((void  __far * )0);
	*len = EAP_EMSK_LEN;
	_f_memcpy(key, data->key_data+EAP_TLS_KEY_LEN, EAP_EMSK_LEN);
	return key;
}

/*** BeginHeader eap_peer_tls_register */
// From "eap_tls.c":264
int eap_peer_tls_register(void );
/*** EndHeader */
_wpa_debug
int eap_peer_tls_register(void ) {
	struct eap_method __far * eap; 	// From "eap_tls.c":266
	int ret; 	// From "eap_tls.c":267


	eap = eap_peer_method_alloc(1, EAP_VENDOR_IETF, EAP_TYPE_TLS, "TLS" );
	if (eap==((void  __far * )0))
		return  -1;
	eap->init = _wpa_s11_eap_tls_init;
	eap->deinit = _wpa_s11_eap_tls_deinit;
	eap->process = _wpa_s11_eap_tls_process;
	eap->isKeyAvailable = _wpa_s11_eap_tls_isKeyAvailable;
	eap->getKey = _wpa_s11_eap_tls_getKey;
	eap->get_status = _wpa_s11_eap_tls_get_status;
	eap->has_reauth_data = _wpa_s11_eap_tls_has_reauth_data;
	eap->deinit_for_reauth = _wpa_s11_eap_tls_deinit_for_reauth;
	eap->init_for_reauth = _wpa_s11_eap_tls_init_for_reauth;
	eap->get_emsk = _wpa_s11_eap_tls_get_emsk;
	ret = eap_peer_method_register(eap);
	if (ret)
		eap_peer_method_free(eap);
	return ret;
}
// @ TUName[]  ; -- translator directive

/*** BeginHeader eap_tlv_build_nak */
// From "eap_tlv.c":32
char __far * eap_tlv_build_nak(int id, word nak_type, size_t __far * resp_len);
/*** EndHeader */
_wpa_debug
char __far * eap_tlv_build_nak(int id, word nak_type, size_t __far * resp_len) {
	struct eap_hdr __far * hdr; 	// From "eap_tlv.c":34
	char __far * pos; 	// From "eap_tlv.c":35


	hdr = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_TLV, resp_len, 10, EAP_CODE_RESPONSE,
                     id, &pos);
	if (hdr==((void  __far * )0))
		return ((void  __far * )0);
	*pos++ = 0x80;
	*pos++ = 4;
	*pos++ = 0;
	*pos++ = 6;
	*pos++ = 0;
	*pos++ = 0;
	*pos++ = 0;
	*pos++ = 0;
	do {
		(pos)[0] = ((word  )(nak_type))>>8;
		(pos)[1] = ((word  )(nak_type))&0xff;
	} while (0);
	return (char  __far * )hdr;
}

/*** BeginHeader eap_tlv_build_result */
// From "eap_tlv.c":69
char __far * eap_tlv_build_result(int id, word status, size_t __far * resp_len);
/*** EndHeader */
_wpa_debug
char __far * eap_tlv_build_result(int id, word status, size_t __far * resp_len) {
	struct eap_hdr __far * hdr; 	// From "eap_tlv.c":71
	char __far * pos; 	// From "eap_tlv.c":72


	hdr = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_TLV, resp_len, 6, EAP_CODE_RESPONSE,
                     id, &pos);
	if (hdr==((void  __far * )0))
		return ((void  __far * )0);
	*pos++ = 0x80;
	*pos++ = 3;
	*pos++ = 0;
	*pos++ = 2;
	do {
		(pos)[0] = ((word  )(status))>>8;
		(pos)[1] = ((word  )(status))&0xff;
	} while (0);
	return (char  __far * )hdr;
}

/*** BeginHeader eap_tlv_process */
// From "eap_tlv.c":105
int eap_tlv_process(struct eap_sm __far * sm, struct eap_method_ret __far * ret, struct eap_hdr __far * hdr,
                    char __far * __far * resp, size_t __far * resp_len);
/*** EndHeader */
_wpa_debug
int eap_tlv_process(struct eap_sm __far * sm, struct eap_method_ret __far * ret, struct eap_hdr __far * hdr,
                    char __far * __far * resp, size_t __far * resp_len) {
	size_t left; 	// From "eap_tlv.c":108
	size_t tlv_len; 	// From "eap_tlv.c":108
	char __far * pos; 	// From "eap_tlv.c":109
	char __far * result_tlv /* = ((void  far * )0) */; 	// From "eap_tlv.c":110
	size_t result_tlv_len /* = 0 */; 	// From "eap_tlv.c":111
	int tlv_type; 	// From "eap_tlv.c":112
	int mandatory; 	// From "eap_tlv.c":112

	union  {

		struct  {
			int status;
			int resp_status;

		} __s3;

	} __u; 	// From "eap_tlv.c":107

	result_tlv = ((void  __far * )0);
	result_tlv_len = 0;

	left = intel16(hdr->length)-sizeof(struct eap_hdr  )-1;
	pos = (char  __far * )(hdr+1);
	pos++;
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-TLV: Received TLVs" , pos, left));
	while (left>=4) {
		mandatory = !!(pos[0]&0x80);
		tlv_type = ((word  )(((pos)[0]<<8)|(pos)[1]))&0x3fff;
		pos += 2;
		tlv_len = ((word  )(((pos)[0]<<8)|(pos)[1]));
		pos += 2;
		left -= 4;
		if (tlv_len>left) {
			_WPA_PRINTF((MSG_DEBUG, "EAP-TLV: TLV underrun " \
			 "(tlv_len=%lu left=%lu)" , (unsigned long  )tlv_len, (unsigned long  )left));
			return  -1;
		}
		switch ((int)(tlv_type)) {
			case 3:
			result_tlv = pos;
			result_tlv_len = tlv_len;
			break;
			default:
			_WPA_PRINTF((MSG_DEBUG, "EAP-TLV: Unsupported TLV Type %d%ls" , tlv_type, (char  __far * )(mandatory ?
			  " (mandatory)"  :
			  "" )));
			if (mandatory) {
				*resp = eap_tlv_build_nak(hdr->identifier, tlv_type, resp_len);
				return *resp==((void  __far * )0) ?
				   -1 :
				  0;
			}
			break;
		}
		pos += tlv_len;
		left -= tlv_len;
	}
	if (left) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-TLV: Last TLV too short in " \
		 "Request (left=%lu)" , (unsigned long  )left));
		return  -1;
	}
	if (result_tlv) {
		_WPA_HEXDUMP((MSG_DEBUG, "EAP-TLV: Result TLV" , result_tlv, result_tlv_len));
		if (result_tlv_len<2) {
			_WPA_PRINTF((MSG_INFO, "EAP-TLV: Too short Result TLV " \
			 "(len=%lu)" , (unsigned long  )result_tlv_len));
			return  -1;
		}
		__u.__s3.status = ((word  )(((result_tlv)[0]<<8)|(result_tlv)[1]));
		if (__u.__s3.status==1) {
			_WPA_PRINTF((MSG_INFO, "EAP-TLV: TLV Result - Success " \
			 "- EAP-TLV/Phase2 Completed" ));
			__u.__s3.resp_status = 1;
			ret->decision = DECISION_UNCOND_SUCC;
		}
		else if (__u.__s3.status==2) {
			_WPA_PRINTF((MSG_INFO, "EAP-TLV: TLV Result - Failure" ));
			__u.__s3.resp_status = 2;
			ret->decision = DECISION_FAIL;
		}
		else {
			_WPA_PRINTF((MSG_INFO, "EAP-TLV: Unknown TLV Result " \
			 "Status %d" , __u.__s3.status));
			__u.__s3.resp_status = 2;
			ret->decision = DECISION_FAIL;
		}
		ret->methodState = METHOD_DONE;
		*resp = eap_tlv_build_result(hdr->identifier, __u.__s3.resp_status, resp_len);
	}
	return 0;
}
// @ TUName[]  ; -- translator directive
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

typedef
enum wpa_event_type {
	//SJH - v28282: the enum values are forced to be the same as the WLN_* values
	// because there is a direct call from to base driver to the WPA event
	// handler with no translation.
	EVENT_ASSOC = WLN_EVT_ASSOC,
	EVENT_DISASSOC = WLN_EVT_DISASSOC,
	EVENT_MICHAEL_MIC_FAILURE = WLN_EVT_MIC_FAIL,
	EVENT_SCAN_RESULTS = WLN_EVT_SCAN_RESULTS,
	EVENT_INTERFACE_STATUS = WLN_EVT_LINKUP,
	EVENT_ASSOCINFO = 100,
	EVENT_PMKID_CANDIDATE,
	EVENT_STKSTART
}  wpa_event_type;	// From "wpa_supplicant.h":136

union wpa_event_data {

	struct assoc_info {
		char __far * req_ies;
		size_t req_ies_len;
		char __far * resp_ies;
		size_t resp_ies_len;
		char __far * beacon_ies;
		size_t beacon_ies_len;

	} assoc_info;

	struct michael_mic_failure {
		int unicast;

	} michael_mic_failure;

	struct interface_status {
		char ifname[100];

		enum  {
			EVENT_INTERFACE_ADDED,
			EVENT_INTERFACE_REMOVED
		}  ievent;

	} interface_status;

	struct pmkid_candidate {
		char bssid[6];
		int index;
		int preauth;

	} pmkid_candidate;

	struct stkstart {
		char peer[6];

	} stkstart;

} ;	// From "wpa_supplicant.h":246

enum  {
	AUTH_ALG_OPEN_SYSTEM = 0x01
}  ;	// From "driver.h":22

enum  {
	AUTH_ALG_SHARED_KEY = 0x02
}  ;	// From "driver.h":23

enum  {
	AUTH_ALG_LEAP = 0x04
}  ;	// From "driver.h":24

enum  {
	IEEE80211_CAP_IBSS = 0x0002
}  ;	// From "driver.h":30

enum  {
	IEEE80211_CAP_PRIVACY = 0x0010
}  ;	// From "driver.h":31

enum {
   SSID_MAX_WPA_IE_LEN = 40
}  ;  // From "driver.h":33

struct wpa_scan_result {
	char bssid[6];
	char ssid[32];
	size_t ssid_len;
	char wpa_ie[SSID_MAX_WPA_IE_LEN];
	size_t wpa_ie_len;
	char rsn_ie[SSID_MAX_WPA_IE_LEN];
	size_t rsn_ie_len;
	int freq;
	word caps;
	int qual;
	int noise;
	int level;
	int maxrate;

} ;	// From "driver.h":68

struct wpa_driver_associate_params {
	char __far * bssid;
	char __far * ssid;
	size_t ssid_len;
	int freq;
	char __far * wpa_ie;
	size_t wpa_ie_len;
	wpa_cipher pairwise_suite;
	wpa_cipher group_suite;
	wpa_key_mgmt key_mgmt_suite;
	int auth_alg;
	int mode;
	char __far * wep_key[4];
	size_t wep_key_len[4];
	int wep_tx_keyidx;

	enum  {
		NO_MGMT_FRAME_PROTECTION,
		MGMT_FRAME_PROTECTION_OPTIONAL,
		MGMT_FRAME_PROTECTION_REQUIRED
	}  mgmt_frame_protection;

} ;	// From "driver.h":155


	// Rabbit note: enumified defines in struct before key_mgmt
	enum  {
		WPA_DRIVER_CAPA_KEY_MGMT_WPA = 0x00000001
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_KEY_MGMT_WPA2 = 0x00000002
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK = 0x00000004
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK = 0x00000008
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_KEY_MGMT_WPA_NONE = 0x00000010
	}  ; // Anon union

	// Rabbit note: enumified defines in struct before enc
	enum  {
		WPA_DRIVER_CAPA_ENC_WEP40 = 0x00000001
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_ENC_WEP104 = 0x00000002
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_ENC_TKIP = 0x00000004
	}  ; // Anon union

	enum  {
		WPA_DRIVER_CAPA_ENC_CCMP = 0x00000008
	}  ; // Anon union

	// Rabbit note: enumified defines in struct before auth
	enum  {
		WPA_DRIVER_AUTH_OPEN = 0x00000001
	}  ; // Anon union

	enum  {
		WPA_DRIVER_AUTH_SHARED = 0x00000002
	}  ; // Anon union

	enum  {
		WPA_DRIVER_AUTH_LEAP = 0x00000004
	}  ; // Anon union

	// Rabbit note: enumified defines in struct before flags
	enum  {
		WPA_DRIVER_FLAGS_DRIVER_IE = 0x00000001
	}  ; // Anon union

	enum  {
		WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC = 0x00000002
	}  ; // Anon union

	enum  {
		WPA_DRIVER_FLAGS_USER_SPACE_MLME = 0x00000004
	}  ; // Anon union
struct wpa_driver_capa {
	unsigned int key_mgmt;
	unsigned int enc;
	unsigned int auth;
	unsigned int flags;

} ;	// From "driver.h":184

struct wpa_channel_data {
	short chan;
	short freq;
	int flag;

} ;	// From "driver.h":195

struct wpa_rate_data {
	int rate;
	int flags;

} ;	// From "driver.h":208

typedef
enum  {
	WPA_MODE_IEEE80211B,
	WPA_MODE_IEEE80211G,
	WPA_MODE_IEEE80211A,
	NUM_WPA_MODES
}  wpa_hw_mode;	// From "driver.h":215

struct wpa_hw_modes {
	wpa_hw_mode mode;
	int num_channels;
	struct wpa_channel_data __far * channels;
	int num_rates;
	struct wpa_rate_data __far * rates;

} ;	// From "driver.h":223

struct wpa_driver_ops {
	char __far * name;
	char __far * desc;
	int (FUNCPTR get_bssid)( /* void far * priv, char far * bssid */ );
	int (FUNCPTR get_ssid)( /* void far * priv, char far * ssid */ );
	int (FUNCPTR set_wpa)( /* void far * priv, int enabled */ );
	int (FUNCPTR set_key)( /* void far * priv, wpa_alg alg, char far * addr, int key_idx,
                           int set_tx, char far * seq, size_t seq_len, char far * key,
                           size_t key_len */ );
	void __far * (FUNCPTR init)( /* void far * ctx, char far * ifname */ );
	void (FUNCPTR deinit)( /* void far * priv */ );
	int (FUNCPTR set_param)( /* void far * priv, char far * param */ );
	int (FUNCPTR set_countermeasures)( /* void far * priv, int enabled */ );
	int (FUNCPTR set_drop_unencrypted)( /* void far * priv, int enabled */ );
	int (FUNCPTR scan)( /* void far * priv, char far * ssid, size_t ssid_len */ );
	int (FUNCPTR get_scan_results)( /* void far * priv, struct wpa_scan_result far * results,
                                    size_t max_size */ );
	int (FUNCPTR deauthenticate)( /* void far * priv, char far * addr, int reason_code */ );
	int (FUNCPTR disassociate)( /* void far * priv, char far * addr, int reason_code */ );
	int (FUNCPTR associate)( /* void far * priv, struct wpa_driver_associate_params far * params */ );
	int (FUNCPTR set_auth_alg)( /* void far * priv, int auth_alg */ );
	int (FUNCPTR add_pmkid)( /* void far * priv, char far * bssid, char far * pmkid */ );
	int (FUNCPTR remove_pmkid)( /* void far * priv, char far * bssid, char far * pmkid */ );
	int (FUNCPTR flush_pmkid)( /* void far * priv */ );
	int (FUNCPTR get_capa)( /* void far * priv, struct wpa_driver_capa far * capa */ );
	void (FUNCPTR poll)( /* void far * priv */ );
	char __far * (FUNCPTR get_ifname)( /* void far * priv */ );
	char __far * (FUNCPTR get_mac_addr)( /* void far * priv */ );
	int (FUNCPTR send_eapol)( /* void far * priv, char far * dest, word proto, char far * data,
                              size_t data_len */ );
	int (FUNCPTR set_operstate)( /* void far * priv, int state */ );
	int (FUNCPTR mlme_setprotection)( /* void far * priv, char far * addr, int protect_type,
                                      int key_type */ );
	struct wpa_hw_modes __far * (FUNCPTR get_hw_feature_data)( /* void far * priv, word far * num_modes,
                                                             word far * flags */ );
	int (FUNCPTR set_channel)( /* void far * priv, wpa_hw_mode phymode, int chan, int freq */ );
	int (FUNCPTR set_ssid)( /* void far * priv, char far * ssid, size_t ssid_len */ );
	int (FUNCPTR set_bssid)( /* void far * priv, char far * bssid */ );
	int (FUNCPTR send_mlme)( /* void far * priv, char far * data, size_t data_len */ );
	int (FUNCPTR mlme_add_sta)( /* void far * priv, char far * addr, char far * supp_rates,
                                size_t supp_rates_len */ );
	int (FUNCPTR mlme_remove_sta)( /* void far * priv, char far * addr */ );

} ;	// From "driver.h":755

struct wpa_blacklist {
	struct wpa_blacklist __far * next;
	char bssid[6];
	int count;

} ;	// From "wpa_all.c":953

struct wpa_interface {
	char __far * confname;
	char __far * ctrl_interface;
	char __far * driver;
	char __far * driver_param;
	char __far * ifname;
	char __far * bridge_ifname;

} ;	// From "wpa_all.c":1023

struct wpa_params {
	int daemonize;
	int wait_for_interface;
	int wait_for_monitor;
	char __far * pid_file;
	int wpa_debug_level;
	int wpa_debug_show_keys;
	int wpa_debug_timestamp;
	char __far * ctrl_interface;
	int dbus_ctrl_interface;
	int wpa_debug_use_file;

} ;	// From "wpa_all.c":1093

struct wpa_global {
	struct wpa_supplicant __far * ifaces;
	struct wpa_params params;
	struct ctrl_iface_global_priv __far * ctrl_iface;
	struct ctrl_iface_dbus_priv __far * dbus_ctrl_iface;

} ;	// From "wpa_all.c":1106

struct wpa_supplicant {
	struct wpa_global __far * global;
	struct wpa_supplicant __far * next;
	struct l2_packet_data __far * l2;
	struct l2_packet_data __far * l2_br;
	unsigned char own_addr[6];
	char ifname[100];
	char bridge_ifname[16];
	char __far * confname;
	struct wpa_config __far * conf;
	int countermeasures;
	os_time_t last_michael_mic_error;
	char bssid[6];
	char pending_bssid[6];
	int reassociate;
	int disconnected;
	struct wpa_ssid __far * current_ssid;
	int pairwise_cipher;
	int group_cipher;
	int key_mgmt;
	int mgmt_group_cipher;
	void __far * drv_priv;
	struct wpa_ssid __far * prev_scan_ssid;
	struct wpa_scan_result __far * scan_results;
	int num_scan_results;
	struct wpa_driver_ops const __far * driver;
	int interface_removed;
	struct wpa_sm __far * wpa;
	struct eapol_sm __far * eapol;
	struct ctrl_iface_priv __far * ctrl_iface;
	wpa_states wpa_state;
	int new_connection;
	int reassociated_connection;
	int eapol_received;
#ifdef WPA_USE_SCARD_GSIM
	struct scard_data __far * scard;
#endif//def WPA_USE_SCARD_GSIM
	unsigned char last_eapol_src[6];
	int keys_cleared;
	struct wpa_blacklist __far * blacklist;
	int scan_req;
	int scan_res_tried;
	int use_client_mlme;

} ;	// From "wpa_all.c":1275
// @ TUName[]  ; -- translator directive

struct rsn_pmksa_cache_entry {
	struct rsn_pmksa_cache_entry __far * next;
	char pmkid[PMKID_LEN];
	char pmk[PMK_LEN];
	size_t pmk_len;
	os_time_t expiration;
	int akmp;
	char aa[6];
	os_time_t reauth_time;
	struct wpa_ssid __far * ssid;
	int opportunistic;

} ;	// From "pmksa_cache.h":33
/*** EndHeader */

/*** BeginHeader _wpa_s15_wpaS_dbus_ctrl_iface_init */
// From "ctrl_iface_dbus.h":110
struct ctrl_iface_dbus_priv __far * _wpa_s15_wpaS_dbus_ctrl_iface_init(struct wpa_global __far * global);
/*** EndHeader */
_wpa_debug
struct ctrl_iface_dbus_priv __far * _wpa_s15_wpaS_dbus_ctrl_iface_init(struct wpa_global __far * global) {
	return (struct ctrl_iface_dbus_priv  __far * )1;
}

/*** BeginHeader _wpa_s15_wpaS_dbus_ctrl_iface_deinit */
// From "ctrl_iface_dbus.h":116
void _wpa_s15_wpaS_dbus_ctrl_iface_deinit(struct ctrl_iface_dbus_priv __far * iface);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_dbus_ctrl_iface_deinit(struct ctrl_iface_dbus_priv __far * iface) {
}

/*** BeginHeader _wpa_s15_wpaS_dbus_notify_scan_results */
// From "ctrl_iface_dbus.h":121
void _wpa_s15_wpaS_dbus_notify_scan_results(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_dbus_notify_scan_results(struct wpa_supplicant __far * wpa_s) {
}

/*** BeginHeader _wpa_s15_wpaS_dbus_notify_state_change */
// From "ctrl_iface_dbus.h":126
void _wpa_s15_wpaS_dbus_notify_state_change(struct wpa_supplicant __far * wpa_s,
                                                      wpa_states new_state, wpa_states old_state);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_dbus_notify_state_change(struct wpa_supplicant __far * wpa_s,
                                                      wpa_states new_state, wpa_states old_state) {
}

/*** BeginHeader _wpa_s15_wpas_dbus_register_iface */
// From "ctrl_iface_dbus.h":133
int _wpa_s15_wpas_dbus_register_iface(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s15_wpas_dbus_register_iface(struct wpa_supplicant __far * wpa_s) {
	return 0;
}

/*** BeginHeader _wpa_s15_wpas_dbus_unregister_iface */
// From "ctrl_iface_dbus.h":139
int _wpa_s15_wpas_dbus_unregister_iface(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s15_wpas_dbus_unregister_iface(struct wpa_supplicant __far * wpa_s) {
	return 0;
}

/*** BeginHeader _wpa_s15_wpaS_select_config */
// From "events.c":33
int _wpa_s15_wpaS_select_config(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s15_wpaS_select_config(struct wpa_supplicant __far * wpa_s) {
	struct wpa_ssid __far * ssid; 	// From "events.c":35

	union  {

		struct  {
			char wpa_ie[80];
			size_t wpa_ie_len /* = sizeof (__u.__s3.wpa_ie) */;

		} __s3;

	} __u; 	// From "events.c":34


	if (wpa_s->conf->ap_scan==1 &&
	wpa_s->current_ssid)
		return 0;
	ssid = wpaS_get_ssid(wpa_s);
	if (ssid==((void  __far * )0)) {
		_WPA_PRINTF((MSG_INFO, "No network configuration found for the " \
		 "current AP" ));
		return  -1;
	}
	if (ssid->disabled) {
		_WPA_PRINTF((MSG_DEBUG, "Selected network is disabled" ));
		return  -1;
	}
	_WPA_PRINTF((MSG_DEBUG, "Network configuration found for the current " \
	 "AP" ));
	if (ssid->key_mgmt&(WPA_KEY_MGMT_PSK|WPA_KEY_MGMT_IEEE8021X|WPA_KEY_MGMT_WPA_NONE)) {
		__u.__s3.wpa_ie_len = sizeof (__u.__s3.wpa_ie);

		wpaS_set_suites(wpa_s, ((void  __far * )0), ssid, __u.__s3.wpa_ie, &__u.__s3.wpa_ie_len);
	}
	else {
		wpaS_set_non_wpa_policy(wpa_s, ssid);
	}
#ifdef WPA_USE_EAP
	if (wpa_s->current_ssid &&
	wpa_s->current_ssid!=ssid)
		eapol_sm_invalidate_cached_session(wpa_s->eapol);
#endif//def WPA_USE_EAP
	wpa_s->current_ssid = ssid;
	wpa_sm_set_config(wpa_s->wpa, wpa_s->current_ssid);
#ifdef WPA_USE_EAP
	wpaS_initiate_eapol(wpa_s);
#endif//def WPA_USE_EAP
	return 0;
}

/*** BeginHeader _wpa_s15_wpaS_stop_countermeasures */
// From "events.c":74
void _wpa_s15_wpaS_stop_countermeasures(void __far * eloop_ctx, void __far * sock_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_stop_countermeasures(void __far * eloop_ctx, void __far * sock_ctx) {
	struct wpa_supplicant __far * wpa_s /* = eloop_ctx */; 	// From "events.c":77

	wpa_s = eloop_ctx;

	if (wpa_s->countermeasures) {
		wpa_s->countermeasures = 0;
		(wpa_s->driver->set_countermeasures ?
		  wpa_s->driver->set_countermeasures((void  __far * )(wpa_s->drv_priv), (int  )(0)) :
		   -1);
		_WPA_MSG((wpa_s, MSG_INFO, "WPA: TKIP countermeasures stopped" ));
		wpaS_req_scan(wpa_s, 0, 0);
	}
}

/*** BeginHeader wpaS_mark_disassoc */
// From "events.c":88
void wpaS_mark_disassoc(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void wpaS_mark_disassoc(struct wpa_supplicant __far * wpa_s) {
	wpaS_set_state(wpa_s, WPA_DISCONNECTED);
	_f_memset(wpa_s->bssid, 0, 6);
	_f_memset(wpa_s->pending_bssid, 0, 6);
#ifdef WPA_USE_EAP
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_PSK)
		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
#endif//def WPA_USE_EAP
}

/*** BeginHeader _wpa_s15_wpa_find_assoc_pmkid */
// From "events.c":100
void _wpa_s15_wpa_find_assoc_pmkid(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpa_find_assoc_pmkid(struct wpa_supplicant __far * wpa_s) {
	struct wpa_ie_data ie; 	// From "events.c":102
	int i; 	// From "events.c":103
	int pmksa_set /* =  -1 */; 	// From "events.c":103

	pmksa_set =  -1;

	if (wpa_sm_parse_own_wpa_ie(wpa_s->wpa, &ie)<0 ||
	ie.pmkid==((void  __far * )0))
		return /*void*/;
	for (i = 0; i<ie.num_pmkid; i++) {
		pmksa_set = pmksa_cache_set_current(wpa_s->wpa, ie.pmkid+i*PMKID_LEN, ((void  __far * )0),
                                      ((void  __far * )0), 0);
		if (pmksa_set==0) {
#ifdef WPA_USE_EAP
			eapol_sm_notify_pmkid_attempt(wpa_s->eapol, 1);
#endif//def WPA_USE_EAP
			break;
		}
	}
	_WPA_PRINTF((MSG_DEBUG, "RSN: PMKID from assoc IE %lsfound from PMKSA cache" ,
              (char  __far * )(pmksa_set==0 ?
	  ""  :
	  "not " )));
}

/*** BeginHeader _wpa_s15_wpaS_event_pmkid_candidate */
// From "events.c":124
void _wpa_s15_wpaS_event_pmkid_candidate(struct wpa_supplicant __far * wpa_s,
                                                   union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_pmkid_candidate(struct wpa_supplicant __far * wpa_s,
                                                   union wpa_event_data __far * data) {
	if (data==((void  __far * )0)) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: No data in PMKID candidate event" ));
		return /*void*/;
	}
	_WPA_PRINTF((MSG_DEBUG, "RSN: PMKID candidate event - bssid=" \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " index=%d preauth=%d" , (data->pmkid_candidate.bssid)[0], (data->pmkid_candidate.bssid)[1],
              (data->pmkid_candidate.bssid)[2], (data->pmkid_candidate.bssid)[3],
              (data->pmkid_candidate.bssid)[4], (data->pmkid_candidate.bssid)[5],
              data->pmkid_candidate.index, data->pmkid_candidate.preauth));
	pmksa_candidate_add(wpa_s->wpa, data->pmkid_candidate.bssid, data->pmkid_candidate.index,
                     data->pmkid_candidate.preauth);
}

/*** BeginHeader _wpa_s15_wpaS_dynamic_keys */
// From "events.c":143
int _wpa_s15_wpaS_dynamic_keys(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s15_wpaS_dynamic_keys(struct wpa_supplicant __far * wpa_s) {
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_NONE ||
	wpa_s->key_mgmt==WPA_KEY_MGMT_WPA_NONE)
		return 0;
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X_NO_WPA &&
	wpa_s->current_ssid &&
	!(wpa_s->current_ssid->eapol_flags&(EAPOL_FLAG_REQUIRE_KEY_UNICAST|EAPOL_FLAG_REQUIRE_KEY_BROADCAST))) {
		return 0;
	}
	return 1;
}

/*** BeginHeader wpaS_scard_init */
// From "events.c":174
int wpaS_scard_init(struct wpa_supplicant __far * wpa_s, struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
int wpaS_scard_init(struct wpa_supplicant __far * wpa_s, struct wpa_ssid __far * ssid) {
	int aka /* = 0 */; 	// From "events.c":178
	int sim /* = 0 */; 	// From "events.c":178
	int type; 	// From "events.c":178

	union  {

		struct  {
			struct eap_method_type __far * eap /* = ssid->eap_methods */;

		} __s2;

	} __u; 	// From "events.c":176

	aka = 0;
	sim = 0;

	if (ssid->pcsc==((void  __far * )0) ||
	wpa_s->scard!=((void  __far * )0))
		return 0;
	if (ssid->eap_methods==((void  __far * )0)) {
		sim = 1;
		aka = 1;
	}
	else {
		__u.__s2.eap = ssid->eap_methods;

		while (__u.__s2.eap->vendor!=EAP_VENDOR_IETF ||
		__u.__s2.eap->method!=EAP_TYPE_NONE) {
			if (__u.__s2.eap->vendor==EAP_VENDOR_IETF) {
				if (__u.__s2.eap->method==EAP_TYPE_SIM)
					sim = 1;
				else if (__u.__s2.eap->method==EAP_TYPE_AKA)
					aka = 1;
			}
			__u.__s2.eap++;
		}
	}
	if (eap_sm_get_eap_methods(EAP_VENDOR_IETF, EAP_TYPE_SIM)==((void  __far * )0))
		sim = 0;
	if (eap_sm_get_eap_methods(EAP_VENDOR_IETF, EAP_TYPE_AKA)==((void  __far * )0))
		aka = 0;
	if (!sim &&
	!aka) {
		_WPA_PRINTF((MSG_DEBUG, "Selected network is configured to use " \
		 "SIM, but neither EAP-SIM nor EAP-AKA are enabled" ));
		return 0;
	}
	_WPA_PRINTF((MSG_DEBUG, "Selected network is configured to use SIM " \
	 "(sim=%d aka=%d) - initialize PCSC" , sim, aka));
	if (sim &&
	aka)
		type = SCARD_TRY_BOTH;
	else if (aka)
		type = SCARD_USIM_ONLY;
	else
		type = SCARD_GSM_SIM_ONLY;
	wpa_s->scard = ((void  __far * )0);
	if (wpa_s->scard==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "Failed to initialize SIM " \
		 "(pcsc-lite)" ));
		return  -1;
	}
	wpa_sm_set_scard_ctx(wpa_s->wpa, wpa_s->scard);
	eapol_sm_register_scard_ctx(wpa_s->eapol, wpa_s->scard);
	return 0;
}

/*** BeginHeader _wpa_s15_wpaS_match_privacy */
// From "events.c":234
int _wpa_s15_wpaS_match_privacy(struct wpa_scan_result __far * bss, struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
int _wpa_s15_wpaS_match_privacy(struct wpa_scan_result __far * bss, struct wpa_ssid __far * ssid) {
	int i; 	// From "events.c":237
	int privacy /* = 0 */; 	// From "events.c":237

	privacy = 0;

	if (ssid->mixed_cell)
		return 1;
	for (i = 0; i<NUM_WEP_KEYS; i++) {
		if (ssid->wep_key_len[i]) {
			privacy = 1;
			break;
		}
	}
	if ((ssid->key_mgmt&WPA_KEY_MGMT_IEEE8021X_NO_WPA) &&
	ssid->eapol_flags&(EAPOL_FLAG_REQUIRE_KEY_UNICAST|EAPOL_FLAG_REQUIRE_KEY_BROADCAST))
		privacy = 1;
	if (bss->caps&IEEE80211_CAP_PRIVACY)
		return privacy;
	return !privacy;
}

/*** BeginHeader _wpa_s15_wpaS_ssid_bss_match */
// From "events.c":261
int _wpa_s15_wpaS_ssid_bss_match(struct wpa_ssid __far * ssid, struct wpa_scan_result __far * bss);
/*** EndHeader */
_wpa_debug
int _wpa_s15_wpaS_ssid_bss_match(struct wpa_ssid __far * ssid, struct wpa_scan_result __far * bss) {
	struct wpa_ie_data ie; 	// From "events.c":264
	int proto_match /* = 0 */; 	// From "events.c":265

	proto_match = 0;

	while ((ssid->proto&WPA_PROTO_RSN) &&
	bss->rsn_ie_len>0) {
		proto_match++;
		if (wpa_parse_wpa_ie(bss->rsn_ie, bss->rsn_ie_len, &ie)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "RSN IE", "parse failed" ));
			break;
		}
		if (!(ie.proto&ssid->proto)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "RSN IE", "proto " \
			 "mismatch" ));
			break;
		}
		if (!(ie.pairwise_cipher&ssid->pairwise_cipher)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "RSN IE", "PTK cipher " \
			 "mismatch" ));
			break;
		}
		if (!(ie.group_cipher&ssid->group_cipher)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "RSN IE", "GTK cipher " \
			 "mismatch" ));
			break;
		}
		if (!(ie.key_mgmt&ssid->key_mgmt)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "RSN IE", "key mgmt " \
			 "mismatch" ));
			break;
		}
		_WPA_PRINTF((MSG_DEBUG, "   selected based on RSN IE" ));
		return 1;
	}
	while ((ssid->proto&WPA_PROTO_WPA) &&
	bss->wpa_ie_len>0) {
		proto_match++;
		if (wpa_parse_wpa_ie(bss->wpa_ie, bss->wpa_ie_len, &ie)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "WPA IE", "parse failed" ));
			break;
		}
		if (!(ie.proto&ssid->proto)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "WPA IE", "proto " \
			 "mismatch" ));
			break;
		}
		if (!(ie.pairwise_cipher&ssid->pairwise_cipher)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "WPA IE", "PTK cipher " \
			 "mismatch" ));
			break;
		}
		if (!(ie.group_cipher&ssid->group_cipher)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "WPA IE", "GTK cipher " \
			 "mismatch" ));
			break;
		}
		if (!(ie.key_mgmt&ssid->key_mgmt)) {
			_WPA_PRINTF((MSG_DEBUG, "   skip %s - %s", "WPA IE", "key mgmt " \
			 "mismatch" ));
			break;
		}
		_WPA_PRINTF((MSG_DEBUG, "   selected based on WPA IE" ));
		return 1;
	}
	if (proto_match==0)
		_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "no WPA/RSN proto match" ));
	return 0;
}

/*** BeginHeader _wpa_s15_wpaS_select_bss */
// From "events.c":354
struct wpa_scan_result __far * _wpa_s15_wpaS_select_bss(struct wpa_supplicant __far * wpa_s,
                                                                struct wpa_ssid __far * group,
                                                                struct wpa_scan_result __far * results,
                                                                int num, struct wpa_ssid __far * __far * selected_ssid);
/*** EndHeader */
_wpa_debug
struct wpa_scan_result __far * _wpa_s15_wpaS_select_bss(struct wpa_supplicant __far * wpa_s,
                                                                struct wpa_ssid __far * group,
                                                                struct wpa_scan_result __far * results,
                                                                int num, struct wpa_ssid __far * __far * selected_ssid) {
	struct wpa_ssid __far * ssid; 	// From "events.c":358
	struct wpa_scan_result __far * bss; 	// From "events.c":359
	struct wpa_scan_result __far * selected /* = ((void  far * )0) */; 	// From "events.c":359
	int i; 	// From "events.c":360
	struct wpa_blacklist __far * e; 	// From "events.c":361

	selected = ((void  __far * )0);

	_WPA_PRINTF((MSG_DEBUG, "Selecting BSS from priority group %d" , group->priority));
	bss = ((void  __far * )0);
	ssid = ((void  __far * )0);
	_WPA_PRINTF((MSG_DEBUG, "Try to find WPA-enabled AP" ));
	for (i = 0; i<num &&
	!selected; i++) {
		bss = &results[i];
		_WPA_PRINTF((MSG_DEBUG, "%d: %02x:%02x:%02x:%02x:%02x:%02x ssid='%ls' wpa_ie_len=%lu rsn_ie_len=%lu caps=0x%x" ,
               i, (bss->bssid)[0], (bss->bssid)[1], (bss->bssid)[2], (bss->bssid)[3],
               (bss->bssid)[4], (bss->bssid)[5], (char  __far * )(wpa_ssid_txt(bss->ssid,
                                                                             bss->ssid_len)),
               (unsigned long  )bss->wpa_ie_len, (unsigned long  )bss->rsn_ie_len,
               bss->caps));
		e = wpa_blacklist_get(wpa_s, bss->bssid);
		if (e &&
		e->count>1) {
			_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "blacklisted" ));
			continue;
		}
		if (bss->wpa_ie_len==0 &&
		bss->rsn_ie_len==0) {
			_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "no WPA/RSN IE" ));
			continue;
		}
		for (ssid = group; ssid; ssid = ssid->pnext) {
			if (ssid->disabled) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "disabled" ));
				continue;
			}
			if (bss->ssid_len!=ssid->ssid_len ||
			memcmp(bss->ssid, ssid->ssid, bss->ssid_len)!=0) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "SSID mismatch" ));
				continue;
			}
			if (ssid->bssid_set &&
			memcmp(bss->bssid, ssid->bssid, 6)!=0) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "BSSID mismatch" ));
				continue;
			}
			if (_wpa_s15_wpaS_ssid_bss_match(ssid, bss)) {
				selected = bss;
				*selected_ssid = ssid;
				_WPA_PRINTF((MSG_DEBUG, "   selected WPA AP %02x:%02x:%02x:%02x:%02x:%02x ssid='%ls'" ,
                 (bss->bssid)[0], (bss->bssid)[1], (bss->bssid)[2], (bss->bssid)[3],
                 (bss->bssid)[4], (bss->bssid)[5], (char  __far * )(wpa_ssid_txt(bss->ssid,
                                                                               bss->ssid_len))));
				break;
			}
		}
	}
	_WPA_PRINTF((MSG_DEBUG, "Try to find non-WPA AP" ));
	for (i = 0; i<num &&
	!selected; i++) {
		bss = &results[i];
		_WPA_PRINTF((MSG_DEBUG, "%d: %02x:%02x:%02x:%02x:%02x:%02x ssid='%ls' wpa_ie_len=%lu rsn_ie_len=%lu caps=0x%x" ,
               i, (bss->bssid)[0], (bss->bssid)[1], (bss->bssid)[2], (bss->bssid)[3],
               (bss->bssid)[4], (bss->bssid)[5], (char  __far * )(wpa_ssid_txt(bss->ssid,
                                                                             bss->ssid_len)),
               (unsigned long  )bss->wpa_ie_len, (unsigned long  )bss->rsn_ie_len,
               bss->caps));
		e = wpa_blacklist_get(wpa_s, bss->bssid);
		if (e &&
		e->count>1) {
			_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "blacklisted" ));
			continue;
		}
		for (ssid = group; ssid; ssid = ssid->pnext) {
			if (ssid->disabled) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "disabled" ));
				continue;
			}
			if (bss->ssid_len!=ssid->ssid_len ||
			memcmp(bss->ssid, ssid->ssid, bss->ssid_len)!=0) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "SSID mismatch" ));
				continue;
			}
			if (ssid->bssid_set &&
			memcmp(bss->bssid, ssid->bssid, 6)!=0) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "BSSID mismatch" ));
				continue;
			}
			if (!(ssid->key_mgmt&WPA_KEY_MGMT_NONE) &&
			!(ssid->key_mgmt&WPA_KEY_MGMT_IEEE8021X_NO_WPA)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "non-WPA network not allowed" ));
				continue;
			}
			if ((ssid->key_mgmt&(WPA_KEY_MGMT_IEEE8021X|WPA_KEY_MGMT_PSK)) ||
			bss->wpa_ie_len!=0 ||
			bss->rsn_ie_len!=0) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "WPA network" ));
				continue;
			}
			if (!_wpa_s15_wpaS_match_privacy(bss, ssid)) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "privacy mismatch" ));
				continue;
			}
			if (bss->caps&IEEE80211_CAP_IBSS) {
				_WPA_PRINTF((MSG_DEBUG, "   skip - %s", "IBSS (adhoc) network" ));
				continue;
			}
			selected = bss;
			*selected_ssid = ssid;
			_WPA_PRINTF((MSG_DEBUG, "   selected non-WPA AP %02x:%02x:%02x:%02x:%02x:%02x ssid='%ls'" ,
                (bss->bssid)[0], (bss->bssid)[1], (bss->bssid)[2], (bss->bssid)[3],
                (bss->bssid)[4], (bss->bssid)[5], (char  __far * )(wpa_ssid_txt(bss->ssid,
                                                                              bss->ssid_len))));
			break;
		}
	}
	return selected;
}

/*** BeginHeader _wpa_s15_wpaS_event_scan_results */
// From "events.c":500
void _wpa_s15_wpaS_event_scan_results(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_scan_results(struct wpa_supplicant __far * wpa_s) {
	int num; 	// From "events.c":502
	int prio; 	// From "events.c":502
	int timeout; 	// From "events.c":502
	struct wpa_scan_result __far * selected /* = ((void  far * )0) */; 	// From "events.c":503
	struct wpa_ssid __far * ssid /* = ((void  far * )0) */; 	// From "events.c":504
	struct wpa_scan_result __far * results; 	// From "events.c":505

	selected = ((void  __far * )0);
	ssid = ((void  __far * )0);

	if (wpaS_get_scan_results(wpa_s)<0) {
		if (wpa_s->conf->ap_scan==2)
			return /*void*/;
		_WPA_PRINTF((MSG_DEBUG, "Failed to get scan results - try " \
		 "scanning again" ));
		timeout = 1;
		goto req_scan;
	}
#ifdef WPA_USE_CTRL_IFACE_DBUS_H
	_wpa_s15_wpaS_dbus_notify_scan_results(wpa_s);
#endif//def WPA_USE_CTRL_IFACE_DBUS_H
	if (wpa_s->conf->ap_scan==2)
		return /*void*/;
	results = wpa_s->scan_results;
	num = wpa_s->num_scan_results;
	while (selected==((void  __far * )0)) {
		for (prio = 0; prio<wpa_s->conf->num_prio; prio++) {
			selected = _wpa_s15_wpaS_select_bss(wpa_s, wpa_s->conf->pssid[prio],
                                                 results, num, &ssid);
			if (selected)
				break;
		}
		if (selected==((void  __far * )0) &&
		wpa_s->blacklist) {
			_WPA_PRINTF((MSG_DEBUG, "No APs found - clear blacklist " \
			 "and try again" ));
			wpa_blacklist_clear(wpa_s);
		}
		else if (selected==((void  __far * )0)) {
			break;
		}
	}
	if (selected) {
		if (wpa_s->reassociate ||
		(memcmp(selected->bssid, wpa_s->bssid, 6)!=0 &&
		(wpa_s->wpa_state!=WPA_ASSOCIATING ||
		memcmp(selected->bssid, wpa_s->pending_bssid, 6)!=0))) {
#ifdef WPA_USE_SCARD_GSIM
			if (wpaS_scard_init(wpa_s, ssid)) {
				wpaS_req_scan(wpa_s, 10, 0);
				return /*void*/;
			}
#endif//def WPA_USE_SCARD_GSIM
			wpaS_associate(wpa_s, selected, ssid);
		}
		else {
			_WPA_PRINTF((MSG_DEBUG, "Already associated with the " \
			 "selected AP." ));
		}
#ifdef WPA_USE_PREAUTH_C
		rsn_preauth_scan_results(wpa_s->wpa, results, num);
#endif//def WPA_USE_PREAUTH_C
	}
	else {
		_WPA_PRINTF((MSG_DEBUG, "No suitable AP found." ));
		timeout = 5;
		goto req_scan;
	}
	return /*void*/;
	req_scan:
	if (wpa_s->scan_res_tried==1 &&
	wpa_s->conf->ap_scan==1) {
		wpa_s->scan_res_tried++;
		timeout = 0;
	}
	wpaS_req_scan(wpa_s, timeout, 0);
}

/*** BeginHeader _wpa_s15_wpaS_event_associnfo */
// From "events.c":582
void _wpa_s15_wpaS_event_associnfo(struct wpa_supplicant __far * wpa_s,
                                             union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_associnfo(struct wpa_supplicant __far * wpa_s,
                                             union wpa_event_data __far * data) {
	int l; 	// From "events.c":585
	int len; 	// From "events.c":585
	int found /* = 0 */; 	// From "events.c":585
	int wpa_found; 	// From "events.c":585
	int rsn_found; 	// From "events.c":585
	char __far * p; 	// From "events.c":586

	found = 0;

	_WPA_PRINTF((MSG_DEBUG, "Association info event" ));
	if (data->assoc_info.req_ies)
		_WPA_HEXDUMP((MSG_DEBUG, "req_ies" , data->assoc_info.req_ies, data->assoc_info.req_ies_len));
	if (data->assoc_info.resp_ies)
		_WPA_HEXDUMP((MSG_DEBUG, "resp_ies" , data->assoc_info.resp_ies, data->assoc_info.resp_ies_len));
	if (data->assoc_info.beacon_ies)
		_WPA_HEXDUMP((MSG_DEBUG, "beacon_ies" , data->assoc_info.beacon_ies, data->assoc_info.beacon_ies_len));
	p = data->assoc_info.req_ies;
	l = data->assoc_info.req_ies_len;
	while (p &&
	l>=2) {
		len = p[1]+2;
		if (len>l) {
			_WPA_HEXDUMP((MSG_DEBUG, "Truncated IE in assoc_info" , p, l));
			break;
		}
		if ((p[0]==GENERIC_INFO_ELEM &&
		p[1]>=6 &&
		(memcmp(&p[2], "\x00\x50\xF2\x01\x01\x00" , 6)==0)) ||
		(p[0]==RSN_INFO_ELEM &&
		p[1]>=2)) {
			if (wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, p, len))
				break;
			found = 1;
#ifdef WPA_USE_PMKSA_CACHE
			_wpa_s15_wpa_find_assoc_pmkid(wpa_s);
#endif//def WPA_USE_PMKSA_CACHE
			break;
		}
		l -= len;
		p += len;
	}
	if (!found &&
	data->assoc_info.req_ies)
		wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, ((void  __far * )0), 0);
	p = data->assoc_info.beacon_ies;
	l = data->assoc_info.beacon_ies_len;
	wpa_found = rsn_found = 0;
	while (p &&
	l>=2) {
		len = p[1]+2;
		if (len>l) {
			_WPA_HEXDUMP((MSG_DEBUG, "Truncated IE in beacon_ies" , p, l));
			break;
		}
		if (!wpa_found &&
		p[0]==GENERIC_INFO_ELEM &&
		p[1]>=6 &&
		memcmp(&p[2], "\x00\x50\xF2\x01\x01\x00" , 6)==0) {
			wpa_found = 1;
			wpa_sm_set_ap_wpa_ie(wpa_s->wpa, p, len);
		}
		if (!rsn_found &&
		p[0]==RSN_INFO_ELEM &&
		p[1]>=2) {
			rsn_found = 1;
			wpa_sm_set_ap_rsn_ie(wpa_s->wpa, p, len);
		}
		l -= len;
		p += len;
	}
	if (!wpa_found &&
	data->assoc_info.beacon_ies)
		wpa_sm_set_ap_wpa_ie(wpa_s->wpa, ((void  __far * )0), 0);
	if (!rsn_found &&
	data->assoc_info.beacon_ies)
		wpa_sm_set_ap_rsn_ie(wpa_s->wpa, ((void  __far * )0), 0);
}

/*** BeginHeader _wpa_s15_wpaS_event_assoc */
// From "events.c":664
void _wpa_s15_wpaS_event_assoc(struct wpa_supplicant __far * wpa_s, union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_assoc(struct wpa_supplicant __far * wpa_s, union wpa_event_data __far * data) {
	char bssid[6]; 	// From "events.c":667


	if (data)
		_wpa_s15_wpaS_event_associnfo(wpa_s, data);
	wpaS_set_state(wpa_s, WPA_ASSOCIATED);
	if (wpa_s->use_client_mlme)
		_f_memcpy(bssid, wpa_s->bssid, 6);
	if (wpa_s->use_client_mlme ||
	((wpa_s->driver->get_bssid ?
	  wpa_s->driver->get_bssid((void  __far * )(wpa_s->drv_priv), (char  __far * )(bssid)) :
	   -1)>=0 &&
	memcmp(bssid, wpa_s->bssid, 6)!=0)) {
		_WPA_MSG((wpa_s, MSG_DEBUG, "Associated to a new BSS: BSSID=" \
		 "%02x:%02x:%02x:%02x:%02x:%02x" , (bssid)[0], (bssid)[1], (bssid)[2], (bssid)[3],
            (bssid)[4], (bssid)[5]));
		_f_memcpy(wpa_s->bssid, bssid, 6);
		_f_memset(wpa_s->pending_bssid, 0, 6);
		if (_wpa_s15_wpaS_dynamic_keys(wpa_s)) {
			wpa_clear_keys(wpa_s, bssid);
		}
		if (_wpa_s15_wpaS_select_config(wpa_s)<0) {
			wpaS_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
			return /*void*/;
		}
	}
	_WPA_MSG((wpa_s, MSG_INFO, "Associated with " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (bssid)[0], (bssid)[1], (bssid)[2], (bssid)[3],
           (bssid)[4], (bssid)[5]));
#ifdef WPA_USE_SCARD_GSIM
	if (wpa_s->current_ssid) {
		wpaS_scard_init(wpa_s, wpa_s->current_ssid);
	}
#endif//def WPA_USE_SCARD_GSIM
	wpa_sm_notify_assoc(wpa_s->wpa, bssid);
	l2_packet_notify_auth_start(wpa_s->l2);
#ifdef WPA_USE_EAP
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_PSK)
		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
	eapol_sm_notify_portEnabled(wpa_s->eapol, TRUE);
#endif//def WPA_USE_EAP
	wpa_s->eapol_received = 0;
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_NONE ||
	wpa_s->key_mgmt==WPA_KEY_MGMT_WPA_NONE) {
		wpaS_cancel_auth_timeout(wpa_s);
		wpaS_set_state(wpa_s, WPA_COMPLETED);
	}
	else {
		wpaS_req_auth_timeout(wpa_s, 10000);
	}
	wpaS_cancel_scan(wpa_s);
}

/*** BeginHeader _wpa_s15_wpaS_event_disassoc */
// From "events.c":730
void _wpa_s15_wpaS_event_disassoc(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_disassoc(struct wpa_supplicant __far * wpa_s) {
	char __far * bssid; 	// From "events.c":732


	if (wpa_s->key_mgmt==WPA_KEY_MGMT_WPA_NONE) {
		_WPA_PRINTF((MSG_DEBUG, "Disconnect event - ignore in " \
		 "IBSS/WPA-None mode" ));
		return /*void*/;
	}
	if (wpa_s->wpa_state==WPA_4WAY_HANDSHAKE &&
	wpa_s->key_mgmt==WPA_KEY_MGMT_PSK) {
		_WPA_MSG((wpa_s, MSG_INFO, "WPA: 4-Way Handshake failed - " \
		 "pre-shared key may be incorrect" ));
	}
	if (wpa_s->wpa_state>=WPA_ASSOCIATED)
		wpaS_req_scan(wpa_s, 0, 100000);
	bssid = wpa_s->bssid;
	if (memcmp(bssid, "\x00\x00\x00\x00\x00\x00" , 6)==0)
		bssid = wpa_s->pending_bssid;
	wpa_blacklist_add(wpa_s, bssid);
	wpa_sm_notify_disassoc(wpa_s->wpa);
	_WPA_MSG((wpa_s, MSG_INFO, "CTRL-EVENT-DISCONNECTED " \
	 "- Disconnect event - " \
	 "remove keys" ));
	if (_wpa_s15_wpaS_dynamic_keys(wpa_s)) {
		wpa_s->keys_cleared = 0;
		wpa_clear_keys(wpa_s, wpa_s->bssid);
	}
	wpaS_mark_disassoc(wpa_s);
}

/*** BeginHeader _wpa_s15_wpaS_event_michael_mic_failure */
// From "events.c":768
void _wpa_s15_wpaS_event_michael_mic_failure(struct wpa_supplicant __far * wpa_s,
                                                       union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_michael_mic_failure(struct wpa_supplicant __far * wpa_s,
                                                       union wpa_event_data __far * data) {
	int pairwise; 	// From "events.c":771
	struct os_time t; 	// From "events.c":772


	_WPA_MSG((wpa_s, MSG_WARNING, "Michael MIC failure detected" ));
	pairwise = (data &&
	data->michael_mic_failure.unicast);
	wpa_sm_key_request(wpa_s->wpa, 1, pairwise);
	os_get_time(&t);
	if (wpa_s->last_michael_mic_error &&
	t.sec-wpa_s->last_michael_mic_error<=60) {
		wpa_s->countermeasures = 1;
		_WPA_MSG((wpa_s, MSG_WARNING, "TKIP countermeasures started" ));
		os_sleep(0, 10000);
		(wpa_s->driver->set_countermeasures ?
		  wpa_s->driver->set_countermeasures((void  __far * )(wpa_s->drv_priv), (int  )(1)) :
		   -1);
		wpaS_deauthenticate(wpa_s, REASON_MICHAEL_MIC_FAILURE);
		eloop_cancel_timeout(_wpa_s15_wpaS_stop_countermeasures, wpa_s, ((void  __far * )0));
		eloop_register_timeout(60000uL, _wpa_s15_wpaS_stop_countermeasures, wpa_s,
                         ((void  __far * )0));
	}
	wpa_s->last_michael_mic_error = t.sec;
}

/*** BeginHeader _wpa_s15_wpaS_event_interface_status */
// From "events.c":806
void _wpa_s15_wpaS_event_interface_status(struct wpa_supplicant __far * wpa_s,
                                                    union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_interface_status(struct wpa_supplicant __far * wpa_s,
                                                    union wpa_event_data __far * data) {
	if (strcmp(wpa_s->ifname, data->interface_status.ifname)!=0)
		return /*void*/;
	switch ((int)(data->interface_status.ievent)) {
		case EVENT_INTERFACE_ADDED:
		if (!wpa_s->interface_removed)
			break;
		wpa_s->interface_removed = 0;
		_WPA_PRINTF((MSG_DEBUG, "Configured interface was added." ));
		if (wpaS_driver_init(wpa_s, 1)<0) {
			_WPA_PRINTF((MSG_INFO, "Failed to initialize the driver " \
			 "after interface was added." ));
		}
		break;
		case EVENT_INTERFACE_REMOVED:
		_WPA_PRINTF((MSG_DEBUG, "Configured interface was removed." ));
		wpa_s->interface_removed = 1;
		wpaS_mark_disassoc(wpa_s);
		l2_packet_deinit(wpa_s->l2);
		wpa_s->l2 = ((void  __far * )0);
		break;
	}
}

/*** BeginHeader _wpa_s15_wpaS_event_stkstart */
// From "events.c":836
void _wpa_s15_wpaS_event_stkstart(struct wpa_supplicant __far * wpa_s, union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s15_wpaS_event_stkstart(struct wpa_supplicant __far * wpa_s, union wpa_event_data __far * data) {
	if (data==((void  __far * )0))
		return /*void*/;
	wpa_sm_stkstart(wpa_s->wpa, data->stkstart.peer);
}

/*** BeginHeader wpaS_event */
// From "events.c":846
void wpaS_event(struct wpa_supplicant __far * wpa_s, wpa_event_type event,
                          union wpa_event_data __far * data);
/*** EndHeader */
_wpa_debug
void wpaS_event(struct wpa_supplicant __far * wpa_s, wpa_event_type event,
                          union wpa_event_data __far * data) {
	switch ((int)(event)) {
		case EVENT_ASSOC:
		_wpa_s15_wpaS_event_assoc(wpa_s, data);
		break;
		case EVENT_DISASSOC:
		_wpa_s15_wpaS_event_disassoc(wpa_s);
		break;
		case EVENT_MICHAEL_MIC_FAILURE:
		_wpa_s15_wpaS_event_michael_mic_failure(wpa_s, data);
		break;
		case EVENT_SCAN_RESULTS:
		_wpa_s15_wpaS_event_scan_results(wpa_s);
		break;
		case EVENT_ASSOCINFO:
		_wpa_s15_wpaS_event_associnfo(wpa_s, data);
		break;
		case EVENT_INTERFACE_STATUS:
		_wpa_s15_wpaS_event_interface_status(wpa_s, data);
		break;
#ifdef WPA_USE_PMKSA_CACHE
		case EVENT_PMKID_CANDIDATE:
		_wpa_s15_wpaS_event_pmkid_candidate(wpa_s, data);
		break;
#endif//def WPA_USE_PMKSA_CACHE
		case EVENT_STKSTART:
		_wpa_s15_wpaS_event_stkstart(wpa_s, data);
		break;
		default:
		_WPA_PRINTF((MSG_INFO, "Unknown event %d" , event));
		break;
	}
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

struct wpa_ptk {
	char kck[16];
	char kek[16];
	char tk1[16];

	union  {
		char tk2[16];

		struct  {
			char tx_mic_key[8];
			char rx_mic_key[8];

		} auth;

	} u;

} ;	// From "wpa_all.c":1479

enum  {
	PEERKEY_MAX_IE_LEN = 80
}  ;	// From "wpa_all.c":1484

struct wpa_peerkey {
	struct wpa_peerkey __far * next;
	int initiator;
	char addr[6];
	char inonce[WPA_NONCE_LEN];
	char pnonce[WPA_NONCE_LEN];
	char rsnie_i[PEERKEY_MAX_IE_LEN];
	size_t rsnie_i_len;
	char rsnie_p[PEERKEY_MAX_IE_LEN];
	size_t rsnie_p_len;
	char smk[PMK_LEN];
	int smk_complete;
	char smkid[PMKID_LEN];
	longword lifetime;
	os_time_t expiration;
	int cipher;
	char replay_counter[8];
	int replay_counter_set;
	struct wpa_ptk stk;
	struct wpa_ptk tstk;
	int stk_set;
	int tstk_set;

} ;	// From "wpa_all.c":1506

struct wpa_sm {
	char pmk[PMK_LEN];
	size_t pmk_len;
	struct wpa_ptk ptk;
	struct wpa_ptk tptk;
	int ptk_set;
	int tptk_set;
	char snonce[WPA_NONCE_LEN];
	char anonce[WPA_NONCE_LEN];
	int renew_snonce;
	char rx_replay_counter[8];
	int rx_replay_counter_set;
	char request_counter[8];
	struct eapol_sm __far * eapol;
	struct rsn_pmksa_cache __far * pmksa;
	struct rsn_pmksa_cache_entry __far * cur_pmksa;
	struct rsn_pmksa_candidate __far * pmksa_candidates;
	struct l2_packet_data __far * l2_preauth;
	struct l2_packet_data __far * l2_preauth_br;
	char preauth_bssid[6];
	struct eapol_sm __far * preauth_eapol;
	struct wpa_sm_ctx __far * ctx;
#ifdef WPA_USE_SCARD_GSIM
	void __far * scard_ctx;
#endif//def WPA_USE_SCARD_GSIM
	int fast_reauth;
	struct wpa_ssid __far * cur_ssid;
	char own_addr[6];
	char __far * ifname;
	char __far * bridge_ifname;
	char bssid[6];
	unsigned int dot11RSNAConfigPMKLifetime;
	unsigned int dot11RSNAConfigPMKReauthThreshold;
	unsigned int dot11RSNAConfigSATimeout;
	unsigned int dot11RSNA4WayHandshakeFailures;
	unsigned int proto;
	unsigned int pairwise_cipher;
	unsigned int group_cipher;
	unsigned int key_mgmt;
	unsigned int mgmt_group_cipher;
	char __far * assoc_wpa_ie;
	size_t assoc_wpa_ie_len;
	char __far * ap_wpa_ie;
	char __far * ap_rsn_ie;
	size_t ap_wpa_ie_len;
	size_t ap_rsn_ie_len;
	struct wpa_peerkey __far * peerkey;

} ;	// From "wpa_all.c":1573
// @ TUName[]  ; -- translator directive

struct rsn_pmksa_cache {
	struct rsn_pmksa_cache_entry __far * pmksa;
	int pmksa_count;
	struct wpa_sm __far * sm;
	void (FUNCPTR free_cb)( /* struct rsn_pmksa_cache_entry far * entry, void far * ctx,
                            int replace */ );
	void __far * ctx;

} ;	// From "pmksa_cache.c":39
/*** EndHeader */

/*** BeginHeader _wpa_s17_rsn_pmkid */
// From "pmksa_cache.c":52
void _wpa_s17_rsn_pmkid(char __far * pmk, size_t pmk_len, char __far * aa, char __far * spa,
                        char __far * pmkid);
/*** EndHeader */
_wpa_debug
void _wpa_s17_rsn_pmkid(char __far * pmk, size_t pmk_len, char __far * aa, char __far * spa,
                        char __far * pmkid) {
	char __far * title /* = "PMK Name"  */; 	// From "pmksa_cache.c":55
	char __far * addr[3]; 	// From "pmksa_cache.c":56
	size_t len[3] /* =
	{
		8,
		6,
		6
	} */; 	// From "pmksa_cache.c":57
	unsigned char hash[SHA1_MAC_LEN]; 	// From "pmksa_cache.c":58

	title = "PMK Name" ;
	// Rabbit note: changed implementation
	/*
	len =
	{
		8,
		6,
		6
	};
	*/
	len[0] = 8;
	len[1] = 6;
	len[2] = 6;

	addr[0] = (char  __far * )title;
	addr[1] = aa;
	addr[2] = spa;
	hmac_sha1_vector(pmk, pmk_len, 3, addr, len, hash);
	_f_memcpy(pmkid, hash, PMKID_LEN);
}
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader _wpa_s17__pmksa_cache_free_entry */
// From "pmksa_cache.c":72
void _wpa_s17__pmksa_cache_free_entry(struct rsn_pmksa_cache_entry __far * entry);
/*** EndHeader */
_wpa_debug
void _wpa_s17__pmksa_cache_free_entry(struct rsn_pmksa_cache_entry __far * entry) {
	_sys_free(entry);
}

/*** BeginHeader _wpa_s17_pmksa_cache_free_entry */
// From "pmksa_cache.c":78
void _wpa_s17_pmksa_cache_free_entry(struct rsn_pmksa_cache __far * pmksa, struct rsn_pmksa_cache_entry __far * entry,
                                     int replace);
/*** EndHeader */
_wpa_debug
void _wpa_s17_pmksa_cache_free_entry(struct rsn_pmksa_cache __far * pmksa, struct rsn_pmksa_cache_entry __far * entry,
                                     int replace) {
	pmksa->pmksa_count--;
	pmksa->free_cb((struct rsn_pmksa_cache_entry  __far * )(entry), (void  __far * )(pmksa->ctx),
                (int  )(replace));
	_wpa_s17__pmksa_cache_free_entry(entry);
}

/*** BeginHeader _wpa_s17_pmksa_cache_expire */
// From "pmksa_cache.c":88
void _wpa_s17_pmksa_cache_expire(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s17_pmksa_cache_expire(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct rsn_pmksa_cache __far * pmksa /* = eloop_ctx */; 	// From "pmksa_cache.c":90
	struct os_time now; 	// From "pmksa_cache.c":91

	union  {

		struct  {
			struct rsn_pmksa_cache_entry __far * entry /* = pmksa->pmksa */;

		} __s1;

	} __u; 	// From "pmksa_cache.c":89

	pmksa = eloop_ctx;

	os_get_time(&now);
	while (pmksa->pmksa &&
	pmksa->pmksa->expiration<=now.sec) {
		__u.__s1.entry = pmksa->pmksa;

		pmksa->pmksa = __u.__s1.entry->next;
		_WPA_PRINTF((MSG_DEBUG, "RSN: expired PMKSA cache entry for " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" , (__u.__s1.entry->aa)[0], (__u.__s1.entry->aa)[1],
               (__u.__s1.entry->aa)[2], (__u.__s1.entry->aa)[3], (__u.__s1.entry->aa)[4],
               (__u.__s1.entry->aa)[5]));
		_wpa_s17_pmksa_cache_free_entry(pmksa, __u.__s1.entry, 0);
	}
	_wpa_s17_pmksa_cache_set_expiration(pmksa);
}

/*** BeginHeader _wpa_s17_pmksa_cache_reauth */
// From "pmksa_cache.c":106
void _wpa_s17_pmksa_cache_reauth(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s17_pmksa_cache_reauth(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct rsn_pmksa_cache __far * pmksa /* = eloop_ctx */; 	// From "pmksa_cache.c":108

	pmksa = eloop_ctx;

	pmksa->sm->cur_pmksa = ((void  __far * )0);
	eapol_sm_request_reauth(pmksa->sm->eapol);
}

/*** BeginHeader _wpa_s17_pmksa_cache_set_expiration */
// From "pmksa_cache.c":114
void _wpa_s17_pmksa_cache_set_expiration(struct rsn_pmksa_cache __far * pmksa);
/*** EndHeader */
_wpa_debug
void _wpa_s17_pmksa_cache_set_expiration(struct rsn_pmksa_cache __far * pmksa) {
	// Rabbit mod  - changed to long from int
	long sec; 	// From "pmksa_cache.c":116
	struct rsn_pmksa_cache_entry __far * entry; 	// From "pmksa_cache.c":117
	struct os_time now; 	// From "pmksa_cache.c":118


	eloop_cancel_timeout(_wpa_s17_pmksa_cache_expire, pmksa, ((void  __far * )0));
	eloop_cancel_timeout(_wpa_s17_pmksa_cache_reauth, pmksa, ((void  __far * )0));
	if (pmksa->pmksa==((void  __far * )0))
		return /*void*/;
	os_get_time(&now);
	sec = pmksa->pmksa->expiration-now.sec;
	if (sec<0)
		sec = 0;
	eloop_register_timeout((sec+1)<<10, _wpa_s17_pmksa_cache_expire, pmksa, ((void  __far * )0));
	entry = pmksa->sm->cur_pmksa ?
	  pmksa->sm->cur_pmksa :
	  pmksa_cache_get(pmksa, pmksa->sm->bssid, ((void  __far * )0));
	if (entry) {
		sec = pmksa->pmksa->reauth_time-now.sec;
		if (sec<0)
			sec = 0;
		eloop_register_timeout(sec<<10, _wpa_s17_pmksa_cache_reauth, pmksa, ((void  __far * )0));
	}
}

/*** BeginHeader pmksa_cache_add */
// From "pmksa_cache.c":158
struct rsn_pmksa_cache_entry __far * pmksa_cache_add(struct rsn_pmksa_cache __far * pmksa,
                                                   char __far * pmk, size_t pmk_len,
                                                   char __far * aa, char __far * spa,
                                                   struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
struct rsn_pmksa_cache_entry __far * pmksa_cache_add(struct rsn_pmksa_cache __far * pmksa,
                                                   char __far * pmk, size_t pmk_len,
                                                   char __far * aa, char __far * spa,
                                                   struct wpa_ssid __far * ssid) {
	struct rsn_pmksa_cache_entry __far * entry; 	// From "pmksa_cache.c":161
	struct rsn_pmksa_cache_entry __far * pos; 	// From "pmksa_cache.c":161
	struct rsn_pmksa_cache_entry __far * prev; 	// From "pmksa_cache.c":161
	struct os_time now; 	// From "pmksa_cache.c":162


	if (pmksa->sm->proto!=WPA_PROTO_RSN ||
	pmk_len>PMK_LEN)
		return ((void  __far * )0);
	entry = _sys_calloc(sizeof (*entry));
	if (entry==((void  __far * )0))
		return ((void  __far * )0);
	_f_memcpy(entry->pmk, pmk, pmk_len);
	entry->pmk_len = pmk_len;
	_wpa_s17_rsn_pmkid(pmk, pmk_len, aa, spa, entry->pmkid);
	os_get_time(&now);
	entry->expiration = now.sec+pmksa->sm->dot11RSNAConfigPMKLifetime;
	entry->reauth_time = now.sec+pmksa->sm->dot11RSNAConfigPMKLifetime*pmksa->sm->dot11RSNAConfigPMKReauthThreshold
                              /100;
	entry->akmp = WPA_KEY_MGMT_IEEE8021X;
	_f_memcpy(entry->aa, aa, 6);
	entry->ssid = ssid;
	pos = pmksa->pmksa;
	prev = ((void  __far * )0);
	while (pos) {
		if (memcmp(aa, pos->aa, 6)==0) {
			if (pos->pmk_len==pmk_len &&
			memcmp(pos->pmk, pmk, pmk_len)==0 &&
			memcmp(pos->pmkid, entry->pmkid, PMKID_LEN)==0) {
				_WPA_PRINTF((MSG_DEBUG, "WPA: reusing previous " \
				 "PMKSA entry" ));
				_sys_free(entry);
				return pos;
			}
			if (prev==((void  __far * )0))
				pmksa->pmksa = pos->next;
			else
				prev->next = pos->next;
			if (pos==pmksa->sm->cur_pmksa) {
				_WPA_PRINTF((MSG_DEBUG, "RSN: replacing current " \
				 "PMKSA entry" ));
				pmksa->sm->cur_pmksa = ((void  __far * )0);
			}
			_WPA_PRINTF((MSG_DEBUG, "RSN: Replace PMKSA entry for " \
			 "the current AP" ));
			_wpa_s17_pmksa_cache_free_entry(pmksa, pos, 1);
			break;
		}
		prev = pos;
		pos = pos->next;
	}
	if (pmksa->pmksa_count>=pmksa_cache_max_entries &&
	pmksa->pmksa) {
		pos = pmksa->pmksa;
		pmksa->pmksa = pos->next;
		_WPA_PRINTF((MSG_DEBUG, "RSN: removed the oldest PMKSA cache " \
		 "entry (for " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 ") to make room for new one" , (pos->aa)[0], (pos->aa)[1], (pos->aa)[2], (pos->aa)[3],
               (pos->aa)[4], (pos->aa)[5]));
   // Rabbit note: not needed
		//pmksa->sm->ctx->remove_pmkid((void  far * )(pmksa->sm->ctx->ctx), (char  far * )(pos->aa),
      //                         (char  far * )(pos->pmkid));
		_wpa_s17_pmksa_cache_free_entry(pmksa, pos, 0);
	}
	pos = pmksa->pmksa;
	prev = ((void  __far * )0);
	while (pos) {
		if (pos->expiration>entry->expiration)
			break;
		prev = pos;
		pos = pos->next;
	}
	if (prev==((void  __far * )0)) {
		entry->next = pmksa->pmksa;
		pmksa->pmksa = entry;
		_wpa_s17_pmksa_cache_set_expiration(pmksa);
	}
	else {
		entry->next = prev->next;
		prev->next = entry;
	}
	pmksa->pmksa_count++;
	_WPA_PRINTF((MSG_DEBUG, "RSN: added PMKSA cache entry for " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (entry->aa)[0], (entry->aa)[1], (entry->aa)[2],
              (entry->aa)[3], (entry->aa)[4], (entry->aa)[5]));
   // Rabbit note: not needed
	//pmksa->sm->ctx->add_pmkid((void  far * )(pmksa->sm->ctx->ctx), (char  far * )(entry->aa),
   //                        (char  far * )(entry->pmkid));
	return entry;
}

/*** BeginHeader pmksa_cache_deinit */
// From "pmksa_cache.c":263
void pmksa_cache_deinit(struct rsn_pmksa_cache __far * pmksa);
/*** EndHeader */
_wpa_debug
void pmksa_cache_deinit(struct rsn_pmksa_cache __far * pmksa) {
	struct rsn_pmksa_cache_entry __far * entry; 	// From "pmksa_cache.c":265
	struct rsn_pmksa_cache_entry __far * prev; 	// From "pmksa_cache.c":265


	if (pmksa==((void  __far * )0))
		return /*void*/;
	entry = pmksa->pmksa;
	pmksa->pmksa = ((void  __far * )0);
	while (entry) {
		prev = entry;
		entry = entry->next;
		_sys_free(prev);
	}
	_wpa_s17_pmksa_cache_set_expiration(pmksa);
	_sys_free(pmksa);
}

/*** BeginHeader pmksa_cache_get */
// From "pmksa_cache.c":289
struct rsn_pmksa_cache_entry __far * pmksa_cache_get(struct rsn_pmksa_cache __far * pmksa,
                                                   char __far * aa, char __far * pmkid);
/*** EndHeader */
_wpa_debug
struct rsn_pmksa_cache_entry __far * pmksa_cache_get(struct rsn_pmksa_cache __far * pmksa,
                                                   char __far * aa, char __far * pmkid) {
	struct rsn_pmksa_cache_entry __far * entry /* = pmksa->pmksa */; 	// From "pmksa_cache.c":292

	entry = pmksa->pmksa;

	while (entry) {
		if ((aa==((void  __far * )0) ||
		memcmp(entry->aa, aa, 6)==0) &&
		(pmkid==((void  __far * )0) ||
		memcmp(entry->pmkid, pmkid, PMKID_LEN)==0))
			return entry;
		entry = entry->next;
	}
	return ((void  __far * )0);
}

/*** BeginHeader pmksa_cache_notify_reconfig */
// From "pmksa_cache.c":310
void pmksa_cache_notify_reconfig(struct rsn_pmksa_cache __far * pmksa);
/*** EndHeader */
_wpa_debug
void pmksa_cache_notify_reconfig(struct rsn_pmksa_cache __far * pmksa) {
	struct rsn_pmksa_cache_entry __far * entry /* = pmksa->pmksa */; 	// From "pmksa_cache.c":312

	entry = pmksa->pmksa;

	while (entry) {
		entry->ssid = ((void  __far * )0);
		entry = entry->next;
	}
}

/*** BeginHeader _wpa_s17_pmksa_cache_clone_entry */
// From "pmksa_cache.c":321
struct rsn_pmksa_cache_entry __far * _wpa_s17_pmksa_cache_clone_entry(struct rsn_pmksa_cache __far * pmksa,
                                                                    struct rsn_pmksa_cache_entry __far * old_entry,
                                                                    char __far * aa);
/*** EndHeader */
_wpa_debug
struct rsn_pmksa_cache_entry __far * _wpa_s17_pmksa_cache_clone_entry(struct rsn_pmksa_cache __far * pmksa,
                                                                    struct rsn_pmksa_cache_entry __far * old_entry,
                                                                    char __far * aa) {
	struct rsn_pmksa_cache_entry __far * new_entry; 	// From "pmksa_cache.c":325


	new_entry = pmksa_cache_add(pmksa, old_entry->pmk, old_entry->pmk_len, aa, pmksa->sm->own_addr,
                             old_entry->ssid);
	if (new_entry==((void  __far * )0))
		return ((void  __far * )0);
	new_entry->expiration = old_entry->expiration;
	new_entry->opportunistic = 1;
	return new_entry;
}

/*** BeginHeader pmksa_cache_get_opportunistic */
// From "pmksa_cache.c":352
struct rsn_pmksa_cache_entry __far * pmksa_cache_get_opportunistic(struct rsn_pmksa_cache __far * pmksa,
                                                                 struct wpa_ssid __far * ssid,
                                                                 char __far * aa);
/*** EndHeader */
_wpa_debug
struct rsn_pmksa_cache_entry __far * pmksa_cache_get_opportunistic(struct rsn_pmksa_cache __far * pmksa,
                                                                 struct wpa_ssid __far * ssid,
                                                                 char __far * aa) {
	struct rsn_pmksa_cache_entry __far * entry /* = pmksa->pmksa */; 	// From "pmksa_cache.c":355

	entry = pmksa->pmksa;

	if (ssid==((void  __far * )0))
		return ((void  __far * )0);
	while (entry) {
		if (entry->ssid==ssid) {
			entry = _wpa_s17_pmksa_cache_clone_entry(pmksa, entry, aa);
			if (entry) {
				_WPA_PRINTF((MSG_DEBUG, "RSN: added " \
				 "opportunistic PMKSA cache entry " \
				 "for " \
				 "%02x:%02x:%02x:%02x:%02x:%02x" , (aa)[0], (aa)[1], (aa)[2], (aa)[3], (aa)[4],
                 (aa)[5]));
			}
			return entry;
		}
		entry = entry->next;
	}
	return ((void  __far * )0);
}

/*** BeginHeader pmksa_cache_get_current */
// From "pmksa_cache.c":380
struct rsn_pmksa_cache_entry __far * pmksa_cache_get_current(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
struct rsn_pmksa_cache_entry __far * pmksa_cache_get_current(struct wpa_sm __far * sm) {
	if (sm==((void  __far * )0))
		return ((void  __far * )0);
	return sm->cur_pmksa;
}

/*** BeginHeader pmksa_cache_clear_current */
// From "pmksa_cache.c":392
void pmksa_cache_clear_current(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void pmksa_cache_clear_current(struct wpa_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
	sm->cur_pmksa = ((void  __far * )0);
}

/*** BeginHeader pmksa_cache_set_current */
// From "pmksa_cache.c":409
int pmksa_cache_set_current(struct wpa_sm __far * sm, char __far * pmkid, char __far * bssid,
                            struct wpa_ssid __far * ssid, int try_opportunistic);
/*** EndHeader */
_wpa_debug
int pmksa_cache_set_current(struct wpa_sm __far * sm, char __far * pmkid, char __far * bssid,
                            struct wpa_ssid __far * ssid, int try_opportunistic) {
	struct rsn_pmksa_cache __far * pmksa /* = sm->pmksa */; 	// From "pmksa_cache.c":413

	pmksa = sm->pmksa;

	sm->cur_pmksa = ((void  __far * )0);
	if (pmkid)
		sm->cur_pmksa = pmksa_cache_get(pmksa, ((void  __far * )0), pmkid);
	if (sm->cur_pmksa==((void  __far * )0) &&
	bssid)
		sm->cur_pmksa = pmksa_cache_get(pmksa, bssid, ((void  __far * )0));
	if (sm->cur_pmksa==((void  __far * )0) &&
	try_opportunistic &&
	bssid)
		sm->cur_pmksa = pmksa_cache_get_opportunistic(pmksa, ssid, bssid);
	if (sm->cur_pmksa) {
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: PMKID" , sm->cur_pmksa->pmkid, PMKID_LEN));
		return 0;
	}
	return  -1;
}

/*** BeginHeader pmksa_cache_list */
// From "pmksa_cache.c":441
int pmksa_cache_list(struct wpa_sm __far * sm, char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
int pmksa_cache_list(struct wpa_sm __far * sm, char __far * buf, size_t len) {
	int i; 	// From "pmksa_cache.c":443
	int ret; 	// From "pmksa_cache.c":443
	char __far * pos /* = buf */; 	// From "pmksa_cache.c":444
	struct rsn_pmksa_cache_entry __far * entry; 	// From "pmksa_cache.c":445
	struct os_time now; 	// From "pmksa_cache.c":446

	pos = buf;

	os_get_time(&now);
	ret = snprintf(pos, (_x509_ptrdiff_t)(buf+len-pos), "Index / AA / PMKID / expiration (in seconds) / " \
	 "opportunistic\n" );
	if (ret<0 ||
	ret>=(_x509_ptrdiff_t)(buf+len-pos))
		return (_x509_ptrdiff_t)(pos-buf);
	pos += ret;
	i = 0;
	entry = sm->pmksa->pmksa;
	while (entry) {
		i++;
		ret = snprintf(pos, (_x509_ptrdiff_t)(buf+len-pos), "%d " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 " " , i, (entry->aa)[0], (entry->aa)[1], (entry->aa)[2], (entry->aa)[3], (entry->aa)[4],
                 (entry->aa)[5]);
		if (ret<0 ||
		ret>=(_x509_ptrdiff_t)(buf+len-pos))
			return (_x509_ptrdiff_t)(pos-buf);
		pos += ret;
		pos += wpa_snprintf_hex(pos, (_x509_ptrdiff_t)(buf+len-pos), entry->pmkid, PMKID_LEN);
		ret = snprintf(pos, (_x509_ptrdiff_t)(buf+len-pos), " %d %d\n" , (int  )(entry->expiration
                                                                           -now.sec),
                 entry->opportunistic);
		if (ret<0 ||
		ret>=(_x509_ptrdiff_t)(buf+len-pos))
			return (_x509_ptrdiff_t)(pos-buf);
		pos += ret;
		entry = entry->next;
	}
	return (_x509_ptrdiff_t)(pos-buf);
}

/*** BeginHeader pmksa_cache_init */
// From "pmksa_cache.c":486
struct rsn_pmksa_cache __far * pmksa_cache_init(void (FUNCPTR free_cb)( /* struct rsn_pmksa_cache_entry far * entry,
                                                                         void far * ctx,
                                                                         int replace */ ),
                                              void __far * ctx, struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
struct rsn_pmksa_cache __far * pmksa_cache_init(void (FUNCPTR free_cb)( /* struct rsn_pmksa_cache_entry far * entry,
                                                                         void far * ctx,
                                                                         int replace */ ),
                                              void __far * ctx, struct wpa_sm __far * sm) {
	struct rsn_pmksa_cache __far * pmksa; 	// From "pmksa_cache.c":490


	pmksa = _sys_calloc(sizeof (*pmksa));
	if (pmksa) {
		pmksa->free_cb = free_cb;
		pmksa->ctx = ctx;
		pmksa->sm = sm;
	}
	return pmksa;
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

enum  {
	PMKID_CANDIDATE_PRIO_SCAN = 1000
}  ;	// From "preauth.c":29

struct rsn_pmksa_candidate {
	struct rsn_pmksa_candidate __far * next;
	char bssid[6];
	int priority;

} ;	// From "preauth.c":36
/*** EndHeader */

/*** BeginHeader pmksa_candidate_free */
// From "preauth.c":43
void pmksa_candidate_free(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void pmksa_candidate_free(struct wpa_sm __far * sm) {
	struct rsn_pmksa_candidate __far * entry; 	// From "preauth.c":45
	struct rsn_pmksa_candidate __far * prev; 	// From "preauth.c":45


	if (sm==((void  __far * )0))
		return /*void*/;
	entry = sm->pmksa_candidates;
	sm->pmksa_candidates = ((void  __far * )0);
	while (entry) {
		prev = entry;
		entry = entry->next;
		_sys_free(prev);
	}
}

/*** BeginHeader _wpa_s18_rsn_preauth_receive */
// From "preauth.c":62
void _wpa_s18_rsn_preauth_receive(void __far * ctx, char __far * src_addr, char __far * buf,
                                  size_t len);
/*** EndHeader */
_wpa_debug
void _wpa_s18_rsn_preauth_receive(void __far * ctx, char __far * src_addr, char __far * buf,
                                  size_t len) {
	struct wpa_sm __far * sm /* = ctx */; 	// From "preauth.c":65

	sm = ctx;

	_WPA_PRINTF((MSG_DEBUG, "RX pre-auth from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (src_addr)[0], (src_addr)[1], (src_addr)[2],
              (src_addr)[3], (src_addr)[4], (src_addr)[5]));
	_WPA_HEXDUMP((MSG_MSGDUMP, "RX pre-auth" , buf, len));
	if (sm->preauth_eapol==((void  __far * )0) ||
	memcmp(sm->preauth_bssid, "\x00\x00\x00\x00\x00\x00" , 6)==0 ||
	memcmp(sm->preauth_bssid, src_addr, 6)!=0) {
		_WPA_PRINTF((MSG_WARNING, "RSN pre-auth frame received from " \
		 "unexpected source " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 " - dropped" , (src_addr)[0], (src_addr)[1], (src_addr)[2], (src_addr)[3], (src_addr)[4],
               (src_addr)[5]));
		return /*void*/;
	}
	eapol_sm_rx_eapol(sm->preauth_eapol, src_addr, buf, len);
}

/*** BeginHeader _wpa_s18_rsn_preauth_eapol_cb */
// From "preauth.c":84
void _wpa_s18_rsn_preauth_eapol_cb(struct eapol_sm __far * eapol, int success, void __far * ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s18_rsn_preauth_eapol_cb(struct eapol_sm __far * eapol, int success, void __far * ctx) {
	struct wpa_sm __far * sm /* = ctx */; 	// From "preauth.c":87
	char pmk[PMK_LEN]; 	// From "preauth.c":88

	union  {

		struct  {
			int res;
			int pmk_len;

		} __s1;

	} __u; 	// From "preauth.c":86

	sm = ctx;

	if (success) {
		__u.__s1.pmk_len = PMK_LEN;
		__u.__s1.res = eapol_sm_get_key(eapol, pmk, PMK_LEN);
		if (__u.__s1.res) {
			__u.__s1.res = eapol_sm_get_key(eapol, pmk, 16);
			__u.__s1.pmk_len = 16;
		}
		if (__u.__s1.res==0) {
			_WPA_HEXDUMP((MSG_DEBUG, "RSN: PMK from pre-auth" , pmk, __u.__s1.pmk_len));
			sm->pmk_len = __u.__s1.pmk_len;
			pmksa_cache_add(sm->pmksa, pmk, __u.__s1.pmk_len, sm->preauth_bssid, sm->own_addr,
                   sm->cur_ssid);
		}
		else {
			_WPA_MSG((sm->ctx->ctx, MSG_INFO, "RSN: failed to get " \
			 "master session key from pre-auth EAPOL state " \
			 "machines" ));
			success = 0;
		}
	}
	_WPA_MSG((sm->ctx->ctx, MSG_INFO, "RSN: pre-authentication with %02x:%02x:%02x:%02x:%02x:%02x %ls" ,
           (sm->preauth_bssid)[0], (sm->preauth_bssid)[1], (sm->preauth_bssid)[2],
           (sm->preauth_bssid)[3], (sm->preauth_bssid)[4], (sm->preauth_bssid)[5],
           (char  __far * )(success ?
	  "completed successfully"  :
	  "failed" )));
	rsn_preauth_deinit(sm);
	rsn_preauth_candidate_process(sm);
}

/*** BeginHeader _wpa_s18_rsn_preauth_timeout */
// From "preauth.c":126
void _wpa_s18_rsn_preauth_timeout(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s18_rsn_preauth_timeout(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct wpa_sm __far * sm /* = eloop_ctx */; 	// From "preauth.c":128

	sm = eloop_ctx;

	_WPA_MSG((sm->ctx->ctx, MSG_INFO, "RSN: pre-authentication with " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " timed out" , (sm->preauth_bssid)[0], (sm->preauth_bssid)[1], (sm->preauth_bssid)[2],
           (sm->preauth_bssid)[3], (sm->preauth_bssid)[4], (sm->preauth_bssid)[5]));
	rsn_preauth_deinit(sm);
	rsn_preauth_candidate_process(sm);
}

/*** BeginHeader _wpa_s18_rsn_preauth_eapol_send */
// From "preauth.c":137
int _wpa_s18_rsn_preauth_eapol_send(void __far * ctx, int type, char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
int _wpa_s18_rsn_preauth_eapol_send(void __far * ctx, int type, char __far * buf, size_t len) {
	struct wpa_sm __far * sm /* = ctx */; 	// From "preauth.c":140
	char __far * msg; 	// From "preauth.c":141
	size_t msglen; 	// From "preauth.c":142
	int res; 	// From "preauth.c":143

	sm = ctx;

	if (sm->l2_preauth==((void  __far * )0))
		return  -1;
	msg = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(type), (void  __far * )(buf),
                            (word  )(len), (size_t  __far * )(&msglen), (void  __far * __far * )(((void  __far * )0)));
	if (msg==((void  __far * )0))
		return  -1;
	_WPA_HEXDUMP((MSG_MSGDUMP, "TX EAPOL (preauth)" , msg, msglen));
	res = l2_packet_send(sm->l2_preauth, sm->preauth_bssid, ETH_P_RSN_PREAUTH, msg,
                      msglen);
	_sys_free(msg);
	return res;
}

/*** BeginHeader rsn_preauth_init */
// From "preauth.c":177
int rsn_preauth_init(struct wpa_sm __far * sm, char __far * dst, struct wpa_ssid __far * config);
/*** EndHeader */
_wpa_debug
int rsn_preauth_init(struct wpa_sm __far * sm, char __far * dst, struct wpa_ssid __far * config) {
	struct eapol_config eapol_conf; 	// From "preauth.c":179
	struct eapol_ctx __far * ctx; 	// From "preauth.c":180


	if (sm->preauth_eapol)
		return  -1;
	_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: starting pre-authentication " \
	 "with " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (dst)[0], (dst)[1], (dst)[2], (dst)[3], (dst)[4],
           (dst)[5]));
	sm->l2_preauth = l2_packet_init(sm->ifname, sm->own_addr, ETH_P_RSN_PREAUTH, _wpa_s18_rsn_preauth_receive,
                                 sm, 0);
	if (sm->l2_preauth==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "RSN: Failed to initialize L2 packet " \
		 "processing for pre-authentication" ));
		return  -2;
	}
	if (sm->bridge_ifname) {
		sm->l2_preauth_br = l2_packet_init(sm->bridge_ifname, sm->own_addr, ETH_P_RSN_PREAUTH,
                                     _wpa_s18_rsn_preauth_receive, sm, 0);
		if (sm->l2_preauth_br==((void  __far * )0)) {
			_WPA_PRINTF((MSG_WARNING, "RSN: Failed to initialize L2 " \
			 "packet processing (bridge) for " \
			 "pre-authentication" ));
			return  -2;
		}
	}
	ctx = _sys_calloc(sizeof (*ctx));
	if (ctx==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "Failed to allocate EAPOL context." ));
		return  -4;
	}
	ctx->ctx = sm->ctx->ctx;
	ctx->msg_ctx = sm->ctx->ctx;
	ctx->preauth = 1;
	ctx->cb = _wpa_s18_rsn_preauth_eapol_cb;
	ctx->cb_ctx = sm;
#ifdef WPA_USE_SCARD_GSIM
	ctx->scard_ctx = sm->scard_ctx;
#endif//def WPA_USE_SCARD_GSIM
	ctx->eapol_send = _wpa_s18_rsn_preauth_eapol_send;
	ctx->eapol_send_ctx = sm;
	ctx->set_config_blob = sm->ctx->set_config_blob;
	ctx->get_config_blob = sm->ctx->get_config_blob;
	sm->preauth_eapol = eapol_sm_init(ctx);
	if (sm->preauth_eapol==((void  __far * )0)) {
		_sys_free(ctx);
		_WPA_PRINTF((MSG_WARNING, "RSN: Failed to initialize EAPOL " \
		 "state machines for pre-authentication" ));
		return  -3;
	}
	_f_memset(&eapol_conf, 0, sizeof (eapol_conf));
	eapol_conf.accept_802_1x_keys = 0;
	eapol_conf.required_keys = 0;
	eapol_conf.fast_reauth = sm->fast_reauth;
	if (config)
		eapol_conf.workaround = config->eap_workaround;
	eapol_sm_notify_config(sm->preauth_eapol, config, &eapol_conf);
	eapol_sm_configure(sm->preauth_eapol,  -1,  -1, 5, 6);
	_f_memcpy(sm->preauth_bssid, dst, 6);
#ifdef WPA_USE_EAP
	eapol_sm_notify_portValid(sm->preauth_eapol, TRUE);
	eapol_sm_notify_portEnabled(sm->preauth_eapol, TRUE);
#endif//def WPA_USE_EAP
	eloop_register_timeout((uint32)sm->dot11RSNAConfigSATimeout<<10, _wpa_s18_rsn_preauth_timeout,
                        sm, ((void  __far * )0));
	return 0;
}

/*** BeginHeader rsn_preauth_deinit */
// From "preauth.c":267
void rsn_preauth_deinit(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void rsn_preauth_deinit(struct wpa_sm __far * sm) {
	if (sm==((void  __far * )0) ||
	!sm->preauth_eapol)
		return /*void*/;
	eloop_cancel_timeout(_wpa_s18_rsn_preauth_timeout, sm, ((void  __far * )0));
#ifdef WPA_USE_EAP
	eapol_sm_deinit(sm->preauth_eapol);
#endif//def WPA_USE_EAP
	sm->preauth_eapol = ((void  __far * )0);
	_f_memset(sm->preauth_bssid, 0, 6);
	l2_packet_deinit(sm->l2_preauth);
	sm->l2_preauth = ((void  __far * )0);
	if (sm->l2_preauth_br) {
		l2_packet_deinit(sm->l2_preauth_br);
		sm->l2_preauth_br = ((void  __far * )0);
	}
}

/*** BeginHeader rsn_preauth_candidate_process */
// From "preauth.c":294
void rsn_preauth_candidate_process(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void rsn_preauth_candidate_process(struct wpa_sm __far * sm) {
	struct rsn_pmksa_candidate __far * candidate; 	// From "preauth.c":296

	union  {

		struct  {
			struct rsn_pmksa_cache_entry __far * p /* = ((void  far * )0) */;

		} __s2;

	} __u; 	// From "preauth.c":295


	if (sm->pmksa_candidates==((void  __far * )0))
		return /*void*/;
	_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: processing PMKSA candidate " \
	 "list" ));
	if (sm->preauth_eapol ||
	sm->proto!=WPA_PROTO_RSN ||
	sm->ctx->get_state((void  __far * )(sm->ctx->ctx))!=WPA_COMPLETED ||
	sm->key_mgmt!=WPA_KEY_MGMT_IEEE8021X) {
		_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: not in suitable state " \
		 "for new pre-authentication" ));
		return /*void*/;
	}
	while (sm->pmksa_candidates) {
		__u.__s2.p = ((void  __far * )0);

		candidate = sm->pmksa_candidates;
		__u.__s2.p = pmksa_cache_get(sm->pmksa, candidate->bssid, ((void  __far * )0));
		if (memcmp(sm->bssid, candidate->bssid, 6)!=0 &&
		(__u.__s2.p==((void  __far * )0) ||
		__u.__s2.p->opportunistic)) {
			_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: PMKSA " \
			 "candidate " \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 " selected for pre-authentication" , (candidate->bssid)[0], (candidate->bssid)[1],
             (candidate->bssid)[2], (candidate->bssid)[3], (candidate->bssid)[4],
             (candidate->bssid)[5]));
			sm->pmksa_candidates = candidate->next;
			rsn_preauth_init(sm, candidate->bssid, sm->cur_ssid);
			_sys_free(candidate);
			return /*void*/;
		}
		_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: PMKSA candidate " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 " does not need pre-authentication anymore" , (candidate->bssid)[0], (candidate->bssid)[1],
            (candidate->bssid)[2], (candidate->bssid)[3], (candidate->bssid)[4],
            (candidate->bssid)[5]));
   // Rabbit note: not needed
		//if (__u.__s2.p) {
		//	sm->ctx->add_pmkid((void  far * )(sm->ctx->ctx), (char  far * )(candidate->bssid),
      //                (char  far * )(__u.__s2.p->pmkid));
		//}
		sm->pmksa_candidates = candidate->next;
		_sys_free(candidate);
	}
	_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: no more pending PMKSA " \
	 "candidates" ));
}

/*** BeginHeader pmksa_candidate_add */
// From "preauth.c":357
void pmksa_candidate_add(struct wpa_sm __far * sm, char __far * bssid, int prio, int preauth);
/*** EndHeader */
_wpa_debug
void pmksa_candidate_add(struct wpa_sm __far * sm, char __far * bssid, int prio, int preauth) {
	struct rsn_pmksa_candidate __far * cand; 	// From "preauth.c":360
	struct rsn_pmksa_candidate __far * prev; 	// From "preauth.c":360
	struct rsn_pmksa_candidate __far * pos; 	// From "preauth.c":360


	if (sm->cur_ssid &&
	sm->cur_ssid->proactive_key_caching)
		pmksa_cache_get_opportunistic(sm->pmksa, sm->cur_ssid, bssid);
	if (!preauth) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Ignored PMKID candidate without " \
		 "preauth flag" ));
		return /*void*/;
	}
	prev = ((void  __far * )0);
	cand = sm->pmksa_candidates;
	while (cand) {
		if (memcmp(cand->bssid, bssid, 6)==0) {
			if (prev)
				prev->next = cand->next;
			else
				sm->pmksa_candidates = cand->next;
			break;
		}
		prev = cand;
		cand = cand->next;
	}
	if (cand) {
		if (prio<PMKID_CANDIDATE_PRIO_SCAN)
			cand->priority = prio;
	}
	else {
		cand = _sys_calloc(sizeof (*cand));
		if (cand==((void  __far * )0))
			return /*void*/;
		_f_memcpy(cand->bssid, bssid, 6);
		cand->priority = prio;
	}
	prev = ((void  __far * )0);
	pos = sm->pmksa_candidates;
	while (pos) {
		if (cand->priority<=pos->priority)
			break;
		prev = pos;
		pos = pos->next;
	}
	cand->next = pos;
	if (prev)
		prev->next = cand;
	else
		sm->pmksa_candidates = cand;
	_WPA_MSG((sm->ctx->ctx, MSG_DEBUG, "RSN: added PMKSA cache " \
	 "candidate " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " prio %d" , (bssid)[0], (bssid)[1], (bssid)[2], (bssid)[3], (bssid)[4], (bssid)[5],
           prio));
	rsn_preauth_candidate_process(sm);
}

/*** BeginHeader rsn_preauth_scan_results */
// From "preauth.c":431
void rsn_preauth_scan_results(struct wpa_sm __far * sm, struct wpa_scan_result __far * results,
                              int count);
/*** EndHeader */
_wpa_debug
void rsn_preauth_scan_results(struct wpa_sm __far * sm, struct wpa_scan_result __far * results,
                              int count) {
	struct wpa_scan_result __far * r; 	// From "preauth.c":434
	struct wpa_ie_data ie; 	// From "preauth.c":435
	int i; 	// From "preauth.c":436
	struct rsn_pmksa_cache_entry __far * pmksa; 	// From "preauth.c":437


	if (sm->cur_ssid==((void  __far * )0))
		return /*void*/;
	pmksa_candidate_free(sm);
	for (i = count-1; i>=0; i--) {
		r = &results[i];
		if (r->ssid_len!=sm->cur_ssid->ssid_len ||
		memcmp(r->ssid, sm->cur_ssid->ssid, r->ssid_len)!=0)
			continue;
		if (memcmp(r->bssid, sm->bssid, 6)==0)
			continue;
		if (r->rsn_ie_len==0 ||
		wpa_parse_wpa_ie(r->rsn_ie, r->rsn_ie_len, &ie))
			continue;
		pmksa = pmksa_cache_get(sm->pmksa, r->bssid, ((void  __far * )0));
		if (pmksa &&
		(!pmksa->opportunistic ||
		!(ie.capabilities&WPA_CAPABILITY_PREAUTH)))
			continue;
		pmksa_candidate_add(sm, r->bssid, PMKID_CANDIDATE_PRIO_SCAN, ie.capabilities&WPA_CAPABILITY_PREAUTH);
	}
}

/*** BeginHeader rsn_preauth_in_progress */
// From "preauth.c":519
int rsn_preauth_in_progress(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
int rsn_preauth_in_progress(struct wpa_sm __far * sm) {
	return sm->preauth_eapol!=((void  __far * )0);
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */
int const WPA_SELECTOR_LEN = 4; 	// From "wpa.c":32
char const WPA_OUI_TYPE[] =
{
	0x00,
	0x50,
	0xf2,
	1
}; 	// From "wpa.c":33
word const WPA_VERSION = 1; 	// From "wpa.c":34
char const WPA_AUTH_KEY_MGMT_NONE[] =
{
	0x00,
	0x50,
	0xf2,
	0
}; 	// From "wpa.c":35
char const WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[] =
{
	0x00,
	0x50,
	0xf2,
	1
}; 	// From "wpa.c":36
char const WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[] =
{
	0x00,
	0x50,
	0xf2,
	2
}; 	// From "wpa.c":37
char const WPA_CIPHER_SUITE_NONE[] =
{
	0x00,
	0x50,
	0xf2,
	0
}; 	// From "wpa.c":38
char const WPA_CIPHER_SUITE_WEP40[] =
{
	0x00,
	0x50,
	0xf2,
	1
}; 	// From "wpa.c":39
char const WPA_CIPHER_SUITE_TKIP[] =
{
	0x00,
	0x50,
	0xf2,
	2
}; 	// From "wpa.c":40
char const WPA_CIPHER_SUITE_CCMP[] =
{
	0x00,
	0x50,
	0xf2,
	4
}; 	// From "wpa.c":44
char const WPA_CIPHER_SUITE_WEP104[] =
{
	0x00,
	0x50,
	0xf2,
	5
}; 	// From "wpa.c":45

struct wpa_ie_hdr {
	char elem_id;
	char len;
	char oui[3];
	char oui_type;
	char version[2];

} ;	// From "wpa.c":71
int const RSN_SELECTOR_LEN = 4; 	// From "wpa.c":78
word const RSN_VERSION = 1; 	// From "wpa.c":79
char const RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[] =
{
	0x00,
	0x0f,
	0xac,
	1
}; 	// From "wpa.c":80
char const RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[] =
{
	0x00,
	0x0f,
	0xac,
	2
}; 	// From "wpa.c":81
char const RSN_CIPHER_SUITE_NONE[] =
{
	0x00,
	0x0f,
	0xac,
	0
}; 	// From "wpa.c":82
char const RSN_CIPHER_SUITE_WEP40[] =
{
	0x00,
	0x0f,
	0xac,
	1
}; 	// From "wpa.c":83
char const RSN_CIPHER_SUITE_TKIP[] =
{
	0x00,
	0x0f,
	0xac,
	2
}; 	// From "wpa.c":84
char const RSN_CIPHER_SUITE_CCMP[] =
{
	0x00,
	0x0f,
	0xac,
	4
}; 	// From "wpa.c":88
char const RSN_CIPHER_SUITE_WEP104[] =
{
	0x00,
	0x0f,
	0xac,
	5
}; 	// From "wpa.c":89
char const RSN_KEY_DATA_GROUPKEY[] =
{
	0x00,
	0x0f,
	0xac,
	1
}; 	// From "wpa.c":97
char const RSN_KEY_DATA_MAC_ADDR[] =
{
	0x00,
	0x0f,
	0xac,
	3
}; 	// From "wpa.c":101
char const RSN_KEY_DATA_PMKID[] =
{
	0x00,
	0x0f,
	0xac,
	4
}; 	// From "wpa.c":102
char const RSN_KEY_DATA_SMK[] =
{
	0x00,
	0x0f,
	0xac,
	5
}; 	// From "wpa.c":104
char const RSN_KEY_DATA_NONCE[] =
{
	0x00,
	0x0f,
	0xac,
	6
}; 	// From "wpa.c":105
char const RSN_KEY_DATA_LIFETIME[] =
{
	0x00,
	0x0f,
	0xac,
	7
}; 	// From "wpa.c":106
char const RSN_KEY_DATA_ERROR[] =
{
	0x00,
	0x0f,
	0xac,
	8
}; 	// From "wpa.c":107

enum  {
	STK_MUI_4WAY_STA_AP = 1,
	STK_MUI_4WAY_STAT_STA = 2,
	STK_MUI_GTK = 3,
	STK_MUI_SMK = 4
}  ;	// From "wpa.c":123

enum  {
	STK_ERR_STA_NR = 1,
	STK_ERR_STA_NRSN = 2,
	STK_ERR_CPHR_NS = 3,
	STK_ERR_NO_STSL = 4
}  ;	// From "wpa.c":130

struct rsn_ie_hdr {
	char elem_id;
	char len;
	char version[2];

} ;	// From "wpa.c":165

struct wpa_eapol_key {
	char type;
	char key_info[2];
	char key_length[2];
	char replay_counter[8];
	char key_nonce[WPA_NONCE_LEN];
	char key_iv[16];
	char key_rsc[8];
	char key_id[8];
	char key_mic[16];
	char key_data_length[2];

} ;	// From "wpa.c":181

struct rsn_error_kde {
	word mui;
	word error_type;

} ;	// From "wpa.c":187

enum  {
	WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 = (1<<(0))
}  ;	// From "wpa.c":206

enum  {
	WPA_KEY_INFO_TYPE_HMAC_SHA1_AES = (1<<(1))
}  ;	// From "wpa.c":207

enum  {
	WPA_KEY_INFO_KEY_TYPE = (1<<(3))
}  ;	// From "wpa.c":208

enum  {
	WPA_KEY_INFO_KEY_INDEX_MASK = ((1<<(4))|(1<<(5)))
}  ;	// From "wpa.c":210

enum  {
	WPA_KEY_INFO_INSTALL = (1<<(6))
}  ;	// From "wpa.c":212

enum  {
	WPA_KEY_INFO_TXRX = (1<<(6))
}  ;	// From "wpa.c":213

enum  {
	WPA_KEY_INFO_ACK = (1<<(7))
}  ;	// From "wpa.c":214

enum  {
	WPA_KEY_INFO_MIC = (1<<(8))
}  ;	// From "wpa.c":215

enum  {
	WPA_KEY_INFO_SECURE = (1<<(9))
}  ;	// From "wpa.c":216
/*** EndHeader */

/*** BeginHeader _wpa_s19_wpa_cipher_txt */
// From "wpa.c":234
char __far * _wpa_s19_wpa_cipher_txt(int cipher);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s19_wpa_cipher_txt(int cipher) {
	switch ((int)(cipher)) {
		case WPA_CIPHER_NONE:
		return "NONE" ;
		case WPA_CIPHER_WEP40:
		return "WEP-40" ;
		case WPA_CIPHER_WEP104:
		return "WEP-104" ;
		case WPA_CIPHER_TKIP:
		return "TKIP" ;
		case WPA_CIPHER_CCMP:
		return "CCMP" ;
		default:
		return "UNKNOWN" ;
	}
}

/*** BeginHeader _wpa_s19_wpa_key_mgmt_txt */
// From "wpa.c":259
char __far * _wpa_s19_wpa_key_mgmt_txt(int key_mgmt, int proto);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s19_wpa_key_mgmt_txt(int key_mgmt, int proto) {
	switch ((int)(key_mgmt)) {
		case WPA_KEY_MGMT_IEEE8021X:
		return proto==WPA_PROTO_RSN ?
		  "WPA2/IEEE 802.1X/EAP"  :
		  "WPA/IEEE 802.1X/EAP" ;
		case WPA_KEY_MGMT_PSK:
		return proto==WPA_PROTO_RSN ?
		  "WPA2-PSK"  :
		  "WPA-PSK" ;
		case WPA_KEY_MGMT_NONE:
		return "NONE" ;
		case WPA_KEY_MGMT_IEEE8021X_NO_WPA:
		return "IEEE 802.1X (no WPA)" ;
		default:
		return "UNKNOWN" ;
	}
}

/*** BeginHeader _wpa_s19_wpa_selector_to_bitfield */
// From "wpa.c":278
int _wpa_s19_wpa_selector_to_bitfield(char __far * s);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_selector_to_bitfield(char __far * s) {
	if (memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_NONE;
	if (memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_WEP40;
	if (memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_TKIP;
	if (memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_CCMP;
	if (memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_WEP104;
	return 0;
}

/*** BeginHeader _wpa_s19_wpa_key_mgmt_to_bitfield */
// From "wpa.c":294
int _wpa_s19_wpa_key_mgmt_to_bitfield(char __far * s);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_key_mgmt_to_bitfield(char __far * s) {
	if (memcmp(s, WPA_AUTH_KEY_MGMT_UNSPEC_802_1X, WPA_SELECTOR_LEN)
     ==0)
		return WPA_KEY_MGMT_IEEE8021X;
	if (memcmp(s, WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X, WPA_SELECTOR_LEN)
     ==0)
		return WPA_KEY_MGMT_PSK;
	if (memcmp(s, WPA_AUTH_KEY_MGMT_NONE, WPA_SELECTOR_LEN)
     ==0)
		return WPA_KEY_MGMT_WPA_NONE;
	return 0;
}

/*** BeginHeader _wpa_s19_rsn_selector_to_bitfield */
// From "wpa.c":309
int _wpa_s19_rsn_selector_to_bitfield(char __far * s);
/*** EndHeader */
_wpa_debug
int _wpa_s19_rsn_selector_to_bitfield(char __far * s) {
	if (memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_NONE;
	if (memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_WEP40;
	if (memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_TKIP;
	if (memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_CCMP;
	if (memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN)
     ==0)
		return WPA_CIPHER_WEP104;
	return 0;
}

/*** BeginHeader _wpa_s19_rsn_key_mgmt_to_bitfield */
// From "wpa.c":329
int _wpa_s19_rsn_key_mgmt_to_bitfield(char __far * s);
/*** EndHeader */
_wpa_debug
int _wpa_s19_rsn_key_mgmt_to_bitfield(char __far * s) {
	if (memcmp(s, RSN_AUTH_KEY_MGMT_UNSPEC_802_1X, RSN_SELECTOR_LEN)
     ==0)
		return WPA_KEY_MGMT_IEEE8021X;
	if (memcmp(s, RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X, RSN_SELECTOR_LEN)
     ==0)
		return WPA_KEY_MGMT_PSK;
	return 0;
}

/*** BeginHeader _wpa_s19_wpa_add_ie */
// From "wpa.c":343
char __far * _wpa_s19_wpa_add_ie(char __far * pos, char __far * ie, size_t ie_len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s19_wpa_add_ie(char __far * pos, char __far * ie, size_t ie_len) {
	_f_memcpy(pos, ie, ie_len);
	return pos+ie_len;
}

/*** BeginHeader _wpa_s19_wpa_add_kde */
// From "wpa.c":350
char __far * _wpa_s19_wpa_add_kde(char __far * pos, const char __far * kde,
                                char __far * data, size_t data_len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s19_wpa_add_kde(char __far * pos, const char __far * kde,
                                char __far * data, size_t data_len) {
	*pos++ = GENERIC_INFO_ELEM;
	*pos++ = RSN_SELECTOR_LEN+data_len;
	_f_memcpy(pos, kde, RSN_SELECTOR_LEN);
	pos += RSN_SELECTOR_LEN;
	_f_memcpy(pos, data, data_len);
	pos += data_len;
	return pos;
}

/*** BeginHeader _wpa_s19_wpa_parse_wpa_ie_wpa */
// From "wpa.c":364
int _wpa_s19_wpa_parse_wpa_ie_wpa(char __far * wpa_ie, size_t wpa_ie_len, struct wpa_ie_data __far * data);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_parse_wpa_ie_wpa(char __far * wpa_ie, size_t wpa_ie_len, struct wpa_ie_data __far * data) {
	struct wpa_ie_hdr __far * hdr; 	// From "wpa.c":367
	char __far * pos; 	// From "wpa.c":368
	int left; 	// From "wpa.c":369
	int i; 	// From "wpa.c":370
	int count; 	// From "wpa.c":370


	data->proto = WPA_PROTO_WPA;
	data->pairwise_cipher = WPA_CIPHER_TKIP;
	data->group_cipher = WPA_CIPHER_TKIP;
	data->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
	data->capabilities = 0;
	data->pmkid = ((void  __far * )0);
	data->num_pmkid = 0;
	data->mgmt_group_cipher = 0;
	if (wpa_ie_len==0) {
		return  -1;
	}
	if (wpa_ie_len<sizeof(struct wpa_ie_hdr  )) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie len too short %lu" , (char  __far * )("wpa_parse_wpa_ie_wpa" ),
               (unsigned long  )wpa_ie_len));
		return  -1;
	}
	hdr = (struct wpa_ie_hdr  __far * )wpa_ie;
	if (hdr->elem_id!=GENERIC_INFO_ELEM ||
	hdr->len!=wpa_ie_len-2 ||
	memcmp(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN)
	!=0 ||
	((word  )(((hdr->version)[1]<<8)|(hdr->version)[0]))!=WPA_VERSION) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: malformed ie or unknown version" , (char  __far * )("wpa_parse_wpa_ie_wpa" )));
		return  -1;
	}
	pos = (char  __far * )(hdr+1);
	left = wpa_ie_len-sizeof (*hdr);
	if (left>=WPA_SELECTOR_LEN) {
		data->group_cipher = _wpa_s19_wpa_selector_to_bitfield(pos);
		pos += WPA_SELECTOR_LEN;
		left -= WPA_SELECTOR_LEN;
	}
	else if (left>0) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie length mismatch, %u too much" , (char  __far * )("wpa_parse_wpa_ie_wpa" ),
               left));
		return  -1;
	}
	if (left>=2) {
		data->pairwise_cipher = 0;
		count = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
		if (count==0 ||
		left<count*WPA_SELECTOR_LEN) {
			_WPA_PRINTF((MSG_DEBUG, "%ls: ie count botch (pairwise), count %u left %u" ,
                (char  __far * )("wpa_parse_wpa_ie_wpa" ), count, left));
			return  -1;
		}
		for (i = 0; i<count; i++) {
			data->pairwise_cipher |= _wpa_s19_wpa_selector_to_bitfield(pos);
			pos += WPA_SELECTOR_LEN;
			left -= WPA_SELECTOR_LEN;
		}
	}
	else if (left==1) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie too short (for key mgmt)" , (char  __far * )("wpa_parse_wpa_ie_wpa" )));
		return  -1;
	}
	if (left>=2) {
		data->key_mgmt = 0;
		count = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
		if (count==0 ||
		left<count*WPA_SELECTOR_LEN) {
			_WPA_PRINTF((MSG_DEBUG, "%ls: ie count botch (key mgmt), count %u left %u" ,
                (char  __far * )("wpa_parse_wpa_ie_wpa" ), count, left));
			return  -1;
		}
		for (i = 0; i<count; i++) {
			data->key_mgmt |= _wpa_s19_wpa_key_mgmt_to_bitfield(pos);
			pos += WPA_SELECTOR_LEN;
			left -= WPA_SELECTOR_LEN;
		}
	}
	else if (left==1) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie too short (for capabilities)" , (char  __far * )("wpa_parse_wpa_ie_wpa" )));
		return  -1;
	}
	if (left>=2) {
		data->capabilities = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
	}
	if (left>0) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie has %u trailing bytes - ignored" , (char  __far * )("wpa_parse_wpa_ie_wpa" ),
               left));
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpa_parse_wpa_ie_rsn */
// From "wpa.c":473
int _wpa_s19_wpa_parse_wpa_ie_rsn(char __far * rsn_ie, size_t rsn_ie_len, struct wpa_ie_data __far * data);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_parse_wpa_ie_rsn(char __far * rsn_ie, size_t rsn_ie_len, struct wpa_ie_data __far * data) {
	struct rsn_ie_hdr __far * hdr; 	// From "wpa.c":477
	char __far * pos; 	// From "wpa.c":478
	int left; 	// From "wpa.c":479
	int i; 	// From "wpa.c":480
	int count; 	// From "wpa.c":480


	data->proto = WPA_PROTO_RSN;
	data->pairwise_cipher = WPA_CIPHER_CCMP;
	data->group_cipher = WPA_CIPHER_CCMP;
	data->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
	data->capabilities = 0;
	data->pmkid = ((void  __far * )0);
	data->num_pmkid = 0;
	data->mgmt_group_cipher = 0;
	if (rsn_ie_len==0) {
		return  -1;
	}
	if (rsn_ie_len<sizeof(struct rsn_ie_hdr  )) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie len too short %lu" , (char  __far * )("wpa_parse_wpa_ie_rsn" ),
               (unsigned long  )rsn_ie_len));
		return  -1;
	}
	hdr = (struct rsn_ie_hdr  __far * )rsn_ie;
	if (hdr->elem_id!=RSN_INFO_ELEM ||
	hdr->len!=rsn_ie_len-2 ||
	((word  )(((hdr->version)[1]<<8)|(hdr->version)[0]))!=RSN_VERSION) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: malformed ie or unknown version" , (char  __far * )("wpa_parse_wpa_ie_rsn" )));
		return  -1;
	}
	pos = (char  __far * )(hdr+1);
	left = rsn_ie_len-sizeof (*hdr);
	if (left>=RSN_SELECTOR_LEN) {
		data->group_cipher = _wpa_s19_rsn_selector_to_bitfield(pos);
		pos += RSN_SELECTOR_LEN;
		left -= RSN_SELECTOR_LEN;
	}
	else if (left>0) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie length mismatch, %u too much" , (char  __far * )("wpa_parse_wpa_ie_rsn" ),
               left));
		return  -1;
	}
	if (left>=2) {
		data->pairwise_cipher = 0;
		count = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
		if (count==0 ||
		left<count*RSN_SELECTOR_LEN) {
			_WPA_PRINTF((MSG_DEBUG, "%ls: ie count botch (pairwise), count %u left %u" ,
                (char  __far * )("wpa_parse_wpa_ie_rsn" ), count, left));
			return  -1;
		}
		for (i = 0; i<count; i++) {
			data->pairwise_cipher |= _wpa_s19_rsn_selector_to_bitfield(pos);
			pos += RSN_SELECTOR_LEN;
			left -= RSN_SELECTOR_LEN;
		}
	}
	else if (left==1) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie too short (for key mgmt)" , (char  __far * )("wpa_parse_wpa_ie_rsn" )));
		return  -1;
	}
	if (left>=2) {
		data->key_mgmt = 0;
		count = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
		if (count==0 ||
		left<count*RSN_SELECTOR_LEN) {
			_WPA_PRINTF((MSG_DEBUG, "%ls: ie count botch (key mgmt), count %u left %u" ,
                (char  __far * )("wpa_parse_wpa_ie_rsn" ), count, left));
			return  -1;
		}
		for (i = 0; i<count; i++) {
			data->key_mgmt |= _wpa_s19_rsn_key_mgmt_to_bitfield(pos);
			pos += RSN_SELECTOR_LEN;
			left -= RSN_SELECTOR_LEN;
		}
	}
	else if (left==1) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie too short (for capabilities)" , (char  __far * )("wpa_parse_wpa_ie_rsn" )));
		return  -1;
	}
	if (left>=2) {
		data->capabilities = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
	}
	if (left>=2) {
		data->num_pmkid = ((word  )(((pos)[1]<<8)|(pos)[0]));
		pos += 2;
		left -= 2;
		if (left<data->num_pmkid*PMKID_LEN) {
			_WPA_PRINTF((MSG_DEBUG, "%ls: PMKID underflow (num_pmkid=%d left=%d)" , (char  __far * )("wpa_parse_wpa_ie_rsn" ),
                data->num_pmkid, left));
			data->num_pmkid = 0;
		}
		else {
			data->pmkid = pos;
			pos += data->num_pmkid*PMKID_LEN;
			left -= data->num_pmkid*PMKID_LEN;
		}
	}
	if (left>0) {
		_WPA_PRINTF((MSG_DEBUG, "%ls: ie has %u trailing bytes - ignored" , (char  __far * )("wpa_parse_wpa_ie_rsn" ),
               left));
	}
	return 0;
}

/*** BeginHeader wpa_parse_wpa_ie */
// From "wpa.c":643
int wpa_parse_wpa_ie(char __far * wpa_ie, size_t wpa_ie_len, struct wpa_ie_data __far * data);
/*** EndHeader */
_wpa_debug
int wpa_parse_wpa_ie(char __far * wpa_ie, size_t wpa_ie_len, struct wpa_ie_data __far * data) {
	if (wpa_ie_len>=1 &&
	wpa_ie[0]==RSN_INFO_ELEM)
		return _wpa_s19_wpa_parse_wpa_ie_rsn(wpa_ie, wpa_ie_len, data);
	else
		return _wpa_s19_wpa_parse_wpa_ie_wpa(wpa_ie, wpa_ie_len, data);
}

/*** BeginHeader _wpa_s19_wpa_gen_wpa_ie_wpa */
// From "wpa.c":653
int _wpa_s19_wpa_gen_wpa_ie_wpa(char __far * wpa_ie, size_t wpa_ie_len, int pairwise_cipher,
                                int group_cipher, int key_mgmt);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_gen_wpa_ie_wpa(char __far * wpa_ie, size_t wpa_ie_len, int pairwise_cipher,
                                int group_cipher, int key_mgmt) {
	char __far * pos; 	// From "wpa.c":657
	struct wpa_ie_hdr __far * hdr; 	// From "wpa.c":658


	if (wpa_ie_len<sizeof (*hdr)+WPA_SELECTOR_LEN+2+WPA_SELECTOR_LEN
                +2+WPA_SELECTOR_LEN)
		return  -1;
	hdr = (struct wpa_ie_hdr  __far * )wpa_ie;
	hdr->elem_id = GENERIC_INFO_ELEM;
	_f_memcpy(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
	do {
		(hdr->version)[1] = ((word  )(WPA_VERSION))>>8;
		(hdr->version)[0] = ((word  )(WPA_VERSION))&0xff;
	} while (0);
	pos = (char  __far * )(hdr+1);
	if (group_cipher==WPA_CIPHER_CCMP) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
	}
	else if (group_cipher==WPA_CIPHER_TKIP) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
	}
	else if (group_cipher==WPA_CIPHER_WEP104) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN);
	}
	else if (group_cipher==WPA_CIPHER_WEP40) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN);
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "Invalid group cipher (%d)." , group_cipher));
		return  -1;
	}
	pos += WPA_SELECTOR_LEN;
	*pos++ = 1;
	*pos++ = 0;
	if (pairwise_cipher==WPA_CIPHER_CCMP) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
	}
	else if (pairwise_cipher==WPA_CIPHER_TKIP) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
	}
	else if (pairwise_cipher==WPA_CIPHER_NONE) {
		_f_memcpy(pos, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN);
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "Invalid pairwise cipher (%d)." , pairwise_cipher));
		return  -1;
	}
	pos += WPA_SELECTOR_LEN;
	*pos++ = 1;
	*pos++ = 0;
	if (key_mgmt==WPA_KEY_MGMT_IEEE8021X) {
		_f_memcpy(pos, WPA_AUTH_KEY_MGMT_UNSPEC_802_1X, WPA_SELECTOR_LEN);
	}
	else if (key_mgmt==WPA_KEY_MGMT_PSK) {
		_f_memcpy(pos, WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X, WPA_SELECTOR_LEN);
	}
	else if (key_mgmt==WPA_KEY_MGMT_WPA_NONE) {
		_f_memcpy(pos, WPA_AUTH_KEY_MGMT_NONE, WPA_SELECTOR_LEN);
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "Invalid key management type (%d)." , key_mgmt));
		return  -1;
	}
	pos += WPA_SELECTOR_LEN;
	hdr->len = ((_x509_ptrdiff_t)(pos-wpa_ie))-2;
	do {
	} while (0);
	return (_x509_ptrdiff_t)(pos-wpa_ie);
}

/*** BeginHeader _wpa_s19_wpa_gen_wpa_ie_rsn */
// From "wpa.c":727
int _wpa_s19_wpa_gen_wpa_ie_rsn(char __far * rsn_ie, size_t rsn_ie_len, int pairwise_cipher,
                                int group_cipher, int key_mgmt, int mgmt_group_cipher,
                                struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_gen_wpa_ie_rsn(char __far * rsn_ie, size_t rsn_ie_len, int pairwise_cipher,
                                int group_cipher, int key_mgmt, int mgmt_group_cipher,
                                struct wpa_sm __far * sm) {
	char __far * pos; 	// From "wpa.c":733
	struct rsn_ie_hdr __far * hdr; 	// From "wpa.c":734
	word capab; 	// From "wpa.c":735


	if (rsn_ie_len<sizeof (*hdr)+RSN_SELECTOR_LEN+2+RSN_SELECTOR_LEN
                +2+RSN_SELECTOR_LEN+2+(sm->cur_pmksa ?
	  2+PMKID_LEN :
	  0))
		return  -1;
	hdr = (struct rsn_ie_hdr  __far * )rsn_ie;
	hdr->elem_id = RSN_INFO_ELEM;
	do {
		(hdr->version)[1] = ((word  )(RSN_VERSION))>>8;
		(hdr->version)[0] = ((word  )(RSN_VERSION))&0xff;
	} while (0);
	pos = (char  __far * )(hdr+1);
	if (group_cipher==WPA_CIPHER_CCMP) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	}
	else if (group_cipher==WPA_CIPHER_TKIP) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
	}
	else if (group_cipher==WPA_CIPHER_WEP104) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN);
	}
	else if (group_cipher==WPA_CIPHER_WEP40) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN);
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "Invalid group cipher (%d)." , group_cipher));
		return  -1;
	}
	pos += RSN_SELECTOR_LEN;
	*pos++ = 1;
	*pos++ = 0;
	if (pairwise_cipher==WPA_CIPHER_CCMP) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	}
	else if (pairwise_cipher==WPA_CIPHER_TKIP) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
	}
	else if (pairwise_cipher==WPA_CIPHER_NONE) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN);
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "Invalid pairwise cipher (%d)." , pairwise_cipher));
		return  -1;
	}
	pos += RSN_SELECTOR_LEN;
	*pos++ = 1;
	*pos++ = 0;
	if (key_mgmt==WPA_KEY_MGMT_IEEE8021X) {
		_f_memcpy(pos, RSN_AUTH_KEY_MGMT_UNSPEC_802_1X, RSN_SELECTOR_LEN);
	}
	else if (key_mgmt==WPA_KEY_MGMT_PSK) {
		_f_memcpy(pos, RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X, RSN_SELECTOR_LEN);
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "Invalid key management type (%d)." , key_mgmt));
		return  -1;
	}
	pos += RSN_SELECTOR_LEN;
	capab = 0;
	do {
		(pos)[1] = ((word  )(capab))>>8;
		(pos)[0] = ((word  )(capab))&0xff;
	} while (0);
	pos += 2;
#ifdef WPA_USE_PMKSA_CACHE
	if (sm->cur_pmksa) {
		*pos++ = 1;
		*pos++ = 0;
		_f_memcpy(pos, sm->cur_pmksa->pmkid, PMKID_LEN);
		pos += PMKID_LEN;
	}
#endif//def WPA_USE_PMKSA_CACHE
	hdr->len = ((_x509_ptrdiff_t)(pos-rsn_ie))-2;
	do {
	} while (0);
	return (_x509_ptrdiff_t)(pos-rsn_ie);
}

/*** BeginHeader _wpa_s19_wpa_gen_wpa_ie */
// From "wpa.c":843
int _wpa_s19_wpa_gen_wpa_ie(struct wpa_sm __far * sm, char __far * wpa_ie, size_t wpa_ie_len);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpa_gen_wpa_ie(struct wpa_sm __far * sm, char __far * wpa_ie, size_t wpa_ie_len) {
	if (sm->proto==WPA_PROTO_RSN)
		return _wpa_s19_wpa_gen_wpa_ie_rsn(wpa_ie, wpa_ie_len, sm->pairwise_cipher, sm->group_cipher,
                                     sm->key_mgmt, sm->mgmt_group_cipher, sm);
	else
		return _wpa_s19_wpa_gen_wpa_ie_wpa(wpa_ie, wpa_ie_len, sm->pairwise_cipher, sm->group_cipher,
                                     sm->key_mgmt);
}

/*** BeginHeader _wpa_s19_wpa_pmk_to_ptk */
// From "wpa.c":880
void _wpa_s19_wpa_pmk_to_ptk(char __far * pmk, size_t pmk_len, char __far * label, char __far * addr1,
                             char __far * addr2, char __far * nonce1, char __far * nonce2,
                             char __far * ptk, size_t ptk_len);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_pmk_to_ptk(char __far * pmk, size_t pmk_len, char __far * label, char __far * addr1,
                             char __far * addr2, char __far * nonce1, char __far * nonce2,
                             char __far * ptk, size_t ptk_len) {
	char data[2*6+2*32]; 	// From "wpa.c":886


	if (memcmp(addr1, addr2, 6)<0) {
		_f_memcpy(data, addr1, 6);
		_f_memcpy(data+6, addr2, 6);
	}
	else {
		_f_memcpy(data, addr2, 6);
		_f_memcpy(data+6, addr1, 6);
	}
	if (memcmp(nonce1, nonce2, 32)<0) {
		_f_memcpy(data+2*6, nonce1, 32);
		_f_memcpy(data+2*6+32, nonce2, 32);
	}
	else {
		_f_memcpy(data+2*6, nonce2, 32);
		_f_memcpy(data+2*6+32, nonce1, 32);
	}
	sha1_prf(pmk, pmk_len, label, data, sizeof (data), ptk, ptk_len);
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: PMK" , pmk, pmk_len));
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: PTK" , ptk, ptk_len));
}

/*** BeginHeader _wpa_s19_wpa_eapol_key_mic */
// From "wpa.c":928
void _wpa_s19_wpa_eapol_key_mic(char __far * key, int ver, char __far * buf, size_t len,
                                char __far * mic);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_eapol_key_mic(char __far * key, int ver, char __far * buf, size_t len,
                                char __far * mic) {

	union  {

		struct  {
			char hash[SHA1_MAC_LEN];

		} __s2;

	} __u; 	// From "wpa.c":930


	if (ver==WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
		// Rabbit note: hmac_md5 has swapped args in Rabbit version: hmac_md5(key, 16, buf, len, mic);
		hmac_md5(buf, len, key, 16, mic);
	}
	else if (ver==WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		hmac_sha1(key, 16, buf, len, __u.__s2.hash);
		_f_memcpy(mic, __u.__s2.hash, MD5_MAC_LEN);
	}
   _WPA_HEXDUMP((MSG_DEBUG, "Rabbit note: MIC:", mic, 8));
}

/*** BeginHeader _wpa_s19_wpa_eapol_key_send */
// From "wpa.c":941
void _wpa_s19_wpa_eapol_key_send(struct wpa_sm __far * sm, char __far * kck, int ver,
                                 char __far * dest, word proto, char __far * msg, size_t msg_len,
                                 char __far * key_mic);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_eapol_key_send(struct wpa_sm __far * sm, char __far * kck, int ver,
                                 char __far * dest, word proto, char __far * msg, size_t msg_len,
                                 char __far * key_mic) {
	if (memcmp(dest, "\x00\x00\x00\x00\x00\x00" , 6)==0 &&
	memcmp(sm->bssid, "\x00\x00\x00\x00\x00\x00" , 6)==0) {
		if (sm->ctx->get_bssid((void  __far * )(sm->ctx->ctx), (char  __far * )(sm->bssid))
      <0) {
			_WPA_PRINTF((MSG_DEBUG, "WPA: Failed to %s", "read BSSID for " \
			 "EAPOL-Key destination address" ));
		}
		else {
			dest = sm->bssid;
			_WPA_PRINTF((MSG_DEBUG, "WPA: Use BSSID (" \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 ") as the destination for EAPOL-Key" , (dest)[0], (dest)[1], (dest)[2], (dest)[3],
                (dest)[4], (dest)[5]));
		}
	}
	if (key_mic) {
      _WPA_HEXDUMP((MSG_DEBUG, " Rabbit note: kck", kck, 16));
      _WPA_HEXDUMP((MSG_DEBUG, " Rabbit note: msg", msg, msg_len));
		_wpa_s19_wpa_eapol_key_mic(kck, ver, msg, msg_len, key_mic);
	}
	_WPA_HEXDUMP((MSG_MSGDUMP, "WPA: TX EAPOL-Key" , msg, msg_len));
	sm->ctx->ether_send((void  __far * )(sm->ctx->ctx), (char  __far * )(dest), (word  )(proto),
                     (char  __far * )(msg), (size_t  )(msg_len));
#ifdef WPA_USE_EAP
	eapol_sm_notify_tx_eapol_key(sm->eapol);
#endif//def WPA_USE_EAP
	_sys_free(msg);
}

/*** BeginHeader wpa_sm_key_request */
// From "wpa.c":982
void wpa_sm_key_request(struct wpa_sm __far * sm, int error, int pairwise);
/*** EndHeader */
_wpa_debug
void wpa_sm_key_request(struct wpa_sm __far * sm, int error, int pairwise) {
	size_t rlen; 	// From "wpa.c":984
	struct wpa_eapol_key __far * reply; 	// From "wpa.c":985
	int key_info; 	// From "wpa.c":986
	int ver; 	// From "wpa.c":986
	char bssid[6]; 	// From "wpa.c":987
	char __far * rbuf; 	// From "wpa.c":987


	if (sm->pairwise_cipher==WPA_CIPHER_CCMP)
		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
	else
		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
	if (sm->ctx->get_bssid((void  __far * )(sm->ctx->ctx), (char  __far * )(bssid))<0) {
		_WPA_PRINTF((MSG_WARNING, "Failed to read BSSID for EAPOL-Key " \
		 "request" ));
		return /*void*/;
	}
	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*reply)),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&reply));
	if (rbuf==((void  __far * )0))
		return /*void*/;
	reply->type = sm->proto==WPA_PROTO_RSN ?
	  EAPOL_KEY_TYPE_RSN :
	  EAPOL_KEY_TYPE_WPA;
	key_info = (1<<(11))|ver;
	if (sm->ptk_set)
		key_info |= WPA_KEY_INFO_MIC;
	if (error)
		key_info |= (1<<(10));
	if (pairwise)
		key_info |= WPA_KEY_INFO_KEY_TYPE;
	do {
		(reply->key_info)[0] = ((word  )(key_info))>>8;
		(reply->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	do {
		(reply->key_length)[0] = ((word  )(0))>>8;
		(reply->key_length)[1] = ((word  )(0))&0xff;
	} while (0);
	_f_memcpy(reply->replay_counter, sm->request_counter, 8);
	inc_byte_array(sm->request_counter, 8);
	do {
		(reply->key_data_length)[0] = ((word  )(0))>>8;
		(reply->key_data_length)[1] = ((word  )(0))&0xff;
	} while (0);
	_WPA_PRINTF((MSG_INFO, "WPA: Sending EAPOL-Key Request (error=%d " \
	 "pairwise=%d ptk_set=%d len=%lu)" , error, pairwise, sm->ptk_set, (unsigned long  )rlen));
	_wpa_s19_wpa_eapol_key_send(sm, sm->ptk.kck, ver, bssid, ETH_P_EAPOL, rbuf, rlen,
                             key_info&WPA_KEY_INFO_MIC ?
	  reply->key_mic :
	  ((void  __far * )0));
}

/*** BeginHeader wpa_sm_stkstart */
// From "wpa.c":1040
int wpa_sm_stkstart(struct wpa_sm __far * sm, char __far * peer);
/*** EndHeader */
_wpa_debug
int wpa_sm_stkstart(struct wpa_sm __far * sm, char __far * peer) {
	size_t rlen; 	// From "wpa.c":1043
	size_t kde_len; 	// From "wpa.c":1043
	struct wpa_eapol_key __far * req; 	// From "wpa.c":1044
	int key_info; 	// From "wpa.c":1045
	int ver; 	// From "wpa.c":1045
	char bssid[6]; 	// From "wpa.c":1046
	char __far * rbuf; 	// From "wpa.c":1046
	char __far * pos; 	// From "wpa.c":1046
	char __far * count_pos; 	// From "wpa.c":1046
	word count; 	// From "wpa.c":1047
	struct wpa_ssid __far * ssid /* = sm->cur_ssid */; 	// From "wpa.c":1048
	struct rsn_ie_hdr __far * hdr; 	// From "wpa.c":1049
	struct wpa_peerkey __far * peerkey; 	// From "wpa.c":1050
	struct wpa_ie_data ie; 	// From "wpa.c":1051

	ssid = sm->cur_ssid;

	if (sm->proto!=WPA_PROTO_RSN ||
	!sm->ptk_set ||
	ssid==((void  __far * )0) ||
	!ssid->peerkey)
		return  -1;
	if (sm->ap_rsn_ie &&
	_wpa_s19_wpa_parse_wpa_ie_rsn(sm->ap_rsn_ie, sm->ap_rsn_ie_len, &ie)==0 &&
	!(ie.capabilities&WPA_CAPABILITY_PEERKEY_ENABLED)) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Current AP does not support STK" ));
		return  -1;
	}
	if (sm->pairwise_cipher==WPA_CIPHER_CCMP)
		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
	else
		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
	if (sm->ctx->get_bssid((void  __far * )(sm->ctx->ctx), (char  __far * )(bssid))<0) {
		_WPA_PRINTF((MSG_WARNING, "Failed to read BSSID for EAPOL-Key " \
		 "SMK M1" ));
		return  -1;
	}
	peerkey = _sys_malloc(sizeof (*peerkey));
	if (peerkey==((void  __far * )0))
		return  -1;
	_f_memset(peerkey, 0, sizeof (*peerkey));
	peerkey->initiator = 1;
	_f_memcpy(peerkey->addr, peer, 6);
	hdr = (struct rsn_ie_hdr  __far * )peerkey->rsnie_i;
	hdr->elem_id = RSN_INFO_ELEM;
	do {
		(hdr->version)[1] = ((word  )(RSN_VERSION))>>8;
		(hdr->version)[0] = ((word  )(RSN_VERSION))&0xff;
	} while (0);
	pos = (char  __far * )(hdr+1);
	_f_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	pos += RSN_SELECTOR_LEN;
	count_pos = pos;
	pos += 2;
	count = 0;
	if (ssid->pairwise_cipher&WPA_CIPHER_CCMP) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
		pos += RSN_SELECTOR_LEN;
		count++;
	}
	if (ssid->pairwise_cipher&WPA_CIPHER_TKIP) {
		_f_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
		pos += RSN_SELECTOR_LEN;
		count++;
	}
	do {
		(count_pos)[1] = ((word  )(count))>>8;
		(count_pos)[0] = ((word  )(count))&0xff;
	} while (0);
	hdr->len = ((_x509_ptrdiff_t)(pos-peerkey->rsnie_i))-2;
	peerkey->rsnie_i_len = (_x509_ptrdiff_t)(pos-peerkey->rsnie_i);
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: RSN IE for SMK handshake" , peerkey->rsnie_i, peerkey->rsnie_i_len));
	kde_len = peerkey->rsnie_i_len+2+RSN_SELECTOR_LEN+6;
	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*req)
                                                                         +kde_len),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&req));
	if (rbuf==((void  __far * )0)) {
		_wpa_s19_wpaS_peerkey_free(sm, peerkey);
		return  -1;
	}
	req->type = EAPOL_KEY_TYPE_RSN;
	key_info = (1<<(13))|WPA_KEY_INFO_MIC|WPA_KEY_INFO_SECURE|(1<<(11))|ver;
	do {
		(req->key_info)[0] = ((word  )(key_info))>>8;
		(req->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	do {
		(req->key_length)[0] = ((word  )(0))>>8;
		(req->key_length)[1] = ((word  )(0))&0xff;
	} while (0);
	_f_memcpy(req->replay_counter, sm->request_counter, 8);
	inc_byte_array(sm->request_counter, 8);
	if (os_get_random(peerkey->inonce, WPA_NONCE_LEN)) {
		_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "WPA: Failed to %s", "get random data for INonce" ));
		_sys_free(rbuf);
		_wpa_s19_wpaS_peerkey_free(sm, peerkey);
		return  -1;
	}
	_f_memcpy(req->key_nonce, peerkey->inonce, WPA_NONCE_LEN);
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: INonce for SMK handshake" , req->key_nonce, WPA_NONCE_LEN));
	do {
		(req->key_data_length)[0] = ((word  )((word  )kde_len))>>8;
		(req->key_data_length)[1] = ((word  )((word  )kde_len))&0xff;
	} while (0);
	pos = (char  __far * )(req+1);
	pos = _wpa_s19_wpa_add_ie(pos, peerkey->rsnie_i, peerkey->rsnie_i_len);
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_MAC_ADDR, peer,
                            6);
	_WPA_PRINTF((MSG_INFO, "RSN: Sending EAPOL-Key SMK M1 Request (peer " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 ")" , (peer)[0], (peer)[1], (peer)[2], (peer)[3], (peer)[4], (peer)[5]));
	_wpa_s19_wpa_eapol_key_send(sm, sm->ptk.kck, ver, bssid, ETH_P_EAPOL, rbuf, rlen,
                             req->key_mic);
	peerkey->next = sm->peerkey;
	sm->peerkey = peerkey;
	return 0;
}
/*** BeginHeader */

struct wpa_eapol_ie_parse {
	char __far * wpa_ie;
	size_t wpa_ie_len;
	char __far * rsn_ie;
	size_t rsn_ie_len;
	char __far * pmkid;
	char __far * gtk;
	size_t gtk_len;
	char __far * mac_addr;
	size_t mac_addr_len;
	char __far * smk;
	size_t smk_len;
	char __far * nonce;
	size_t nonce_len;
	char __far * lifetime;
	size_t lifetime_len;
	char __far * error;
	size_t error_len;

} ;	// From "wpa.c":1200
/*** EndHeader */

/*** BeginHeader _wpa_s19_wpaS_parse_generic */
// From "wpa.c":1210
int _wpa_s19_wpaS_parse_generic(char __far * pos, char __far * end, struct wpa_eapol_ie_parse __far * ie);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_parse_generic(char __far * pos, char __far * end, struct wpa_eapol_ie_parse __far * ie) {
	if (pos[1]==0)
		return 1;
	if (pos[1]>=6 &&
	memcmp(pos+2, WPA_OUI_TYPE, WPA_SELECTOR_LEN) ==0 &&
	pos[2+WPA_SELECTOR_LEN]==1 &&
	pos[2+WPA_SELECTOR_LEN+1]==0) {
		ie->wpa_ie = pos;
		ie->wpa_ie_len = pos[1]+2;
		return 0;
	}
	if (pos+1+RSN_SELECTOR_LEN<end &&
	pos[1]>=RSN_SELECTOR_LEN+PMKID_LEN &&
	memcmp(pos+2, RSN_KEY_DATA_PMKID, RSN_SELECTOR_LEN)
	==0) {
		ie->pmkid = pos+2+RSN_SELECTOR_LEN;
		return 0;
	}
	if (pos[1]>RSN_SELECTOR_LEN+2 &&
	memcmp(pos+2, RSN_KEY_DATA_GROUPKEY, RSN_SELECTOR_LEN)
	==0) {
		ie->gtk = pos+2+RSN_SELECTOR_LEN;
		ie->gtk_len = pos[1]-RSN_SELECTOR_LEN;
		return 0;
	}
	if (pos[1]>RSN_SELECTOR_LEN+2 &&
	memcmp(pos+2, RSN_KEY_DATA_MAC_ADDR, RSN_SELECTOR_LEN)
	==0) {
		ie->mac_addr = pos+2+RSN_SELECTOR_LEN;
		ie->mac_addr_len = pos[1]-RSN_SELECTOR_LEN;
		return 0;
	}
	if (pos[1]>RSN_SELECTOR_LEN+2 &&
	memcmp(pos+2, RSN_KEY_DATA_SMK, RSN_SELECTOR_LEN)
	==0) {
		ie->smk = pos+2+RSN_SELECTOR_LEN;
		ie->smk_len = pos[1]-RSN_SELECTOR_LEN;
		return 0;
	}
	if (pos[1]>RSN_SELECTOR_LEN+2 &&
	memcmp(pos+2, RSN_KEY_DATA_NONCE, RSN_SELECTOR_LEN)
	==0) {
		ie->nonce = pos+2+RSN_SELECTOR_LEN;
		ie->nonce_len = pos[1]-RSN_SELECTOR_LEN;
		return 0;
	}
	if (pos[1]>RSN_SELECTOR_LEN+2 &&
	memcmp(pos+2, RSN_KEY_DATA_LIFETIME, RSN_SELECTOR_LEN)
	==0) {
		ie->lifetime = pos+2+RSN_SELECTOR_LEN;
		ie->lifetime_len = pos[1]-RSN_SELECTOR_LEN;
		return 0;
	}
	if (pos[1]>RSN_SELECTOR_LEN+2 &&
	memcmp(pos+2, RSN_KEY_DATA_ERROR, RSN_SELECTOR_LEN)
	==0) {
		ie->error = pos+2+RSN_SELECTOR_LEN;
		ie->error_len = pos[1]-RSN_SELECTOR_LEN;
		return 0;
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_parse_ies */
// From "wpa.c":1303
int _wpa_s19_wpaS_parse_ies(char __far * buf, size_t len, struct wpa_eapol_ie_parse __far * ie);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_parse_ies(char __far * buf, size_t len, struct wpa_eapol_ie_parse __far * ie) {
	char __far * pos; 	// From "wpa.c":1306
	char __far * end; 	// From "wpa.c":1306
	int ret /* = 0 */; 	// From "wpa.c":1307

	ret = 0;

	_f_memset(ie, 0, sizeof (*ie));
	for (pos = buf, end = pos+len; pos+1<end; pos += 2+pos[1]) {
		if (pos[0]==0xdd &&
		((pos==buf+len-1) ||
		pos[1]==0)) {
			break;
		}
		if (pos+2+pos[1]>end) {
			_WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL-Key Key Data " \
			 "underflow (ie=%d len=%d pos=%d)" , pos[0], pos[1], (int  )((_x509_ptrdiff_t)(pos-buf))));
			_WPA_HEXDUMP((MSG_DEBUG, "WPA: Key Data" , buf, len));
			ret =  -1;
			break;
		}
		if (*pos==RSN_INFO_ELEM) {
			ie->rsn_ie = pos;
			ie->rsn_ie_len = pos[1]+2;
		}
		else if (*pos==GENERIC_INFO_ELEM) {
			ret = _wpa_s19_wpaS_parse_generic(pos, end, ie);
			if (ret<0)
				break;
			if (ret>0) {
				ret = 0;
				break;
			}
		}
		else {
			_WPA_HEXDUMP((MSG_DEBUG, "WPA: Unrecognized EAPOL-Key " \
			 "Key Data IE" , pos, 2+pos[1]));
		}
	}
	return ret;
}

/*** BeginHeader _wpa_s19_wpaS_get_pmk */
// From "wpa.c":1346
int _wpa_s19_wpaS_get_pmk(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                    char __far * pmkid);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_get_pmk(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                    char __far * pmkid) {
	int abort_cached /* = 0 */; 	// From "wpa.c":1350

	union  {

		struct  {
			int res;
			int pmk_len;

		} __s3;

		struct  {
			char __far * buf;
			size_t buflen;

		} __s4;

	} __u; 	// From "wpa.c":1349

	abort_cached = 0;

	if (pmkid &&
	!sm->cur_pmksa) {
#ifdef WPA_USE_PMKSA_CACHE
		sm->cur_pmksa = pmksa_cache_get(sm->pmksa, src_addr, pmkid);
#endif//def WPA_USE_PMKSA_CACHE
		if (sm->cur_pmksa) {
			_WPA_PRINTF((MSG_DEBUG, "RSN: found matching PMKID from " \
			 "PMKSA cache" ));
		}
		else {
			_WPA_PRINTF((MSG_DEBUG, "RSN: no matching PMKID found" ));
			abort_cached = 1;
		}
	}
	if (pmkid &&
	sm->cur_pmksa &&
	memcmp(pmkid, sm->cur_pmksa->pmkid, PMKID_LEN)==0) {
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: matched PMKID" , pmkid, PMKID_LEN));
		wpa_sm_set_pmk_from_pmksa(sm);
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: PMK from PMKSA cache" , sm->pmk, sm->pmk_len));
#ifdef WPA_USE_EAP
		eapol_sm_notify_cached(sm->eapol);
#endif//def WPA_USE_EAP
	}
	else if (sm->key_mgmt==WPA_KEY_MGMT_IEEE8021X &&
	sm->eapol) {
#ifdef WPA_USE_EAP
		__u.__s3.pmk_len = PMK_LEN;
		__u.__s3.res = eapol_sm_get_key(sm->eapol, sm->pmk, PMK_LEN);
#endif//def WPA_USE_EAP
		if (__u.__s3.res) {
#ifdef WPA_USE_EAP
			__u.__s3.res = eapol_sm_get_key(sm->eapol, sm->pmk, 16);
			__u.__s3.pmk_len = 16;
#endif//def WPA_USE_EAP
		}
		if (__u.__s3.res==0) {
			_WPA_HEXDUMP((MSG_DEBUG, "WPA: PMK from EAPOL state " \
			 "machines" , sm->pmk, __u.__s3.pmk_len));
			sm->pmk_len = __u.__s3.pmk_len;
#ifdef WPA_USE_PMKSA_CACHE
			pmksa_cache_add(sm->pmksa, sm->pmk, __u.__s3.pmk_len, src_addr, sm->own_addr,
                   sm->cur_ssid);
			if (!sm->cur_pmksa &&
			pmkid &&
			pmksa_cache_get(sm->pmksa, src_addr, pmkid)) {
				_WPA_PRINTF((MSG_DEBUG, "RSN: the new PMK " \
				 "matches with the PMKID" ));
				abort_cached = 0;
			}
#endif//def WPA_USE_PMKSA_CACHE
		}
		else {
			_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "WPA: Failed to %s", "get master session key from " \
			 "EAPOL state machines" ));
			_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "WPA: Key handshake aborted" ));
			if (sm->cur_pmksa) {
				_WPA_PRINTF((MSG_DEBUG, "RSN: Cancelled PMKSA " \
				 "caching attempt" ));
				sm->cur_pmksa = ((void  __far * )0);
				abort_cached = 1;
			}
			else {
				return  -1;
			}
		}
	}
	if (abort_cached &&
	sm->key_mgmt==WPA_KEY_MGMT_IEEE8021X) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: no PMKSA entry found - trigger " \
		 "full EAP authentication" ));
		__u.__s4.buf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_START),
                                      (void  __far * )(((void  __far * )0)), (word  )(0),
                                      (size_t  __far * )(&__u.__s4.buflen), (void  __far * __far * )(((void  __far * )0)));
		if (__u.__s4.buf) {
			sm->ctx->ether_send((void  __far * )(sm->ctx->ctx), (char  __far * )(sm->bssid),
                       (word  )(ETH_P_EAPOL), (char  __far * )(__u.__s4.buf), (size_t  )(__u.__s4.buflen));
			_sys_free(__u.__s4.buf);
		}
		return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_send_2_of_4 */
// From "wpa.c":1437
int _wpa_s19_wpaS_send_2_of_4(struct wpa_sm __far * sm, unsigned char __far * dst,
                                        struct wpa_eapol_key __far * key, int ver,
                                        char __far * nonce, char __far * wpa_ie, size_t wpa_ie_len,
                                        struct wpa_ptk __far * ptk);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_send_2_of_4(struct wpa_sm __far * sm, unsigned char __far * dst,
                                        struct wpa_eapol_key __far * key, int ver,
                                        char __far * nonce, char __far * wpa_ie, size_t wpa_ie_len,
                                        struct wpa_ptk __far * ptk) {
	size_t rlen; 	// From "wpa.c":1444
	struct wpa_eapol_key __far * reply; 	// From "wpa.c":1445
	char __far * rbuf; 	// From "wpa.c":1446


	if (wpa_ie==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "WPA: No wpa_ie set - cannot " \
		 "generate msg 2/4" ));
		return  -1;
	}
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: WPA IE for msg 2/4" , wpa_ie, wpa_ie_len));
	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*reply)
                                                                         +wpa_ie_len),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&reply));
	if (rbuf==((void  __far * )0))
		return  -1;
	reply->type = sm->proto==WPA_PROTO_RSN ?
	  EAPOL_KEY_TYPE_RSN :
	  EAPOL_KEY_TYPE_WPA;
	do {
		(reply->key_info)[0] = ((word  )(ver|WPA_KEY_INFO_KEY_TYPE|WPA_KEY_INFO_MIC))>>8;
		(reply->key_info)[1] = ((word  )(ver|WPA_KEY_INFO_KEY_TYPE|WPA_KEY_INFO_MIC))&0xff;
	} while (0);
	if (sm->proto==WPA_PROTO_RSN)
		do {
			(reply->key_length)[0] = ((word  )(0))>>8;
			(reply->key_length)[1] = ((word  )(0))&0xff;
		} while (0);
	else
		_f_memcpy(reply->key_length, key->key_length, 2);
	_f_memcpy(reply->replay_counter, key->replay_counter, 8);
	do {
		(reply->key_data_length)[0] = ((word  )(wpa_ie_len))>>8;
		(reply->key_data_length)[1] = ((word  )(wpa_ie_len))&0xff;
	} while (0);
	_f_memcpy(reply+1, wpa_ie, wpa_ie_len);
	_f_memcpy(reply->key_nonce, nonce, WPA_NONCE_LEN);
	_WPA_PRINTF((MSG_DEBUG, "WPA: Sending EAPOL-Key 2/4" ));
	_wpa_s19_wpa_eapol_key_send(sm, ptk->kck, ver, dst, ETH_P_EAPOL, rbuf, rlen, reply->key_mic);
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_1_of_4 */
// From "wpa.c":1486
void _wpa_s19_wpaS_process_1_of_4(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                            struct wpa_eapol_key __far * key, word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_1_of_4(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                            struct wpa_eapol_key __far * key, word ver) {
	struct wpa_eapol_ie_parse ie; 	// From "wpa.c":1491
	struct wpa_ptk __far * ptk; 	// From "wpa.c":1492
	char buf[8]; 	// From "wpa.c":1493

	union  {

		struct  {
			char __far * _buf /* = (char  far * )(key+1) */;
			size_t len /* = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1])) */;

		} __s2;

	} __u; 	// From "wpa.c":1490


   //  Rabbit note: Internal Error: Expression temporary stack usage: function pointer return pointer to far struct is the problem, so cast to ugliness.
   //  Rabbit note: Vantive 24988
	//if (sm->ctx->get_ssid((void  far * )(sm->ctx->ctx))==((void  far * )0)) {
	if (((void __far * (*)()) sm->ctx->get_ssid)((void  __far * )(sm->ctx->ctx))==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "WPA: No SSID info found (msg 1 of " \
		 "4)." ));
		return /*void*/;
	}
	sm->ctx->set_state((void  __far * )(sm->ctx->ctx), (wpa_states  )(WPA_4WAY_HANDSHAKE));
	_WPA_PRINTF((MSG_DEBUG, "WPA: RX message 1 of 4-Way Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (src_addr)[0], (src_addr)[1], (src_addr)[2], (src_addr)[3], (src_addr)[4],
              (src_addr)[5], ver));
	_f_memset(&ie, 0, sizeof (ie));
	if (sm->proto==WPA_PROTO_RSN) {
		__u.__s2._buf = (char  __far * )(key+1);
		__u.__s2.len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));

		_WPA_HEXDUMP((MSG_DEBUG, "RSN: msg 1/4 key data" , __u.__s2._buf, __u.__s2.len));
		_wpa_s19_wpaS_parse_ies(__u.__s2._buf, __u.__s2.len, &ie);
		if (ie.pmkid) {
			_WPA_HEXDUMP((MSG_DEBUG, "RSN: PMKID from " \
			 "Authenticator" , ie.pmkid, PMKID_LEN));
		}
	}
	if (_wpa_s19_wpaS_get_pmk(sm, src_addr, ie.pmkid))
		return /*void*/;
	if (sm->renew_snonce) {
		if (os_get_random(sm->snonce, WPA_NONCE_LEN)) {
			_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "WPA: Failed to %s", "get random data for SNonce" ));
			return /*void*/;
		}
		sm->renew_snonce = 0;
		_WPA_HEXDUMP((MSG_DEBUG, "WPA: Renewed SNonce" , sm->snonce, WPA_NONCE_LEN));
	}
	ptk = &sm->tptk;
   //  Rabbit note: Hack to use src_addr as bssid if bssid is blank
   if (0 == memcmp(sm->bssid, "\x00\x00\x00\x00\x00\x00", 6)) {
   	_WPA_PRINTF((MSG_WARNING, " Rabbit note: Hack -- using src_addr for bssid"));
      _f_memcpy(sm->bssid, src_addr, 6);
   }
   _WPA_HEXDUMP((MSG_DEBUG, "WPA: bssid:", sm->bssid, 6));
   _WPA_HEXDUMP((MSG_DEBUG, "WPA: own_addr:", sm->own_addr, 6));
   //  Rabbit note: Hack -- using _wifi_macParams.wpa_psk for pmk if pmk_len is 0.
   if (! sm->pmk_len) {
      _WPA_PRINTF((MSG_WARNING, " Rabbit note: Hack -- using _wifi_macParams.wpa_psk for pmk."));
      //  Rabbit note: The sizeof() could potentially be wrong if we allow longer PSKs.
      sm->pmk_len = sizeof(_wifi_macParams.wpa_psk);
      _f_memcpy(sm->pmk, _wifi_macParams.wpa_psk, sizeof(_wifi_macParams.wpa_psk));
   }
	_WPA_HEXDUMP((MSG_DEBUG, "key_nonce" , key->key_nonce, WPA_NONCE_LEN));
	_wpa_s19_wpa_pmk_to_ptk(sm->pmk, sm->pmk_len, "Pairwise key expansion" , sm->own_addr,
                         sm->bssid, sm->snonce, key->key_nonce, (char  __far * )ptk,
                         sizeof (*ptk));
	_f_memcpy(buf, ptk->u.auth.tx_mic_key, 8);
	_f_memcpy(ptk->u.auth.tx_mic_key, ptk->u.auth.rx_mic_key, 8);
	_f_memcpy(ptk->u.auth.rx_mic_key, buf, 8);
	sm->tptk_set = 1;
   //  Rabbit note: Not the place for it, but set key->key_length = 0
   *(int __far *)key->key_length = 0;
	if (_wpa_s19_wpaS_send_2_of_4(sm, sm->bssid, key, ver, sm->snonce, sm->assoc_wpa_ie,
                                         sm->assoc_wpa_ie_len, ptk))
		return /*void*/;
	_f_memcpy(sm->anonce, key->key_nonce, WPA_NONCE_LEN);
}

/*** BeginHeader _wpa_s19_wpa_sm_start_preauth */
// From "wpa.c":1556
void _wpa_s19_wpa_sm_start_preauth(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_sm_start_preauth(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct wpa_sm __far * sm /* = eloop_ctx */; 	// From "wpa.c":1558

	sm = eloop_ctx;

#ifdef WPA_USE_PREAUTH_C
	rsn_preauth_candidate_process(sm);
#endif//def WPA_USE_PREAUTH_C
}

/*** BeginHeader _wpa_s19_wpaS_key_neg_complete */
// From "wpa.c":1563
void _wpa_s19_wpaS_key_neg_complete(struct wpa_sm __far * sm, char __far * addr,
                                              int secure);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_key_neg_complete(struct wpa_sm __far * sm, char __far * addr,
                                              int secure) {
	_WPA_MSG((sm->ctx->ctx, MSG_INFO, "WPA: Key negotiation completed with %02x:%02x:%02x:%02x:%02x:%02x [PTK=%ls GTK=%ls]" ,
           (addr)[0], (addr)[1], (addr)[2], (addr)[3], (addr)[4], (addr)[5], (char  __far * )(_wpa_s19_wpa_cipher_txt(
                                                                                                                    sm->pairwise_cipher)),
           (char  __far * )(_wpa_s19_wpa_cipher_txt(sm->group_cipher))));
	eloop_cancel_timeout(sm->ctx->scan, sm->ctx->ctx, ((void  __far * )0));
	sm->ctx->cancel_auth_timeout((void  __far * )(sm->ctx->ctx));
	sm->ctx->set_state((void  __far * )(sm->ctx->ctx), (wpa_states  )(WPA_COMPLETED));
	if (secure) {
		sm->ctx->mlme_setprotection((void  __far * )(sm->ctx->ctx), (char  __far * )(addr),
                              (int  )(3), (int  )(1));
#ifdef WPA_USE_EAP
		eapol_sm_notify_portValid(sm->eapol, TRUE);
		if (sm->key_mgmt==WPA_KEY_MGMT_PSK)
			eapol_sm_notify_eap_success(sm->eapol, TRUE);
#endif//def WPA_USE_EAP
#ifdef WPA_USE_PREAUTH_C
		eloop_register_timeout(1000, _wpa_s19_wpa_sm_start_preauth, sm, ((void  __far * )0));
#endif//def WPA_USE_PREAUTH_C
	}
	if (sm->cur_pmksa &&
	sm->cur_pmksa->opportunistic) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Authenticator accepted " \
		 "opportunistic PMKSA entry - marking it valid" ));
		sm->cur_pmksa->opportunistic = 0;
	}
}

/*** BeginHeader _wpa_s19_wpaS_install_ptk */
// From "wpa.c":1599
int _wpa_s19_wpaS_install_ptk(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_install_ptk(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key) {
	int keylen; 	// From "wpa.c":1602
	int rsclen; 	// From "wpa.c":1602
	wpa_alg alg; 	// From "wpa.c":1603
	char __far * key_rsc; 	// From "wpa.c":1604
	char null_rsc[8] /* =
	{
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	} */; 	// From "wpa.c":1605

   //  Rabbit note: cannot assign to array null_rsc, using memset
   /*
	null_rsc =
	{
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	};
   */
   memset(null_rsc, 0, sizeof(null_rsc));

	_WPA_PRINTF((MSG_DEBUG, "WPA: Installing PTK to the driver." ));
	switch ((int)(sm->pairwise_cipher)) {
		case WPA_CIPHER_CCMP:
		alg = WPA_ALG_CCMP;
		keylen = 16;
		rsclen = 6;
		break;
		case WPA_CIPHER_TKIP:
		alg = WPA_ALG_TKIP;
		keylen = 32;
		rsclen = 6;
		break;
		case WPA_CIPHER_NONE:
		_WPA_PRINTF((MSG_DEBUG, "WPA: Pairwise Cipher Suite: " \
		 "NONE - do not use pairwise keys" ));
		return 0;
		default:
		_WPA_PRINTF((MSG_WARNING, "WPA: Unsupported pairwise cipher %d" , sm->pairwise_cipher));
		return  -1;
	}
	if (sm->proto==WPA_PROTO_RSN) {
		key_rsc = null_rsc;
	}
	else {
		key_rsc = key->key_rsc;
      //  Rabbit note: added zero to promoted const char far * to work around bug
		_WPA_HEXDUMP((MSG_DEBUG, "WPA: RSC" + 0, key_rsc, rsclen));
	}
	if (sm->ctx->set_key((void  __far * )(sm->ctx->ctx), (wpa_alg  )(alg), (char  __far * )(sm->bssid),
                      (int  )(0), (int  )(1), (char  __far * )(key_rsc), (size_t  )(rsclen),
                      (char  __far * )((char  __far * )sm->ptk.tk1), (size_t  )(keylen))
     <0) {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "set PTK to the driver." ));
		return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_check_group_cipher */
// From "wpa.c":1647
int _wpa_s19_wpaS_check_group_cipher(int group_cipher, int keylen, int maxkeylen,
                                               int __far * key_rsc_len, wpa_alg __far * alg);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_check_group_cipher(int group_cipher, int keylen, int maxkeylen,
                                               int __far * key_rsc_len, wpa_alg __far * alg) {
	int ret /* = 0 */; 	// From "wpa.c":1651

	ret = 0;

	switch ((int)(group_cipher)) {
		case WPA_CIPHER_CCMP:
		if (keylen!=16 ||
		maxkeylen<16) {
			ret =  -1;
			break;
		}
		*key_rsc_len = 6;
		*alg = WPA_ALG_CCMP;
		break;
		case WPA_CIPHER_TKIP:
		if (keylen!=32 ||
		maxkeylen<32) {
			ret =  -1;
			break;
		}
		*key_rsc_len = 6;
		*alg = WPA_ALG_TKIP;
		break;
		case WPA_CIPHER_WEP104:
		if (keylen!=13 ||
		maxkeylen<13) {
			ret =  -1;
			break;
		}
		*key_rsc_len = 0;
		*alg = WPA_ALG_WEP;
		break;
		case WPA_CIPHER_WEP40:
		if (keylen!=5 ||
		maxkeylen<5) {
			ret =  -1;
			break;
		}
		*key_rsc_len = 0;
		*alg = WPA_ALG_WEP;
		break;
		default:
		_WPA_PRINTF((MSG_WARNING, "WPA: Unsupported Group Cipher %d" , group_cipher));
		return  -1;
	}
	if (ret<0) {
		_WPA_PRINTF((MSG_WARNING, "WPA: Unsupported %ls Group Cipher key length %d (%d)." ,
               (char  __far * )(_wpa_s19_wpa_cipher_txt(group_cipher)), keylen, maxkeylen));
	}
	return ret;
}
/*** BeginHeader */

struct wpa_gtk_data {
	wpa_alg alg;
	int tx;
	int key_rsc_len;
	int keyidx;
	char gtk[32];
	int gtk_len;

} ;	// From "wpa.c":1707
/*** EndHeader */

/*** BeginHeader _wpa_s19_wpaS_install_gtk */
// From "wpa.c":1710
int _wpa_s19_wpaS_install_gtk(struct wpa_sm __far * sm, struct wpa_gtk_data __far * gd,
                                        char __far * key_rsc);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_install_gtk(struct wpa_sm __far * sm, struct wpa_gtk_data __far * gd,
                                        char __far * key_rsc) {
	char __far * _gtk /* = gd->gtk */; 	// From "wpa.c":1714
	char gtk_buf[32]; 	// From "wpa.c":1715

	_gtk = gd->gtk;

	_WPA_HEXDUMP((MSG_DEBUG, "WPA: Group Key" , gd->gtk, gd->gtk_len));
	_WPA_PRINTF((MSG_DEBUG, "WPA: Installing GTK to the driver " \
	 "(keyidx=%d tx=%d)." , gd->keyidx, gd->tx));
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: RSC" , key_rsc, gd->key_rsc_len));
	if (sm->group_cipher==WPA_CIPHER_TKIP) {
		_f_memcpy(gtk_buf, gd->gtk, 16);
		_f_memcpy(gtk_buf+16, gd->gtk+24, 8);
		_f_memcpy(gtk_buf+24, gd->gtk+16, 8);
		_gtk = gtk_buf;
	}
	if (sm->pairwise_cipher==WPA_CIPHER_NONE) {
		if (sm->ctx->set_key((void  __far * )(sm->ctx->ctx), (wpa_alg  )(gd->alg), (char  __far * )((char  __far * )"\xff\xff\xff\xff\xff\xff" ),
                       (int  )(gd->keyidx), (int  )(1), (char  __far * )(key_rsc),
                       (size_t  )(gd->key_rsc_len), (char  __far * )(_gtk), (size_t  )(gd->gtk_len))
      <0) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "set GTK to the driver (Group only)." ));
			return  -1;
		}
	}
	else if (sm->ctx->set_key((void  __far * )(sm->ctx->ctx), (wpa_alg  )(gd->alg), (char  __far * )((char  __far * )"\xff\xff\xff\xff\xff\xff" ),
                           (int  )(gd->keyidx), (int  )(gd->tx), (char  __far * )(key_rsc),
                           (size_t  )(gd->key_rsc_len), (char  __far * )(_gtk), (size_t  )(gd->gtk_len))
          <0) {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "set GTK to the driver." ));
		return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_gtk_tx_bit_workaround */
// From "wpa.c":1750
int _wpa_s19_wpaS_gtk_tx_bit_workaround(struct wpa_sm __far * sm, int tx);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_gtk_tx_bit_workaround(struct wpa_sm __far * sm, int tx) {
	if (tx &&
	sm->pairwise_cipher!=WPA_CIPHER_NONE) {
		_WPA_PRINTF((MSG_INFO, "WPA: Tx bit set for GTK, but pairwise " \
		 "keys are used - ignore Tx bit" ));
		return 0;
	}
	return tx;
}

/*** BeginHeader _wpa_s19_wpaS_pairwise_gtk */
// From "wpa.c":1767
int _wpa_s19_wpaS_pairwise_gtk(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                         char __far * gtk, size_t gtk_len, int key_info);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_pairwise_gtk(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                         char __far * gtk, size_t gtk_len, int key_info) {
	struct wpa_gtk_data gd; 	// From "wpa.c":1773


	_f_memset(&gd, 0, sizeof (gd));
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: received GTK in pairwise handshake" , gtk, gtk_len));
	if (gtk_len<2 ||
	gtk_len-2>sizeof (gd.gtk))
		return  -1;
	gd.keyidx = gtk[0]&0x3;
	gd.tx = _wpa_s19_wpaS_gtk_tx_bit_workaround(sm, !!(gtk[0]&(1<<(2))));
	gtk += 2;
	gtk_len -= 2;
	_f_memcpy(gd.gtk, gtk, gtk_len);
	gd.gtk_len = gtk_len;
	if (_wpa_s19_wpaS_check_group_cipher(sm->group_cipher, gtk_len, gtk_len,
                                                &gd.key_rsc_len, &gd.alg) ||
	_wpa_s19_wpaS_install_gtk(sm, &gd, key->key_rsc)) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Failed to install GTK" ));
		return  -1;
	}
	_wpa_s19_wpaS_key_neg_complete(sm, sm->bssid, key_info&WPA_KEY_INFO_SECURE);
	return 0;
}

/*** BeginHeader _wpa_s19_ieee80211w_set_keys */
// From "wpa.c":1816
int _wpa_s19_ieee80211w_set_keys(struct wpa_sm __far * sm, struct wpa_eapol_ie_parse __far * ie);
/*** EndHeader */
_wpa_debug
int _wpa_s19_ieee80211w_set_keys(struct wpa_sm __far * sm, struct wpa_eapol_ie_parse __far * ie) {
	return 0;
}

/*** BeginHeader _wpa_s19_wpa_report_ie_mismatch */
// From "wpa.c":1872
void _wpa_s19_wpa_report_ie_mismatch(struct wpa_sm __far * sm, char __far * reason,
                                     char __far * src_addr, char __far * wpa_ie, size_t wpa_ie_len,
                                     char __far * rsn_ie, size_t rsn_ie_len);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_report_ie_mismatch(struct wpa_sm __far * sm, char __far * reason,
                                     char __far * src_addr, char __far * wpa_ie, size_t wpa_ie_len,
                                     char __far * rsn_ie, size_t rsn_ie_len) {
	_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "WPA: %ls (src=%02x:%02x:%02x:%02x:%02x:%02x)" ,
           (char  __far * )(reason), (src_addr)[0], (src_addr)[1], (src_addr)[2],
           (src_addr)[3], (src_addr)[4], (src_addr)[5]));
	if (sm->ap_wpa_ie) {
		_WPA_HEXDUMP((MSG_INFO, "WPA: WPA IE in Beacon/ProbeResp" , sm->ap_wpa_ie, sm->ap_wpa_ie_len));
	}
	if (wpa_ie) {
		if (!sm->ap_wpa_ie) {
			_WPA_PRINTF((MSG_INFO, "WPA: No WPA IE in " \
			 "Beacon/ProbeResp" ));
		}
		_WPA_HEXDUMP((MSG_INFO, "WPA: WPA IE in 3/4 msg" , wpa_ie, wpa_ie_len));
	}
	if (sm->ap_rsn_ie) {
		_WPA_HEXDUMP((MSG_INFO, "WPA: RSN IE in Beacon/ProbeResp" , sm->ap_rsn_ie, sm->ap_rsn_ie_len));
	}
	if (rsn_ie) {
		if (!sm->ap_rsn_ie) {
			_WPA_PRINTF((MSG_INFO, "WPA: No RSN IE in " \
			 "Beacon/ProbeResp" ));
		}
		_WPA_HEXDUMP((MSG_INFO, "WPA: RSN IE in 3/4 msg" , rsn_ie, rsn_ie_len));
	}
	sm->ctx->disassociate((void  __far * )(sm->ctx->ctx), (int  )(REASON_IE_IN_4WAY_DIFFERS));
	sm->ctx->req_scan((void  __far * )(sm->ctx->ctx), (int  )(0), (int  )(0));
}

/*** BeginHeader _wpa_s19_wpaS_validate_ie */
// From "wpa.c":1911
int _wpa_s19_wpaS_validate_ie(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                        struct wpa_eapol_ie_parse __far * ie);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_validate_ie(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                        struct wpa_eapol_ie_parse __far * ie) {
	struct wpa_ssid __far * ssid /* = sm->cur_ssid */; 	// From "wpa.c":1915

	ssid = sm->cur_ssid;

	if (sm->ap_wpa_ie==((void  __far * )0) &&
	sm->ap_rsn_ie==((void  __far * )0)) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: No WPA/RSN IE for this AP known. " \
		 "Trying to get from scan results" ));
		if (sm->ctx->get_beacon_ie((void  __far * )(sm->ctx->ctx))<0) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Could not find AP from " \
			 "the scan results" ));
		}
		else {
			_WPA_PRINTF((MSG_DEBUG, "WPA: Found the current AP from " \
			 "updated scan results" ));
		}
	}
	if (ie->wpa_ie==((void  __far * )0) &&
	ie->rsn_ie==((void  __far * )0) &&
	(sm->ap_wpa_ie ||
	sm->ap_rsn_ie)) {
		_wpa_s19_wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match " \
		 "with IE in Beacon/ProbeResp (no IE?)" , src_addr, ie->wpa_ie, ie->wpa_ie_len,
                                  ie->rsn_ie, ie->rsn_ie_len);
		return  -1;
	}
	if ((ie->wpa_ie &&
	sm->ap_wpa_ie &&
	(ie->wpa_ie_len!=sm->ap_wpa_ie_len ||
	memcmp(ie->wpa_ie, sm->ap_wpa_ie, ie->wpa_ie_len)!=0)) ||
	(ie->rsn_ie &&
	sm->ap_rsn_ie &&
	(ie->rsn_ie_len!=sm->ap_rsn_ie_len ||
	memcmp(ie->rsn_ie, sm->ap_rsn_ie, ie->rsn_ie_len)!=0))) {
		_wpa_s19_wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match " \
		 "with IE in Beacon/ProbeResp" , src_addr, ie->wpa_ie, ie->wpa_ie_len, ie->rsn_ie,
                                  ie->rsn_ie_len);
		return  -1;
	}
	if (sm->proto==WPA_PROTO_WPA &&
	ie->rsn_ie &&
	sm->ap_rsn_ie==((void  __far * )0) &&
	ssid &&
	(ssid->proto&WPA_PROTO_RSN)) {
		_wpa_s19_wpa_report_ie_mismatch(sm, "Possible downgrade attack " \
		 "detected - RSN was enabled and RSN IE " \
		 "was in msg 3/4, but not in " \
		 "Beacon/ProbeResp" , src_addr, ie->wpa_ie, ie->wpa_ie_len, ie->rsn_ie, ie->rsn_ie_len);
		return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_send_4_of_4 */
// From "wpa.c":1967
int _wpa_s19_wpaS_send_4_of_4(struct wpa_sm __far * sm, unsigned char __far * dst,
                                        struct wpa_eapol_key __far * key, word ver,
                                        word key_info, char __far * kde, size_t kde_len,
                                        struct wpa_ptk __far * ptk);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_send_4_of_4(struct wpa_sm __far * sm, unsigned char __far * dst,
                                        struct wpa_eapol_key __far * key, word ver,
                                        word key_info, char __far * kde, size_t kde_len,
                                        struct wpa_ptk __far * ptk) {
	size_t rlen; 	// From "wpa.c":1974
	struct wpa_eapol_key __far * reply; 	// From "wpa.c":1975
	char __far * rbuf; 	// From "wpa.c":1976


	if (kde)
		_WPA_HEXDUMP((MSG_DEBUG, "WPA: KDE for msg 4/4" , kde, kde_len));
	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*reply)
                                                                         +kde_len),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&reply));
	if (rbuf==((void  __far * )0))
		return  -1;
	reply->type = sm->proto==WPA_PROTO_RSN ?
	  EAPOL_KEY_TYPE_RSN :
	  EAPOL_KEY_TYPE_WPA;
	key_info &= WPA_KEY_INFO_SECURE;
	key_info |= ver|WPA_KEY_INFO_KEY_TYPE|WPA_KEY_INFO_MIC;
	do {
		(reply->key_info)[0] = ((word  )(key_info))>>8;
		(reply->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	if (sm->proto==WPA_PROTO_RSN)
		do {
			(reply->key_length)[0] = ((word  )(0))>>8;
			(reply->key_length)[1] = ((word  )(0))&0xff;
		} while (0);
	else
		_f_memcpy(reply->key_length, key->key_length, 2);
	_f_memcpy(reply->replay_counter, key->replay_counter, 8);
	do {
		(reply->key_data_length)[0] = ((word  )(kde_len))>>8;
		(reply->key_data_length)[1] = ((word  )(kde_len))&0xff;
	} while (0);
	if (kde)
		_f_memcpy(reply+1, kde, kde_len);
	_WPA_PRINTF((MSG_DEBUG, "WPA: Sending EAPOL-Key 4/4" ));
	_wpa_s19_wpa_eapol_key_send(sm, ptk->kck, ver, dst, ETH_P_EAPOL, rbuf, rlen, reply->key_mic);
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_3_of_4 */
// From "wpa.c":2011
void _wpa_s19_wpaS_process_3_of_4(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                            word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_3_of_4(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                            word ver) {
	word key_info; 	// From "wpa.c":2015
	word keylen; 	// From "wpa.c":2015
	word len; 	// From "wpa.c":2015
	char __far * pos; 	// From "wpa.c":2016
	struct wpa_eapol_ie_parse ie; 	// From "wpa.c":2017


	sm->ctx->set_state((void  __far * )(sm->ctx->ctx), (wpa_states  )(WPA_4WAY_HANDSHAKE));
	_WPA_PRINTF((MSG_DEBUG, "WPA: RX message 3 of 4-Way Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (sm->bssid)[0], (sm->bssid)[1], (sm->bssid)[2], (sm->bssid)[3],
              (sm->bssid)[4], (sm->bssid)[5], ver));
	key_info = ((word  )(((key->key_info)[0]<<8)|(key->key_info)[1]));
	pos = (char  __far * )(key+1);
	len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: IE KeyData" , pos, len));
	_wpa_s19_wpaS_parse_ies(pos, len, &ie);
	if (ie.gtk &&
	!(key_info&(1<<(12)))) {
		_WPA_PRINTF((MSG_WARNING, "WPA: GTK IE in unencrypted key data" ));
		return /*void*/;
	}
	if (_wpa_s19_wpaS_validate_ie(sm, sm->bssid, &ie)<0)
		return /*void*/;
	if (memcmp(sm->anonce, key->key_nonce, WPA_NONCE_LEN)!=0) {
		_WPA_PRINTF((MSG_WARNING, "WPA: ANonce from message 1 of 4-Way " \
		 "Handshake differs from 3 of 4-Way Handshake - drop" \
		 " packet (src=" \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 ")" , (sm->bssid)[0], (sm->bssid)[1], (sm->bssid)[2], (sm->bssid)[3], (sm->bssid)[4],
               (sm->bssid)[5]));
		return /*void*/;
	}
	keylen = ((word  )(((key->key_length)[0]<<8)|(key->key_length)[1]));
	switch ((int)(sm->pairwise_cipher)) {
		case WPA_CIPHER_CCMP:
		if (keylen!=16) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Invalid CCMP key length " \
			 "%d (src=" \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 ")" , keylen, (sm->bssid)[0], (sm->bssid)[1], (sm->bssid)[2], (sm->bssid)[3],
                (sm->bssid)[4], (sm->bssid)[5]));
			return /*void*/;
		}
		break;
		case WPA_CIPHER_TKIP:
		if (keylen!=32) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Invalid TKIP key length " \
			 "%d (src=" \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 ")" , keylen, (sm->bssid)[0], (sm->bssid)[1], (sm->bssid)[2], (sm->bssid)[3],
                (sm->bssid)[4], (sm->bssid)[5]));
			return /*void*/;
		}
		break;
	}
	if (_wpa_s19_wpaS_send_4_of_4(sm, sm->bssid, key, ver, key_info, ((void  __far * )0),
                                         0, &sm->ptk))
		return /*void*/;
	sm->renew_snonce = 1;
	if (key_info&WPA_KEY_INFO_INSTALL) {
		_wpa_s19_wpaS_install_ptk(sm, key);
	}
	if (key_info&WPA_KEY_INFO_SECURE) {
		sm->ctx->mlme_setprotection((void  __far * )(sm->ctx->ctx), (char  __far * )(sm->bssid),
                              (int  )(1), (int  )(1));
#ifdef WPA_USE_EAP
		eapol_sm_notify_portValid(sm->eapol, TRUE);
#endif//def WPA_USE_EAP
	}
	sm->ctx->set_state((void  __far * )(sm->ctx->ctx), (wpa_states  )(WPA_GROUP_HANDSHAKE));
	if (ie.gtk &&
	_wpa_s19_wpaS_pairwise_gtk(sm, key, ie.gtk, ie.gtk_len, key_info)<0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to configure GTK" ));
	}
	if (_wpa_s19_ieee80211w_set_keys(sm, &ie)<0)
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to configure DHV/IGTK" ));
}

/*** BeginHeader _wpa_s19_wpaS_smk_timeout */
// From "wpa.c":2116
void _wpa_s19_wpaS_smk_timeout(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_smk_timeout(void __far * eloop_ctx, void __far * timeout_ctx) {
}

/*** BeginHeader _wpa_s19_wpaS_peerkey_free */
// From "wpa.c":2126
void _wpa_s19_wpaS_peerkey_free(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_peerkey_free(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey) {
	eloop_cancel_timeout(_wpa_s19_wpaS_smk_timeout, sm, peerkey);
	_sys_free(peerkey);
}

/*** BeginHeader _wpa_s19_wpaS_send_smk_error */
// From "wpa.c":2134
int _wpa_s19_wpaS_send_smk_error(struct wpa_sm __far * sm, char __far * dst,
                                           char __far * peer, word mui, word error_type,
                                           int ver);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_send_smk_error(struct wpa_sm __far * sm, char __far * dst,
                                           char __far * peer, word mui, word error_type,
                                           int ver) {
	size_t rlen; 	// From "wpa.c":2139
	struct wpa_eapol_key __far * err; 	// From "wpa.c":2140
	struct rsn_error_kde error; 	// From "wpa.c":2141
	char __far * rbuf; 	// From "wpa.c":2142
	char __far * pos; 	// From "wpa.c":2142
	size_t kde_len; 	// From "wpa.c":2143
	word key_info; 	// From "wpa.c":2144


	kde_len = 2+RSN_SELECTOR_LEN+sizeof (error);
	if (peer)
		kde_len += 2+RSN_SELECTOR_LEN+6;
	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*err)
                                                                         +kde_len),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&err));
	if (rbuf==((void  __far * )0))
		return  -1;
	err->type = EAPOL_KEY_TYPE_RSN;
	key_info = ver|(1<<(13))|WPA_KEY_INFO_MIC|WPA_KEY_INFO_SECURE|(1<<(10))|(1<<(11));
	do {
		(err->key_info)[0] = ((word  )(key_info))>>8;
		(err->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	do {
		(err->key_length)[0] = ((word  )(0))>>8;
		(err->key_length)[1] = ((word  )(0))&0xff;
	} while (0);
	_f_memcpy(err->replay_counter, sm->request_counter, 8);
	inc_byte_array(sm->request_counter, 8);
	do {
		(err->key_data_length)[0] = ((word  )((word  )kde_len))>>8;
		(err->key_data_length)[1] = ((word  )((word  )kde_len))&0xff;
	} while (0);
	pos = (char  __far * )(err+1);
	if (peer) {
		pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_MAC_ADDR, peer,
                             6);
	}
	error.mui = intel16(mui);
	error.error_type = intel16(error_type);
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_ERROR, (char  __far * )&error,
                            sizeof (error));
	if (peer) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error (peer " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 " mui %d error_type %d)" , (peer)[0], (peer)[1], (peer)[2], (peer)[3], (peer)[4],
               (peer)[5], mui, error_type));
	}
	else {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error " \
		 "(mui %d error_type %d)" , mui, error_type));
	}
	_wpa_s19_wpa_eapol_key_send(sm, sm->ptk.kck, ver, dst, ETH_P_EAPOL, rbuf, rlen,
                             err->key_mic);
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_send_smk_m3 */
// From "wpa.c":2199
int _wpa_s19_wpaS_send_smk_m3(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                        struct wpa_eapol_key __far * key, int ver,
                                        struct wpa_peerkey __far * peerkey);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_send_smk_m3(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                        struct wpa_eapol_key __far * key, int ver,
                                        struct wpa_peerkey __far * peerkey) {
	size_t rlen; 	// From "wpa.c":2204
	struct wpa_eapol_key __far * reply; 	// From "wpa.c":2205
	char __far * rbuf; 	// From "wpa.c":2206
	char __far * pos; 	// From "wpa.c":2206
	size_t kde_len; 	// From "wpa.c":2207
	word key_info; 	// From "wpa.c":2208


	kde_len = peerkey->rsnie_p_len+2+RSN_SELECTOR_LEN+6+2+RSN_SELECTOR_LEN
           +WPA_NONCE_LEN;
	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*reply)
                                                                         +kde_len),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&reply));
	if (rbuf==((void  __far * )0))
		return  -1;
	reply->type = EAPOL_KEY_TYPE_RSN;
	key_info = ver|(1<<(13))|WPA_KEY_INFO_MIC|WPA_KEY_INFO_SECURE;
	do {
		(reply->key_info)[0] = ((word  )(key_info))>>8;
		(reply->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	do {
		(reply->key_length)[0] = ((word  )(0))>>8;
		(reply->key_length)[1] = ((word  )(0))&0xff;
	} while (0);
	_f_memcpy(reply->replay_counter, key->replay_counter, 8);
	_f_memcpy(reply->key_nonce, peerkey->pnonce, WPA_NONCE_LEN);
	do {
		(reply->key_data_length)[0] = ((word  )((word  )kde_len))>>8;
		(reply->key_data_length)[1] = ((word  )((word  )kde_len))&0xff;
	} while (0);
	pos = (char  __far * )(reply+1);
	pos = _wpa_s19_wpa_add_ie(pos, peerkey->rsnie_p, peerkey->rsnie_p_len);
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_MAC_ADDR, peerkey->addr,
                            6);
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_NONCE, peerkey->inonce,
                            WPA_NONCE_LEN);
	_WPA_PRINTF((MSG_DEBUG, "RSN: Sending EAPOL-Key SMK M3" ));
	_wpa_s19_wpa_eapol_key_send(sm, sm->ptk.kck, ver, src_addr, ETH_P_EAPOL, rbuf,
                             rlen, reply->key_mic);
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_smk_m2 */
// From "wpa.c":2252
int _wpa_s19_wpaS_process_smk_m2(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                           struct wpa_eapol_key __far * key, size_t extra_len,
                                           int ver);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_process_smk_m2(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                           struct wpa_eapol_key __far * key, size_t extra_len,
                                           int ver) {
	struct wpa_ssid __far * ssid /* = sm->cur_ssid */; 	// From "wpa.c":2256
	struct wpa_peerkey __far * peerkey; 	// From "wpa.c":2257
	struct wpa_eapol_ie_parse kde; 	// From "wpa.c":2258
	struct wpa_ie_data ie; 	// From "wpa.c":2259
	int cipher; 	// From "wpa.c":2260
	struct rsn_ie_hdr __far * hdr; 	// From "wpa.c":2261
	char __far * pos; 	// From "wpa.c":2262

	ssid = sm->cur_ssid;

	_WPA_PRINTF((MSG_DEBUG, "RSN: Received SMK M2" ));
	if (ssid==((void  __far * )0) ||
	!ssid->peerkey ||
	sm->proto!=WPA_PROTO_RSN) {
		_WPA_PRINTF((MSG_INFO, "RSN: SMK handshake not allowed for " \
		 "the current network" ));
		return  -1;
	}
	if (_wpa_s19_wpaS_parse_ies((char  __far * )(key+1), extra_len, &kde)<0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to parse KDEs in SMK M2" ));
		return  -1;
	}
	if (kde.rsn_ie==((void  __far * )0) ||
	kde.mac_addr==((void  __far * )0) ||
	kde.mac_addr_len<6) {
		_WPA_PRINTF((MSG_INFO, "RSN: No RSN IE or MAC address KDE in " \
		 "SMK M2" ));
		return  -1;
	}
	_WPA_PRINTF((MSG_DEBUG, "RSN: SMK M2 - SMK initiator " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (kde.mac_addr)[0], (kde.mac_addr)[1], (kde.mac_addr)[2],
              (kde.mac_addr)[3], (kde.mac_addr)[4], (kde.mac_addr)[5]));
	if (kde.rsn_ie_len>PEERKEY_MAX_IE_LEN) {
		_WPA_PRINTF((MSG_INFO, "RSN: Too long Initiator RSN IE in SMK " \
		 "M2" ));
		return  -1;
	}
	if (_wpa_s19_wpa_parse_wpa_ie_rsn(kde.rsn_ie, kde.rsn_ie_len, &ie)<0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to parse RSN IE in SMK M2" ));
		return  -1;
	}
	cipher = ie.pairwise_cipher&ssid->pairwise_cipher;
	if (cipher&WPA_CIPHER_CCMP) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Using CCMP for PeerKey" ));
		cipher = WPA_CIPHER_CCMP;
	}
	else if (cipher&WPA_CIPHER_TKIP) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Using TKIP for PeerKey" ));
		cipher = WPA_CIPHER_TKIP;
	}
	else {
		_WPA_PRINTF((MSG_INFO, "RSN: No acceptable cipher in SMK M2" ));
		_wpa_s19_wpaS_send_smk_error(sm, src_addr, kde.mac_addr, STK_MUI_SMK,
                                         STK_ERR_CPHR_NS, ver);
		return  -1;
	}
	peerkey = _sys_malloc(sizeof (*peerkey));
	if (peerkey==((void  __far * )0))
		return  -1;
	_f_memset(peerkey, 0, sizeof (*peerkey));
	_f_memcpy(peerkey->addr, kde.mac_addr, 6);
	_f_memcpy(peerkey->inonce, key->key_nonce, WPA_NONCE_LEN);
	_f_memcpy(peerkey->rsnie_i, kde.rsn_ie, kde.rsn_ie_len);
	peerkey->rsnie_i_len = kde.rsn_ie_len;
	peerkey->cipher = cipher;
	if (os_get_random(peerkey->pnonce, WPA_NONCE_LEN)) {
		_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "WPA: Failed to %s", "get random data for PNonce" ));
		_wpa_s19_wpaS_peerkey_free(sm, peerkey);
		return  -1;
	}
	hdr = (struct rsn_ie_hdr  __far * )peerkey->rsnie_p;
	hdr->elem_id = RSN_INFO_ELEM;
	do {
		(hdr->version)[1] = ((word  )(RSN_VERSION))>>8;
		(hdr->version)[0] = ((word  )(RSN_VERSION))&0xff;
	} while (0);
	pos = (char  __far * )(hdr+1);
	_f_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	pos += RSN_SELECTOR_LEN;
	do {
		(pos)[1] = ((word  )(1))>>8;
		(pos)[0] = ((word  )(1))&0xff;
	} while (0);
	pos += 2;
	if (cipher==WPA_CIPHER_CCMP)
		_f_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	else if (cipher==WPA_CIPHER_TKIP)
		_f_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
	pos += RSN_SELECTOR_LEN;
	hdr->len = ((_x509_ptrdiff_t)(pos-peerkey->rsnie_p))-2;
	peerkey->rsnie_p_len = (_x509_ptrdiff_t)(pos-peerkey->rsnie_p);
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: RSN IE for SMK handshake" , peerkey->rsnie_p, peerkey->rsnie_p_len));
	_wpa_s19_wpaS_send_smk_m3(sm, src_addr, key, ver, peerkey);
	peerkey->next = sm->peerkey;
	sm->peerkey = peerkey;
	return 0;
}

/*** BeginHeader _wpa_s19_rsn_smkid */
// From "wpa.c":2376
void _wpa_s19_rsn_smkid(char __far * smk, char __far * pnonce, char __far * mac_p, char __far * inonce,
                        char __far * mac_i, char __far * smkid);
/*** EndHeader */
_wpa_debug
void _wpa_s19_rsn_smkid(char __far * smk, char __far * pnonce, char __far * mac_p, char __far * inonce,
                        char __far * mac_i, char __far * smkid) {
	char __far * title /* = "SMK Name"  */; 	// From "wpa.c":2379
	char __far * addr[5]; 	// From "wpa.c":2380
   //  Rabbit note: Making initialized array const static
	static const size_t len[5] =
	{
		8,
		WPA_NONCE_LEN,
		6,
		WPA_NONCE_LEN,
		6
	}; 	// From "wpa.c":2382
	unsigned char hash[SHA1_MAC_LEN]; 	// From "wpa.c":2383

	title = "SMK Name" ;
/*	len =
	{
		8,
		WPA_NONCE_LEN,
		6,
		WPA_NONCE_LEN,
		6
	};*/

	addr[0] = (char  __far * )title;
	addr[1] = pnonce;
	addr[2] = mac_p;
	addr[3] = inonce;
	addr[4] = mac_i;
	hmac_sha1_vector(smk, PMK_LEN, 5, addr, len, hash);
	_f_memcpy(smkid, hash, PMKID_LEN);
}

/*** BeginHeader _wpa_s19_wpaS_send_stk_1_of_4 */
// From "wpa.c":2396
void _wpa_s19_wpaS_send_stk_1_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_send_stk_1_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey) {
	size_t mlen; 	// From "wpa.c":2399
	struct wpa_eapol_key __far * msg; 	// From "wpa.c":2400
	char __far * mbuf; 	// From "wpa.c":2401
	size_t kde_len; 	// From "wpa.c":2402
	word key_info; 	// From "wpa.c":2403
	word ver; 	// From "wpa.c":2403


	kde_len = 2+RSN_SELECTOR_LEN+PMKID_LEN;
	mbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*msg)
                                                                         +kde_len),
                             (size_t  __far * )(&mlen), (void  __far * __far * )((void  __far * )&msg));
	if (mbuf==((void  __far * )0))
		return /*void*/;
	msg->type = EAPOL_KEY_TYPE_RSN;
	if (peerkey->cipher==WPA_CIPHER_CCMP)
		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
	else
		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
	key_info = ver|WPA_KEY_INFO_KEY_TYPE|WPA_KEY_INFO_ACK;
	do {
		(msg->key_info)[0] = ((word  )(key_info))>>8;
		(msg->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	if (peerkey->cipher==WPA_CIPHER_CCMP)
		do {
			(msg->key_length)[0] = ((word  )(16))>>8;
			(msg->key_length)[1] = ((word  )(16))&0xff;
		} while (0);
	else
		do {
			(msg->key_length)[0] = ((word  )(32))>>8;
			(msg->key_length)[1] = ((word  )(32))&0xff;
		} while (0);
	_f_memcpy(msg->replay_counter, peerkey->replay_counter, 8);
	inc_byte_array(peerkey->replay_counter, 8);
	do {
		(msg->key_data_length)[0] = ((word  )(kde_len))>>8;
		(msg->key_data_length)[1] = ((word  )(kde_len))&0xff;
	} while (0);
	_wpa_s19_wpa_add_kde((char  __far * )(msg+1), RSN_KEY_DATA_PMKID,
                      peerkey->smkid, PMKID_LEN);
	if (os_get_random(peerkey->inonce, WPA_NONCE_LEN)) {
		_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "RSN: Failed to get random data for INonce (STK)" ));
		_sys_free(mbuf);
		return /*void*/;
	}
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: INonce for STK 4-Way Handshake" , peerkey->inonce,
               WPA_NONCE_LEN));
	_f_memcpy(msg->key_nonce, peerkey->inonce, WPA_NONCE_LEN);
	_WPA_PRINTF((MSG_DEBUG, "RSN: Sending EAPOL-Key STK %d/4 to " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , 1, (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2],
              (peerkey->addr)[3], (peerkey->addr)[4], (peerkey->addr)[5]));
	_wpa_s19_wpa_eapol_key_send(sm, ((void  __far * )0), ver, peerkey->addr, ETH_P_EAPOL,
                             mbuf, mlen, ((void  __far * )0));
}

/*** BeginHeader _wpa_s19_wpaS_send_stk_3_of_4 */
// From "wpa.c":2453
void _wpa_s19_wpaS_send_stk_3_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_send_stk_3_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey) {
	size_t mlen; 	// From "wpa.c":2456
	struct wpa_eapol_key __far * msg; 	// From "wpa.c":2457
	char __far * mbuf; 	// From "wpa.c":2458
	char __far * pos; 	// From "wpa.c":2458
	size_t kde_len; 	// From "wpa.c":2459
	word key_info; 	// From "wpa.c":2460
	word ver; 	// From "wpa.c":2460
	longword lifetime; 	// From "wpa.c":2461


	kde_len = peerkey->rsnie_i_len+2+RSN_SELECTOR_LEN+sizeof (lifetime);
	mbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*msg)
                                                                         +kde_len),
                             (size_t  __far * )(&mlen), (void  __far * __far * )((void  __far * )&msg));
	if (mbuf==((void  __far * )0))
		return /*void*/;
	msg->type = EAPOL_KEY_TYPE_RSN;
	if (peerkey->cipher==WPA_CIPHER_CCMP)
		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
	else
		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
	key_info = ver|WPA_KEY_INFO_KEY_TYPE|WPA_KEY_INFO_ACK|WPA_KEY_INFO_MIC|WPA_KEY_INFO_SECURE;
	do {
		(msg->key_info)[0] = ((word  )(key_info))>>8;
		(msg->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	if (peerkey->cipher==WPA_CIPHER_CCMP)
		do {
			(msg->key_length)[0] = ((word  )(16))>>8;
			(msg->key_length)[1] = ((word  )(16))&0xff;
		} while (0);
	else
		do {
			(msg->key_length)[0] = ((word  )(32))>>8;
			(msg->key_length)[1] = ((word  )(32))&0xff;
		} while (0);
	_f_memcpy(msg->replay_counter, peerkey->replay_counter, 8);
	inc_byte_array(peerkey->replay_counter, 8);
	do {
		(msg->key_data_length)[0] = ((word  )(kde_len))>>8;
		(msg->key_data_length)[1] = ((word  )(kde_len))&0xff;
	} while (0);
	pos = (char  __far * )(msg+1);
	pos = _wpa_s19_wpa_add_ie(pos, peerkey->rsnie_i, peerkey->rsnie_i_len);
	lifetime = intel(peerkey->lifetime);
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_LIFETIME, (char  __far * )&lifetime,
                            sizeof (lifetime));
	_f_memcpy(msg->key_nonce, peerkey->inonce, WPA_NONCE_LEN);
	_WPA_PRINTF((MSG_DEBUG, "RSN: Sending EAPOL-Key STK %d/4 to " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , 3, (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2],
              (peerkey->addr)[3], (peerkey->addr)[4], (peerkey->addr)[5]));
	_wpa_s19_wpa_eapol_key_send(sm, peerkey->stk.kck, ver, peerkey->addr, ETH_P_EAPOL,
                             mbuf, mlen, msg->key_mic);
}

/*** BeginHeader _wpa_s19_wpaS_process_smk_m45 */
// From "wpa.c":2508
int _wpa_s19_wpaS_process_smk_m45(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                            struct wpa_eapol_key __far * key, size_t extra_len,
                                            int ver);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_process_smk_m45(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                            struct wpa_eapol_key __far * key, size_t extra_len,
                                            int ver) {
	struct wpa_ssid __far * ssid /* = sm->cur_ssid */; 	// From "wpa.c":2512
	struct wpa_peerkey __far * peerkey; 	// From "wpa.c":2513
	struct wpa_eapol_ie_parse kde; 	// From "wpa.c":2514
	longword lifetime; 	// From "wpa.c":2515
	struct os_time now; 	// From "wpa.c":2516
	struct wpa_ie_data ie; 	// From "wpa.c":2517

	union  {

		struct  {
			int cipher;

		} __s6;

	} __u; 	// From "wpa.c":2511

	ssid = sm->cur_ssid;

	if (ssid==((void  __far * )0) ||
	!ssid->peerkey ||
	sm->proto!=WPA_PROTO_RSN) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: SMK handshake not allowed for " \
		 "the current network" ));
		return  -1;
	}
	if (_wpa_s19_wpaS_parse_ies((char  __far * )(key+1), extra_len, &kde)<0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to parse KDEs in SMK M4/M5" ));
		return  -1;
	}
	if (kde.mac_addr==((void  __far * )0) ||
	kde.mac_addr_len<6 ||
	kde.nonce==((void  __far * )0) ||
	kde.nonce_len<WPA_NONCE_LEN ||
	kde.smk==((void  __far * )0) ||
	kde.smk_len<PMK_LEN+WPA_NONCE_LEN ||
	kde.lifetime==((void  __far * )0) ||
	kde.lifetime_len<4) {
		_WPA_PRINTF((MSG_INFO, "RSN: No MAC Address, Nonce, SMK, or " \
		 "Lifetime KDE in SMK M4/M5" ));
		return  -1;
	}
	for (peerkey = sm->peerkey; peerkey; peerkey = peerkey->next) {
		if (memcmp(peerkey->addr, kde.mac_addr, 6)==0 &&
		memcmp(peerkey->initiator ?
		  peerkey->inonce :
		  peerkey->pnonce, key->key_nonce, WPA_NONCE_LEN)==0)
			break;
	}
	if (peerkey==((void  __far * )0)) {
		_WPA_PRINTF((MSG_INFO, "RSN: No matching SMK handshake found " \
		 "for SMK M4/M5: peer " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" , (kde.mac_addr)[0], (kde.mac_addr)[1], (kde.mac_addr)[2],
               (kde.mac_addr)[3], (kde.mac_addr)[4], (kde.mac_addr)[5]));
		return  -1;
	}
	if (peerkey->initiator) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Received SMK M5 (Peer " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 ")" , (kde.mac_addr)[0], (kde.mac_addr)[1], (kde.mac_addr)[2], (kde.mac_addr)[3],
               (kde.mac_addr)[4], (kde.mac_addr)[5]));
		if (kde.rsn_ie==((void  __far * )0) ||
		kde.rsn_ie_len>PEERKEY_MAX_IE_LEN ||
		_wpa_s19_wpa_parse_wpa_ie_rsn(kde.rsn_ie, kde.rsn_ie_len, &ie)<0) {
			_WPA_PRINTF((MSG_INFO, "RSN: No RSN IE in SMK M5" ));
			return  -1;
		}
		if (memcmp(key->key_nonce, peerkey->inonce, WPA_NONCE_LEN)!=0) {
			_WPA_PRINTF((MSG_INFO, "RSN: Key Nonce in SMK M5 does " \
			 "not match with INonce used in SMK M1" ));
			return  -1;
		}
		if (memcmp(kde.smk+PMK_LEN, peerkey->inonce, WPA_NONCE_LEN)!=0) {
			_WPA_PRINTF((MSG_INFO, "RSN: INonce in SMK KDE does not " \
			 "match with the one used in SMK M1" ));
			return  -1;
		}
		_f_memcpy(peerkey->rsnie_p, kde.rsn_ie, kde.rsn_ie_len);
		peerkey->rsnie_p_len = kde.rsn_ie_len;
		_f_memcpy(peerkey->pnonce, kde.nonce, WPA_NONCE_LEN);
		__u.__s6.cipher = ie.pairwise_cipher&ssid->pairwise_cipher;
		if (__u.__s6.cipher&WPA_CIPHER_CCMP) {
			_WPA_PRINTF((MSG_DEBUG, "RSN: Using CCMP for PeerKey" ));
			peerkey->cipher = WPA_CIPHER_CCMP;
		}
		else if (__u.__s6.cipher&WPA_CIPHER_TKIP) {
			_WPA_PRINTF((MSG_DEBUG, "RSN: Using TKIP for PeerKey" ));
			peerkey->cipher = WPA_CIPHER_TKIP;
		}
		else {
			_WPA_PRINTF((MSG_INFO, "RSN: SMK Peer STA " \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 " selected unacceptable cipher" , (kde.mac_addr)[0], (kde.mac_addr)[1], (kde.mac_addr)[2],
                (kde.mac_addr)[3], (kde.mac_addr)[4], (kde.mac_addr)[5]));
			_wpa_s19_wpaS_send_smk_error(sm, src_addr, kde.mac_addr, STK_MUI_SMK,
                                          STK_ERR_CPHR_NS, ver);
			return  -1;
		}
	}
	else {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Received SMK M4 (Initiator " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 ")" , (kde.mac_addr)[0], (kde.mac_addr)[1], (kde.mac_addr)[2], (kde.mac_addr)[3],
               (kde.mac_addr)[4], (kde.mac_addr)[5]));
		if (memcmp(kde.smk+PMK_LEN, peerkey->pnonce, WPA_NONCE_LEN)!=0) {
			_WPA_PRINTF((MSG_INFO, "RSN: PNonce in SMK KDE does not " \
			 "match with the one used in SMK M3" ));
			return  -1;
		}
		if (memcmp(kde.nonce, peerkey->inonce, WPA_NONCE_LEN)!=0) {
			_WPA_PRINTF((MSG_INFO, "RSN: INonce in SMK M5 did not " \
			 "match with the one received in SMK M2" ));
			return  -1;
		}
	}
	_f_memcpy(peerkey->smk, kde.smk, PMK_LEN);
	peerkey->smk_complete = 1;
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: SMK" , peerkey->smk, PMK_LEN));
	lifetime = ((((longword  )(kde.lifetime)[0])<<24)|(((longword  )(kde.lifetime)[1])<<16)|(((longword  )(kde.lifetime)[2])
                                                                                <<8)
             |((longword  )(kde.lifetime)[3]));
	_WPA_PRINTF((MSG_DEBUG, "RSN: SMK lifetime %u seconds" , lifetime));
	if (lifetime>1000000000)
		lifetime = 1000000000;
	peerkey->lifetime = lifetime;
	os_get_time(&now);
	peerkey->expiration = now.sec+lifetime;
	eloop_register_timeout(lifetime<<10, _wpa_s19_wpaS_smk_timeout, sm, peerkey);
	if (peerkey->initiator) {
		_wpa_s19_rsn_smkid(peerkey->smk, peerkey->pnonce, peerkey->addr, peerkey->inonce,
                     sm->own_addr, peerkey->smkid);
		_wpa_s19_wpaS_send_stk_1_of_4(sm, peerkey);
	}
	else {
		_wpa_s19_rsn_smkid(peerkey->smk, peerkey->pnonce, sm->own_addr, peerkey->inonce,
                     peerkey->addr, peerkey->smkid);
	}
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: SMKID" , peerkey->smkid, PMKID_LEN));
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_smk_error */
// From "wpa.c":2647
int _wpa_s19_wpaS_process_smk_error(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                              struct wpa_eapol_key __far * key, size_t extra_len);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_process_smk_error(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                              struct wpa_eapol_key __far * key, size_t extra_len) {
	struct wpa_ssid __far * ssid /* = sm->cur_ssid */; 	// From "wpa.c":2651
	struct wpa_eapol_ie_parse kde; 	// From "wpa.c":2652
	struct rsn_error_kde error; 	// From "wpa.c":2653
	char peer[6]; 	// From "wpa.c":2654
	word error_type; 	// From "wpa.c":2655

	union  {

		struct  {
			struct wpa_peerkey __far * peerkey;

		} __s4;

	} __u; 	// From "wpa.c":2650

	ssid = sm->cur_ssid;

	_WPA_PRINTF((MSG_DEBUG, "RSN: Received SMK Error" ));
	if (ssid==((void  __far * )0) ||
	!ssid->peerkey ||
	sm->proto!=WPA_PROTO_RSN) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: SMK handshake not allowed for " \
		 "the current network" ));
		return  -1;
	}
	if (_wpa_s19_wpaS_parse_ies((char  __far * )(key+1), extra_len, &kde)<0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to parse KDEs in SMK Error" ));
		return  -1;
	}
	if (kde.error==((void  __far * )0) ||
	kde.error_len<sizeof (error)) {
		_WPA_PRINTF((MSG_INFO, "RSN: No Error KDE in SMK Error" ));
		return  -1;
	}
	if (kde.mac_addr &&
	kde.mac_addr_len>=6)
		_f_memcpy(peer, kde.mac_addr, 6);
	_f_memcpy(&error, kde.error, sizeof (error));
	error_type = intel16(error.error_type);
	_WPA_MSG((sm->ctx->ctx, MSG_INFO, "RSN: SMK Error KDE received: MUI %d error_type %d peer " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , intel16(error.mui), error_type, (peer)[0], (peer)[1],
           (peer)[2], (peer)[3], (peer)[4], (peer)[5]));
	if (kde.mac_addr &&
	(error_type==STK_ERR_STA_NR ||
	error_type==STK_ERR_STA_NRSN ||
	error_type==STK_ERR_CPHR_NS)) {
		for (__u.__s4.peerkey = sm->peerkey; __u.__s4.peerkey; __u.__s4.peerkey = __u.__s4.peerkey->next) {
			if (memcmp(__u.__s4.peerkey->addr, kde.mac_addr, 6)==0)
				break;
		}
		if (__u.__s4.peerkey==((void  __far * )0)) {
			_WPA_PRINTF((MSG_DEBUG, "RSN: No matching SMK handshake " \
			 "found for SMK Error" ));
			return  -1;
		}
	}
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_stk_1_of_4 */
// From "wpa.c":2708
void _wpa_s19_wpaS_process_stk_1_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_stk_1_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver) {
	struct wpa_eapol_ie_parse ie; 	// From "wpa.c":2713
	char __far * kde; 	// From "wpa.c":2714
	size_t len; 	// From "wpa.c":2715
	size_t kde_buf_len; 	// From "wpa.c":2715
	struct wpa_ptk __far * stk; 	// From "wpa.c":2716
	char buf[8]; 	// From "wpa.c":2717
	char __far * kde_buf; 	// From "wpa.c":2717
	char __far * pos; 	// From "wpa.c":2717
	longword lifetime; 	// From "wpa.c":2718


	_WPA_PRINTF((MSG_DEBUG, "RSN: RX message 1 of STK 4-Way Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2], (peerkey->addr)[3],
              (peerkey->addr)[4], (peerkey->addr)[5], ver));
	_f_memset(&ie, 0, sizeof (ie));
	kde = (char  __far * )(key+1);
	len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: msg 1/4 key data" , kde, len));
	if (_wpa_s19_wpaS_parse_ies(kde, len, &ie)<0 ||
	ie.pmkid==((void  __far * )0)) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: No SMKID in STK 1/4" ));
		return /*void*/;
	}
	if (memcmp(ie.pmkid, peerkey->smkid, PMKID_LEN)!=0) {
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: Unknown SMKID in STK 1/4" , ie.pmkid, PMKID_LEN));
		return /*void*/;
	}
	if (os_get_random(peerkey->pnonce, WPA_NONCE_LEN)) {
		_WPA_MSG((sm->ctx->ctx, MSG_WARNING, "RSN: Failed to get random data for PNonce" ));
		return /*void*/;
	}
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: Renewed PNonce" , peerkey->pnonce, WPA_NONCE_LEN));
	stk = &peerkey->tstk;
	_wpa_s19_wpa_pmk_to_ptk(peerkey->smk, PMK_LEN, "Peer key expansion" , sm->own_addr,
                         peerkey->addr, peerkey->pnonce, key->key_nonce, (char  __far * )stk,
                         sizeof (*stk));
	_f_memcpy(buf, stk->u.auth.tx_mic_key, 8);
	_f_memcpy(stk->u.auth.tx_mic_key, stk->u.auth.rx_mic_key, 8);
	_f_memcpy(stk->u.auth.rx_mic_key, buf, 8);
	peerkey->tstk_set = 1;
	kde_buf_len = peerkey->rsnie_p_len+2+RSN_SELECTOR_LEN+sizeof (lifetime)
               +2+RSN_SELECTOR_LEN+PMKID_LEN;
	kde_buf = _sys_malloc(kde_buf_len);
	if (kde_buf==((void  __far * )0))
		return /*void*/;
	pos = kde_buf;
	pos = _wpa_s19_wpa_add_ie(pos, peerkey->rsnie_p, peerkey->rsnie_p_len);
	lifetime = intel(peerkey->lifetime);
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_LIFETIME, (char  __far * )&lifetime,
                            sizeof (lifetime));
	pos = _wpa_s19_wpa_add_kde(pos, RSN_KEY_DATA_PMKID, peerkey->smkid,
                            PMKID_LEN);
	if (_wpa_s19_wpaS_send_2_of_4(sm, peerkey->addr, key, ver, peerkey->pnonce,
                                         kde_buf, kde_buf_len, stk)) {
		_sys_free(kde_buf);
		return /*void*/;
	}
	_sys_free(kde_buf);
	_f_memcpy(peerkey->inonce, key->key_nonce, WPA_NONCE_LEN);
}

/*** BeginHeader _wpa_s19_wpaS_update_smk_lifetime */
// From "wpa.c":2785
void _wpa_s19_wpaS_update_smk_lifetime(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                 struct wpa_eapol_ie_parse __far * kde);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_update_smk_lifetime(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                 struct wpa_eapol_ie_parse __far * kde) {
	longword lifetime; 	// From "wpa.c":2789
	struct os_time now; 	// From "wpa.c":2790


	if (kde->lifetime==((void  __far * )0) ||
	kde->lifetime_len<sizeof (lifetime))
		return /*void*/;
	lifetime = ((((longword  )(kde->lifetime)[0])<<24)|(((longword  )(kde->lifetime)[1])<<16)
             |(((longword  )(kde->lifetime)[2])<<8)|((longword  )(kde->lifetime)[3]));
	if (lifetime>=peerkey->lifetime) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Peer used SMK lifetime %u seconds " \
		 "which is larger than or equal to own value %u " \
		 "seconds - ignored" , lifetime, peerkey->lifetime));
		return /*void*/;
	}
	_WPA_PRINTF((MSG_DEBUG, "RSN: Peer used shorter SMK lifetime %u seconds " \
	 "(own was %u seconds) - updated" , lifetime, peerkey->lifetime));
	peerkey->lifetime = lifetime;
	os_get_time(&now);
	peerkey->expiration = now.sec+lifetime;
	eloop_cancel_timeout(_wpa_s19_wpaS_smk_timeout, sm, peerkey);
	eloop_register_timeout(lifetime<<10, _wpa_s19_wpaS_smk_timeout, sm, peerkey);
}

/*** BeginHeader _wpa_s19_wpaS_process_stk_2_of_4 */
// From "wpa.c":2817
void _wpa_s19_wpaS_process_stk_2_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_stk_2_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver) {
	struct wpa_eapol_ie_parse kde; 	// From "wpa.c":2822
	char __far * keydata; 	// From "wpa.c":2823
	size_t len; 	// From "wpa.c":2824


	_WPA_PRINTF((MSG_DEBUG, "RSN: RX message 2 of STK 4-Way Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2], (peerkey->addr)[3],
              (peerkey->addr)[4], (peerkey->addr)[5], ver));
	_f_memset(&kde, 0, sizeof (kde));
	keydata = (char  __far * )(key+1);
	len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: msg 2/4 key data" , keydata, len));
	if (_wpa_s19_wpaS_parse_ies(keydata, len, &kde)<0 ||
	kde.pmkid==((void  __far * )0) ||
	kde.rsn_ie==((void  __far * )0)) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: No SMKID or RSN IE in STK 2/4" ));
		return /*void*/;
	}
	if (memcmp(kde.pmkid, peerkey->smkid, PMKID_LEN)!=0) {
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: Unknown SMKID in STK 2/4" , kde.pmkid, PMKID_LEN));
		return /*void*/;
	}
	if (kde.rsn_ie_len!=peerkey->rsnie_p_len ||
	memcmp(kde.rsn_ie, peerkey->rsnie_p, kde.rsn_ie_len)!=0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Peer RSN IE in SMK and STK " \
		 "handshakes did not match" ));
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: Peer RSN IE in SMK handshake" , peerkey->rsnie_p,
                peerkey->rsnie_p_len));
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: Peer RSN IE in STK handshake" , kde.rsn_ie, kde.rsn_ie_len));
		return /*void*/;
	}
	_wpa_s19_wpaS_update_smk_lifetime(sm, peerkey, &kde);
	_wpa_s19_wpaS_send_stk_3_of_4(sm, peerkey);
	_f_memcpy(peerkey->pnonce, key->key_nonce, WPA_NONCE_LEN);
}

/*** BeginHeader _wpa_s19_wpaS_process_stk_3_of_4 */
// From "wpa.c":2866
void _wpa_s19_wpaS_process_stk_3_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_stk_3_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver) {
	struct wpa_eapol_ie_parse kde; 	// From "wpa.c":2871
	char __far * keydata; 	// From "wpa.c":2872
	size_t len; 	// From "wpa.c":2873
	size_t key_len; 	// From "wpa.c":2873
	char __far * _key; 	// From "wpa.c":2874
	char key_buf[32]; 	// From "wpa.c":2875
	char rsc[6]; 	// From "wpa.c":2875


	_WPA_PRINTF((MSG_DEBUG, "RSN: RX message 3 of STK 4-Way Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2], (peerkey->addr)[3],
              (peerkey->addr)[4], (peerkey->addr)[5], ver));
	_f_memset(&kde, 0, sizeof (kde));
	keydata = (char  __far * )(key+1);
	len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: msg 3/4 key data" , keydata, len));
	if (_wpa_s19_wpaS_parse_ies(keydata, len, &kde)<0) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Failed to parse key data in " \
		 "STK 3/4" ));
		return /*void*/;
	}
	if (kde.rsn_ie_len!=peerkey->rsnie_i_len ||
	memcmp(kde.rsn_ie, peerkey->rsnie_i, kde.rsn_ie_len)!=0) {
		_WPA_PRINTF((MSG_INFO, "RSN: Initiator RSN IE in SMK and STK " \
		 "handshakes did not match" ));
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: Initiator RSN IE in SMK " \
		 "handshake" , peerkey->rsnie_i, peerkey->rsnie_i_len));
		_WPA_HEXDUMP((MSG_DEBUG, "RSN: Initiator RSN IE in STK " \
		 "handshake" , kde.rsn_ie, kde.rsn_ie_len));
		return /*void*/;
	}
	if (memcmp(peerkey->inonce, key->key_nonce, WPA_NONCE_LEN)!=0) {
		_WPA_PRINTF((MSG_WARNING, "RSN: INonce from message 1 of STK " \
		 "4-Way Handshake differs from 3 of STK 4-Way " \
		 "Handshake - drop packet (src=" \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 ")" , (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2], (peerkey->addr)[3],
               (peerkey->addr)[4], (peerkey->addr)[5]));
		return /*void*/;
	}
	_wpa_s19_wpaS_update_smk_lifetime(sm, peerkey, &kde);
	if (_wpa_s19_wpaS_send_4_of_4(sm, peerkey->addr, key, ver, ((word  )(((key->key_info)[0]
                                                                                 <<8)
                                                                                |(key->key_info)[1])),
                                         ((void  __far * )0), 0, &peerkey->stk))
		return /*void*/;
	_key = (char  __far * )peerkey->stk.tk1;
	if (peerkey->cipher==WPA_CIPHER_TKIP) {
		_f_memcpy(key_buf, _key, 16);
		_f_memcpy(key_buf+16, _key+24, 8);
		_f_memcpy(key_buf+24, _key+16, 8);
		_key = key_buf;
		key_len = 32;
	}
	else
		key_len = 16;
	_f_memset(rsc, 0, 6);
	if (sm->ctx->set_key((void  __far * )(sm->ctx->ctx), (wpa_alg  )(peerkey->cipher),
                      (char  __far * )(peerkey->addr), (int  )(0), (int  )(1), (char  __far * )(rsc),
                      (size_t  )(sizeof (rsc)), (char  __far * )(_key), (size_t  )(key_len))
     <0) {
		_WPA_PRINTF((MSG_WARNING, "RSN: Failed to set STK to the " \
		 "driver." ));
		return /*void*/;
	}
}

/*** BeginHeader _wpa_s19_wpaS_process_stk_4_of_4 */
// From "wpa.c":2942
void _wpa_s19_wpaS_process_stk_4_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_stk_4_of_4(struct wpa_sm __far * sm, struct wpa_peerkey __far * peerkey,
                                                struct wpa_eapol_key __far * key,
                                                word ver) {
	char rsc[6]; 	// From "wpa.c":2947


	_WPA_PRINTF((MSG_DEBUG, "RSN: RX message 4 of STK 4-Way Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (peerkey->addr)[0], (peerkey->addr)[1], (peerkey->addr)[2], (peerkey->addr)[3],
              (peerkey->addr)[4], (peerkey->addr)[5], ver));
	_f_memset(rsc, 0, 6);
	if (sm->ctx->set_key((void  __far * )(sm->ctx->ctx), (wpa_alg  )(peerkey->cipher),
                      (char  __far * )(peerkey->addr), (int  )(0), (int  )(1), (char  __far * )(rsc),
                      (size_t  )(sizeof (rsc)), (char  __far * )((char  __far * )peerkey->stk.tk1),
                      (size_t  )(peerkey->cipher==WPA_CIPHER_TKIP ?
	  32 :
	  16))<0) {
		_WPA_PRINTF((MSG_WARNING, "RSN: Failed to set STK to the " \
		 "driver." ));
		return /*void*/;
	}
}

/*** BeginHeader _wpa_s19_wpaS_process_1_of_2_rsn */
// From "wpa.c":2964
int _wpa_s19_wpaS_process_1_of_2_rsn(struct wpa_sm __far * sm, char __far * keydata,
                                               size_t keydatalen, word key_info,
                                               struct wpa_gtk_data __far * gd);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_process_1_of_2_rsn(struct wpa_sm __far * sm, char __far * keydata,
                                               size_t keydatalen, word key_info,
                                               struct wpa_gtk_data __far * gd) {
	int maxkeylen; 	// From "wpa.c":2970
	struct wpa_eapol_ie_parse ie; 	// From "wpa.c":2971


	_WPA_HEXDUMP((MSG_DEBUG, "RSN: msg 1/2 key data" , keydata, keydatalen));
	_wpa_s19_wpaS_parse_ies(keydata, keydatalen, &ie);
	if (ie.gtk &&
	!(key_info&(1<<(12)))) {
		_WPA_PRINTF((MSG_WARNING, "WPA: GTK IE in unencrypted key data" ));
		return  -1;
	}
	if (ie.gtk==((void  __far * )0)) {
		_WPA_PRINTF((MSG_INFO, "WPA: No GTK IE in Group Key msg 1/2" ));
		return  -1;
	}
	maxkeylen = gd->gtk_len = ie.gtk_len-2;
	if (_wpa_s19_wpaS_check_group_cipher(sm->group_cipher, gd->gtk_len, maxkeylen,
                                                &gd->key_rsc_len, &gd->alg))
		return  -1;
	_WPA_HEXDUMP((MSG_DEBUG, "RSN: received GTK in group key handshake" , ie.gtk, ie.gtk_len));
	gd->keyidx = ie.gtk[0]&0x3;
	gd->tx = _wpa_s19_wpaS_gtk_tx_bit_workaround(sm, !!(ie.gtk[0]&(1<<(2))));
	if (ie.gtk_len-2>sizeof (gd->gtk)) {
		_WPA_PRINTF((MSG_INFO, "RSN: Too long GTK in GTK IE " \
		 "(len=%lu)" , (unsigned long  )ie.gtk_len-2));
		return  -1;
	}
	_f_memcpy(gd->gtk, ie.gtk+2, ie.gtk_len-2);
	if (_wpa_s19_ieee80211w_set_keys(sm, &ie)<0)
		_WPA_PRINTF((MSG_INFO, "RSN: Failed to configure DHV/IGTK" ));
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_1_of_2_wpa */
// From "wpa.c":3009
int _wpa_s19_wpaS_process_1_of_2_wpa(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                               size_t keydatalen, int key_info,
                                               size_t extra_len, word ver, struct wpa_gtk_data __far * gd);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_process_1_of_2_wpa(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                               size_t keydatalen, int key_info,
                                               size_t extra_len, word ver, struct wpa_gtk_data __far * gd) {
	size_t maxkeylen; 	// From "wpa.c":3015
	char ek[32]; 	// From "wpa.c":3016


	gd->gtk_len = ((word  )(((key->key_length)[0]<<8)|(key->key_length)[1]));
	maxkeylen = keydatalen;
	if (keydatalen>extra_len) {
		_WPA_PRINTF((MSG_INFO, "WPA: Truncated EAPOL-Key packet:" \
		 " key_data_length=%lu > extra_len=%lu" , (unsigned long  )keydatalen, (unsigned long  )extra_len));
		return  -1;
	}
	if (ver==WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		if (maxkeylen<8) {
			_WPA_PRINTF((MSG_INFO, "WPA: Too short maxkeylen (%lu)" , (unsigned long  )maxkeylen));
			return  -1;
		}
		maxkeylen -= 8;
	}
	if (_wpa_s19_wpaS_check_group_cipher(sm->group_cipher, gd->gtk_len, maxkeylen,
                                                &gd->key_rsc_len, &gd->alg))
		return  -1;
	gd->keyidx = (key_info&WPA_KEY_INFO_KEY_INDEX_MASK)>>4;
	if (ver==WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
		_f_memcpy(ek, key->key_iv, 16);
		_f_memcpy(ek+16, sm->ptk.kek, 16);
		if (keydatalen>sizeof (gd->gtk)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: RC4 key data " \
			 "too long (%lu)" , (unsigned long  )keydatalen));
			return  -1;
		}
		_f_memcpy(gd->gtk, key+1, keydatalen);
		rc4_skip(ek, 32, 256, gd->gtk, keydatalen);
	}
	else if (ver==WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		if (keydatalen%8) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Unsupported AES-WRAP " \
			 "len %lu" , (unsigned long  )keydatalen));
			return  -1;
		}
		if (maxkeylen>sizeof (gd->gtk)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: AES-WRAP key data " \
			 "too long (keydatalen=%lu maxkeylen=%lu)" , (unsigned long  )keydatalen, (unsigned long  )maxkeylen));
			return  -1;
		}
#ifdef WIFI_AES_ENABLED
		if (aes_unwrap(sm->ptk.kek, maxkeylen/8, (char  __far * )(key+1), gd->gtk)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: AES unwrap " \
			 "failed - could not decrypt GTK" ));
			return  -1;
		}
#endif//def WIFI_AES_ENABLED
	}
	gd->tx = _wpa_s19_wpaS_gtk_tx_bit_workaround(sm, !!(key_info&WPA_KEY_INFO_TXRX));
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_send_2_of_2 */
// From "wpa.c":3080
int _wpa_s19_wpaS_send_2_of_2(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                        int ver, word key_info);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_send_2_of_2(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                        int ver, word key_info) {
	size_t rlen; 	// From "wpa.c":3084
	struct wpa_eapol_key __far * reply; 	// From "wpa.c":3085
	char __far * rbuf; 	// From "wpa.c":3086


	rbuf = sm->ctx->alloc_eapol((void  __far * )(sm->ctx->ctx), (char  )(IEEE802_1X_TYPE_EAPOL_KEY),
                             (void  __far * )(((void  __far * )0)), (word  )(sizeof (*reply)),
                             (size_t  __far * )(&rlen), (void  __far * __far * )((void  __far * )&reply));
	if (rbuf==((void  __far * )0))
		return  -1;
	reply->type = sm->proto==WPA_PROTO_RSN ?
	  EAPOL_KEY_TYPE_RSN :
	  EAPOL_KEY_TYPE_WPA;
	key_info &= WPA_KEY_INFO_KEY_INDEX_MASK;
	key_info |= ver|WPA_KEY_INFO_MIC|WPA_KEY_INFO_SECURE;
	do {
		(reply->key_info)[0] = ((word  )(key_info))>>8;
		(reply->key_info)[1] = ((word  )(key_info))&0xff;
	} while (0);
	if (sm->proto==WPA_PROTO_RSN)
		do {
			(reply->key_length)[0] = ((word  )(0))>>8;
			(reply->key_length)[1] = ((word  )(0))&0xff;
		} while (0);
	else
		_f_memcpy(reply->key_length, key->key_length, 2);
	_f_memcpy(reply->replay_counter, key->replay_counter, 8);
	do {
		(reply->key_data_length)[0] = ((word  )(0))>>8;
		(reply->key_data_length)[1] = ((word  )(0))&0xff;
	} while (0);
	_WPA_PRINTF((MSG_DEBUG, "WPA: Sending EAPOL-Key 2/2" ));
	_wpa_s19_wpa_eapol_key_send(sm, sm->ptk.kck, ver, sm->bssid, ETH_P_EAPOL, rbuf,
                             rlen, reply->key_mic);
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_process_1_of_2 */
// From "wpa.c":3115
void _wpa_s19_wpaS_process_1_of_2(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                            struct wpa_eapol_key __far * key, int extra_len,
                                            word ver);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpaS_process_1_of_2(struct wpa_sm __far * sm, unsigned char __far * src_addr,
                                            struct wpa_eapol_key __far * key, int extra_len,
                                            word ver) {
	word key_info; 	// From "wpa.c":3120
	word keydatalen; 	// From "wpa.c":3120
	int rekey; 	// From "wpa.c":3121
	int ret; 	// From "wpa.c":3121
	struct wpa_gtk_data gd; 	// From "wpa.c":3122


	_f_memset(&gd, 0, sizeof (gd));
	rekey = sm->ctx->get_state((void  __far * )(sm->ctx->ctx))==WPA_COMPLETED;
	_WPA_PRINTF((MSG_DEBUG, "WPA: RX message 1 of Group Key Handshake from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " (ver=%d)" , (src_addr)[0], (src_addr)[1], (src_addr)[2], (src_addr)[3], (src_addr)[4],
              (src_addr)[5], ver));
	key_info = ((word  )(((key->key_info)[0]<<8)|(key->key_info)[1]));
	keydatalen = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	if (sm->proto==WPA_PROTO_RSN) {
		ret = _wpa_s19_wpaS_process_1_of_2_rsn(sm, (char  __far * )(key+1), keydatalen,
                                                   key_info, &gd);
	}
	else {
		ret = _wpa_s19_wpaS_process_1_of_2_wpa(sm, key, keydatalen, key_info,
                                                   extra_len, ver, &gd);
	}
	sm->ctx->set_state((void  __far * )(sm->ctx->ctx), (wpa_states  )(WPA_GROUP_HANDSHAKE));
	if (ret)
		return /*void*/;
	if (_wpa_s19_wpaS_install_gtk(sm, &gd, key->key_rsc) ||
	_wpa_s19_wpaS_send_2_of_2(sm, key, ver, key_info))
		return /*void*/;
	if (rekey) {
		_WPA_MSG((sm->ctx->ctx, MSG_INFO, "WPA: Group rekeying completed with %02x:%02x:%02x:%02x:%02x:%02x [GTK=%ls]" ,
            (sm->bssid)[0], (sm->bssid)[1], (sm->bssid)[2], (sm->bssid)[3], (sm->bssid)[4],
            (sm->bssid)[5], (char  __far * )(_wpa_s19_wpa_cipher_txt(sm->group_cipher))));
		sm->ctx->set_state((void  __far * )(sm->ctx->ctx), (wpa_states  )(WPA_COMPLETED));
	}
	else {
		_wpa_s19_wpaS_key_neg_complete(sm, sm->bssid, key_info&WPA_KEY_INFO_SECURE);
	}
}

/*** BeginHeader _wpa_s19_wpaSVfyEapol_key_mic */
// From "wpa.c":3166
int _wpa_s19_wpaSVfyEapol_key_mic(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                                 word ver, char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaSVfyEapol_key_mic(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                                 word ver, char __far * buf, size_t len) {
	char mic[16]; 	// From "wpa.c":3171
	int ok /* = 0 */; 	// From "wpa.c":3172

	ok = 0;

	_f_memcpy(mic, key->key_mic, 16);
	if (sm->tptk_set) {
		_f_memset(key->key_mic, 0, 16);
		_wpa_s19_wpa_eapol_key_mic(sm->tptk.kck, ver, buf, len, key->key_mic);
		if (memcmp(mic, key->key_mic, 16)!=0) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Invalid EAPOL-Key MIC " \
			 "when using TPTK - ignoring TPTK" ));
		}
		else {
			ok = 1;
			sm->tptk_set = 0;
			sm->ptk_set = 1;
			_f_memcpy(&sm->ptk, &sm->tptk, sizeof (sm->ptk));
		}
	}
	if (!ok &&
	sm->ptk_set) {
		_f_memset(key->key_mic, 0, 16);
		_wpa_s19_wpa_eapol_key_mic(sm->ptk.kck, ver, buf, len, key->key_mic);
		if (memcmp(mic, key->key_mic, 16)!=0) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Invalid EAPOL-Key MIC " \
			 "- dropping packet" ));
			return  -1;
		}
		ok = 1;
	}
	if (!ok) {
		_WPA_PRINTF((MSG_WARNING, "WPA: Could not verify EAPOL-Key MIC " \
		 "- dropping packet" ));
		return  -1;
	}
	_f_memcpy(sm->rx_replay_counter, key->replay_counter, 8);
	sm->rx_replay_counter_set = 1;
	return 0;
}

/*** BeginHeader _wpa_s19_wpaSVfyEapol_key_mic_peerkey */
// From "wpa.c":3216
int _wpa_s19_wpaSVfyEapol_key_mic_peerkey(struct wpa_sm __far * sm,
                                                         struct wpa_peerkey __far * peerkey,
                                                         struct wpa_eapol_key __far * key,
                                                         word ver, char __far * buf,
                                                         size_t len);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaSVfyEapol_key_mic_peerkey(struct wpa_sm __far * sm,
                                                         struct wpa_peerkey __far * peerkey,
                                                         struct wpa_eapol_key __far * key,
                                                         word ver, char __far * buf,
                                                         size_t len) {
	char mic[16]; 	// From "wpa.c":3220
	int ok /* = 0 */; 	// From "wpa.c":3221

	ok = 0;

	if (peerkey->initiator &&
	!peerkey->stk_set) {
		_wpa_s19_wpa_pmk_to_ptk(peerkey->smk, PMK_LEN, "Peer key expansion" , sm->own_addr,
                          peerkey->addr, peerkey->inonce, key->key_nonce, (char  __far * )&peerkey->stk,
                          sizeof (peerkey->stk));
		peerkey->stk_set = 1;
	}
	_f_memcpy(mic, key->key_mic, 16);
	if (peerkey->tstk_set) {
		_f_memset(key->key_mic, 0, 16);
		_wpa_s19_wpa_eapol_key_mic(peerkey->tstk.kck, ver, buf, len, key->key_mic);
		if (memcmp(mic, key->key_mic, 16)!=0) {
			_WPA_PRINTF((MSG_WARNING, "RSN: Invalid EAPOL-Key MIC " \
			 "when using TSTK - ignoring TSTK" ));
		}
		else {
			ok = 1;
			peerkey->tstk_set = 0;
			peerkey->stk_set = 1;
			_f_memcpy(&peerkey->stk, &peerkey->tstk, sizeof (peerkey->stk));
		}
	}
	if (!ok &&
	peerkey->stk_set) {
		_f_memset(key->key_mic, 0, 16);
		_wpa_s19_wpa_eapol_key_mic(peerkey->stk.kck, ver, buf, len, key->key_mic);
		if (memcmp(mic, key->key_mic, 16)!=0) {
			_WPA_PRINTF((MSG_WARNING, "RSN: Invalid EAPOL-Key MIC " \
			 "- dropping packet" ));
			return  -1;
		}
		ok = 1;
	}
	if (!ok) {
		_WPA_PRINTF((MSG_WARNING, "RSN: Could not verify EAPOL-Key MIC " \
		 "- dropping packet" ));
		return  -1;
	}
	_f_memcpy(peerkey->replay_counter, key->replay_counter, 8);
	peerkey->replay_counter_set = 1;
	return 0;
}

/*** BeginHeader _wpa_s19_wpaS_decrypt_key_data */
// From "wpa.c":3275
int _wpa_s19_wpaS_decrypt_key_data(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                             word ver);
/*** EndHeader */
_wpa_debug
int _wpa_s19_wpaS_decrypt_key_data(struct wpa_sm __far * sm, struct wpa_eapol_key __far * key,
                                             word ver) {
	word keydatalen /* = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1])) */; 	// From "wpa.c":3278

	union  {

		struct  {
			char ek[32];

		} __s2;

		struct  {
			char __far * buf;

		} __s3;

	} __u; 	// From "wpa.c":3277

	keydatalen = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));

	_WPA_HEXDUMP((MSG_DEBUG, "RSN: encrypted key data" , (char  __far * )(key+1), keydatalen));
	if (!sm->ptk_set) {
		_WPA_PRINTF((MSG_WARNING, "WPA: PTK not available, " \
		 "cannot decrypt EAPOL-Key key data." ));
		return  -1;
	}
	if (ver==WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
		_f_memcpy(__u.__s2.ek, key->key_iv, 16);
		_f_memcpy(__u.__s2.ek+16, sm->ptk.kek, 16);
		rc4_skip(__u.__s2.ek, 32, 256, (char  __far * )(key+1), keydatalen);
	}
	else if (ver==WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		if (keydatalen%8) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Unsupported " \
			 "AES-WRAP len %d" , keydatalen));
			return  -1;
		}
		keydatalen -= 8;
		__u.__s3.buf = _sys_malloc(keydatalen);
		if (__u.__s3.buf==((void  __far * )0)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: No memory for " \
			 "AES-UNWRAP buffer" ));
			return  -1;
		}
#ifdef WIFI_AES_ENABLED
		if (aes_unwrap(sm->ptk.kek, keydatalen/8, (char  __far * )(key+1), __u.__s3.buf)) {
			_sys_free(__u.__s3.buf);
			_WPA_PRINTF((MSG_WARNING, "WPA: AES unwrap failed - " \
			 "could not decrypt EAPOL-Key key data" ));
			return  -1;
		}
#endif//def WIFI_AES_ENABLED
		_f_memcpy(key+1, __u.__s3.buf, keydatalen);
		_sys_free(__u.__s3.buf);
		do {
			(key->key_data_length)[0] = ((word  )(keydatalen))>>8;
			(key->key_data_length)[1] = ((word  )(keydatalen))&0xff;
		} while (0);
	}
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: decrypted EAPOL-Key key data" , (char  __far * )(key
                                                                               +1),
               keydatalen));
	return 0;
}

/*** BeginHeader wpa_sm_aborted_cached */
// From "wpa.c":3330
void wpa_sm_aborted_cached(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void wpa_sm_aborted_cached(struct wpa_sm __far * sm) {
	if (sm &&
	sm->cur_pmksa) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: Cancelling PMKSA caching attempt" ));
		sm->cur_pmksa = ((void  __far * )0);
	}
}

/*** BeginHeader _wpa_s19_wpa_eapol_key_dump */
// From "wpa.c":3339
void _wpa_s19_wpa_eapol_key_dump(struct wpa_eapol_key __far * key);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_eapol_key_dump(struct wpa_eapol_key __far * key) {
	word key_info /* = ((word  )(((key->key_info)[0]<<8)|(key->key_info)[1])) */; 	// From "wpa.c":3342

	key_info = ((word  )(((key->key_info)[0]<<8)|(key->key_info)[1]));

	_WPA_PRINTF((MSG_DEBUG, "  EAPOL-Key type=%d" , key->type));
	_WPA_PRINTF((MSG_DEBUG, "  key_info 0x%x (ver=%d keyidx=%d rsvd=%d %ls%ls%ls%ls%ls%ls%ls%ls)" ,
              key_info, key_info&((word  )((1<<(0))|(1<<(1))|(1<<(2)))), (key_info
                                                                          &WPA_KEY_INFO_KEY_INDEX_MASK)
                                                                         >>4, (key_info
                                                                               &((1
                                                                                  <<(13))
                                                                                 |(1
                                                                                   <<(14))
                                                                                 |(1
                                                                                   <<(15))))
                                                                              >>13,
              (char  __far * )(key_info&WPA_KEY_INFO_KEY_TYPE ?
	  "Pairwise"  :
	  "Group" ), (char  __far * )(key_info&WPA_KEY_INFO_INSTALL ?
	  " Install"  :
	  "" ), (char  __far * )(key_info&WPA_KEY_INFO_ACK ?
	  " Ack"  :
	  "" ), (char  __far * )(key_info&WPA_KEY_INFO_MIC ?
	  " MIC"  :
	  "" ), (char  __far * )(key_info&WPA_KEY_INFO_SECURE ?
	  " Secure"  :
	  "" ), (char  __far * )(key_info&(1<<(10)) ?
	  " Error"  :
	  "" ), (char  __far * )(key_info&(1<<(11)) ?
	  " Request"  :
	  "" ), (char  __far * )(key_info&(1<<(12)) ?
	  " Encr"  :
	  "" )));
	_WPA_PRINTF((MSG_DEBUG, "  key_length=%u key_data_length=%u" , ((word  )(((key->key_length)[0]
                                                                           <<8)|(key->key_length)[1])),
              ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]))));
	_WPA_HEXDUMP((MSG_DEBUG, "  replay_counter" , key->replay_counter, 8));
	_WPA_HEXDUMP((MSG_DEBUG, "  key_nonce" , key->key_nonce, WPA_NONCE_LEN));
	_WPA_HEXDUMP((MSG_DEBUG, "  key_iv" , key->key_iv, 16));
	_WPA_HEXDUMP((MSG_DEBUG, "  key_rsc" , key->key_rsc, 8));
	_WPA_HEXDUMP((MSG_DEBUG, "  key_id (reserved)" , key->key_id, 8));
	_WPA_HEXDUMP((MSG_DEBUG, "  key_mic" , key->key_mic, 16));
}

/*** BeginHeader wpa_sm_rx_eapol */
// From "wpa.c":3389
int wpa_sm_rx_eapol(struct wpa_sm __far * sm, char __far * src_addr, char __far * buf,
                    size_t len);
/*** EndHeader */
_wpa_debug
int wpa_sm_rx_eapol(struct wpa_sm __far * sm, char __far * src_addr, char __far * buf,
                    size_t len) {
	size_t plen; 	// From "wpa.c":3392
	size_t data_len; 	// From "wpa.c":3392
	size_t extra_len; 	// From "wpa.c":3392
	struct ieee802_1x_hdr __far * hdr; 	// From "wpa.c":3393
	struct wpa_eapol_key __far * key; 	// From "wpa.c":3394
	word key_info; 	// From "wpa.c":3395
	word ver; 	// From "wpa.c":3395
	char __far * tmp; 	// From "wpa.c":3396
	int ret /* =  -1 */; 	// From "wpa.c":3397
	struct wpa_peerkey __far * peerkey /* = ((void  far * )0) */; 	// From "wpa.c":3398

	union  {

		struct  {

			union  {

				struct  {
					char _tmp[8];

				} __s2;

			} __u;

		} __s10;

	} __u; 	// From "wpa.c":3391

	ret =  -1;
	peerkey = ((void  __far * )0);

	if (len<sizeof (*hdr)+sizeof (*key)) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL frame too short to be a WPA " \
		 "EAPOL-Key (len %lu, expecting at least %lu)" , (unsigned long  )len, (unsigned long  )sizeof (*hdr)
                                                                         +sizeof (*key)));
		return 0;
	}
	tmp = _sys_malloc(len);
	if (tmp==((void  __far * )0))
		return  -1;
	_f_memcpy(tmp, buf, len);
	hdr = (struct ieee802_1x_hdr  __far * )tmp;
	key = (struct wpa_eapol_key  __far * )(hdr+1);
	plen = intel16(hdr->length);
	data_len = plen+sizeof (*hdr);
	_WPA_PRINTF((MSG_DEBUG, "IEEE 802.1X RX: version=%d type=%d length=%lu" , hdr->version,
              hdr->type, (unsigned long  )plen));
	if (hdr->version<2) {
	}
	if (hdr->type!=IEEE802_1X_TYPE_EAPOL_KEY) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL frame (type %u) discarded, " \
		 "not a Key frame" , hdr->type));
		ret = 0;
		goto out;
	}
	if (plen>len-sizeof (*hdr) ||
	plen<sizeof (*key)) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL frame payload size %lu " \
		 "invalid (frame size %lu)" , (unsigned long  )plen, (unsigned long  )len));
		ret = 0;
		goto out;
	}
	if (key->type!=EAPOL_KEY_TYPE_WPA &&
	key->type!=EAPOL_KEY_TYPE_RSN) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL-Key type (%d) unknown, " \
		 "discarded" , key->type));
		ret = 0;
		goto out;
	}
#ifdef WPA_USE_EAP
	_wpa_s19_wpa_eapol_key_dump(key);
	eapol_sm_notify_lower_layer_success(sm->eapol);
#endif//def WPA_USE_EAP
	_WPA_HEXDUMP((MSG_MSGDUMP, "WPA: RX EAPOL-Key" , tmp, len));
	if (data_len<len) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: ignoring %lu bytes after the IEEE " \
		 "802.1X data" , (unsigned long  )len-data_len));
	}
	key_info = ((word  )(((key->key_info)[0]<<8)|(key->key_info)[1]));
	ver = key_info&((word  )((1<<(0))|(1<<(1))|(1<<(2))));
	if (ver!=WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 &&
	ver!=WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		_WPA_PRINTF((MSG_INFO, "WPA: Unsupported EAPOL-Key descriptor " \
		 "version %d." , ver));
		goto out;
	}
	if (sm->pairwise_cipher==WPA_CIPHER_CCMP &&
	ver!=WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		_WPA_PRINTF((MSG_INFO, "WPA: CCMP is used, but EAPOL-Key " \
		 "descriptor version (%d) is not 2." , ver));
		if (sm->group_cipher!=WPA_CIPHER_CCMP &&
		!(key_info&WPA_KEY_INFO_KEY_TYPE)) {
			_WPA_PRINTF((MSG_INFO, "WPA: Backwards compatibility: " \
			 "allow invalid version for non-CCMP group " \
			 "keys" ));
		}
		else
			goto out;
	}
	for (peerkey = sm->peerkey; peerkey; peerkey = peerkey->next) {
		if (memcmp(peerkey->addr, src_addr, 6)==0)
			break;
	}
	if (!(key_info&(1<<(13))) &&
	peerkey) {
		if (!peerkey->initiator &&
		peerkey->replay_counter_set &&
		memcmp(key->replay_counter, peerkey->replay_counter, 8)<=0) {
			_WPA_PRINTF((MSG_WARNING, "RSN: EAPOL-Key Replay " \
			 "Counter did not increase (STK) - dropping " \
			 "packet" ));
			goto out;
		}
		else if (peerkey->initiator) {
			_f_memcpy(__u.__s10.__u.__s2._tmp, key->replay_counter, 8);
			inc_byte_array(__u.__s10.__u.__s2._tmp, 8);
			if (memcmp(__u.__s10.__u.__s2._tmp, peerkey->replay_counter, 8)!=0) {
				_WPA_PRINTF((MSG_DEBUG, "RSN: EAPOL-Key Replay " \
				 "Counter did not match (STK) - " \
				 "dropping packet" ));
				goto out;
			}
		}
	}
	if (peerkey &&
	peerkey->initiator &&
	(key_info&WPA_KEY_INFO_ACK)) {
		_WPA_PRINTF((MSG_INFO, "RSN: Ack bit in key_info from STK peer" ));
		goto out;
	}
	if (!peerkey &&
	sm->rx_replay_counter_set &&
	memcmp(key->replay_counter, sm->rx_replay_counter, 8)<=0) {
		_WPA_PRINTF((MSG_WARNING, "WPA: EAPOL-Key Replay Counter did not" \
		 " increase - dropping packet" ));
		goto out;
	}
	if (!(key_info&(WPA_KEY_INFO_ACK|(1<<(13)))) &&
	(peerkey==((void  __far * )0) ||
	!peerkey->initiator)) {
		_WPA_PRINTF((MSG_INFO, "WPA: No Ack bit in key_info" ));
		goto out;
	}
	if (key_info&(1<<(11))) {
		_WPA_PRINTF((MSG_INFO, "WPA: EAPOL-Key with Request bit - " \
		 "dropped" ));
		goto out;
	}
	if ((key_info&WPA_KEY_INFO_MIC) &&
	!peerkey &&
	_wpa_s19_wpaSVfyEapol_key_mic(sm, key, ver, tmp, data_len))
		goto out;
	if ((key_info&WPA_KEY_INFO_MIC) &&
	peerkey &&
	_wpa_s19_wpaSVfyEapol_key_mic_peerkey(sm, peerkey, key, ver, tmp,
                                                      data_len))
		goto out;
	extra_len = data_len-sizeof (*hdr)-sizeof (*key);
	if (((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]))>extra_len) {
		_WPA_MSG((sm->ctx->ctx, MSG_INFO, "WPA: Invalid EAPOL-Key " \
		 "frame - key_data overflow (%d > %lu)" , ((word  )(((key->key_data_length)[0]
                                                       <<8)|(key->key_data_length)[1])),
            (unsigned long  )extra_len));
		goto out;
	}
	extra_len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	if (sm->proto==WPA_PROTO_RSN &&
	(key_info&(1<<(12)))) {
		if (_wpa_s19_wpaS_decrypt_key_data(sm, key, ver))
			goto out;
		extra_len = ((word  )(((key->key_data_length)[0]<<8)|(key->key_data_length)[1]));
	}
	if (key_info&WPA_KEY_INFO_KEY_TYPE) {
		if (key_info&WPA_KEY_INFO_KEY_INDEX_MASK) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Ignored EAPOL-Key " \
			 "(Pairwise) with non-zero key index" ));
			goto out;
		}
		if (peerkey) {
			if ((key_info&(WPA_KEY_INFO_MIC|WPA_KEY_INFO_ACK))==(WPA_KEY_INFO_MIC|WPA_KEY_INFO_ACK)) {
				_wpa_s19_wpaS_process_stk_3_of_4(sm, peerkey, key, ver);
			}
			else if (key_info&WPA_KEY_INFO_ACK) {
				_wpa_s19_wpaS_process_stk_1_of_4(sm, peerkey, key, ver);
			}
			else if (key_info&WPA_KEY_INFO_SECURE) {
				_wpa_s19_wpaS_process_stk_4_of_4(sm, peerkey, key, ver);
			}
			else {
				_wpa_s19_wpaS_process_stk_2_of_4(sm, peerkey, key, ver);
			}
		}
		else if (key_info&WPA_KEY_INFO_MIC) {
			_wpa_s19_wpaS_process_3_of_4(sm, key, ver);
		}
		else {
			_wpa_s19_wpaS_process_1_of_4(sm, src_addr, key, ver);
		}
	}
	else if (key_info&(1<<(13))) {
		if (key_info&(1<<(10))) {
			_wpa_s19_wpaS_process_smk_error(sm, src_addr, key, extra_len);
		}
		else if (key_info&WPA_KEY_INFO_ACK) {
			_wpa_s19_wpaS_process_smk_m2(sm, src_addr, key, extra_len, ver);
		}
		else {
			_wpa_s19_wpaS_process_smk_m45(sm, src_addr, key, extra_len, ver);
		}
	}
	else {
		if (key_info&WPA_KEY_INFO_MIC) {
			_wpa_s19_wpaS_process_1_of_2(sm, src_addr, key, extra_len, ver);
		}
		else {
			_WPA_PRINTF((MSG_WARNING, "WPA: EAPOL-Key (Group) " \
			 "without Mic bit - dropped" ));
		}
	}
	ret = 1;
	out:
	_sys_free(tmp);
	return ret;
}

/*** BeginHeader _wpa_s19_wpa_sm_pmksa_free_cb */
// From "wpa.c":3780
void _wpa_s19_wpa_sm_pmksa_free_cb(struct rsn_pmksa_cache_entry __far * entry, void __far * ctx,
                                   int replace);
/*** EndHeader */
_wpa_debug
void _wpa_s19_wpa_sm_pmksa_free_cb(struct rsn_pmksa_cache_entry __far * entry, void __far * ctx,
                                   int replace) {
	struct wpa_sm __far * sm /* = ctx */; 	// From "wpa.c":3783

	sm = ctx;

	if (sm->cur_pmksa==entry ||
	(sm->pmk_len==entry->pmk_len &&
	memcmp(sm->pmk, entry->pmk, sm->pmk_len)==0)) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: removed current PMKSA entry" ));
		sm->cur_pmksa = ((void  __far * )0);
		if (replace) {
			return /*void*/;
		}
		_f_memset(sm->pmk, 0, sizeof (sm->pmk));
		sm->ctx->deauthenticate((void  __far * )(sm->ctx->ctx), (int  )(REASON_UNSPECIFIED));
		sm->ctx->req_scan((void  __far * )(sm->ctx->ctx), (int  )(0), (int  )(0));
	}
}

/*** BeginHeader wpa_sm_init */
// From "wpa.c":3814
struct wpa_sm __far * wpa_sm_init(struct wpa_sm_ctx __far * ctx);
/*** EndHeader */
_wpa_debug
struct wpa_sm __far * wpa_sm_init(struct wpa_sm_ctx __far * ctx) {
	struct wpa_sm __far * sm; 	// From "wpa.c":3816


	sm = _sys_calloc(sizeof (*sm));
	if (sm==((void  __far * )0))
		return ((void  __far * )0);
	sm->renew_snonce = 1;
	sm->ctx = ctx;
	sm->dot11RSNAConfigPMKLifetime = 43200;
	sm->dot11RSNAConfigPMKReauthThreshold = 70;
	sm->dot11RSNAConfigSATimeout = 60;
#ifdef WPA_USE_PMKSA_CACHE
	sm->pmksa = pmksa_cache_init(_wpa_s19_wpa_sm_pmksa_free_cb, sm, sm);
	if (sm->pmksa==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "RSN: PMKSA cache initialization " \
		 "failed" ));
		_sys_free(sm);
		return ((void  __far * )0);
	}
#endif//def WPA_USE_PMKSA_CACHE
	return sm;
}

/*** BeginHeader wpa_sm_deinit */
// From "wpa.c":3844
void wpa_sm_deinit(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void wpa_sm_deinit(struct wpa_sm __far * sm) {

	union  {

		struct  {
			struct wpa_peerkey __far * prev;
			struct wpa_peerkey __far * peerkey /* = sm->peerkey */;

		} __s1;

	} __u; 	// From "wpa.c":3845


	if (sm==((void  __far * )0))
		return /*void*/;
#ifdef WPA_USE_PMKSA_CACHE
	pmksa_cache_deinit(sm->pmksa);
#endif//def WPA_USE_PMKSA_CACHE
#ifdef WPA_USE_PREAUTH_C
	eloop_cancel_timeout(_wpa_s19_wpa_sm_start_preauth, sm, ((void  __far * )0));
#endif//def WPA_USE_PREAUTH_C
	_sys_free(sm->assoc_wpa_ie);
	_sys_free(sm->ap_wpa_ie);
	_sys_free(sm->ap_rsn_ie);
	_sys_free(sm->ctx);
	{
		__u.__s1.peerkey = sm->peerkey;

		while (__u.__s1.peerkey) {
			__u.__s1.prev = __u.__s1.peerkey;
			__u.__s1.peerkey = __u.__s1.peerkey->next;
			_sys_free(__u.__s1.prev);
		}
	}
	_sys_free(sm);
}

/*** BeginHeader wpa_sm_notify_assoc */
// From "wpa.c":3876
void wpa_sm_notify_assoc(struct wpa_sm __far * sm, char __far * bssid);
/*** EndHeader */
_wpa_debug
void wpa_sm_notify_assoc(struct wpa_sm __far * sm, char __far * bssid) {
	if (sm==((void  __far * )0))
		return /*void*/;
	_WPA_PRINTF((MSG_DEBUG, "WPA: Association event - clear replay counter" ));
	_f_memcpy(sm->bssid, bssid, 6);
	_f_memset(sm->rx_replay_counter, 0, 8);
	sm->rx_replay_counter_set = 0;
	sm->renew_snonce = 1;
#ifdef WPA_USE_PREAUTH_C
	if (memcmp(sm->preauth_bssid, bssid, 6)==0)
		rsn_preauth_deinit(sm);
#endif//def WPA_USE_PREAUTH_C
}

/*** BeginHeader wpa_sm_notify_disassoc */
// From "wpa.c":3898
void wpa_sm_notify_disassoc(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void wpa_sm_notify_disassoc(struct wpa_sm __far * sm) {
#ifdef WPA_USE_PREAUTH_C
	rsn_preauth_deinit(sm);
#endif//def WPA_USE_PREAUTH_C
	if (sm->ctx->get_state((void  __far * )(sm->ctx->ctx))==WPA_4WAY_HANDSHAKE)
		sm->dot11RSNA4WayHandshakeFailures++;
}

/*** BeginHeader wpa_sm_set_pmk */
// From "wpa.c":3914
void wpa_sm_set_pmk(struct wpa_sm __far * sm, char __far * pmk, size_t pmk_len);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_pmk(struct wpa_sm __far * sm, char __far * pmk, size_t pmk_len) {
	if (sm==((void  __far * )0))
		return /*void*/;
	sm->pmk_len = pmk_len;
	_f_memcpy(sm->pmk, pmk, pmk_len);
}

/*** BeginHeader wpa_sm_set_pmk_from_pmksa */
// From "wpa.c":3931
void wpa_sm_set_pmk_from_pmksa(struct wpa_sm __far * sm);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_pmk_from_pmksa(struct wpa_sm __far * sm) {
	if (sm==((void  __far * )0))
		return /*void*/;
#ifdef WPA_USE_PMKSA_CACHE
	if (sm->cur_pmksa) {
		sm->pmk_len = sm->cur_pmksa->pmk_len;
		_f_memcpy(sm->pmk, sm->cur_pmksa->pmk, sm->pmk_len);
	}
	else {
#endif//def WPA_USE_PMKSA_CACHE
		sm->pmk_len = PMK_LEN;
		_f_memset(sm->pmk, 0, PMK_LEN);
#ifdef WPA_USE_PMKSA_CACHE
	}
#endif//def WPA_USE_PMKSA_CACHE
}

/*** BeginHeader wpa_sm_set_fast_reauth */
// From "wpa.c":3951
void wpa_sm_set_fast_reauth(struct wpa_sm __far * sm, int fast_reauth);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_fast_reauth(struct wpa_sm __far * sm, int fast_reauth) {
	if (sm)
		sm->fast_reauth = fast_reauth;
}

/*** BeginHeader wpa_sm_set_scard_ctx */
// From "wpa.c":3963
void wpa_sm_set_scard_ctx(struct wpa_sm __far * sm, void __far * scard_ctx);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_scard_ctx(struct wpa_sm __far * sm, void __far * scard_ctx) {
	if (sm==((void  __far * )0))
		return /*void*/;
	sm->scard_ctx = scard_ctx;
#ifdef WPA_USE_EAP
	if (sm->preauth_eapol)
		eapol_sm_register_scard_ctx(sm->preauth_eapol, scard_ctx);
#endif//def WPA_USE_EAP
}

/*** BeginHeader wpa_sm_set_config */
// From "wpa.c":3982
void wpa_sm_set_config(struct wpa_sm __far * sm, struct wpa_ssid __far * config);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_config(struct wpa_sm __far * sm, struct wpa_ssid __far * config) {
	if (sm) {
		sm->cur_ssid = config;
#ifdef WPA_USE_PMKSA_CACHE
		pmksa_cache_notify_reconfig(sm->pmksa);
#endif//def WPA_USE_PMKSA_CACHE
	}
}

/*** BeginHeader wpa_sm_set_own_addr */
// From "wpa.c":3996
void wpa_sm_set_own_addr(struct wpa_sm __far * sm, char __far * addr);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_own_addr(struct wpa_sm __far * sm, char __far * addr) {
	if (sm)
		_f_memcpy(sm->own_addr, addr, 6);
}

/*** BeginHeader wpa_sm_set_ifname */
// From "wpa.c":4009
void wpa_sm_set_ifname(struct wpa_sm __far * sm, char __far * ifname, char __far * bridge_ifname);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_ifname(struct wpa_sm __far * sm, char __far * ifname, char __far * bridge_ifname) {
	if (sm) {
		sm->ifname = ifname;
		sm->bridge_ifname = bridge_ifname;
	}
}

/*** BeginHeader wpa_sm_set_eapol */
// From "wpa.c":4024
void wpa_sm_set_eapol(struct wpa_sm __far * sm, struct eapol_sm __far * eapol);
/*** EndHeader */
_wpa_debug
void wpa_sm_set_eapol(struct wpa_sm __far * sm, struct eapol_sm __far * eapol) {
	if (sm)
		sm->eapol = eapol;
}

/*** BeginHeader wpa_sm_set_param */
// From "wpa.c":4038
int wpa_sm_set_param(struct wpa_sm __far * sm, enum wpa_sm_conf_params param, unsigned int value);
/*** EndHeader */
_wpa_debug
int wpa_sm_set_param(struct wpa_sm __far * sm, enum wpa_sm_conf_params param, unsigned int value) {
	int ret /* = 0 */; 	// From "wpa.c":4041

	ret = 0;

	if (sm==((void  __far * )0))
		return  -1;
	switch ((int)(param)) {
		case RSNA_PMK_LIFETIME:
		if (value>0)
			sm->dot11RSNAConfigPMKLifetime = value;
		else
			ret =  -1;
		break;
		case RSNA_PMK_REAUTH_THRESHOLD:
		if (value>0 &&
		value<=100)
			sm->dot11RSNAConfigPMKReauthThreshold = value;
		else
			ret =  -1;
		break;
		case RSNA_SA_TIMEOUT:
		if (value>0)
			sm->dot11RSNAConfigSATimeout = value;
		else
			ret =  -1;
		break;
		case WPA_PARAM_PROTO:
		sm->proto = value;
		break;
		case WPA_PARAM_PAIRWISE:
		sm->pairwise_cipher = value;
		break;
		case WPA_PARAM_GROUP:
		sm->group_cipher = value;
		break;
		case WPA_PARAM_KEY_MGMT:
		sm->key_mgmt = value;
		break;
		default:
		break;
	}
	return ret;
}

/*** BeginHeader wpa_sm_get_param */
// From "wpa.c":4096
unsigned int wpa_sm_get_param(struct wpa_sm __far * sm, enum wpa_sm_conf_params param);
/*** EndHeader */
_wpa_debug
unsigned int wpa_sm_get_param(struct wpa_sm __far * sm, enum wpa_sm_conf_params param) {
	if (sm==((void  __far * )0))
		return 0;
	switch ((int)(param)) {
		case RSNA_PMK_LIFETIME:
		return sm->dot11RSNAConfigPMKLifetime;
		case RSNA_PMK_REAUTH_THRESHOLD:
		return sm->dot11RSNAConfigPMKReauthThreshold;
		case RSNA_SA_TIMEOUT:
		return sm->dot11RSNAConfigSATimeout;
		case WPA_PARAM_PROTO:
		return sm->proto;
		case WPA_PARAM_PAIRWISE:
		return sm->pairwise_cipher;
		case WPA_PARAM_GROUP:
		return sm->group_cipher;
		case WPA_PARAM_KEY_MGMT:
		return sm->key_mgmt;
		default:
		return 0;
	}
}

/*** BeginHeader wpa_sm_get_status */
// From "wpa.c":4138
int wpa_sm_get_status(struct wpa_sm __far * sm, char __far * buf, size_t buflen, int verbose);
/*** EndHeader */
_wpa_debug
int wpa_sm_get_status(struct wpa_sm __far * sm, char __far * buf, size_t buflen, int verbose) {
	char __far * pos /* = buf */; 	// From "wpa.c":4141
	char __far * end /* = buf+buflen */; 	// From "wpa.c":4141
	int ret; 	// From "wpa.c":4142

	pos = buf;
	end = buf+buflen;

	ret = snprintf(pos, (_x509_ptrdiff_t)(end-pos), "pairwise_cipher=%ls\ngroup_cipher=%ls\nkey_mgmt=%ls\n" ,
                (char  __far * )(_wpa_s19_wpa_cipher_txt(sm->pairwise_cipher)), (char  __far * )(_wpa_s19_wpa_cipher_txt(
                                                                                                                     sm->group_cipher)),
                (char  __far * )(_wpa_s19_wpa_key_mgmt_txt(sm->key_mgmt, sm->proto)));
	if (ret<0 ||
	ret>=(_x509_ptrdiff_t)(end-pos))
		return (_x509_ptrdiff_t)(pos-buf);
	pos += ret;
	return (_x509_ptrdiff_t)(pos-buf);
}

/*** BeginHeader wpa_sm_set_assoc_wpa_ie_default */
// From "wpa.c":4169
int wpa_sm_set_assoc_wpa_ie_default(struct wpa_sm __far * sm, char __far * wpa_ie, size_t __far * wpa_ie_len);
/*** EndHeader */
_wpa_debug
int wpa_sm_set_assoc_wpa_ie_default(struct wpa_sm __far * sm, char __far * wpa_ie, size_t __far * wpa_ie_len) {
	int res; 	// From "wpa.c":4172


	if (sm==((void  __far * )0))
		return  -1;
	res = _wpa_s19_wpa_gen_wpa_ie(sm, wpa_ie, *wpa_ie_len);
	if (res<0)
		return  -1;
	*wpa_ie_len = res;
	_WPA_HEXDUMP((MSG_DEBUG, "WPA: Set own WPA IE default" , wpa_ie, *wpa_ie_len));
	if (sm->assoc_wpa_ie==((void  __far * )0)) {
		sm->assoc_wpa_ie = _sys_malloc(*wpa_ie_len);
		if (sm->assoc_wpa_ie==((void  __far * )0))
			return  -1;
		_f_memcpy(sm->assoc_wpa_ie, wpa_ie, *wpa_ie_len);
		sm->assoc_wpa_ie_len = *wpa_ie_len;
	}
	return 0;
}

/*** BeginHeader wpa_sm_set_assoc_wpa_ie */
// From "wpa.c":4214
int wpa_sm_set_assoc_wpa_ie(struct wpa_sm __far * sm, char __far * ie, size_t len);
/*** EndHeader */
_wpa_debug
int wpa_sm_set_assoc_wpa_ie(struct wpa_sm __far * sm, char __far * ie, size_t len) {
	if (sm==((void  __far * )0))
		return  -1;
	_sys_free(sm->assoc_wpa_ie);
	if (ie==((void  __far * )0) ||
	len==0) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: clearing own WPA/RSN IE" ));
		sm->assoc_wpa_ie = ((void  __far * )0);
		sm->assoc_wpa_ie_len = 0;
	}
	else {
		_WPA_HEXDUMP((MSG_DEBUG, "WPA: set own WPA/RSN IE" , ie, len));
		sm->assoc_wpa_ie = _sys_malloc(len);
		if (sm->assoc_wpa_ie==((void  __far * )0))
			return  -1;
		_f_memcpy(sm->assoc_wpa_ie, ie, len);
		sm->assoc_wpa_ie_len = len;
	}
	return 0;
}

/*** BeginHeader wpa_sm_set_ap_wpa_ie */
// From "wpa.c":4248
int wpa_sm_set_ap_wpa_ie(struct wpa_sm __far * sm, char __far * ie, size_t len);
/*** EndHeader */
_wpa_debug
int wpa_sm_set_ap_wpa_ie(struct wpa_sm __far * sm, char __far * ie, size_t len) {
	if (sm==((void  __far * )0))
		return  -1;
	_sys_free(sm->ap_wpa_ie);
	if (ie==((void  __far * )0) ||
	len==0) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: clearing AP WPA IE" ));
		sm->ap_wpa_ie = ((void  __far * )0);
		sm->ap_wpa_ie_len = 0;
	}
	else {
		_WPA_HEXDUMP((MSG_DEBUG, "WPA: set AP WPA IE" , ie, len));
		sm->ap_wpa_ie = _sys_malloc(len);
		if (sm->ap_wpa_ie==((void  __far * )0))
			return  -1;
		_f_memcpy(sm->ap_wpa_ie, ie, len);
		sm->ap_wpa_ie_len = len;
	}
	return 0;
}

/*** BeginHeader wpa_sm_set_ap_rsn_ie */
// From "wpa.c":4282
int wpa_sm_set_ap_rsn_ie(struct wpa_sm __far * sm, char __far * ie, size_t len);
/*** EndHeader */
_wpa_debug
int wpa_sm_set_ap_rsn_ie(struct wpa_sm __far * sm, char __far * ie, size_t len) {
	if (sm==((void  __far * )0))
		return  -1;
	_sys_free(sm->ap_rsn_ie);
	if (ie==((void  __far * )0) ||
	len==0) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: clearing AP RSN IE" ));
		sm->ap_rsn_ie = ((void  __far * )0);
		sm->ap_rsn_ie_len = 0;
	}
	else {
		_WPA_HEXDUMP((MSG_DEBUG, "WPA: set AP RSN IE" , ie, len));
		sm->ap_rsn_ie = _sys_malloc(len);
		if (sm->ap_rsn_ie==((void  __far * )0))
			return  -1;
		_f_memcpy(sm->ap_rsn_ie, ie, len);
		sm->ap_rsn_ie_len = len;
	}
	return 0;
}

/*** BeginHeader wpa_sm_parse_own_wpa_ie */
// From "wpa.c":4315
int wpa_sm_parse_own_wpa_ie(struct wpa_sm __far * sm, struct wpa_ie_data __far * data);
/*** EndHeader */
_wpa_debug
int wpa_sm_parse_own_wpa_ie(struct wpa_sm __far * sm, struct wpa_ie_data __far * data) {
	if (sm==((void  __far * )0) ||
	sm->assoc_wpa_ie==((void  __far * )0)) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: No WPA/RSN IE available from " \
		 "association info" ));
		return  -1;
	}
	if (wpa_parse_wpa_ie(sm->assoc_wpa_ie, sm->assoc_wpa_ie_len, data))
		return  -2;
	return 0;
}
// @ TUName[]  ; -- translator directive

/*** BeginHeader _wpa_s20_wpaS_ctrl_iface_init */
// From "ctrl_iface.h":125
struct ctrl_iface_priv __far * _wpa_s20_wpaS_ctrl_iface_init(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
struct ctrl_iface_priv __far * _wpa_s20_wpaS_ctrl_iface_init(struct wpa_supplicant __far * wpa_s) {
	return (void  __far * ) -1;
}

/*** BeginHeader _wpa_s20_wpaS_ctrl_iface_deinit */
// From "ctrl_iface.h":131
void _wpa_s20_wpaS_ctrl_iface_deinit(struct ctrl_iface_priv __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_ctrl_iface_deinit(struct ctrl_iface_priv __far * priv) {
}

/*** BeginHeader _wpa_s20_wpaS_ctrl_iface_send */
// From "ctrl_iface.h":136
void _wpa_s20_wpaS_ctrl_iface_send(struct ctrl_iface_priv __far * priv,
                                             int level, char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_ctrl_iface_send(struct ctrl_iface_priv __far * priv,
                                             int level, char __far * buf, size_t len) {
}

/*** BeginHeader _wpa_s20_wpaS_ctrl_iface_wait */
// From "ctrl_iface.h":142
void _wpa_s20_wpaS_ctrl_iface_wait(struct ctrl_iface_priv __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_ctrl_iface_wait(struct ctrl_iface_priv __far * priv) {
}

/*** BeginHeader _wpa_s20_wpaSGlob_ctrl_iface_init */
// From "ctrl_iface.h":147
struct ctrl_iface_global_priv __far * _wpa_s20_wpaSGlob_ctrl_iface_init(
                                                                                   struct wpa_global __far * global);
/*** EndHeader */
_wpa_debug
struct ctrl_iface_global_priv __far * _wpa_s20_wpaSGlob_ctrl_iface_init(
                                                                                   struct wpa_global __far * global) {
	return (void  __far * )1;
}

/*** BeginHeader _wpa_s20_wpaSGlob_ctrl_iface_deinit */
// From "ctrl_iface.h":153
void _wpa_s20_wpaSGlob_ctrl_iface_deinit(struct ctrl_iface_global_priv __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaSGlob_ctrl_iface_deinit(struct ctrl_iface_global_priv __far * priv) {
}

/*** BeginHeader _wpa_s20_ieee80211_sta_init */
// From "mlme.h":42
int _wpa_s20_ieee80211_sta_init(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_init(struct wpa_supplicant __far * wpa_s) {
	return 0;
}

/*** BeginHeader _wpa_s20_ieee80211_sta_deinit */
// From "mlme.h":47
void _wpa_s20_ieee80211_sta_deinit(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s20_ieee80211_sta_deinit(struct wpa_supplicant __far * wpa_s) {
}

/*** BeginHeader _wpa_s20_ieee80211_sta_req_scan */
// From "mlme.h":51
int _wpa_s20_ieee80211_sta_req_scan(struct wpa_supplicant __far * wpa_s, char __far * ssid,
                                    size_t ssid_len);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_req_scan(struct wpa_supplicant __far * wpa_s, char __far * ssid,
                                    size_t ssid_len) {
	return  -1;
}

/*** BeginHeader _wpa_s20_ieee80211_sta_deauthenticate */
// From "mlme.h":57
int _wpa_s20_ieee80211_sta_deauthenticate(struct wpa_supplicant __far * wpa_s, word reason);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_deauthenticate(struct wpa_supplicant __far * wpa_s, word reason) {
	return  -1;
}

/*** BeginHeader _wpa_s20_ieee80211_sta_disassociate */
// From "mlme.h":63
int _wpa_s20_ieee80211_sta_disassociate(struct wpa_supplicant __far * wpa_s, word reason);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_disassociate(struct wpa_supplicant __far * wpa_s, word reason) {
	return  -1;
}

/*** BeginHeader _wpa_s20_ieee80211_sta_associate */
// From "mlme.h":70
int _wpa_s20_ieee80211_sta_associate(struct wpa_supplicant __far * wpa_s, struct wpa_driver_associate_params __far * params);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_associate(struct wpa_supplicant __far * wpa_s, struct wpa_driver_associate_params __far * params) {
	return  -1;
}

/*** BeginHeader _wpa_s20_ieee80211_sta_get_ssid */
// From "mlme.h":76
int _wpa_s20_ieee80211_sta_get_ssid(struct wpa_supplicant __far * wpa_s, char __far * ssid,
                                    size_t __far * len);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_get_ssid(struct wpa_supplicant __far * wpa_s, char __far * ssid,
                                    size_t __far * len) {
	return  -1;
}



/*** BeginHeader _wpa_s20_ieee80211_sta_get_scan_results */
// From "mlme.h":95
int _wpa_s20_ieee80211_sta_get_scan_results(struct wpa_supplicant __far * wpa_s, struct wpa_scan_result __far * results,
                                            size_t max_size);
/*** EndHeader */
_wpa_debug
int _wpa_s20_ieee80211_sta_get_scan_results(struct wpa_supplicant __far * wpa_s, struct wpa_scan_result __far * results,
                                            size_t max_size) {
	return  -1;
}
/*** BeginHeader */
//  Rabbit note: wpa_supplicant_drivers[] is defined in wifi_driver.lib instead.
//extern struct wpa_driver_ops far * wpa_supplicant_drivers[]; 	// From "wpa_supplicant.c":107
extern int wpa_debug_use_file; 	// From "wpa_supplicant.c":109
extern int wpa_debug_level; 	// From "wpa_supplicant.c":110
extern int wpa_debug_show_keys; 	// From "wpa_supplicant.c":111
extern int wpa_debug_timestamp; 	// From "wpa_supplicant.c":112
/*** EndHeader */

/*** BeginHeader _wpa_s20_wpa_alloc_eapol */
// From "wpa_supplicant.c":117
char __far * _wpa_s20_wpa_alloc_eapol(struct wpa_supplicant __far * wpa_s, char type,
                                    void __far * data, word data_len, size_t __far * msg_len,
                                    void __far * __far * data_pos);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s20_wpa_alloc_eapol(struct wpa_supplicant __far * wpa_s, char type,
                                    void __far * data, word data_len, size_t __far * msg_len,
                                    void __far * __far * data_pos) {
	struct ieee802_1x_hdr __far * hdr; 	// From "wpa_supplicant.c":121


	*msg_len = sizeof (*hdr)+data_len;
	hdr = _sys_malloc(*msg_len);
	if (hdr==((void  __far * )0))
		return ((void  __far * )0);
	hdr->version = wpa_s->conf->eapol_version;
	hdr->type = type;
	hdr->length = intel16(data_len);
	if (data)
		_f_memcpy(hdr+1, data, data_len);
	else
		_f_memset(hdr+1, 0, data_len);
	if (data_pos)
		*data_pos = hdr+1;
	return (char  __far * )hdr;
}

/*** BeginHeader _wpa_s20_wpa_ether_send */
// From "wpa_supplicant.c":153
int _wpa_s20_wpa_ether_send(struct wpa_supplicant __far * wpa_s, char __far * dest,
                            word proto, char __far * buf, size_t len);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpa_ether_send(struct wpa_supplicant __far * wpa_s, char __far * dest,
                            word proto, char __far * buf, size_t len) {
#ifdef WPA_USE_CTRL_IFACE_H
	if (wpa_s->l2) {
		return l2_packet_send(wpa_s->l2, dest, proto, buf, len);
	}
#endif//def WPA_USE_CTRL_IFACE_H
	return (wpa_s->driver->send_eapol ?
	  wpa_s->driver->send_eapol((void  __far * )(wpa_s->drv_priv), (char  __far * )(dest),
                             (word  )(proto), (char  __far * )(buf), (size_t  )(len)) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_eapol_send */
// From "wpa_supplicant.c":177
int _wpa_s20_wpaS_eapol_send(void __far * ctx, int type, char __far * buf,
                                       size_t len);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_eapol_send(void __far * ctx, int type, char __far * buf,
                                       size_t len) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":180
	char __far * msg; 	// From "wpa_supplicant.c":181
	char __far * dst; 	// From "wpa_supplicant.c":181
	char bssid[6]; 	// From "wpa_supplicant.c":181
	size_t msglen; 	// From "wpa_supplicant.c":182
	int res; 	// From "wpa_supplicant.c":183

	wpa_s = ctx;

	if (wpa_s->key_mgmt==WPA_KEY_MGMT_PSK ||
	wpa_s->key_mgmt==WPA_KEY_MGMT_NONE) {
		_WPA_PRINTF((MSG_DEBUG, "WPA: drop TX EAPOL in non-IEEE 802.1X " \
		 "mode (type=%d len=%lu)" , type, (unsigned long  )len));
		return  -1;
	}
#ifdef WPA_USE_PMKSA_CACHE
	if (pmksa_cache_get_current(wpa_s->wpa) &&
	type==IEEE802_1X_TYPE_EAPOL_START) {
		_WPA_PRINTF((MSG_DEBUG, "RSN: PMKSA caching - do not send " \
		 "EAPOL-Start" ));
		return  -1;
	}
#endif//def WPA_USE_PMKSA_CACHE
	if (memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00" , 6)==0) {
		_WPA_PRINTF((MSG_DEBUG, "BSSID not set when trying to send an " \
		 "EAPOL frame" ));
		if ((wpa_s->driver->get_bssid ?
		  wpa_s->driver->get_bssid((void  __far * )(wpa_s->drv_priv), (char  __far * )(bssid)) :
		   -1)==0 &&
		memcmp(bssid, "\x00\x00\x00\x00\x00\x00" , 6)!=0) {
			dst = bssid;
			_WPA_PRINTF((MSG_DEBUG, "Using current BSSID " \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 " from the driver as the EAPOL destination" , (dst)[0], (dst)[1], (dst)[2],
                (dst)[3], (dst)[4], (dst)[5]));
		}
		else {
			dst = wpa_s->last_eapol_src;
			_WPA_PRINTF((MSG_DEBUG, "Using the source address of the" \
			 " last received EAPOL frame " \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 " as " \
			 "the EAPOL destination" , (dst)[0], (dst)[1], (dst)[2], (dst)[3], (dst)[4],
                (dst)[5]));
		}
	}
	else {
		dst = wpa_s->bssid;
	}
	msg = _wpa_s20_wpa_alloc_eapol(wpa_s, type, buf, len, &msglen, ((void  __far * )0));
	if (msg==((void  __far * )0))
		return  -1;
	_WPA_HEXDUMP((MSG_MSGDUMP, "TX EAPOL" , msg, msglen));
	res = _wpa_s20_wpa_ether_send(wpa_s, dst, ETH_P_EAPOL, msg, msglen);
	_sys_free(msg);
	return res;
}

/*** BeginHeader _wpa_s20_wpa_eapol_set_wep_key */
// From "wpa_supplicant.c":252
int _wpa_s20_wpa_eapol_set_wep_key(void __far * ctx, int unicast, int keyidx, char __far * key,
                                   size_t keylen);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpa_eapol_set_wep_key(void __far * ctx, int unicast, int keyidx, char __far * key,
                                   size_t keylen) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":255

	union  {

		struct  {
			int cipher /* = (keylen==5) ?
			  WPA_CIPHER_WEP40 :
			  WPA_CIPHER_WEP104 */;

		} __s1;

	} __u; 	// From "wpa_supplicant.c":254

	wpa_s = ctx;

	if (wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		__u.__s1.cipher = (keylen==5) ?
		  WPA_CIPHER_WEP40 :
		  WPA_CIPHER_WEP104;

		if (unicast)
			wpa_s->pairwise_cipher = __u.__s1.cipher;
		else
			wpa_s->group_cipher = __u.__s1.cipher;
	}
	return (((struct wpa_supplicant  __far * )wpa_s)->driver->set_key ?
	  (((struct wpa_supplicant  __far * )wpa_s)->keys_cleared = 0, ((struct wpa_supplicant  __far * )wpa_s)->driver->set_key(
                                                                                                                      (void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                                                                                      (wpa_alg  )(WPA_ALG_WEP),
                                                                                                                      (char  __far * )(unicast ?
	  wpa_s->bssid :
	  (char  __far * )"\xff\xff\xff\xff\xff\xff" ), (int  )(keyidx), (int  )(unicast),
                                                                                                                      (char  __far * )((char  __far * )"" ),
                                                                                                                      (size_t  )(0),
                                                                                                                      (char  __far * )(key),
                                                                                                                      (size_t  )(keylen))) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_aborted_cached */
// From "wpa_supplicant.c":271
void _wpa_s20_wpaS_aborted_cached(void __far * ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_aborted_cached(void __far * ctx) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":273

	wpa_s = ctx;

	wpa_sm_aborted_cached(wpa_s->wpa);
}

/*** BeginHeader _wpa_s20_wpaS_set_config_blob */
// From "wpa_supplicant.c":281
void _wpa_s20_wpaS_set_config_blob(void __far * ctx, struct wpa_config_blob __far * blob);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_set_config_blob(void __far * ctx, struct wpa_config_blob __far * blob) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":284

	wpa_s = ctx;

	wpa_config_set_blob(wpa_s->conf, blob);
}

/*** BeginHeader _wpa_s20_wpaS_get_config_blob */
// From "wpa_supplicant.c":290
struct wpa_config_blob __far * _wpa_s20_wpaS_get_config_blob(void __far * ctx,
                                                                     char __far * name);
/*** EndHeader */
_wpa_debug
struct wpa_config_blob __far * _wpa_s20_wpaS_get_config_blob(void __far * ctx,
                                                                     char __far * name) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":292

	wpa_s = ctx;

	return wpa_config_get_blob(wpa_s->conf, name);
}

/*** BeginHeader _wpa_s20_wpa_set_wep_key */
// From "wpa_supplicant.c":299
int _wpa_s20_wpa_set_wep_key(void __far * ctx, int set_tx, int keyidx, char __far * key,
                             size_t keylen);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpa_set_wep_key(void __far * ctx, int set_tx, int keyidx, char __far * key,
                             size_t keylen) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":302

	wpa_s = ctx;

	return (((struct wpa_supplicant  __far * )wpa_s)->driver->set_key ?
	  (((struct wpa_supplicant  __far * )wpa_s)->keys_cleared = 0, ((struct wpa_supplicant  __far * )wpa_s)->driver->set_key(
                                                                                                                      (void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                                                                                      (wpa_alg  )(WPA_ALG_WEP),
                                                                                                                      (char  __far * )((char  __far * )"\xff\xff\xff\xff\xff\xff" ),
                                                                                                                      (int  )(keyidx),
                                                                                                                      (int  )(set_tx),
                                                                                                                      (char  __far * )((char  __far * )"" ),
                                                                                                                      (size_t  )(0),
                                                                                                                      (char  __far * )(key),
                                                                                                                      (size_t  )(keylen))) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_set_wpa_none_key */
// From "wpa_supplicant.c":309
int _wpa_s20_wpaS_set_wpa_none_key(struct wpa_supplicant __far * wpa_s,
                                             struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_set_wpa_none_key(struct wpa_supplicant __far * wpa_s,
                                             struct wpa_ssid __far * ssid) {
	char key[32]; 	// From "wpa_supplicant.c":312
	size_t keylen; 	// From "wpa_supplicant.c":313
	wpa_alg alg; 	// From "wpa_supplicant.c":314
	char seq[6] /* =
	{
		0
	} */; 	// From "wpa_supplicant.c":315

   //  Rabbit note: cannot initialize array in code: seq = {0}; using memset
   /*
	seq =
	{
		0
	};
   */
    memset(seq, 0, sizeof(seq));

	if (ssid->mode!=1) {
		_WPA_PRINTF((MSG_INFO, "WPA: Invalid mode %d (not IBSS/ad-hoc) " \
		 "for WPA-None" , ssid->mode));
		return  -1;
	}
	if (!ssid->psk_set) {
		_WPA_PRINTF((MSG_INFO, "WPA: No PSK configured for WPA-None" ));
		return  -1;
	}
	switch ((int)(wpa_s->group_cipher)) {
		case WPA_CIPHER_CCMP:
		_f_memcpy(key, ssid->psk, 16);
		keylen = 16;
		alg = WPA_ALG_CCMP;
		break;
		case WPA_CIPHER_TKIP:
		_f_memcpy(key, ssid->psk, 16+8);
		_f_memcpy(key+16+8, ssid->psk+16, 8);
		keylen = 32;
		alg = WPA_ALG_TKIP;
		break;
		default:
		_WPA_PRINTF((MSG_INFO, "WPA: Invalid group cipher %d for " \
		 "WPA-None" , wpa_s->group_cipher));
		return  -1;
	}
	return (((struct wpa_supplicant  __far * )wpa_s)->driver->set_key ?
	  (((struct wpa_supplicant  __far * )wpa_s)->keys_cleared = 0, ((struct wpa_supplicant  __far * )wpa_s)->driver->set_key(
                                                                                                                      (void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                                                                                      (wpa_alg  )(alg),
                                                                                                                      (char  __far * )((char  __far * )"\xff\xff\xff\xff\xff\xff" ),
                                                                                                                      (int  )(0),
                                                                                                                      (int  )(1),
                                                                                                                      (char  __far * )(seq),
                                                                                                                      (size_t  )(6),
                                                                                                                      (char  __far * )(key),
                                                                                                                      (size_t  )(keylen))) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_notify_eapol_done */
// From "wpa_supplicant.c":359
void _wpa_s20_wpaS_notify_eapol_done(void __far * ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_notify_eapol_done(void __far * ctx) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":361

	wpa_s = ctx;

	_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: EAPOL processing complete" ));
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X) {
		wpaS_set_state(wpa_s, WPA_4WAY_HANDSHAKE);
	}
	else {
		eloop_cancel_timeout(_wpa_s20_wpaS_scan, wpa_s, ((void  __far * )0));
		wpaS_cancel_auth_timeout(wpa_s);
		wpaS_set_state(wpa_s, WPA_COMPLETED);
	}
}

/*** BeginHeader wpa_blacklist_get */
// From "wpa_supplicant.c":380
struct wpa_blacklist __far * wpa_blacklist_get(struct wpa_supplicant __far * wpa_s,
                                             char __far * bssid);
/*** EndHeader */
_wpa_debug
struct wpa_blacklist __far * wpa_blacklist_get(struct wpa_supplicant __far * wpa_s,
                                             char __far * bssid) {
	struct wpa_blacklist __far * e; 	// From "wpa_supplicant.c":383


	e = wpa_s->blacklist;
	while (e) {
		if (memcmp(e->bssid, bssid, 6)==0)
			return e;
		e = e->next;
	}
	return ((void  __far * )0);
}

/*** BeginHeader wpa_blacklist_add */
// From "wpa_supplicant.c":412
int wpa_blacklist_add(struct wpa_supplicant __far * wpa_s, char __far * bssid);
/*** EndHeader */
_wpa_debug
int wpa_blacklist_add(struct wpa_supplicant __far * wpa_s, char __far * bssid) {
	struct wpa_blacklist __far * e; 	// From "wpa_supplicant.c":414


	e = wpa_blacklist_get(wpa_s, bssid);
	if (e) {
		e->count++;
		_WPA_PRINTF((MSG_DEBUG, "BSSID " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 " blacklist count " \
		 "incremented to %d" , (bssid)[0], (bssid)[1], (bssid)[2], (bssid)[3], (bssid)[4],
               (bssid)[5], e->count));
		return 0;
	}
	e = _sys_calloc(sizeof (*e));
	if (e==((void  __far * )0))
		return  -1;
	_f_memcpy(e->bssid, bssid, 6);
	e->count = 1;
	e->next = wpa_s->blacklist;
	wpa_s->blacklist = e;
	_WPA_PRINTF((MSG_DEBUG, "Added BSSID " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " into blacklist" , (bssid)[0], (bssid)[1], (bssid)[2], (bssid)[3], (bssid)[4],
              (bssid)[5]));
	return 0;
}

/*** BeginHeader _wpa_s20_wpa_blacklist_del */
// From "wpa_supplicant.c":439
int _wpa_s20_wpa_blacklist_del(struct wpa_supplicant __far * wpa_s, char __far * bssid);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpa_blacklist_del(struct wpa_supplicant __far * wpa_s, char __far * bssid) {
	struct wpa_blacklist __far * e; 	// From "wpa_supplicant.c":441
	struct wpa_blacklist __far * prev /* = ((void  far * )0) */; 	// From "wpa_supplicant.c":441

	prev = ((void  __far * )0);

	e = wpa_s->blacklist;
	while (e) {
		if (memcmp(e->bssid, bssid, 6)==0) {
			if (prev==((void  __far * )0)) {
				wpa_s->blacklist = e->next;
			}
			else {
				prev->next = e->next;
			}
			_WPA_PRINTF((MSG_DEBUG, "Removed BSSID " \
			 "%02x:%02x:%02x:%02x:%02x:%02x" \
			 " from " \
			 "blacklist" , (bssid)[0], (bssid)[1], (bssid)[2], (bssid)[3], (bssid)[4], (bssid)[5]));
			_sys_free(e);
			return 0;
		}
		prev = e;
		e = e->next;
	}
	return  -1;
}

/*** BeginHeader wpa_blacklist_clear */
// From "wpa_supplicant.c":467
void wpa_blacklist_clear(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void wpa_blacklist_clear(struct wpa_supplicant __far * wpa_s) {
	struct wpa_blacklist __far * e; 	// From "wpa_supplicant.c":469
	struct wpa_blacklist __far * prev; 	// From "wpa_supplicant.c":469


	e = wpa_s->blacklist;
	wpa_s->blacklist = ((void  __far * )0);
	while (e) {
		prev = e;
		e = e->next;
		_WPA_PRINTF((MSG_DEBUG, "Removed BSSID " \
		 "%02x:%02x:%02x:%02x:%02x:%02x" \
		 " from " \
		 "blacklist (clear)" , (prev->bssid)[0], (prev->bssid)[1], (prev->bssid)[2], (prev->bssid)[3],
               (prev->bssid)[4], (prev->bssid)[5]));
		_sys_free(prev);
	}
}

/*** BeginHeader wpaS_req_scan */
// From "wpa_supplicant.c":492
void wpaS_req_scan(struct wpa_supplicant __far * wpa_s, os_time_t sec, os_time_t usec);
/*** EndHeader */
_wpa_debug
void wpaS_req_scan(struct wpa_supplicant __far * wpa_s, os_time_t sec, os_time_t usec) {
	_WPA_MSG((wpa_s, MSG_DEBUG, "Setting scan request: %d sec %d usec" , sec, usec));
	eloop_cancel_timeout(_wpa_s20_wpaS_scan, wpa_s, ((void  __far * )0));
	eloop_register_timeout(((uint32)sec<<10)+(usec>>10), _wpa_s20_wpaS_scan, wpa_s, ((void  __far * )0));
}

/*** BeginHeader wpaS_cancel_scan */
// From "wpa_supplicant.c":508
void wpaS_cancel_scan(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void wpaS_cancel_scan(struct wpa_supplicant __far * wpa_s) {
	_WPA_MSG((wpa_s, MSG_DEBUG, "Cancelling scan request" ));
	eloop_cancel_timeout(_wpa_s20_wpaS_scan, wpa_s, ((void  __far * )0));
}

/*** BeginHeader _wpa_s20_wpaS_timeout */
// From "wpa_supplicant.c":515
void _wpa_s20_wpaS_timeout(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_timeout(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct wpa_supplicant __far * wpa_s /* = eloop_ctx */; 	// From "wpa_supplicant.c":517
	char __far * bssid /* = wpa_s->bssid */; 	// From "wpa_supplicant.c":518

	wpa_s = eloop_ctx;
	bssid = wpa_s->bssid;

	if (memcmp(bssid, "\x00\x00\x00\x00\x00\x00" , 6)==0)
		bssid = wpa_s->pending_bssid;
	_WPA_MSG((wpa_s, MSG_INFO, "Authentication with " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" \
	 " timed out." , (wpa_s->bssid)[0], (wpa_s->bssid)[1], (wpa_s->bssid)[2], (wpa_s->bssid)[3],
           (wpa_s->bssid)[4], (wpa_s->bssid)[5]));
	wpa_blacklist_add(wpa_s, bssid);
	wpa_sm_notify_disassoc(wpa_s->wpa);
	wpaS_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
	wpa_s->reassociate = 1;
	wpaS_req_scan(wpa_s, 0, 0);
}

/*** BeginHeader wpaS_req_auth_timeout */
// From "wpa_supplicant.c":540
void wpaS_req_auth_timeout(struct wpa_supplicant __far * wpa_s, uint32 ms);
/*** EndHeader */
_wpa_debug
void wpaS_req_auth_timeout(struct wpa_supplicant __far * wpa_s, uint32 ms) {
	if (wpa_s->conf &&
	wpa_s->conf->ap_scan==0 &&
	wpa_s->driver &&
	strcmp(wpa_s->driver->name, "wired" )==0)
		return /*void*/;
	_WPA_MSG((wpa_s, MSG_DEBUG, "Setting authentication timeout: %lu ms " , ms));
	eloop_cancel_timeout(_wpa_s20_wpaS_timeout, wpa_s, ((void  __far * )0));
	eloop_register_timeout(ms, _wpa_s20_wpaS_timeout, wpa_s, ((void  __far * )0));
}

/*** BeginHeader wpaS_cancel_auth_timeout */
// From "wpa_supplicant.c":562
void wpaS_cancel_auth_timeout(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void wpaS_cancel_auth_timeout(struct wpa_supplicant __far * wpa_s) {
	_WPA_MSG((wpa_s, MSG_DEBUG, "Cancelling authentication timeout" ));
	eloop_cancel_timeout(_wpa_s20_wpaS_timeout, wpa_s, ((void  __far * )0));
	_wpa_s20_wpa_blacklist_del(wpa_s, wpa_s->bssid);
}

/*** BeginHeader wpaS_initiate_eapol */
// From "wpa_supplicant.c":577
void wpaS_initiate_eapol(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void wpaS_initiate_eapol(struct wpa_supplicant __far * wpa_s) {
	struct eapol_config eapol_conf; 	// From "wpa_supplicant.c":580
	struct wpa_ssid __far * ssid /* = wpa_s->current_ssid */; 	// From "wpa_supplicant.c":581

	ssid = wpa_s->current_ssid;

#ifdef WPA_USE_EAP
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_PSK) {
		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
		eapol_sm_notify_eap_fail(wpa_s->eapol, FALSE);
	}

	if (wpa_s->key_mgmt==WPA_KEY_MGMT_NONE ||
	wpa_s->key_mgmt==WPA_KEY_MGMT_WPA_NONE)
		eapol_sm_notify_portControl(wpa_s->eapol, ForceAuthorized);
	else
#endif//def WPA_USE_EAP
		eapol_sm_notify_portControl(wpa_s->eapol, Auto);
	_f_memset(&eapol_conf, 0, sizeof (eapol_conf));
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		eapol_conf.accept_802_1x_keys = 1;
		eapol_conf.required_keys = 0;
		if (ssid->eapol_flags&EAPOL_FLAG_REQUIRE_KEY_UNICAST) {
			eapol_conf.required_keys |= EAPOL_REQUIRE_KEY_UNICAST;
		}
		if (ssid->eapol_flags&EAPOL_FLAG_REQUIRE_KEY_BROADCAST) {
			eapol_conf.required_keys |= EAPOL_REQUIRE_KEY_BROADCAST;
		}
		if (wpa_s->conf &&
		wpa_s->driver &&
		strcmp(wpa_s->driver->name, "wired" )==0) {
			eapol_conf.required_keys = 0;
		}
	}
#ifdef WPA_USE_EAP
	if (wpa_s->conf)
		eapol_conf.fast_reauth = wpa_s->conf->fast_reauth;
	eapol_conf.workaround = ssid->eap_workaround;
	eapol_conf.eap_disabled = wpa_s->key_mgmt!=WPA_KEY_MGMT_IEEE8021X &&
	wpa_s->key_mgmt!=WPA_KEY_MGMT_IEEE8021X_NO_WPA;
	eapol_sm_notify_config(wpa_s->eapol, ssid, &eapol_conf);
#endif//def WPA_USE_EAP
}

/*** BeginHeader wpaS_set_non_wpa_policy */
// From "wpa_supplicant.c":629
void wpaS_set_non_wpa_policy(struct wpa_supplicant __far * wpa_s, struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
void wpaS_set_non_wpa_policy(struct wpa_supplicant __far * wpa_s, struct wpa_ssid __far * ssid) {
	int i; 	// From "wpa_supplicant.c":632


	if (ssid->key_mgmt&WPA_KEY_MGMT_IEEE8021X_NO_WPA)
		wpa_s->key_mgmt = WPA_KEY_MGMT_IEEE8021X_NO_WPA;
	else
		wpa_s->key_mgmt = WPA_KEY_MGMT_NONE;
	wpa_sm_set_ap_wpa_ie(wpa_s->wpa, ((void  __far * )0), 0);
	wpa_sm_set_ap_rsn_ie(wpa_s->wpa, ((void  __far * )0), 0);
	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, ((void  __far * )0), 0);
	wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
	wpa_s->group_cipher = WPA_CIPHER_NONE;
	wpa_s->mgmt_group_cipher = 0;
	for (i = 0; i<NUM_WEP_KEYS; i++) {
		if (ssid->wep_key_len[i]>5) {
			wpa_s->pairwise_cipher = WPA_CIPHER_WEP104;
			wpa_s->group_cipher = WPA_CIPHER_WEP104;
			break;
		}
		else if (ssid->wep_key_len[i]>0) {
			wpa_s->pairwise_cipher = WPA_CIPHER_WEP40;
			wpa_s->group_cipher = WPA_CIPHER_WEP40;
			break;
		}
	}
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_KEY_MGMT, wpa_s->key_mgmt);
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_PAIRWISE, wpa_s->pairwise_cipher);
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_GROUP, wpa_s->group_cipher);
#ifdef WPA_USE_PMKSA_CACHE
	pmksa_cache_clear_current(wpa_s->wpa);
#endif//def WPA_USE_PMKSA_CACHE
}

/*** BeginHeader _wpa_s20_wpaS_cleanup */
// From "wpa_supplicant.c":670
void _wpa_s20_wpaS_cleanup(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_cleanup(struct wpa_supplicant __far * wpa_s) {
	do {
	} while (0);
#ifdef WPA_USE_SCARD_GSIM
	wpa_s->scard = ((void  __far * )0);
	wpa_sm_set_scard_ctx(wpa_s->wpa, ((void  __far * )0));
#ifdef WPA_USE_EAP
	eapol_sm_register_scard_ctx(wpa_s->eapol, ((void  __far * )0));
#endif//def WPA_USE_EAP
#endif//def WPA_USE_SCARD_GSIM
	l2_packet_deinit(wpa_s->l2);
	wpa_s->l2 = ((void  __far * )0);
	if (wpa_s->l2_br) {
		l2_packet_deinit(wpa_s->l2_br);
		wpa_s->l2_br = ((void  __far * )0);
	}
#ifdef WPA_USE_CTRL_IFACE_H
	if (wpa_s->ctrl_iface) {
		_wpa_s20_wpaS_ctrl_iface_deinit(wpa_s->ctrl_iface);
		wpa_s->ctrl_iface = ((void  __far * )0);
	}
#endif // ndef WPA_USE_CTRL_IFACE_H
	if (wpa_s->conf!=((void  __far * )0)) {
		wpa_config_free(wpa_s->conf);
		//wpa_s->conf = ((void  far * )0);	//SJH
	}
	//_sys_free(wpa_s->confname);
	wpa_s->confname = ((void  __far * )0);
#ifdef WPA_USE_EAP
	wpa_sm_set_eapol(wpa_s->wpa, ((void  __far * )0));
	eapol_sm_deinit(wpa_s->eapol);
#endif//def WPA_USE_EAP
	wpa_s->eapol = ((void  __far * )0);
#ifdef WPA_USE_PREAUTH_C
	rsn_preauth_deinit(wpa_s->wpa);
#endif//def WPA_USE_PREAUTH_C
#ifdef WPA_USE_PMKSA_CACHE
	pmksa_candidate_free(wpa_s->wpa);
#endif//def WPA_USE_PMKSA_CACHE
	wpa_sm_deinit(wpa_s->wpa);
	wpa_s->wpa = ((void  __far * )0);
	wpa_blacklist_clear(wpa_s);
	_sys_free(wpa_s->scan_results);
	wpa_s->scan_results = ((void  __far * )0);
	wpa_s->num_scan_results = 0;
	wpaS_cancel_scan(wpa_s);
	wpaS_cancel_auth_timeout(wpa_s);
	_wpa_s20_ieee80211_sta_deinit(wpa_s);
}


/*** BeginHeader wpaS_state_txt */
// From "wpa_supplicant.c":765
char __far * wpaS_state_txt(int state);
/*** EndHeader */
_wpa_debug
char __far * wpaS_state_txt(int state) {
	switch ((int)(state)) {
		case WPA_DISCONNECTED:
		return "DISCONNECTED" ;
		case WPA_INACTIVE:
		return "INACTIVE" ;
		case WPA_SCANNING:
		return "SCANNING" ;
		case WPA_ASSOCIATING:
		return "ASSOCIATING" ;
		case WPA_ASSOCIATED:
		return "ASSOCIATED" ;
		case WPA_4WAY_HANDSHAKE:
		return "4WAY_HANDSHAKE" ;
		case WPA_GROUP_HANDSHAKE:
		return "GROUP_HANDSHAKE" ;
		case WPA_COMPLETED:
		return "COMPLETED" ;
		default:
		return "UNKNOWN" ;
	}
}

/*** BeginHeader wpaS_set_state */
// From "wpa_supplicant.c":798
void wpaS_set_state(struct wpa_supplicant __far * wpa_s, wpa_states state);
/*** EndHeader */
_wpa_debug
void wpaS_set_state(struct wpa_supplicant __far * wpa_s, wpa_states state) {

	union  {

		struct  {
			struct wpa_ssid __far * ssid /* = wpa_s->current_ssid */;

		} __s1;

	} __u; 	// From "wpa_supplicant.c":799


	_WPA_PRINTF((MSG_DEBUG, "State: %ls -> %ls" , (char  __far * )(wpaS_state_txt(
                                                                                       wpa_s->wpa_state)),
              (char  __far * )(wpaS_state_txt(state))));
#ifdef WPA_USE_CTRL_IFACE_DBUS_H
	wpa_supplicant_dbus_notify_state_change(wpa_s, state, wpa_s->wpa_state);
#endif//def WPA_USE_CTRL_IFACE_DBUS_H
	if (state==WPA_COMPLETED &&
	wpa_s->new_connection) {
		__u.__s1.ssid = wpa_s->current_ssid;

		_WPA_MSG((wpa_s, MSG_INFO, "CTRL-EVENT-CONNECTED - Connection to %02x:%02x:%02x:%02x:%02x:%02x completed %ls [id=%d id_str=%ls]" ,
            (wpa_s->bssid)[0], (wpa_s->bssid)[1], (wpa_s->bssid)[2], (wpa_s->bssid)[3],
            (wpa_s->bssid)[4], (wpa_s->bssid)[5], (wpa_s->reassociated_connection ?
		  (char  __far * )"(reauth)"  :
		  (char  __far * )"(auth)" ), __u.__s1.ssid ?
		  __u.__s1.ssid->id :
		   -1, (__u.__s1.ssid &&
		__u.__s1.ssid->id_str ?
		  (char  __far * )__u.__s1.ssid->id_str :
		  (char  __far * )"" )));
		wpa_s->new_connection = 0;
		wpa_s->reassociated_connection = 1;
		(wpa_s->driver->set_operstate ?
		  wpa_s->driver->set_operstate((void  __far * )(wpa_s->drv_priv), (int  )(1)) :
		  0);
	}
	else if (state==WPA_DISCONNECTED ||
	state==WPA_ASSOCIATING ||
	state==WPA_ASSOCIATED) {
		wpa_s->new_connection = 1;
		(wpa_s->driver->set_operstate ?
		  wpa_s->driver->set_operstate((void  __far * )(wpa_s->drv_priv), (int  )(0)) :
		  0);
	}
	wpa_s->wpa_state = state;
}

/*** BeginHeader wpaS_get_state */
// From "wpa_supplicant.c":834
wpa_states wpaS_get_state(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
wpa_states wpaS_get_state(struct wpa_supplicant __far * wpa_s) {
	return wpa_s->wpa_state;
}

/*** BeginHeader _wpa_s20_wpaS_terminate */
// From "wpa_supplicant.c":840
void _wpa_s20_wpaS_terminate(int sig, void __far * eloop_ctx, void __far * signal_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_terminate(int sig, void __far * eloop_ctx, void __far * signal_ctx) {
	struct wpa_global __far * global /* = eloop_ctx */; 	// From "wpa_supplicant.c":843
	struct wpa_supplicant __far * wpa_s; 	// From "wpa_supplicant.c":844

	global = eloop_ctx;

	for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next) {
		_WPA_MSG((wpa_s, MSG_INFO, "CTRL-EVENT-TERMINATING " \
		 "- signal %d " \
		 "received" , sig));
	}
	eloop_terminate();
}

/*** BeginHeader _wpa_s20_wpaS_clear_status */
// From "wpa_supplicant.c":853
void _wpa_s20_wpaS_clear_status(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_clear_status(struct wpa_supplicant __far * wpa_s) {
	wpa_s->pairwise_cipher = 0;
	wpa_s->group_cipher = 0;
	wpa_s->mgmt_group_cipher = 0;
	wpa_s->key_mgmt = 0;
	wpa_s->wpa_state = WPA_DISCONNECTED;
}

/*** BeginHeader wpaS_reload_configuration */
// From "wpa_supplicant.c":874
int wpaS_reload_configuration(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int wpaS_reload_configuration(struct wpa_supplicant __far * wpa_s) {
	struct wpa_config __far * conf; 	// From "wpa_supplicant.c":876
	int reconf_ctrl; 	// From "wpa_supplicant.c":877


	if (wpa_s->confname==((void  __far * )0))
		return  -1;
	conf = wpa_config_read(wpa_s->confname);
	if (conf==((void  __far * )0)) {
		_WPA_MSG((wpa_s, MSG_ERROR, "Failed to parse the configuration file '%ls' - exiting" ,
            (char  __far * )(wpa_s->confname)));
		return  -1;
	}
	reconf_ctrl = !!conf->ctrl_interface!=!!wpa_s->conf->ctrl_interface ||
	(conf->ctrl_interface &&
	wpa_s->conf->ctrl_interface &&
	strcmp(conf->ctrl_interface, wpa_s->conf->ctrl_interface)!=0);
	if (reconf_ctrl &&
	wpa_s->ctrl_iface) {
		_wpa_s20_wpaS_ctrl_iface_deinit(wpa_s->ctrl_iface);
		wpa_s->ctrl_iface = ((void  __far * )0);
	}
#ifdef WPA_USE_EAP
	eapol_sm_invalidate_cached_session(wpa_s->eapol);
#endif//def WPA_USE_EAP
	wpa_s->current_ssid = ((void  __far * )0);
#ifdef WPA_USE_EAP
	eapol_sm_notify_config(wpa_s->eapol, ((void  __far * )0), ((void  __far * )0));
#endif//def WPA_USE_EAP
	wpa_sm_set_config(wpa_s->wpa, ((void  __far * )0));
	wpa_sm_set_fast_reauth(wpa_s->wpa, wpa_s->conf->fast_reauth);
#ifdef WPA_USE_PREAUTH_C
	rsn_preauth_deinit(wpa_s->wpa);
#endif//def WPA_USE_PREAUTH_C
	wpa_config_free(wpa_s->conf);
	wpa_s->conf = conf;
	if (reconf_ctrl)
		wpa_s->ctrl_iface = _wpa_s20_wpaS_ctrl_iface_init(wpa_s);
	_wpa_s20_wpaS_clear_status(wpa_s);
	wpa_s->reassociate = 1;
	wpaS_req_scan(wpa_s, 0, 0);
	_WPA_MSG((wpa_s, MSG_DEBUG, "Reconfiguration completed" ));
	return 0;
}

/*** BeginHeader _wpa_s20_wpaS_reconfig */
// From "wpa_supplicant.c":920
void _wpa_s20_wpaS_reconfig(int sig, void __far * eloop_ctx, void __far * signal_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_reconfig(int sig, void __far * eloop_ctx, void __far * signal_ctx) {
	struct wpa_global __far * global /* = eloop_ctx */; 	// From "wpa_supplicant.c":923
	struct wpa_supplicant __far * wpa_s; 	// From "wpa_supplicant.c":924

	global = eloop_ctx;

	_WPA_PRINTF((MSG_DEBUG, "Signal %d received - reconfiguring" , sig));
	for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next) {
		if (wpaS_reload_configuration(wpa_s)<0) {
			eloop_terminate();
		}
	}
}

/*** BeginHeader _wpa_s20_wpaS_gen_assoc_event */
// From "wpa_supplicant.c":934
void _wpa_s20_wpaS_gen_assoc_event(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_gen_assoc_event(struct wpa_supplicant __far * wpa_s) {
	struct wpa_ssid __far * ssid; 	// From "wpa_supplicant.c":936
	union wpa_event_data data; 	// From "wpa_supplicant.c":937


	ssid = wpaS_get_ssid(wpa_s);
	if (ssid==((void  __far * )0))
		return /*void*/;
	if (wpa_s->current_ssid==((void  __far * )0))
		wpa_s->current_ssid = ssid;
#ifdef WPA_USE_EAP
	wpaS_initiate_eapol(wpa_s);
#endif//def WPA_USE_EAP
	_WPA_PRINTF((MSG_DEBUG, "Already associated with a configured network - " \
	 "generating associated event" ));
	_f_memset(&data, 0, sizeof (data));
	wpaS_event(wpa_s, EVENT_ASSOC, &data);
}

/*** BeginHeader _wpa_s20_wpaS_scan */
// From "wpa_supplicant.c":953
void _wpa_s20_wpaS_scan(void __far * eloop_ctx, void __far * timeout_ctx);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_scan(void __far * eloop_ctx, void __far * timeout_ctx) {
	struct wpa_supplicant __far * wpa_s /* = eloop_ctx */; 	// From "wpa_supplicant.c":955
	struct wpa_ssid __far * ssid; 	// From "wpa_supplicant.c":956
	int enabled; 	// From "wpa_supplicant.c":957
	int scan_req /* = 0 */; 	// From "wpa_supplicant.c":957
	int ret; 	// From "wpa_supplicant.c":957

	wpa_s = eloop_ctx;
	scan_req = 0;

	if (wpa_s->disconnected)
		return /*void*/;
	enabled = 0;
	ssid = wpa_s->conf->ssid;
	while (ssid) {
		if (!ssid->disabled) {
			enabled++;
			break;
		}
		ssid = ssid->next;
	}
	if (!enabled &&
	!wpa_s->scan_req) {
		_WPA_PRINTF((MSG_DEBUG, "No enabled networks - do not scan" ));
		wpaS_set_state(wpa_s, WPA_INACTIVE);
		return /*void*/;
	}
	scan_req = wpa_s->scan_req;
	wpa_s->scan_req = 0;
	if (wpa_s->conf->ap_scan!=0 &&
	wpa_s->driver &&
	strcmp(wpa_s->driver->name, "wired" )==0) {
		_WPA_PRINTF((MSG_DEBUG, "Using wired driver - overriding " \
		 "ap_scan configuration" ));
		wpa_s->conf->ap_scan = 0;
	}
	if (wpa_s->conf->ap_scan==0) {
		_wpa_s20_wpaS_gen_assoc_event(wpa_s);
		return /*void*/;
	}
	if (wpa_s->wpa_state==WPA_DISCONNECTED ||
	wpa_s->wpa_state==WPA_INACTIVE)
		wpaS_set_state(wpa_s, WPA_SCANNING);
	ssid = wpa_s->conf->ssid;
	if (wpa_s->prev_scan_ssid!=((struct wpa_ssid  __far * )1)) {
		while (ssid) {
			if (ssid==wpa_s->prev_scan_ssid) {
				ssid = ssid->next;
				break;
			}
			ssid = ssid->next;
		}
	}
	while (ssid) {
		if (!ssid->disabled &&
		(ssid->scan_ssid ||
		wpa_s->conf->ap_scan==2))
			break;
		ssid = ssid->next;
	}
	if (scan_req!=2 &&
	wpa_s->conf->ap_scan==2) {
		if (ssid==((void  __far * )0)) {
			_WPA_PRINTF((MSG_DEBUG, "wpa_supplicant_scan: Reached " \
			 "end of scan list - go back to beginning" ));
			wpa_s->prev_scan_ssid = ((struct wpa_ssid  __far * )1);
			wpaS_req_scan(wpa_s, 0, 0);
			return /*void*/;
		}
		if (ssid->next) {
			wpa_s->prev_scan_ssid = ssid;
		}
		else {
			wpa_s->prev_scan_ssid = ((struct wpa_ssid  __far * )1);
		}
		wpaS_associate(wpa_s, ((void  __far * )0), ssid);
		return /*void*/;
	}
	_WPA_PRINTF((MSG_DEBUG, "Starting AP scan (%ls SSID)" , (char  __far * )(ssid ?
	  "specific"  :
	  "broadcast" )));
	if (ssid) {
		_WPA_HEXDUMP((MSG_DEBUG, "Scan SSID" , ssid->ssid, ssid->ssid_len));
		wpa_s->prev_scan_ssid = ssid;
	}
	else
		wpa_s->prev_scan_ssid = ((struct wpa_ssid  __far * )1);
	if (wpa_s->scan_res_tried==0 &&
	wpa_s->conf->ap_scan==1) {
		wpa_s->scan_res_tried++;
		_WPA_PRINTF((MSG_DEBUG, "Trying to get current scan results " \
		 "first without requesting a new scan to speed up " \
		 "initial association" ));
		wpaS_event(wpa_s, EVENT_SCAN_RESULTS, ((void  __far * )0));
		return /*void*/;
	}
	if (wpa_s->use_client_mlme) {
		ret = _wpa_s20_ieee80211_sta_req_scan(wpa_s, ssid ?
		  ssid->ssid :
		  ((void  __far * )0), ssid ?
		  ssid->ssid_len :
		  0);
	}
	else {
		ret = (wpa_s->driver->scan ?
		  wpa_s->driver->scan((void  __far * )(wpa_s->drv_priv), (char  __far * )(ssid ?
		  ssid->ssid :
		  ((void  __far * )0)), (size_t  )(ssid ?
		  ssid->ssid_len :
		  0)) :
		   -1);
	}
	if (ret) {
		_WPA_PRINTF((MSG_WARNING, "Failed to initiate AP scan." ));
		wpaS_req_scan(wpa_s, 10, 0);
	}
}

/*** BeginHeader _wpa_s20_cipher_suite2driver */
// From "wpa_supplicant.c":1067
wpa_cipher _wpa_s20_cipher_suite2driver(int cipher);
/*** EndHeader */
_wpa_debug
wpa_cipher _wpa_s20_cipher_suite2driver(int cipher) {
	switch ((int)(cipher)) {
		case WPA_CIPHER_NONE:
		return CIPHER_NONE;
		case WPA_CIPHER_WEP40:
		return CIPHER_WEP40;
		case WPA_CIPHER_WEP104:
		return CIPHER_WEP104;
		case WPA_CIPHER_CCMP:
		return CIPHER_CCMP;
		case WPA_CIPHER_TKIP:
		default:
		return CIPHER_TKIP;
	}
}

/*** BeginHeader _wpa_s20_key_mgmt2driver */
// From "wpa_supplicant.c":1085
wpa_key_mgmt _wpa_s20_key_mgmt2driver(int key_mgmt);
/*** EndHeader */
_wpa_debug
wpa_key_mgmt _wpa_s20_key_mgmt2driver(int key_mgmt) {
	switch ((int)(key_mgmt)) {
		case WPA_KEY_MGMT_NONE:
		return KEY_MGMT_NONE;
		case WPA_KEY_MGMT_IEEE8021X_NO_WPA:
		return KEY_MGMT_802_1X_NO_WPA;
		case WPA_KEY_MGMT_IEEE8021X:
		return KEY_MGMT_802_1X;
		case WPA_KEY_MGMT_WPA_NONE:
		return KEY_MGMT_WPA_NONE;
		case WPA_KEY_MGMT_PSK:
		default:
		return KEY_MGMT_PSK;
	}
}

/*** BeginHeader _wpa_s20_wpaS_suites_from_ai */
// From "wpa_supplicant.c":1103
int _wpa_s20_wpaS_suites_from_ai(struct wpa_supplicant __far * wpa_s, struct wpa_ssid __far * ssid,
                                           struct wpa_ie_data __far * ie);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_suites_from_ai(struct wpa_supplicant __far * wpa_s, struct wpa_ssid __far * ssid,
                                           struct wpa_ie_data __far * ie) {
	int ret /* = wpa_sm_parse_own_wpa_ie(wpa_s->wpa, ie) */; 	// From "wpa_supplicant.c":1107

	ret = wpa_sm_parse_own_wpa_ie(wpa_s->wpa, ie);

	if (ret) {
		if (ret== -2) {
			_WPA_MSG((wpa_s, MSG_INFO, "WPA: Failed to %s", "parse WPA IE " \
			 "from association info" ));
		}
		return  -1;
	}
	_WPA_PRINTF((MSG_DEBUG, "WPA: Using WPA IE from AssocReq to set cipher " \
	 "suites" ));
	if (!(ie->group_cipher&ssid->group_cipher)) {
		_WPA_MSG((wpa_s, MSG_INFO, "WPA: Driver used disabled group " \
		 "cipher 0x%x (mask 0x%x) - reject" , ie->group_cipher, ssid->group_cipher));
		return  -1;
	}
	if (!(ie->pairwise_cipher&ssid->pairwise_cipher)) {
		_WPA_MSG((wpa_s, MSG_INFO, "WPA: Driver used disabled pairwise " \
		 "cipher 0x%x (mask 0x%x) - reject" , ie->pairwise_cipher, ssid->pairwise_cipher));
		return  -1;
	}
	if (!(ie->key_mgmt&ssid->key_mgmt)) {
		_WPA_MSG((wpa_s, MSG_INFO, "WPA: Driver used disabled key " \
		 "management 0x%x (mask 0x%x) - reject" , ie->key_mgmt, ssid->key_mgmt));
		return  -1;
	}
	return 0;
}

/*** BeginHeader wpaS_set_suites */
// From "wpa_supplicant.c":1165
int wpaS_set_suites(struct wpa_supplicant __far * wpa_s, struct wpa_scan_result __far * bss,
                              struct wpa_ssid __far * ssid, char __far * wpa_ie, size_t __far * wpa_ie_len);
/*** EndHeader */
_wpa_debug
int wpaS_set_suites(struct wpa_supplicant __far * wpa_s, struct wpa_scan_result __far * bss,
                              struct wpa_ssid __far * ssid, char __far * wpa_ie, size_t __far * wpa_ie_len) {
	struct wpa_ie_data ie; 	// From "wpa_supplicant.c":1170
	int sel; 	// From "wpa_supplicant.c":1171
	int proto; 	// From "wpa_supplicant.c":1171


	if (bss &&
	bss->rsn_ie_len &&
	(ssid->proto&WPA_PROTO_RSN) &&
	wpa_parse_wpa_ie(bss->rsn_ie, bss->rsn_ie_len, &ie)==0 &&
	(ie.group_cipher&ssid->group_cipher) &&
	(ie.pairwise_cipher&ssid->pairwise_cipher) &&
	(ie.key_mgmt&ssid->key_mgmt)) {
		_WPA_MSG((wpa_s, MSG_DEBUG, "RSN: using IEEE 802.11i/D9.0" ));
		proto = WPA_PROTO_RSN;
	}
	else if (bss &&
	bss->wpa_ie_len &&
	(ssid->proto&WPA_PROTO_WPA) &&
	wpa_parse_wpa_ie(bss->wpa_ie, bss->wpa_ie_len, &ie)==0 &&
	(ie.group_cipher&ssid->group_cipher) &&
	(ie.pairwise_cipher&ssid->pairwise_cipher) &&
	(ie.key_mgmt&ssid->key_mgmt)) {
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "IEEE 802.11i/D3.0" ));
		proto = WPA_PROTO_WPA;
	}
	else if (bss) {
		_WPA_MSG((wpa_s, MSG_WARNING, "WPA: Failed to %s", "select WPA/RSN" ));
		return  -1;
	}
	else {
		if (ssid->proto&WPA_PROTO_RSN)
			proto = WPA_PROTO_RSN;
		else
			proto = WPA_PROTO_WPA;
		if (_wpa_s20_wpaS_suites_from_ai(wpa_s, ssid, &ie)<0) {
			_f_memset(&ie, 0, sizeof (ie));
			ie.group_cipher = ssid->group_cipher;
			ie.pairwise_cipher = ssid->pairwise_cipher;
			ie.key_mgmt = ssid->key_mgmt;
			_WPA_PRINTF((MSG_DEBUG, "WPA: Set cipher suites based " \
			 "on configuration" ));
		}
		else
			proto = ie.proto;
	}
	_WPA_PRINTF((MSG_DEBUG, "WPA: Selected cipher suites: group %d " \
	 "pairwise %d key_mgmt %d proto %d" , ie.group_cipher, ie.pairwise_cipher, ie.key_mgmt,
              proto));
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_PROTO, proto);
	if (wpa_sm_set_ap_wpa_ie(wpa_s->wpa, bss ?
	  bss->wpa_ie :
	  ((void  __far * )0), bss ?
	  bss->wpa_ie_len :
	  0) ||
	wpa_sm_set_ap_rsn_ie(wpa_s->wpa, bss ?
	  bss->rsn_ie :
	  ((void  __far * )0), bss ?
	  bss->rsn_ie_len :
	  0))
		return  -1;
	sel = ie.group_cipher&ssid->group_cipher;
	if (sel&WPA_CIPHER_CCMP) {
		wpa_s->group_cipher = WPA_CIPHER_CCMP;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "GTK CCMP" ));
	}
	else if (sel&WPA_CIPHER_TKIP) {
		wpa_s->group_cipher = WPA_CIPHER_TKIP;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "GTK TKIP" ));
	}
	else if (sel&WPA_CIPHER_WEP104) {
		wpa_s->group_cipher = WPA_CIPHER_WEP104;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "GTK WEP104" ));
	}
	else if (sel&WPA_CIPHER_WEP40) {
		wpa_s->group_cipher = WPA_CIPHER_WEP40;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "GTK WEP40" ));
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "select group cipher." ));
		return  -1;
	}
	sel = ie.pairwise_cipher&ssid->pairwise_cipher;
	if (sel&WPA_CIPHER_CCMP) {
		wpa_s->pairwise_cipher = WPA_CIPHER_CCMP;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "PTK CCMP" ));
	}
	else if (sel&WPA_CIPHER_TKIP) {
		wpa_s->pairwise_cipher = WPA_CIPHER_TKIP;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "PTK TKIP" ));
	}
	else if (sel&WPA_CIPHER_NONE) {
		wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "PTK NONE" ));
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "select pairwise " \
		 "cipher." ));
		return  -1;
	}
	sel = ie.key_mgmt&ssid->key_mgmt;
#ifdef WPA_USE_EAP
	if (sel&WPA_KEY_MGMT_IEEE8021X) {
		wpa_s->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "KEY_MGMT 802.1X" ));
	}
	else
#endif//def WPA_USE_EAP
   if (sel&WPA_KEY_MGMT_PSK) {
		wpa_s->key_mgmt = WPA_KEY_MGMT_PSK;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "KEY_MGMT WPA-PSK" ));
	}
	else if (sel&WPA_KEY_MGMT_WPA_NONE) {
		wpa_s->key_mgmt = WPA_KEY_MGMT_WPA_NONE;
		_WPA_MSG((wpa_s, MSG_DEBUG, "WPA: using %s", "KEY_MGMT WPA-NONE" ));
	}
	else {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "select authenticated " \
		 "key management type." ));
		return  -1;
	}
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_KEY_MGMT, wpa_s->key_mgmt);
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_PAIRWISE, wpa_s->pairwise_cipher);
	wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_GROUP, wpa_s->group_cipher);
	if (wpa_sm_set_assoc_wpa_ie_default(wpa_s->wpa, wpa_ie, wpa_ie_len)) {
		_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "generate WPA IE." ));
		return  -1;
	}
	if (ssid->key_mgmt&WPA_KEY_MGMT_PSK)
		wpa_sm_set_pmk(wpa_s->wpa, ssid->psk, PMK_LEN);
	else
		wpa_sm_set_pmk_from_pmksa(wpa_s->wpa);
	return 0;
}

/*** BeginHeader wpaS_associate */
// From "wpa_supplicant.c":1323
void wpaS_associate(struct wpa_supplicant __far * wpa_s, struct wpa_scan_result __far * bss,
                              struct wpa_ssid __far * ssid);
/*** EndHeader */
_wpa_debug
void wpaS_associate(struct wpa_supplicant __far * wpa_s, struct wpa_scan_result __far * bss,
                              struct wpa_ssid __far * ssid) {
	char wpa_ie[80]; 	// From "wpa_supplicant.c":1327
	size_t wpa_ie_len; 	// From "wpa_supplicant.c":1328
	int use_crypt; 	// From "wpa_supplicant.c":1329
	int ret; 	// From "wpa_supplicant.c":1329
	int i; 	// From "wpa_supplicant.c":1329
	int algs /* = AUTH_ALG_OPEN_SYSTEM */; 	// From "wpa_supplicant.c":1330
	wpa_cipher cipher_pairwise; 	// From "wpa_supplicant.c":1331
	wpa_cipher cipher_group; 	// From "wpa_supplicant.c":1331
	struct wpa_driver_associate_params params; 	// From "wpa_supplicant.c":1332
	int wep_keys_set /* = 0 */; 	// From "wpa_supplicant.c":1333
	struct wpa_driver_capa capa; 	// From "wpa_supplicant.c":1334
	int assoc_failed /* = 0 */; 	// From "wpa_supplicant.c":1335

	union  {

		struct  {
			int try_opportunistic;

		} __s5;

		struct  {
			int timeout;

		} __s16;

		struct  {
			int j;

		} __s17;

	} __u; 	// From "wpa_supplicant.c":1326

	algs = AUTH_ALG_OPEN_SYSTEM;
	wep_keys_set = 0;
	assoc_failed = 0;

	wpa_s->reassociate = 0;
	if (bss) {
		_WPA_MSG((wpa_s, MSG_INFO, "Trying to associate with %02x:%02x:%02x:%02x:%02x:%02x (SSID='%ls' freq=%d MHz)" ,
            (bss->bssid)[0], (bss->bssid)[1], (bss->bssid)[2], (bss->bssid)[3],
            (bss->bssid)[4], (bss->bssid)[5], (char  __far * )(wpa_ssid_txt(bss->ssid,
                                                                          bss->ssid_len)),
            bss->freq));
		_f_memset(wpa_s->bssid, 0, 6);
		_f_memcpy(wpa_s->pending_bssid, bss->bssid, 6);
	}
	else {
		_WPA_MSG((wpa_s, MSG_INFO, "Trying to associate with SSID '%ls'" , (char  __far * )(wpa_ssid_txt(
                                                                                                 ssid->ssid,
                                                                                                 ssid->ssid_len))));
		_f_memset(wpa_s->pending_bssid, 0, 6);
	}
	wpaS_cancel_scan(wpa_s);
	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, ((void  __far * )0), 0);
	if (ssid->key_mgmt&WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		if (ssid->leap) {
			if (ssid->non_leap==0)
				algs = AUTH_ALG_LEAP;
			else
				algs |= AUTH_ALG_LEAP;
		}
	}
	_WPA_PRINTF((MSG_DEBUG, "Automatic auth_alg selection: 0x%x" , algs));
	if (ssid->auth_alg) {
		algs = 0;
		if (ssid->auth_alg&WPA_AUTH_ALG_OPEN)
			algs |= AUTH_ALG_OPEN_SYSTEM;
		if (ssid->auth_alg&WPA_AUTH_ALG_SHARED)
			algs |= AUTH_ALG_SHARED_KEY;
		if (ssid->auth_alg&WPA_AUTH_ALG_LEAP)
			algs |= AUTH_ALG_LEAP;
		_WPA_PRINTF((MSG_DEBUG, "Overriding auth_alg selection: 0x%x" , algs));
	}
	(wpa_s->driver->set_auth_alg ?
	  wpa_s->driver->set_auth_alg((void  __far * )(wpa_s->drv_priv), (int  )(algs)) :
	   -1);
	if (bss &&
	(bss->wpa_ie_len ||
	bss->rsn_ie_len) &&
	(ssid->key_mgmt&(WPA_KEY_MGMT_IEEE8021X|WPA_KEY_MGMT_PSK))) {
		__u.__s5.try_opportunistic = ssid->proactive_key_caching &&
		(ssid->proto&WPA_PROTO_RSN);
#ifdef WPA_USE_EAP
#ifdef WPA_USE_PMKSA_CACHE
		if (pmksa_cache_set_current(wpa_s->wpa, ((void  __far * )0), bss->bssid, wpa_s->current_ssid,
                              __u.__s5.try_opportunistic)==0)
			eapol_sm_notify_pmkid_attempt(wpa_s->eapol, 1);
#endif//def WPA_USE_PMKSA_CACHE
#endif//def WPA_USE_EAP
		wpa_ie_len = sizeof (wpa_ie);
		if (wpaS_set_suites(wpa_s, bss, ssid, wpa_ie, &wpa_ie_len)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "set WPA key " \
			 "management and encryption suites" ));
			return /*void*/;
		}
	}
	else if (ssid->key_mgmt&(WPA_KEY_MGMT_PSK|WPA_KEY_MGMT_IEEE8021X|WPA_KEY_MGMT_WPA_NONE)) {
		wpa_ie_len = sizeof (wpa_ie);
		if (wpaS_set_suites(wpa_s, ((void  __far * )0), ssid, wpa_ie, &wpa_ie_len)) {
			_WPA_PRINTF((MSG_WARNING, "WPA: Failed to %s", "set WPA key " \
			 "management and encryption suites (no scan " \
			 "results)" ));
			return /*void*/;
		}
	}
	else {
		wpaS_set_non_wpa_policy(wpa_s, ssid);
		wpa_ie_len = 0;
	}
	wpa_clear_keys(wpa_s, bss ?
	  bss->bssid :
	  ((void  __far * )0));
	use_crypt = 1;
	cipher_pairwise = _wpa_s20_cipher_suite2driver(wpa_s->pairwise_cipher);
	cipher_group = _wpa_s20_cipher_suite2driver(wpa_s->group_cipher);
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_NONE ||
	wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		if (wpa_s->key_mgmt==WPA_KEY_MGMT_NONE)
			use_crypt = 0;
		for (i = 0; i<NUM_WEP_KEYS; i++) {
			if (ssid->wep_key_len[i]) {
				use_crypt = 1;
				wep_keys_set = 1;
				_wpa_s20_wpa_set_wep_key(wpa_s, i==ssid->wep_tx_keyidx, i, ssid->wep_key[i],
                             ssid->wep_key_len[i]);
			}
		}
	}
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		if ((ssid->eapol_flags&(EAPOL_FLAG_REQUIRE_KEY_UNICAST|EAPOL_FLAG_REQUIRE_KEY_BROADCAST))
      ==0 &&
		!wep_keys_set) {
			use_crypt = 0;
		}
		else {
			cipher_pairwise = cipher_group = CIPHER_WEP104;
		}
	}
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_WPA_NONE) {
		_wpa_s20_wpaS_set_wpa_none_key(wpa_s, ssid);
	}
	(wpa_s->driver->set_drop_unencrypted ?
	  wpa_s->driver->set_drop_unencrypted((void  __far * )(wpa_s->drv_priv), (int  )(use_crypt)) :
	   -1);
	wpaS_set_state(wpa_s, WPA_ASSOCIATING);
	_f_memset(&params, 0, sizeof (params));
	if (bss) {
		params.bssid = bss->bssid;
		params.ssid = bss->ssid;
		params.ssid_len = bss->ssid_len;
		params.freq = bss->freq;
	}
	else {
		params.ssid = ssid->ssid;
		params.ssid_len = ssid->ssid_len;
	}
	params.wpa_ie = wpa_ie;
	params.wpa_ie_len = wpa_ie_len;
	params.pairwise_suite = cipher_pairwise;
	params.group_suite = cipher_group;
	params.key_mgmt_suite = _wpa_s20_key_mgmt2driver(wpa_s->key_mgmt);
	params.auth_alg = algs;
	params.mode = ssid->mode;
	for (i = 0; i<NUM_WEP_KEYS; i++) {
		if (ssid->wep_key_len[i])
			params.wep_key[i] = (char __far *)(ssid->wep_key + i);
		params.wep_key_len[i] = ssid->wep_key_len[i];
	}
	params.wep_tx_keyidx = ssid->wep_tx_keyidx;
	if (wpa_s->use_client_mlme)
		ret = _wpa_s20_ieee80211_sta_associate(wpa_s, &params);
	else
		ret = (wpa_s->driver->associate ?
		  wpa_s->driver->associate((void  __far * )(wpa_s->drv_priv), (struct wpa_driver_associate_params  __far * )(&params)) :
		   -1);
	if (ret<0) {
		_WPA_MSG((wpa_s, MSG_INFO, "Association request to the driver " \
		 "failed" ));
		assoc_failed = 1;
	}
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_WPA_NONE) {
		_wpa_s20_wpaS_set_wpa_none_key(wpa_s, ssid);
		wpaS_cancel_auth_timeout(wpa_s);
		wpaS_set_state(wpa_s, WPA_COMPLETED);
	}
	else {
		if (assoc_failed)
			__u.__s16.timeout = 5;
		else if (wpa_s->conf->ap_scan==1)
			__u.__s16.timeout = 10;
		else
			__u.__s16.timeout = 60;
		wpaS_req_auth_timeout(wpa_s, (uint32)__u.__s16.timeout<<10);
	}
	if (wep_keys_set &&
	(wpa_s->driver->get_capa ?
	  wpa_s->driver->get_capa((void  __far * )(wpa_s->drv_priv), (struct wpa_driver_capa  __far * )(&capa)) :
	   -1)==0 &&
	capa.flags&WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC) {
		for (__u.__s17.j = 0; __u.__s17.j<NUM_WEP_KEYS; __u.__s17.j++) {
			if (ssid->wep_key_len[__u.__s17.j]) {
				_wpa_s20_wpa_set_wep_key(wpa_s, __u.__s17.j==ssid->wep_tx_keyidx, __u.__s17.j,
                             ssid->wep_key[__u.__s17.j], ssid->wep_key_len[__u.__s17.j]);
			}
		}
	}
#ifdef WPA_USE_EAP
	if (wpa_s->current_ssid &&
	wpa_s->current_ssid!=ssid) {
		eapol_sm_invalidate_cached_session(wpa_s->eapol);
	}
#endif//def WPA_USE_EAP
	wpa_s->current_ssid = ssid;
	wpa_sm_set_config(wpa_s->wpa, wpa_s->current_ssid);
#ifdef WPA_USE_EAP
	wpaS_initiate_eapol(wpa_s);
#endif//def WPA_USE_EAP
}

/*** BeginHeader wpaS_disassociate */
// From "wpa_supplicant.c":1559
void wpaS_disassociate(struct wpa_supplicant __far * wpa_s, int reason_code);
/*** EndHeader */
_wpa_debug
void wpaS_disassociate(struct wpa_supplicant __far * wpa_s, int reason_code) {
	char __far * addr /* = ((void  far * )0) */; 	// From "wpa_supplicant.c":1562

	addr = ((void  __far * )0);

	if (memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00" , 6)!=0) {
		if (wpa_s->use_client_mlme)
			_wpa_s20_ieee80211_sta_disassociate(wpa_s, reason_code);
		else
			(wpa_s->driver->disassociate ?
			  wpa_s->driver->disassociate((void  __far * )(wpa_s->drv_priv), (char  __far * )(wpa_s->bssid),
                                 (int  )(reason_code)) :
			   -1);
		addr = wpa_s->bssid;
	}
	wpa_clear_keys(wpa_s, addr);
	wpaS_mark_disassoc(wpa_s);
	wpa_s->current_ssid = ((void  __far * )0);
	wpa_sm_set_config(wpa_s->wpa, ((void  __far * )0));
#ifdef WPA_USE_EAP
	eapol_sm_notify_config(wpa_s->eapol, ((void  __far * )0), ((void  __far * )0));
#endif//def WPA_USE_EAP
}

/*** BeginHeader wpaS_deauthenticate */
// From "wpa_supplicant.c":1587
void wpaS_deauthenticate(struct wpa_supplicant __far * wpa_s, int reason_code);
/*** EndHeader */
_wpa_debug
void wpaS_deauthenticate(struct wpa_supplicant __far * wpa_s, int reason_code) {
	char __far * addr /* = ((void  far * )0) */; 	// From "wpa_supplicant.c":1590

	addr = ((void  __far * )0);

	wpaS_set_state(wpa_s, WPA_DISCONNECTED);
	if (memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00" , 6)!=0) {
		if (wpa_s->use_client_mlme)
			_wpa_s20_ieee80211_sta_deauthenticate(wpa_s, reason_code);
		else
			if (wpa_s->driver->deauthenticate) {
			  	wpa_s->driver->deauthenticate((void  __far * )(wpa_s->drv_priv), (char  __far * )(wpa_s->bssid),
                                   (int  )(reason_code));
         }
		addr = wpa_s->bssid;
	}
	wpa_clear_keys(wpa_s, addr);
	wpa_s->current_ssid = ((void  __far * )0);
	wpa_sm_set_config(wpa_s->wpa, ((void  __far * )0));
#ifdef WPA_USE_EAP
	eapol_sm_notify_config(wpa_s->eapol, ((void  __far * )0), ((void  __far * )0));
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
#endif//def WPA_USE_EAP
}

/*** BeginHeader wpaS_get_scan_results */
// From "wpa_supplicant.c":1618
int wpaS_get_scan_results(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int wpaS_get_scan_results(struct wpa_supplicant __far * wpa_s) {
	//enum {SCAN_AP_LIMIT = 128};
	struct wpa_scan_result __far * results; 	// From "wpa_supplicant.c":1621
	struct wpa_scan_result __far * tmp; 	// From "wpa_supplicant.c":1621
	int num; 	// From "wpa_supplicant.c":1622


	results = _sys_malloc(SCAN_AP_LIMIT*sizeof(struct wpa_scan_result  ));
	if (results==((void  __far * )0)) {
		_WPA_PRINTF((MSG_WARNING, "Failed to allocate memory for scan " \
		 "results" ));
		return  -1;
	}
	if (wpa_s->use_client_mlme) {
		num = _wpa_s20_ieee80211_sta_get_scan_results(wpa_s, results, SCAN_AP_LIMIT);
	}
	else
		num = (wpa_s->driver->get_scan_results ?
		  wpa_s->driver->get_scan_results((void  __far * )(wpa_s->drv_priv), (struct wpa_scan_result  __far * )(results),
                                    (size_t  )(SCAN_AP_LIMIT)) :
		   -1);
	_WPA_PRINTF((MSG_DEBUG, "Scan results: %d" , num));
	if (num<0) {
		_WPA_PRINTF((MSG_DEBUG, "Failed to get scan results" ));
		_sys_free(results);
		return  -1;
	}
	if (num>SCAN_AP_LIMIT) {
		_WPA_PRINTF((MSG_INFO, "Not enough room for all APs (%d < %d)" , num, SCAN_AP_LIMIT));
		num = SCAN_AP_LIMIT;
	}
	tmp = _sys_realloc(results, num*sizeof(struct wpa_scan_result  ));
	if (tmp ||
	num==0) {
		results = tmp;
	}
	_sys_free(wpa_s->scan_results);
	wpa_s->scan_results = results;
	wpa_s->num_scan_results = num;
	return 0;
}

/*** BeginHeader _wpa_s20_wpa_get_beacon_ie */
// From "wpa_supplicant.c":1663
int _wpa_s20_wpa_get_beacon_ie(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpa_get_beacon_ie(struct wpa_supplicant __far * wpa_s) {
	int i; 	// From "wpa_supplicant.c":1665
	int ret /* = 0 */; 	// From "wpa_supplicant.c":1665
	struct wpa_scan_result __far * results; 	// From "wpa_supplicant.c":1666
	struct wpa_scan_result __far * curr /* = ((void  far * )0) */; 	// From "wpa_supplicant.c":1666

	union  {

		struct  {
			struct wpa_ssid __far * ssid /* = wpa_s->current_ssid */;

		} __s2;

	} __u; 	// From "wpa_supplicant.c":1664

	ret = 0;
	curr = ((void  __far * )0);

	results = wpa_s->scan_results;
	if (results==((void  __far * )0)) {
		return  -1;
	}
	for (i = 0; i<wpa_s->num_scan_results; i++) {
		__u.__s2.ssid = wpa_s->current_ssid;

		if (memcmp(results[i].bssid, wpa_s->bssid, 6)!=0)
			continue;
		if (__u.__s2.ssid==((void  __far * )0) ||
		((results[i].ssid_len==__u.__s2.ssid->ssid_len &&
		memcmp(results[i].ssid, __u.__s2.ssid->ssid, __u.__s2.ssid->ssid_len)==0) ||
		__u.__s2.ssid->ssid_len==0)) {
			curr = &results[i];
			break;
		}
	}
	if (curr) {
		if (wpa_sm_set_ap_wpa_ie(wpa_s->wpa, curr->wpa_ie, curr->wpa_ie_len) ||
		wpa_sm_set_ap_rsn_ie(wpa_s->wpa, curr->rsn_ie, curr->rsn_ie_len))
			ret =  -1;
	}
	else {
		ret =  -1;
	}
	return ret;
}

/*** BeginHeader _wpa_s20_wpaS_get_beacon_ie */
// From "wpa_supplicant.c":1701
int _wpa_s20_wpaS_get_beacon_ie(void __far * ctx);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_get_beacon_ie(void __far * ctx) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":1703

	wpa_s = ctx;

	if (_wpa_s20_wpa_get_beacon_ie(wpa_s)==0) {
		return 0;
	}
	if (wpaS_get_scan_results(wpa_s)<0) {
		return  -1;
	}
	return _wpa_s20_wpa_get_beacon_ie(wpa_s);
}

/*** BeginHeader wpaS_get_ssid */
// From "wpa_supplicant.c":1724
struct wpa_ssid __far * wpaS_get_ssid(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
struct wpa_ssid __far * wpaS_get_ssid(struct wpa_supplicant __far * wpa_s) {
	struct wpa_ssid __far * entry; 	// From "wpa_supplicant.c":1726
	char ssid[MAX_SSID_LEN]; 	// From "wpa_supplicant.c":1727
	int res; 	// From "wpa_supplicant.c":1728
	size_t ssid_len; 	// From "wpa_supplicant.c":1729
	char bssid[6]; 	// From "wpa_supplicant.c":1730
	int wired; 	// From "wpa_supplicant.c":1731


	if (wpa_s->use_client_mlme) {
		if (_wpa_s20_ieee80211_sta_get_ssid(wpa_s, ssid, &ssid_len)) {
			_WPA_PRINTF((MSG_WARNING, "Could not read SSID from " \
			 "MLME." ));
			return ((void  __far * )0);
		}
	}
	else {
		res = (wpa_s->driver->get_ssid ?
		  wpa_s->driver->get_ssid((void  __far * )(wpa_s->drv_priv), (char  __far * )(ssid)) :
		   -1);
		if (res<0) {
			_WPA_PRINTF((MSG_WARNING, "Could not read SSID from " \
			 "driver." ));
			return ((void  __far * )0);
		}
		ssid_len = res;
	}
	if (wpa_s->use_client_mlme)
		_f_memcpy(bssid, wpa_s->bssid, 6);
	else if ((wpa_s->driver->get_bssid ?
	  wpa_s->driver->get_bssid((void  __far * )(wpa_s->drv_priv), (char  __far * )(bssid)) :
	   -1)<0) {
		_WPA_PRINTF((MSG_WARNING, "Could not read BSSID from driver." ));
		return ((void  __far * )0);
	}
	wired = wpa_s->conf->ap_scan==0 &&
	wpa_s->driver &&
	strcmp(wpa_s->driver->name, "wired" )==0;
	entry = wpa_s->conf->ssid;
	while (entry) {
		if (!entry->disabled &&
		((ssid_len==entry->ssid_len &&
		memcmp(ssid, entry->ssid, ssid_len)==0) ||
		wired) &&
		(!entry->bssid_set ||
		memcmp(bssid, entry->bssid, 6)==0))
			return entry;
		entry = entry->next;
	}
	return ((void  __far * )0);
}

/*** BeginHeader _wpa_s20__wpa_alloc_eapol */
// From "wpa_supplicant.c":1775
char __far * _wpa_s20__wpa_alloc_eapol(void __far * wpa_s, char type, void __far * data,
                                     word data_len, size_t __far * msg_len, void __far * __far * data_pos);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s20__wpa_alloc_eapol(void __far * wpa_s, char type, void __far * data,
                                     word data_len, size_t __far * msg_len, void __far * __far * data_pos) {
	return _wpa_s20_wpa_alloc_eapol(wpa_s, type, data, data_len, msg_len, data_pos);
}

/*** BeginHeader _wpa_s20__wpa_ether_send */
// From "wpa_supplicant.c":1783
int _wpa_s20__wpa_ether_send(void __far * wpa_s, char __far * dest, word proto, char __far * buf,
                             size_t len);
/*** EndHeader */
_wpa_debug
int _wpa_s20__wpa_ether_send(void __far * wpa_s, char __far * dest, word proto, char __far * buf,
                             size_t len) {
	return _wpa_s20_wpa_ether_send(wpa_s, dest, proto, buf, len);
}

/*** BeginHeader _wpa_s20__wpaS_req_scan */
// From "wpa_supplicant.c":1790
void _wpa_s20__wpaS_req_scan(void __far * wpa_s, int sec, int usec);
/*** EndHeader */
_wpa_debug
void _wpa_s20__wpaS_req_scan(void __far * wpa_s, int sec, int usec) {
	wpaS_req_scan(wpa_s, sec, usec);
}

/*** BeginHeader _wpa_s20__wpaS_cancel_auth_timeout */
// From "wpa_supplicant.c":1796
void _wpa_s20__wpaS_cancel_auth_timeout(void __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s20__wpaS_cancel_auth_timeout(void __far * wpa_s) {
	wpaS_cancel_auth_timeout(wpa_s);
}

/*** BeginHeader _wpa_s20__wpaS_set_state */
// From "wpa_supplicant.c":1802
void _wpa_s20__wpaS_set_state(void __far * wpa_s, wpa_states state);
/*** EndHeader */
_wpa_debug
void _wpa_s20__wpaS_set_state(void __far * wpa_s, wpa_states state) {
	wpaS_set_state(wpa_s, state);
}

/*** BeginHeader _wpa_s20__wpaS_get_state */
// From "wpa_supplicant.c":1808
wpa_states _wpa_s20__wpaS_get_state(void __far * wpa_s);
/*** EndHeader */
_wpa_debug
wpa_states _wpa_s20__wpaS_get_state(void __far * wpa_s) {
	return wpaS_get_state(wpa_s);
}

/*** BeginHeader _wpa_s20__wpaS_disassociate */
// From "wpa_supplicant.c":1814
void _wpa_s20__wpaS_disassociate(void __far * wpa_s, int reason_code);
/*** EndHeader */
_wpa_debug
void _wpa_s20__wpaS_disassociate(void __far * wpa_s, int reason_code) {
	wpaS_disassociate(wpa_s, reason_code);
}

/*** BeginHeader _wpa_s20__wpaS_deauthenticate */
// From "wpa_supplicant.c":1820
void _wpa_s20__wpaS_deauthenticate(void __far * wpa_s, int reason_code);
/*** EndHeader */
_wpa_debug
void _wpa_s20__wpaS_deauthenticate(void __far * wpa_s, int reason_code) {
	wpaS_deauthenticate(wpa_s, reason_code);
}

/*** BeginHeader _wpa_s20__wpaS_get_ssid */
// From "wpa_supplicant.c":1826
struct wpa_ssid __far * _wpa_s20__wpaS_get_ssid(void __far * wpa_s);
/*** EndHeader */
_wpa_debug
struct wpa_ssid __far * _wpa_s20__wpaS_get_ssid(void __far * wpa_s) {
	return wpaS_get_ssid(wpa_s);
}

/*** BeginHeader _wpa_s20_wpaS_get_bssid */
// From "wpa_supplicant.c":1832
int _wpa_s20_wpaS_get_bssid(void __far * ctx, char __far * bssid);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_get_bssid(void __far * ctx, char __far * bssid) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":1834

	wpa_s = ctx;

	if (wpa_s->use_client_mlme) {
		_f_memcpy(bssid, wpa_s->bssid, 6);
		return 0;
	}
	return (wpa_s->driver->get_bssid ?
	  wpa_s->driver->get_bssid((void  __far * )(wpa_s->drv_priv), (char  __far * )(bssid)) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_set_key */
// From "wpa_supplicant.c":1843
   //  Rabbit note: DC doesn't like the return type (cast problem?)  Return struct far * instead
int _wpa_s20_wpaS_set_key(struct wpa_supplicant __far * wpa_s, wpa_alg alg, char __far * addr,
                                    int key_idx, int set_tx, char __far * seq, size_t seq_len,
                                    char __far * key, size_t key_len);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_set_key(struct wpa_supplicant __far * wpa_s, wpa_alg alg, char __far * addr,
                                    int key_idx, int set_tx, char __far * seq, size_t seq_len,
                                    char __far * key, size_t key_len) {
	return (((struct wpa_supplicant  __far * )wpa_s)->driver->set_key ?
	  (((struct wpa_supplicant  __far * )wpa_s)->keys_cleared = 0, ((struct wpa_supplicant  __far * )wpa_s)->driver->set_key(
                                                                                                                      (void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                                                                                      (wpa_alg  )(alg),
                                                                                                                      (char  __far * )(addr),
                                                                                                                      (int  )(key_idx),
                                                                                                                      (int  )(set_tx),
                                                                                                                      (char  __far * )(seq),
                                                                                                                      (size_t  )(seq_len),
                                                                                                                      (char  __far * )(key),
                                                                                                                      (size_t  )(key_len))) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_mlme_setprotection */
// From "wpa_supplicant.c":1853
int _wpa_s20_wpaS_mlme_setprotection(void __far * wpa_s, char __far * addr,
                                               int protection_type, int key_type);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_mlme_setprotection(void __far * wpa_s, char __far * addr,
                                               int protection_type, int key_type) {
	return (((struct wpa_supplicant  __far * )wpa_s)->driver->mlme_setprotection ?
	  ((struct wpa_supplicant  __far * )wpa_s)->driver->mlme_setprotection((void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                                      (char  __far * )(addr),
                                                                      (int  )(protection_type),
                                                                      (int  )(key_type)) :
	  0);
}

/*** BeginHeader _wpa_s20_wpaS_add_pmkid */
// From "wpa_supplicant.c":1862
int _wpa_s20_wpaS_add_pmkid(void __far * wpa_s, char __far * bssid, char __far * pmkid);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_add_pmkid(void __far * wpa_s, char __far * bssid, char __far * pmkid) {
	return (((struct wpa_supplicant  __far * )wpa_s)->driver->add_pmkid ?
	  ((struct wpa_supplicant  __far * )wpa_s)->driver->add_pmkid((void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                             (char  __far * )(bssid),
                                                             (char  __far * )(pmkid)) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_remove_pmkid */
// From "wpa_supplicant.c":1869
int _wpa_s20_wpaS_remove_pmkid(void __far * wpa_s, char __far * bssid, char __far * pmkid);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_remove_pmkid(void __far * wpa_s, char __far * bssid, char __far * pmkid) {
	return (((struct wpa_supplicant  __far * )wpa_s)->driver->remove_pmkid ?
	  ((struct wpa_supplicant  __far * )wpa_s)->driver->remove_pmkid((void  __far * )(((struct wpa_supplicant  __far * )wpa_s)->drv_priv),
                                                                (char  __far * )(bssid),
                                                                (char  __far * )(pmkid)) :
	   -1);
}

/*** BeginHeader _wpa_s20_wpaS_set_driver */
// From "wpa_supplicant.c":1877
int _wpa_s20_wpaS_set_driver(struct wpa_supplicant __far * wpa_s, char __far * name);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_set_driver(struct wpa_supplicant __far * wpa_s, char __far * name) {
	int i; 	// From "wpa_supplicant.c":1880


	if (wpa_s==((void  __far * )0))
		return  -1;
	if (wpa_supplicant_drivers[0]==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "No driver interfaces build into " \
		 "wpa_supplicant." ));
		return  -1;
	}
	if (name==((void  __far * )0)) {
		wpa_s->driver = wpa_supplicant_drivers[0];
		return 0;
	}
	for (i = 0; wpa_supplicant_drivers[i]; i++) {
		if (strcmp(name, wpa_supplicant_drivers[i]->name)==0) {
			wpa_s->driver = wpa_supplicant_drivers[i];
			return 0;
		}
	}
	_WPA_PRINTF((MSG_ERROR, "Unsupported driver '%ls'.\n" , (char  __far * )(name)));
	return  -1;
}

/*** BeginHeader wpaS_rx_eapol */
// From "wpa_supplicant.c":1909
void wpaS_rx_eapol(void __far * ctx, char __far * src_addr, char __far * buf,
                             size_t len);
/*** EndHeader */
_wpa_debug
void wpaS_rx_eapol(void __far * ctx, char __far * src_addr, char __far * buf,
                             size_t len) {
	struct wpa_supplicant __far * wpa_s /* = ctx */; 	// From "wpa_supplicant.c":1912

	wpa_s = ctx;

	_WPA_PRINTF((MSG_DEBUG, "RX EAPOL from " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (src_addr)[0], (src_addr)[1], (src_addr)[2],
              (src_addr)[3], (src_addr)[4], (src_addr)[5]));
	_WPA_HEXDUMP((MSG_MSGDUMP, "RX EAPOL" , buf, len));
	if (!wpa_s->wpa) {
		_WPA_PRINTF((MSG_DEBUG, "Ignored received EAPOL frame since no sm" ));
		return /*void*/;
	}
	if (wpa_s->key_mgmt==WPA_KEY_MGMT_NONE) {
		_WPA_PRINTF((MSG_DEBUG, "Ignored received EAPOL frame since " \
		 "no key management is configured" ));
		return /*void*/;
	}
	if (wpa_s->eapol_received==0) {
		wpaS_req_auth_timeout(wpa_s, (wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X
                                           ||
		wpa_s->key_mgmt==WPA_KEY_MGMT_IEEE8021X_NO_WPA) ?
		  70000uL :
		  10000uL);
	}
	wpa_s->eapol_received++;
	if (wpa_s->countermeasures) {
		_WPA_PRINTF((MSG_INFO, "WPA: Countermeasures - dropped EAPOL " \
		 "packet" ));
		return /*void*/;
	}
	_f_memcpy(wpa_s->last_eapol_src, src_addr, 6);
#ifdef WPA_USE_EAP
	if (wpa_s->key_mgmt!=WPA_KEY_MGMT_PSK &&
	eapol_sm_rx_eapol(wpa_s->eapol, src_addr, buf, len)>0)
		return /*void*/;
#endif//def WPA_USE_EAP
	do {
		if (wpa_s->driver->poll)
			wpa_s->driver->poll((void  __far * )(wpa_s->drv_priv));
	} while (0);
	wpa_sm_rx_eapol(wpa_s->wpa, src_addr, buf, len);
}

/*** BeginHeader wpaS_driver_init */
// From "wpa_supplicant.c":1965
int wpaS_driver_init(struct wpa_supplicant __far * wpa_s, int wait_for_interface);
/*** EndHeader */
_wpa_debug
int wpaS_driver_init(struct wpa_supplicant __far * wpa_s, int wait_for_interface) {

	union  {

		struct  {

			union  {

				struct  {
					char __far * addr /* = (wpa_s->driver->get_mac_addr ?
					  wpa_s->driver->get_mac_addr((void  far * )(wpa_s->drv_priv)) :
					  ((void  far * )0)) */;

				} __s1;

			} __u;

		} __s1;

		struct  {
			struct wpa_driver_capa capa;

		} __s4;

	} __u; 	// From "wpa_supplicant.c":1967


	for (; ; ) {
		if (wpa_s->driver->send_eapol) {
			__u.__s1.__u.__s1.addr = (wpa_s->driver->get_mac_addr ?
			  wpa_s->driver->get_mac_addr((void  __far * )(wpa_s->drv_priv)) :
			  ((void  __far * )0));

			if (__u.__s1.__u.__s1.addr)
				_f_memcpy(wpa_s->own_addr, __u.__s1.__u.__s1.addr, 6);
			break;
		}
		wpa_s->l2 = l2_packet_init(wpa_s->ifname, (wpa_s->driver->get_mac_addr ?
		  wpa_s->driver->get_mac_addr((void  __far * )(wpa_s->drv_priv)) :
		  ((void  __far * )0)), ETH_P_EAPOL, wpaS_rx_eapol, wpa_s, 0);
		if (wpa_s->l2)
			break;
		else if (!wait_for_interface)
			return  -1;
		_WPA_PRINTF((MSG_DEBUG, "Waiting for interface.." ));
		os_sleep(5, 0);
	}
	if (wpa_s->l2 &&
	l2_packet_get_own_addr(wpa_s->l2, wpa_s->own_addr)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to get own L2 address" ));
		return  -1;
	}
	_WPA_PRINTF((MSG_DEBUG, "Own MAC address: " \
	 "%02x:%02x:%02x:%02x:%02x:%02x" , (wpa_s->own_addr)[0], (wpa_s->own_addr)[1],
              (wpa_s->own_addr)[2], (wpa_s->own_addr)[3], (wpa_s->own_addr)[4],
              (wpa_s->own_addr)[5]));
	if (wpa_s->bridge_ifname[0]) {
		_WPA_PRINTF((MSG_DEBUG, "Receiving packets from bridge interface '%ls'" , (char  __far * )(wpa_s->bridge_ifname)));
		wpa_s->l2_br = l2_packet_init(wpa_s->bridge_ifname, wpa_s->own_addr, ETH_P_EAPOL,
                                wpaS_rx_eapol, wpa_s, 0);
		if (wpa_s->l2_br==((void  __far * )0)) {
			_WPA_PRINTF((MSG_ERROR, "Failed to open l2_packet connection for the bridge interface '%ls'" ,
                (char  __far * )(wpa_s->bridge_ifname)));
			return  -1;
		}
	}
	if ((wpa_s->driver->set_wpa ?
	  wpa_s->driver->set_wpa((void  __far * )(wpa_s->drv_priv), (int  )(1)) :
	  0)<0) {
		if ((wpa_s->driver->get_capa ?
		  wpa_s->driver->get_capa((void  __far * )(wpa_s->drv_priv), (struct wpa_driver_capa  __far * )(&__u.__s4.capa)) :
		   -1)<0 ||
		!(__u.__s4.capa.flags&(WPA_DRIVER_CAPA_KEY_MGMT_WPA|WPA_DRIVER_CAPA_KEY_MGMT_WPA2))) {
			_WPA_PRINTF((MSG_DEBUG, "Driver does not support WPA." ));
		}
		else {
			_WPA_PRINTF((MSG_ERROR, "Failed to enable WPA in the " \
			 "driver." ));
			return  -1;
		}
	}
	wpa_clear_keys(wpa_s, ((void  __far * )0));
	(wpa_s->driver->set_countermeasures ?
	  wpa_s->driver->set_countermeasures((void  __far * )(wpa_s->drv_priv), (int  )(0)) :
	   -1);
	(wpa_s->driver->set_drop_unencrypted ?
	  wpa_s->driver->set_drop_unencrypted((void  __far * )(wpa_s->drv_priv), (int  )(1)) :
	   -1);
	wpa_s->prev_scan_ssid = ((struct wpa_ssid  __far * )1);
	wpaS_req_scan(wpa_s, __wpa_globals.__s20.__s76.interface_count, 100000);
	__wpa_globals.__s20.__s76.interface_count++;
	return 0;
}

/*** BeginHeader _wpa_s20_wpaS_daemon */
// From "wpa_supplicant.c":2046
int _wpa_s20_wpaS_daemon(char __far * pid_file);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_daemon(char __far * pid_file) {
	_WPA_PRINTF((MSG_DEBUG, "Daemonize.." ));
	return os_daemonize(pid_file);
}

/*** BeginHeader _wpa_s20_wpaS_alloc */
// From "wpa_supplicant.c":2053
struct wpa_supplicant __far * _wpa_s20_wpaS_alloc(void );
/*** EndHeader */
_wpa_debug
struct wpa_supplicant __far * _wpa_s20_wpaS_alloc(void ) {
	struct wpa_supplicant __far * wpa_s; 	// From "wpa_supplicant.c":2055


	wpa_s = _sys_calloc(sizeof (*wpa_s));
	if (wpa_s==((void  __far * )0))
		return ((void  __far * )0);
	wpa_s->scan_req = 1;
	return wpa_s;
}

/*** BeginHeader _wpa_s20_wpaS_init_iface */
// From "wpa_supplicant.c":2066
int _wpa_s20_wpaS_init_iface(struct wpa_supplicant __far * wpa_s, struct wpa_interface __far * iface);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_init_iface(struct wpa_supplicant __far * wpa_s, struct wpa_interface __far * iface) {
	_WPA_PRINTF((MSG_DEBUG, "Initializing interface '%ls' conf '%ls' driver '%ls' ctrl_interface '%ls' bridge '%ls'" ,
              (iface->ifname), (char  __far * )(iface->confname ?
	  (char  __far * )iface->confname :
	  (char  __far * )"N/A" ), (iface->driver ?
	  (char  __far * )iface->driver :
	  (char  __far * )"default" ), (iface->ctrl_interface ?
	  (char  __far * )iface->ctrl_interface :
	  (char  __far * )"N/A" ), (iface->bridge_ifname ?
	  (char  __far * )iface->bridge_ifname :
	  (char  __far * )"N/A" )));
	if (_wpa_s20_wpaS_set_driver(wpa_s, iface->driver)<0) {
		return  -1;
	}
/*
//  Rabbit note: Not using a configuration file.
	if (iface->confname) {
		wpa_s->confname = os_rel2abs_path(iface->confname);
		if (wpa_s->confname==((void  far * )0)) {
			_WPA_PRINTF((MSG_ERROR, "Failed to get absolute path for configuration file '%ls'." ,
                (char  far * )(iface->confname)));
			return  -1;
		}
		_WPA_PRINTF((MSG_DEBUG, "Configuration file '%ls' -> '%ls'" , (char  far * )(iface->confname),
               (char  far * )(wpa_s->confname)));
		wpa_s->conf = wpa_config_read(wpa_s->confname);
		if (wpa_s->conf==((void  far * )0)) {
			_WPA_PRINTF((MSG_ERROR, "Failed to read or parse configuration '%ls'." , (char  far * )(wpa_s->confname)));
			return  -1;
		}
		if (iface->ctrl_interface) {
			_sys_free(wpa_s->conf->ctrl_interface);
			wpa_s->conf->ctrl_interface = _sys_strdup(iface->ctrl_interface);
		}
		if (iface->driver_param) {
			_sys_free(wpa_s->conf->driver_param);
			wpa_s->conf->driver_param = _sys_strdup(iface->driver_param);
		}
	}
	else
		wpa_s->conf = wpa_config_alloc_empty(iface->ctrl_interface, iface->driver_param);
	if (wpa_s->conf==((void  far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "\nNo configuration found." ));
		return  -1;
	}
	if (iface->ifname==((void  far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "\nInterface name is required." ));
		return  -1;
	}
	if (strlen(iface->ifname)>=sizeof (wpa_s->ifname)) {
		_WPA_PRINTF((MSG_ERROR, "\nToo long interface name '%ls'." , (char  far * )(iface->ifname)));
		return  -1;
	}
	_f_strncpy(wpa_s->ifname, iface->ifname, sizeof (wpa_s->ifname));
	if (iface->bridge_ifname) {
		if (strlen(iface->bridge_ifname)>=sizeof (wpa_s->bridge_ifname)) {
			_WPA_PRINTF((MSG_ERROR, "\nToo long bridge interface name '%ls'." , (char  far * )(iface->bridge_ifname)));
			return  -1;
		}
		_f_strncpy(wpa_s->bridge_ifname, iface->bridge_ifname, sizeof (wpa_s->bridge_ifname));
	}
*/
	return 0;
}

/*** BeginHeader _wpa_s20_wpaS_init_eapol */
// From "wpa_supplicant.c":2151
int _wpa_s20_wpaS_init_eapol(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_init_eapol(struct wpa_supplicant __far * wpa_s) {
	struct eapol_ctx __far * ctx; 	// From "wpa_supplicant.c":2154


	ctx = _sys_calloc(sizeof (*ctx));
	if (ctx==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to allocate EAPOL context." ));
		return  -1;
	}
	ctx->ctx = wpa_s;
	ctx->msg_ctx = wpa_s;
	ctx->eapol_send_ctx = wpa_s;
	ctx->preauth = 0;
	ctx->eapol_done_cb = _wpa_s20_wpaS_notify_eapol_done;
	ctx->eapol_send = _wpa_s20_wpaS_eapol_send;
	ctx->set_wep_key = _wpa_s20_wpa_eapol_set_wep_key;
	ctx->set_config_blob = _wpa_s20_wpaS_set_config_blob;
	ctx->get_config_blob = _wpa_s20_wpaS_get_config_blob;
	ctx->aborted_cached = _wpa_s20_wpaS_aborted_cached;
	ctx->opensc_engine_path = wpa_s->conf->opensc_engine_path;
	ctx->pkcs11_engine_path = wpa_s->conf->pkcs11_engine_path;
	ctx->pkcs11_module_path = wpa_s->conf->pkcs11_module_path;
#ifdef WPA_USE_EAP
	wpa_s->eapol = eapol_sm_init(ctx);
	if (wpa_s->eapol==((void  __far * )0)) {
		_sys_free(ctx);
		_WPA_PRINTF((MSG_ERROR, "Failed to initialize EAPOL state " \
		 "machines." ));
		return  -1;
	}
#endif//def WPA_USE_EAP
	return 0;
}

/*** BeginHeader _wpa_s20_wpaS_init_wpa */
// From "wpa_supplicant.c":2187
int _wpa_s20_wpaS_init_wpa(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_init_wpa(struct wpa_supplicant __far * wpa_s) {
	struct wpa_sm_ctx __far * ctx; 	// From "wpa_supplicant.c":2190


	ctx = _sys_calloc(sizeof (*ctx));
	if (ctx==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to allocate WPA context." ));
		return  -1;
	}
	ctx->ctx = wpa_s;
	ctx->set_state = _wpa_s20__wpaS_set_state;
	ctx->get_state = _wpa_s20__wpaS_get_state;
	ctx->req_scan = _wpa_s20__wpaS_req_scan;
	ctx->deauthenticate = _wpa_s20__wpaS_deauthenticate;
	ctx->disassociate = _wpa_s20__wpaS_disassociate;
	ctx->set_key = _wpa_s20_wpaS_set_key;
	ctx->scan = _wpa_s20_wpaS_scan;
	ctx->get_ssid = _wpa_s20__wpaS_get_ssid;
	ctx->get_bssid = _wpa_s20_wpaS_get_bssid;
	ctx->ether_send = _wpa_s20__wpa_ether_send;
	ctx->get_beacon_ie = _wpa_s20_wpaS_get_beacon_ie;
	ctx->alloc_eapol = _wpa_s20__wpa_alloc_eapol;
	ctx->cancel_auth_timeout = _wpa_s20__wpaS_cancel_auth_timeout;
#ifdef WPA_USE_PMKSA_CACHE
	ctx->add_pmkid = _wpa_s20_wpaS_add_pmkid;
	ctx->remove_pmkid = _wpa_s20_wpaS_remove_pmkid;
#endif//def WPA_USE_PMKSA_CACHE
	ctx->set_config_blob = _wpa_s20_wpaS_set_config_blob;
	ctx->get_config_blob = _wpa_s20_wpaS_get_config_blob;
	ctx->mlme_setprotection = _wpa_s20_wpaS_mlme_setprotection;
	wpa_s->wpa = wpa_sm_init(ctx);
	if (wpa_s->wpa==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to initialize WPA state " \
		 "machine" ));
		return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s20_wpaS_init_iface2 */
// From "wpa_supplicant.c":2229
int _wpa_s20_wpaS_init_iface2(struct wpa_supplicant __far * wpa_s, int wait_for_interface);
/*** EndHeader */
_wpa_debug
int _wpa_s20_wpaS_init_iface2(struct wpa_supplicant __far * wpa_s, int wait_for_interface) {
	char __far * ifname; 	// From "wpa_supplicant.c":2232
	struct wpa_driver_capa capa; 	// From "wpa_supplicant.c":2233


	_WPA_PRINTF((MSG_DEBUG, "Initializing interface (2) '%ls'" , (char  __far * )(wpa_s->ifname)));
	if (_wpa_s20_wpaS_init_eapol(wpa_s)<0)
		return  -1;
#ifdef WPA_USE_EAP
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
#endif//def WPA_USE_EAP
	wpa_s->drv_priv = (wpa_s->driver->init ?
	  wpa_s->driver->init((void  __far * )(wpa_s), (char  __far * )(wpa_s->ifname)) :
	  ((void  __far * )0));
	if (wpa_s->drv_priv==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to initialize driver interface" ));
		return  -1;
	}
	if ((wpa_s->driver->set_param ?
	  wpa_s->driver->set_param((void  __far * )(wpa_s->drv_priv), (char  __far * )(wpa_s->conf->driver_param)) :
	  0)<0) {
		_WPA_PRINTF((MSG_ERROR, "Driver interface rejected driver_param '%ls'" , (char  __far * )(wpa_s->conf->driver_param)));
		return  -1;
	}
	ifname = (wpa_s->driver->get_ifname ?
	  wpa_s->driver->get_ifname((void  __far * )(wpa_s->drv_priv)) :
	  ((void  __far * )0));
	if (ifname &&
	strcmp(ifname, wpa_s->ifname)!=0) {
		_WPA_PRINTF((MSG_DEBUG, "Driver interface replaced interface name with '%ls'" ,
               (char  __far * )(ifname)));
		_f_strncpy(wpa_s->ifname, ifname, sizeof (wpa_s->ifname));
	}
	if (_wpa_s20_wpaS_init_wpa(wpa_s)<0)
		return  -1;
	wpa_sm_set_ifname(wpa_s->wpa, wpa_s->ifname, wpa_s->bridge_ifname[0] ?
	  wpa_s->bridge_ifname :
	  ((void  __far * )0));
	wpa_sm_set_fast_reauth(wpa_s->wpa, wpa_s->conf->fast_reauth);
	wpa_sm_set_eapol(wpa_s->wpa, wpa_s->eapol);
	if (wpa_s->conf->dot11RSNAConfigPMKLifetime &&
	wpa_sm_set_param(wpa_s->wpa, RSNA_PMK_LIFETIME, wpa_s->conf->dot11RSNAConfigPMKLifetime)) {
		_WPA_PRINTF((MSG_ERROR, "Invalid WPA parameter value for " \
		 "dot11RSNAConfigPMKLifetime" ));
		return  -1;
	}
	if (wpa_s->conf->dot11RSNAConfigPMKReauthThreshold &&
	wpa_sm_set_param(wpa_s->wpa, RSNA_PMK_REAUTH_THRESHOLD, wpa_s->conf->dot11RSNAConfigPMKReauthThreshold)) {
		_WPA_PRINTF((MSG_ERROR, "Invalid WPA parameter value for " \
		 "dot11RSNAConfigPMKReauthThreshold" ));
		return  -1;
	}
	if (wpa_s->conf->dot11RSNAConfigSATimeout &&
	wpa_sm_set_param(wpa_s->wpa, RSNA_SA_TIMEOUT, wpa_s->conf->dot11RSNAConfigSATimeout)) {
		_WPA_PRINTF((MSG_ERROR, "Invalid WPA parameter value for " \
		 "dot11RSNAConfigSATimeout" ));
		return  -1;
	}
	if (wpaS_driver_init(wpa_s, wait_for_interface)<0) {
		return  -1;
	}
	wpa_sm_set_own_addr(wpa_s->wpa, wpa_s->own_addr);
#ifdef WPA_USE_CTRL_IFACE_H
	wpa_s->ctrl_iface = _wpa_s20_wpaS_ctrl_iface_init(wpa_s);
	if (wpa_s->ctrl_iface==((void  __far * )0)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to initialize control interface '%ls'.\nYou may have another wpa_supplicant process already running or the file was\nleft by an unclean termination of wpa_supplicant in which case you will need\nto manually remove this file before starting wpa_supplicant again.\n" ,
               (char  __far * )(wpa_s->conf->ctrl_interface)));
		return  -1;
	}
#endif//def WPA_USE_CTRL_IFACE_H
	if ((wpa_s->driver->get_capa ?
	  wpa_s->driver->get_capa((void  __far * )(wpa_s->drv_priv), (struct wpa_driver_capa  __far * )(&capa)) :
	   -1)==0 &&
	capa.flags&WPA_DRIVER_FLAGS_USER_SPACE_MLME) {
		wpa_s->use_client_mlme = 1;
		if (_wpa_s20_ieee80211_sta_init(wpa_s))
			return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s20_wpaS_deinit_iface */
// From "wpa_supplicant.c":2330
void _wpa_s20_wpaS_deinit_iface(struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
void _wpa_s20_wpaS_deinit_iface(struct wpa_supplicant __far * wpa_s) {
	if (wpa_s->drv_priv) {
		wpaS_deauthenticate(wpa_s, REASON_DEAUTH_LEAVING);
		if ((wpa_s->driver->set_wpa ?
		  wpa_s->driver->set_wpa((void  __far * )(wpa_s->drv_priv), (int  )(0)) :
		  0)<0) {
			_WPA_PRINTF((MSG_ERROR, "Failed to disable WPA in the " \
			 "driver." ));
		}
		(wpa_s->driver->set_drop_unencrypted ?
		  wpa_s->driver->set_drop_unencrypted((void  __far * )(wpa_s->drv_priv), (int  )(0)) :
		   -1);
		(wpa_s->driver->set_countermeasures ?
		  wpa_s->driver->set_countermeasures((void  __far * )(wpa_s->drv_priv), (int  )(0)) :
		   -1);
		wpa_clear_keys(wpa_s, ((void  __far * )0));
	}
#ifdef WPA_USE_CTRL_IFACE_DBUS_H
	wpas_dbus_unregister_iface(wpa_s);
#endif//def WPA_USE_CTRL_IFACE_DBUS_H
	_wpa_s20_wpaS_cleanup(wpa_s);
	if (wpa_s->drv_priv)
		do {
			if (wpa_s->driver->deinit)
				wpa_s->driver->deinit((void  __far * )(wpa_s->drv_priv));
		} while (0);
}

/*** BeginHeader wpaS_add_iface */
// From "wpa_supplicant.c":2369
struct wpa_supplicant __far * wpaS_add_iface(struct wpa_global __far * global,
                                                     struct wpa_interface __far * iface);
/*** EndHeader */
_wpa_debug
struct wpa_supplicant __far * wpaS_add_iface(struct wpa_global __far * global,
                                                     struct wpa_interface __far * iface) {
	struct wpa_supplicant __far * wpa_s; 	// From "wpa_supplicant.c":2372


	if (global==((void  __far * )0) ||
	iface==((void  __far * )0))
		return ((void  __far * )0);
   //  Rabbit note: use global static wpa_s instead of this "alloc" version
	//wpa_s = _wpa_s20_wpaS_alloc();
   wpa_s = wpa_s_static_pointer;
	if (wpa_s==((void  __far * )0))
		return ((void  __far * )0);
	if (_wpa_s20_wpaS_init_iface(wpa_s, iface) ||
	_wpa_s20_wpaS_init_iface2(wpa_s, global->params.wait_for_interface)) {
		_WPA_PRINTF((MSG_DEBUG, "Failed to add interface %ls" , (char  __far * )(iface->ifname)));
		_wpa_s20_wpaS_deinit_iface(wpa_s);
      //  Rabbit note: wpa_s is static
		//_sys_free(wpa_s);
		return ((void  __far * )0);
	}
	wpa_s->global = global;
#ifdef WPA_USE_CTRL_IFACE_DBUS_H
	if (wpas_dbus_register_iface(wpa_s)) {
		_wpa_s20_wpaS_deinit_iface(wpa_s);
      //  Rabbit note: wpa_s is static
		//_sys_free(wpa_s);
		return ((void  __far * )0);
	}
#endif//def WPA_USE_CTRL_IFACE_DBUS_H
	wpa_s->next = global->ifaces;
	global->ifaces = wpa_s;
	_WPA_PRINTF((MSG_DEBUG, "Added interface %ls" , (char  __far * )(wpa_s->ifname)));
	return wpa_s;
}

/*** BeginHeader wpaS_remove_iface */
// From "wpa_supplicant.c":2420
int wpaS_remove_iface(struct wpa_global __far * global, struct wpa_supplicant __far * wpa_s);
/*** EndHeader */
_wpa_debug
int wpaS_remove_iface(struct wpa_global __far * global, struct wpa_supplicant __far * wpa_s) {
	struct wpa_supplicant __far * prev; 	// From "wpa_supplicant.c":2423


	prev = global->ifaces;
	if (prev==wpa_s) {
		global->ifaces = wpa_s->next;
	}
	else {
		while (prev &&
		prev->next!=wpa_s)
			prev = prev->next;
		if (prev==((void  __far * )0))
			return  -1;
		prev->next = wpa_s->next;
	}
	_WPA_PRINTF((MSG_DEBUG, "Removing interface %ls" , (char  __far * )(wpa_s->ifname)));
	_wpa_s20_wpaS_deinit_iface(wpa_s);
   //  Rabbit note: wpa_s is static
	//_sys_free(wpa_s);
	return 0;
}

/*** BeginHeader wpaS_get_iface */
// From "wpa_supplicant.c":2452
struct wpa_supplicant __far * wpaS_get_iface(struct wpa_global __far * global,
                                                     char __far * ifname);
/*** EndHeader */
_wpa_debug
struct wpa_supplicant __far * wpaS_get_iface(struct wpa_global __far * global,
                                                     char __far * ifname) {
	struct wpa_supplicant __far * wpa_s; 	// From "wpa_supplicant.c":2455


	for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next) {
		if (strcmp(wpa_s->ifname, ifname)==0)
			return wpa_s;
	}
	return ((void  __far * )0);
}

/*** BeginHeader wpaS_init */
// From "wpa_supplicant.c":2474
struct wpa_global __far * wpaS_init(struct wpa_params __far * params);
/*** EndHeader */
_wpa_debug
struct wpa_global __far * wpaS_init(struct wpa_params __far * params) {
	struct wpa_global __far * global; 	// From "wpa_supplicant.c":2476
	int ret; 	// From "wpa_supplicant.c":2477


	if (params==((void  __far * )0))
		return ((void  __far * )0);
	wpa_debug_use_file = params->wpa_debug_use_file;
	;
	ret = eap_peer_register_methods();
	if (ret) {
		_WPA_PRINTF((MSG_ERROR, "Failed to register EAP methods" ));
		if (ret== -2)
			_WPA_PRINTF((MSG_ERROR, "Two or more EAP methods used " \
			 "the same EAP type." ));
		return ((void  __far * )0);
	}
	global = _sys_calloc(sizeof (*global));
	if (global==((void  __far * )0))
		return ((void  __far * )0);
	global->params.daemonize = params->daemonize;
	global->params.wait_for_interface = params->wait_for_interface;
	global->params.wait_for_monitor = params->wait_for_monitor;
#ifdef WPA_USE_CTRL_IFACE_DBUS_H
	global->params.dbus_ctrl_interface = params->dbus_ctrl_interface;
	if (params->pid_file)
		global->params.pid_file = _sys_strdup(params->pid_file);
	if (params->ctrl_interface)
		global->params.ctrl_interface = _sys_strdup(params->ctrl_interface);
	wpa_debug_level = global->params.wpa_debug_level = params->wpa_debug_level;
	wpa_debug_show_keys = global->params.wpa_debug_show_keys = params->wpa_debug_show_keys;
	wpa_debug_timestamp = global->params.wpa_debug_timestamp = params->wpa_debug_timestamp;
	wpa_debug_use_file = global->params.wpa_debug_use_file = params->wpa_debug_use_file;
#endif//def WPA_USE_CTRL_IFACE_DBUS_H
	if (eloop_init(global)) {
		_WPA_PRINTF((MSG_ERROR, "Failed to initialize event loop" ));
		wpaS_deinit(global);
		return ((void  __far * )0);
	}
	global->ctrl_iface = _wpa_s20_wpaSGlob_ctrl_iface_init(global);
	if (global->ctrl_iface==((void  __far * )0)) {
		wpaS_deinit(global);
		return ((void  __far * )0);
	}
#ifdef WPA_USE_CTRL_IFACE_DBUS_H
	if (global->params.dbus_ctrl_interface) {
		global->dbus_ctrl_iface = wpa_supplicant_dbus_ctrl_iface_init(global);
		if (global->dbus_ctrl_iface==((void  __far * )0)) {
			wpaS_deinit(global);
			return ((void  __far * )0);
		}
#endif//def WPA_USE_CTRL_IFACE_DBUS_H
	}
	if (global->params.wait_for_interface &&
	global->params.daemonize &&
	_wpa_s20_wpaS_daemon(global->params.pid_file)) {
		wpaS_deinit(global);
		return ((void  __far * )0);
	}
	return global;
}

/*** BeginHeader wpaS_run */
// From "wpa_supplicant.c":2555
int wpaS_run(struct wpa_global __far * global);
/*** EndHeader */
_wpa_debug
int wpaS_run(struct wpa_global __far * global) {
	struct wpa_supplicant __far * wpa_s; 	// From "wpa_supplicant.c":2557


	if (!global->params.wait_for_interface &&
	global->params.daemonize &&
	_wpa_s20_wpaS_daemon(global->params.pid_file))
		return  -1;
	if (global->params.wait_for_monitor) {
		for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next)
			if (wpa_s->ctrl_iface)
				_wpa_s20_wpaS_ctrl_iface_wait(wpa_s->ctrl_iface);
	}
	eloop_register_signal_terminate(_wpa_s20_wpaS_terminate, ((void  __far * )0));
	eloop_register_signal_reconfig(_wpa_s20_wpaS_reconfig, ((void  __far * )0));
	eloop_run();
	return 0;
}

/*** BeginHeader wpaS_deinit */
// From "wpa_supplicant.c":2586
void wpaS_deinit(struct wpa_global __far * global);
/*** EndHeader */
_wpa_debug
void wpaS_deinit(struct wpa_global __far * global) {
	if (global==((void  __far * )0))
		return /*void*/;
	while (global->ifaces)
		wpaS_remove_iface(global, global->ifaces);
	if (global->ctrl_iface)
		_wpa_s20_wpaSGlob_ctrl_iface_deinit(global->ctrl_iface);
	if (global->dbus_ctrl_iface)
		wpa_supplicant_dbus_ctrl_iface_deinit(global->dbus_ctrl_iface);
	eap_peer_unregister_methods();
	eloop_destroy();
	if (global->params.pid_file) {
		os_daemonize_terminate(global->params.pid_file);
		_sys_free(global->params.pid_file);
	}
	_sys_free(global->params.ctrl_interface);
	_sys_free(global);
	;
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */
/*** EndHeader */

/*** BeginHeader _wpa_s21_challenge_hash */
// From "ms_funcs.c":32
void _wpa_s21_challenge_hash(char __far * peer_challenge, char __far * auth_challenge,
                             char __far * username, size_t username_len, char __far * challenge);
/*** EndHeader */
_wpa_debug
void _wpa_s21_challenge_hash(char __far * peer_challenge, char __far * auth_challenge,
                             char __far * username, size_t username_len, char __far * challenge) {
	char hash[SHA1_MAC_LEN]; 	// From "ms_funcs.c":36
	unsigned char const __far * addr[3]; 	// From "ms_funcs.c":37
	size_t len[3]; 	// From "ms_funcs.c":38


	addr[0] = peer_challenge;
	len[0] = 16;
	addr[1] = auth_challenge;
	len[1] = 16;
	addr[2] = username;
	len[2] = username_len;
	sha1_vector(3, addr, len, hash);
	_f_memcpy(challenge, hash, 8);
}

/*** BeginHeader nt_password_hash */
// From "ms_funcs.c":58
void nt_password_hash(char __far * password, size_t password_len,
                      char __far * password_hash);
/*** EndHeader */
_wpa_debug
void nt_password_hash(char __far * password, size_t password_len,
                      char __far * password_hash) {
	char buf[512]; 	// From "ms_funcs.c":61
	char const __far * pos; 	// From "ms_funcs.c":61
	size_t i; 	// From "ms_funcs.c":62
	size_t len; 	// From "ms_funcs.c":62


	if (password_len>256)
		return /*void*/;
	for (i = 0; i<password_len; i++) {
		buf[2*i] = password[i];
		buf[2*i+1] = 0;
	}
	len = password_len*2;
	pos = buf;
	md4_vector(1, &pos, &len, password_hash);
}

/*** BeginHeader hash_nt_password_hash */
// From "ms_funcs.c":84
void hash_nt_password_hash(char const __far * password_hash, char __far * password_hash_hash);
/*** EndHeader */
_wpa_debug
void hash_nt_password_hash(char const __far * password_hash, char __far * password_hash_hash) {
	size_t len /* = 16 */; 	// From "ms_funcs.c":86

	len = 16;

	md4_vector(1, &password_hash, &len, password_hash_hash);
}

/*** BeginHeader challenge_response */
// From "ms_funcs.c":97
void challenge_response(char __far * challenge, char __far * password_hash, char __far * response);
/*** EndHeader */
_wpa_debug
void challenge_response(char __far * challenge, char __far * password_hash, char __far * response) {
	char zpwd[7]; 	// From "ms_funcs.c":100


	des_encrypt(challenge, password_hash, response);
	des_encrypt(challenge, password_hash+7, response+8);
	zpwd[0] = password_hash[14];
	zpwd[1] = password_hash[15];
	_f_memset(zpwd+2, 0, 5);
	des_encrypt(challenge, zpwd, response+16);
}

/*** BeginHeader generate_nt_response */
// From "ms_funcs.c":120
void generate_nt_response(char __far * auth_challenge, char __far * peer_challenge,
                          char __far * username, size_t username_len, char __far * password,
                          size_t password_len, char __far * response);
/*** EndHeader */
_wpa_debug
void generate_nt_response(char __far * auth_challenge, char __far * peer_challenge,
                          char __far * username, size_t username_len, char __far * password,
                          size_t password_len, char __far * response) {
	char challenge[8]; 	// From "ms_funcs.c":125
	char password_hash[16]; 	// From "ms_funcs.c":126


	_wpa_s21_challenge_hash(peer_challenge, auth_challenge, username, username_len,
                         challenge);
	nt_password_hash(password, password_len, password_hash);
	challenge_response(challenge, password_hash, response);
}

/*** BeginHeader generate_nt_response_pwhash */
// From "ms_funcs.c":144
void generate_nt_response_pwhash(char __far * auth_challenge, char __far * peer_challenge,
                                 char __far * username, size_t username_len, char __far * password_hash,
                                 char __far * response);
/*** EndHeader */
_wpa_debug
void generate_nt_response_pwhash(char __far * auth_challenge, char __far * peer_challenge,
                                 char __far * username, size_t username_len, char __far * password_hash,
                                 char __far * response) {
	char challenge[8]; 	// From "ms_funcs.c":150


	_wpa_s21_challenge_hash(peer_challenge, auth_challenge, username, username_len,
                         challenge);
	challenge_response(challenge, password_hash, response);
}

/*** BeginHeader generate_authenticator_response_pwhash */
// From "ms_funcs.c":169
void generate_authenticator_response_pwhash(char __far * password_hash, char __far * peer_challenge,
                                            char __far * auth_challenge, char __far * username,
                                            size_t username_len, char __far * nt_response,
                                            char __far * response);
/*** EndHeader */
_wpa_debug
void generate_authenticator_response_pwhash(char __far * password_hash, char __far * peer_challenge,
                                            char __far * auth_challenge, char __far * username,
                                            size_t username_len, char __far * nt_response,
                                            char __far * response) {
	static const char magic1[39] =
	{
		0x4D,
		0x61,
		0x67,
		0x69,
		0x63,
		0x20,
		0x73,
		0x65,
		0x72,
		0x76,
		0x65,
		0x72,
		0x20,
		0x74,
		0x6F,
		0x20,
		0x63,
		0x6C,
		0x69,
		0x65,
		0x6E,
		0x74,
		0x20,
		0x73,
		0x69,
		0x67,
		0x6E,
		0x69,
		0x6E,
		0x67,
		0x20,
		0x63,
		0x6F,
		0x6E,
		0x73,
		0x74,
		0x61,
		0x6E,
		0x74
	}; 	// From "ms_funcs.c":180
	static const char magic2[41] =
	{
		0x50,
		0x61,
		0x64,
		0x20,
		0x74,
		0x6F,
		0x20,
		0x6D,
		0x61,
		0x6B,
		0x65,
		0x20,
		0x69,
		0x74,
		0x20,
		0x64,
		0x6F,
		0x20,
		0x6D,
		0x6F,
		0x72,
		0x65,
		0x20,
		0x74,
		0x68,
		0x61,
		0x6E,
		0x20,
		0x6F,
		0x6E,
		0x65,
		0x20,
		0x69,
		0x74,
		0x65,
		0x72,
		0x61,
		0x74,
		0x69,
		0x6F,
		0x6E
	}; 	// From "ms_funcs.c":187
	char password_hash_hash[16]; 	// From "ms_funcs.c":189
	char challenge[8]; 	// From "ms_funcs.c":189
	unsigned char const __far * addr1[3]; 	// From "ms_funcs.c":190
	static const size_t len1[3] =
	{
		16,
		24,
		sizeof (magic1),
	}; 	// From "ms_funcs.c":191
	unsigned char const __far * addr2[3]; 	// From "ms_funcs.c":192
	static const size_t len2[3] =
	{
		SHA1_MAC_LEN,
		8,
		sizeof (magic2),
	}; 	// From "ms_funcs.c":193

	addr1[0] = password_hash_hash;
	addr1[1] = nt_response;
	addr1[2] = magic1;
	addr2[0] = response;
	addr2[1] = challenge;
	addr2[2] = magic2;
	hash_nt_password_hash(password_hash, password_hash_hash);
	sha1_vector(3, addr1, len1, response);
	_wpa_s21_challenge_hash(peer_challenge, auth_challenge, username, username_len,
                         challenge);
	sha1_vector(3, addr2, len2, response);
}

/*** BeginHeader generate_authenticator_response */
// From "ms_funcs.c":224
void generate_authenticator_response(char __far * password, size_t password_len, char __far * peer_challenge,
                                     char __far * auth_challenge, char __far * username,
                                     size_t username_len, char __far * nt_response,
                                     char __far * response);
/*** EndHeader */
_wpa_debug
void generate_authenticator_response(char __far * password, size_t password_len, char __far * peer_challenge,
                                     char __far * auth_challenge, char __far * username,
                                     size_t username_len, char __far * nt_response,
                                     char __far * response) {
	char password_hash[16]; 	// From "ms_funcs.c":230


	nt_password_hash(password, password_len, password_hash);
	generate_authenticator_response_pwhash(password_hash, peer_challenge, auth_challenge,
                                        username, username_len, nt_response, response);
}

/*** BeginHeader nt_challenge_response */
// From "ms_funcs.c":246
void nt_challenge_response(char __far * challenge, char __far * password, size_t password_len,
                           char __far * response);
/*** EndHeader */
_wpa_debug
void nt_challenge_response(char __far * challenge, char __far * password, size_t password_len,
                           char __far * response) {
	char password_hash[16]; 	// From "ms_funcs.c":249


	nt_password_hash(password, password_len, password_hash);
	challenge_response(challenge, password_hash, response);
}

/*** BeginHeader get_master_key */
// From "ms_funcs.c":261
void get_master_key(char __far * password_hash_hash, char __far * nt_response, char __far * master_key);
/*** EndHeader */
	static const char _gmk_magic1[27] =
	{
		0x54,
		0x68,
		0x69,
		0x73,
		0x20,
		0x69,
		0x73,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x4d,
		0x50,
		0x50,
		0x45,
		0x20,
		0x4d,
		0x61,
		0x73,
		0x74,
		0x65,
		0x72,
		0x20,
		0x4b,
		0x65,
		0x79
	}; 	// From "ms_funcs.c":268
	static const size_t _gmk_len[3] =
	{
		16,
		24,
		sizeof (_gmk_magic1),
	}; 	// From "ms_funcs.c":270

_wpa_debug
void get_master_key(char __far * password_hash_hash, char __far * nt_response, char __far * master_key) {
	unsigned char const __far * addr[3]; 	// From "ms_funcs.c":269
	char hash[20]; 	// From "ms_funcs.c":271

	addr[0] = password_hash_hash;
	addr[1] = nt_response;
	addr[2] = _gmk_magic1;
	sha1_vector(3, addr, _gmk_len, hash);
	_f_memcpy(master_key, hash, 16);
}

/*** BeginHeader get_asymetric_start_key */
// From "ms_funcs.c":290
void get_asymetric_start_key(char __far * master_key, char __far * session_key, size_t session_key_len,
                             int is_send, int is_server);
/*** EndHeader */
_wpa_debug
void get_asymetric_start_key(char __far * master_key, char __far * session_key, size_t session_key_len,
                             int is_send, int is_server) {
	// Rabbit note: needs fixes because translator does not handle global static const properly.
	static const char magic2[84] =
	{
		0x4f,
		0x6e,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x63,
		0x6c,
		0x69,
		0x65,
		0x6e,
		0x74,
		0x20,
		0x73,
		0x69,
		0x64,
		0x65,
		0x2c,
		0x20,
		0x74,
		0x68,
		0x69,
		0x73,
		0x20,
		0x69,
		0x73,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x73,
		0x65,
		0x6e,
		0x64,
		0x20,
		0x6b,
		0x65,
		0x79,
		0x3b,
		0x20,
		0x6f,
		0x6e,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x73,
		0x65,
		0x72,
		0x76,
		0x65,
		0x72,
		0x20,
		0x73,
		0x69,
		0x64,
		0x65,
		0x2c,
		0x20,
		0x69,
		0x74,
		0x20,
		0x69,
		0x73,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x72,
		0x65,
		0x63,
		0x65,
		0x69,
		0x76,
		0x65,
		0x20,
		0x6b,
		0x65,
		0x79,
		0x2e
	}; 	// From "ms_funcs.c":304
	static const char magic3[84] =
	{
		0x4f,
		0x6e,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x63,
		0x6c,
		0x69,
		0x65,
		0x6e,
		0x74,
		0x20,
		0x73,
		0x69,
		0x64,
		0x65,
		0x2c,
		0x20,
		0x74,
		0x68,
		0x69,
		0x73,
		0x20,
		0x69,
		0x73,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x72,
		0x65,
		0x63,
		0x65,
		0x69,
		0x76,
		0x65,
		0x20,
		0x6b,
		0x65,
		0x79,
		0x3b,
		0x20,
		0x6f,
		0x6e,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x73,
		0x65,
		0x72,
		0x76,
		0x65,
		0x72,
		0x20,
		0x73,
		0x69,
		0x64,
		0x65,
		0x2c,
		0x20,
		0x69,
		0x74,
		0x20,
		0x69,
		0x73,
		0x20,
		0x74,
		0x68,
		0x65,
		0x20,
		0x73,
		0x65,
		0x6e,
		0x64,
		0x20,
		0x6b,
		0x65,
		0x79,
		0x2e
	}; 	// From "ms_funcs.c":315
	static const char shs_pad1[40] =
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00
	}; 	// From "ms_funcs.c":321
	static const char shs_pad2[40] =
	{
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2,
		0xf2
	}; 	// From "ms_funcs.c":328
	char digest[SHA1_MAC_LEN]; 	// From "ms_funcs.c":329
	unsigned char const __far * addr[4]; 	// From "ms_funcs.c":330
	static const size_t len[4] =
	{
		16,
		40,
		84,
		40
	}; 	// From "ms_funcs.c":331


	addr[0] = master_key;
	addr[1] = shs_pad1;
	if (is_send) {
		addr[2] = is_server ? magic3 : magic2;
	}
	else {
		addr[2] = is_server ? magic2 : magic3;
	}
	addr[3] = shs_pad2;
	sha1_vector(4, addr, len, digest);
	if (session_key_len>SHA1_MAC_LEN)
		session_key_len = SHA1_MAC_LEN;
	_f_memcpy(session_key, digest, session_key_len);
}

/*** BeginHeader _wpa_s21_encrypt_pw_block_with_password_hash */
// From "ms_funcs.c":359
void _wpa_s21_encrypt_pw_block_with_password_hash(char __far * password, size_t password_len,
                                                  char __far * password_hash, char __far * pw_block);
/*** EndHeader */
_wpa_debug
void _wpa_s21_encrypt_pw_block_with_password_hash(char __far * password, size_t password_len,
                                                  char __far * password_hash, char __far * pw_block) {
	size_t i; 	// From "ms_funcs.c":363
	size_t offset; 	// From "ms_funcs.c":363
	char __far * pos; 	// From "ms_funcs.c":364



	if (password_len>256)
		return /*void*/;
	_f_memset(pw_block, 0, 516);
	offset = (256-password_len)*2;
	os_get_random(pw_block, offset);
	for (i = 0; i<password_len; i++)
		pw_block[offset+i*2] = password[i];
	pos = &pw_block[2*256];
	do {
		(pos)[1] = ((word  )(password_len*2))>>8;
		(pos)[0] = ((word  )(password_len*2))&0xff;
	} while (0);
	RC4Skip(password_hash, 16, 0, pw_block, 516);



}

/*** BeginHeader new_password_encrypted_with_old_nt_password_hash */
// From "ms_funcs.c":392
void new_password_encrypted_with_old_nt_password_hash(char __far * new_password, size_t new_password_len,
                                                      char __far * old_password, size_t old_password_len,
                                                      char __far * encrypted_pw_block);
/*** EndHeader */
_wpa_debug
void new_password_encrypted_with_old_nt_password_hash(char __far * new_password, size_t new_password_len,
                                                      char __far * old_password, size_t old_password_len,
                                                      char __far * encrypted_pw_block) {
	char password_hash[16]; 	// From "ms_funcs.c":397


	nt_password_hash(old_password, old_password_len, password_hash);
	_wpa_s21_encrypt_pw_block_with_password_hash(new_password, new_password_len, password_hash,
                                              encrypted_pw_block);
}

/*** BeginHeader _wpa_s21_nt_password_hash_encrypted_with_block */
// From "ms_funcs.c":411
void _wpa_s21_nt_password_hash_encrypted_with_block(char __far * password_hash, char __far * block,
                                                    char __far * cypher);
/*** EndHeader */
_wpa_debug
void _wpa_s21_nt_password_hash_encrypted_with_block(char __far * password_hash, char __far * block,
                                                    char __far * cypher) {
	des_encrypt(password_hash, block, cypher);
	des_encrypt(password_hash+8, block+7, cypher+8);
}

/*** BeginHeader old_nt_password_hash_encrypted_with_new_nt_password_hash */
// From "ms_funcs.c":428
void old_nt_password_hash_encrypted_with_new_nt_password_hash(char __far * new_password,
                                                              size_t new_password_len,
                                                              char __far * old_password,
                                                              size_t old_password_len,
                                                              char __far * encrypted_password_hash);
/*** EndHeader */
_wpa_debug
void old_nt_password_hash_encrypted_with_new_nt_password_hash(char __far * new_password,
                                                              size_t new_password_len,
                                                              char __far * old_password,
                                                              size_t old_password_len,
                                                              char __far * encrypted_password_hash) {
	char old_password_hash[16]; 	// From "ms_funcs.c":433
	char new_password_hash[16]; 	// From "ms_funcs.c":433


	nt_password_hash(old_password, old_password_len, old_password_hash);
	nt_password_hash(new_password, new_password_len, new_password_hash);
	_wpa_s21_nt_password_hash_encrypted_with_block(old_password_hash, new_password_hash,
                                                encrypted_password_hash);
}
// @ TUName[]  ; -- translator directive
/*** BeginHeader */

struct eap_mschapv2_hdr {
	char op_code;
	char mschapv2_id;
	char ms_length[2];

} ;	// From "eap_mschapv2.c":44

struct ms_response {
	char peer_challenge[16];
	char reserved[8];
	char nt_response[24];
	char flags;

} ;	// From "eap_mschapv2.c":52

struct ms_change_password {
	char encr_password[516];
	char encr_hash[16];
	char peer_challenge[16];
	char reserved[8];
	char nt_response[24];
	char flags[2];

} ;	// From "eap_mschapv2.c":62

struct eap_mschapv2_data {
	char auth_response[20];
	int auth_response_valid;
	int prev_error;
	char passwd_change_challenge[16];
	int passwd_change_challenge_valid;
	int passwd_change_version;
	char __far * peer_challenge;
	char __far * auth_challenge;
	int full_key;
	int phase2;
	char master_key[16];
	int master_key_valid;
	int success;
	char __far * prev_challenge;
	size_t prev_challenge_len;

} ;	// From "eap_mschapv2.c":107
/*** EndHeader */

/*** BeginHeader _wpa_s22_eap_mschapv2_init */
// From "eap_mschapv2.c":113
void __far * _wpa_s22_eap_mschapv2_init(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
void __far * _wpa_s22_eap_mschapv2_init(struct eap_sm __far * sm) {
	struct eap_mschapv2_data __far * data; 	// From "eap_mschapv2.c":115


	data = _sys_calloc(sizeof (*data));
	if (data==((void  __far * )0))
		return ((void  __far * )0);
	data->full_key = sm->mschapv2_full_key;
	if (sm->peer_challenge) {
		data->full_key = 1;
		data->peer_challenge = _sys_malloc(16);
		if (data->peer_challenge==((void  __far * )0)) {
			_wpa_s22_eap_mschapv2_deinit(sm, data);
			return ((void  __far * )0);
		}
		_f_memcpy(data->peer_challenge, sm->peer_challenge, 16);
	}
	if (sm->auth_challenge) {
		data->auth_challenge = _sys_malloc(16);
		if (data->auth_challenge==((void  __far * )0)) {
			_wpa_s22_eap_mschapv2_deinit(sm, data);
			return ((void  __far * )0);
		}
		_f_memcpy(data->auth_challenge, sm->auth_challenge, 16);
	}
	data->phase2 = sm->init_phase2;
	return data;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_deinit */
// From "eap_mschapv2.c":149
void _wpa_s22_eap_mschapv2_deinit(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
void _wpa_s22_eap_mschapv2_deinit(struct eap_sm __far * sm, void __far * priv) {
	struct eap_mschapv2_data __far * data /* = priv */; 	// From "eap_mschapv2.c":151

	data = priv;

	_sys_free(data->peer_challenge);
	_sys_free(data->auth_challenge);
	_sys_free(data->prev_challenge);
	_sys_free(data);
}

/*** BeginHeader _wpa_s22_eap_mschapv2_remove_domain */
// From "eap_mschapv2.c":159
char __far * _wpa_s22_eap_mschapv2_remove_domain(char __far * username, size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_remove_domain(char __far * username, size_t __far * len) {
	size_t i; 	// From "eap_mschapv2.c":161


	for (i = 0; i<*len; i++) {
		if (username[i]=='\\') {
			*len -= i+1;
			return username+i+1;
		}
	}
	return username;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_derive_response */
// From "eap_mschapv2.c":180
void _wpa_s22_eap_mschapv2_derive_response(struct eap_mschapv2_data __far * data,
                                           char __far * username, size_t username_len,
                                           char __far * password, size_t password_len,
                                           char __far * auth_challenge, char __far * peer_challenge,
                                           char __far * nt_response);
/*** EndHeader */
_wpa_debug
void _wpa_s22_eap_mschapv2_derive_response(struct eap_mschapv2_data __far * data,
                                           char __far * username, size_t username_len,
                                           char __far * password, size_t password_len,
                                           char __far * auth_challenge, char __far * peer_challenge,
                                           char __far * nt_response) {
	char password_hash[16]; 	// From "eap_mschapv2.c":187
	char password_hash_hash[16]; 	// From "eap_mschapv2.c":187


	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: auth_challenge" , auth_challenge, 16));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: peer_challenge" , peer_challenge, 16));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: username" , username, username_len));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: password" , password, password_len));
	generate_nt_response(auth_challenge, peer_challenge, username, username_len, password,
                      password_len, nt_response);
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: response" , nt_response, 24));
	generate_authenticator_response(password, password_len, peer_challenge, auth_challenge,
                                 username, username_len, nt_response, data->auth_response);
	data->auth_response_valid = 1;
	nt_password_hash(password, password_len, password_hash);
	hash_nt_password_hash(password_hash, password_hash_hash);
	get_master_key(password_hash_hash, nt_response, data->master_key);
	data->master_key_valid = 1;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_challenge_reply */
// From "eap_mschapv2.c":219
char __far * _wpa_s22_eap_mschapv2_challenge_reply(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                                 char id, char mschapv2_id, char __far * auth_challenge,
                                                 size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_challenge_reply(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                                 char id, char mschapv2_id, char __far * auth_challenge,
                                                 size_t __far * respDataLen) {
	struct eap_hdr __far * resp; 	// From "eap_mschapv2.c":225
	struct eap_mschapv2_hdr __far * ms; 	// From "eap_mschapv2.c":226
	char __far * rpos; 	// From "eap_mschapv2.c":227
	char __far * peer_challenge; 	// From "eap_mschapv2.c":227
	int ms_len; 	// From "eap_mschapv2.c":228
	struct ms_response __far * r; 	// From "eap_mschapv2.c":229
	size_t username_len; 	// From "eap_mschapv2.c":230
	size_t identity_len; 	// From "eap_mschapv2.c":230
	size_t password_len; 	// From "eap_mschapv2.c":230
	char __far * username; 	// From "eap_mschapv2.c":231
	char __far * identity; 	// From "eap_mschapv2.c":231
	char __far * password; 	// From "eap_mschapv2.c":231


	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Generating Challenge Response" ));
	identity = eap_get_config_identity(sm, &identity_len);
	password = eap_get_config_password(sm, &password_len);
	if (identity==((void  __far * )0) ||
	    password==((void  __far * )0))
		return ((void  __far * )0);
	username_len = identity_len;
	username = _wpa_s22_eap_mschapv2_remove_domain(identity, &username_len);
	ms_len = sizeof (*ms)+1+sizeof (*r)+identity_len;
	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_MSCHAPV2, respDataLen, ms_len, EAP_CODE_RESPONSE,
                      id, &rpos);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	ms = (struct eap_mschapv2_hdr  __far * )rpos;
	ms->op_code = 2;
	ms->mschapv2_id = mschapv2_id;
	if (data->prev_error) {
		ms->mschapv2_id++;
	}
	do {
		(ms->ms_length)[0] = ((word  )(ms_len))>>8;
		(ms->ms_length)[1] = ((word  )(ms_len))&0xff;
	} while (0);
	rpos = (char  __far * )(ms+1);
	*rpos++ = sizeof (*r);
	r = (struct ms_response  __far * )rpos;
	peer_challenge = r->peer_challenge;
	if (data->peer_challenge) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: peer_challenge generated " \
		 "in Phase 1" ));
		peer_challenge = data->peer_challenge;
		_f_memset(r->peer_challenge, 0, 16);
	}
	else if (os_get_random(peer_challenge, 16)) {
		_sys_free(resp);
		return ((void  __far * )0);
	}
	_f_memset(r->reserved, 0, 8);
	if (data->auth_challenge) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: auth_challenge generated " \
		 "in Phase 1" ));
		auth_challenge = data->auth_challenge;
	}
	_wpa_s22_eap_mschapv2_derive_response(data, username, username_len, password, password_len,
                                       auth_challenge, peer_challenge, r->nt_response);
	r->flags = 0;
	_f_memcpy((char  __far * )(r+1), identity, identity_len);
	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: TX identifier %d mschapv2_id %d " \
	 "(response)" , resp->identifier, ms->mschapv2_id));
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_challenge */
// From "eap_mschapv2.c":309
char __far * _wpa_s22_eap_mschapv2_challenge(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                           struct eap_method_ret __far * ret, struct eap_mschapv2_hdr __far * req,
                                           size_t req_len, char id, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_challenge(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                           struct eap_method_ret __far * ret, struct eap_mschapv2_hdr __far * req,
                                           size_t req_len, char id, size_t __far * respDataLen) {
	size_t len; 	// From "eap_mschapv2.c":315
	size_t challenge_len; 	// From "eap_mschapv2.c":315
	char __far * pos; 	// From "eap_mschapv2.c":316
	char __far * challenge; 	// From "eap_mschapv2.c":316


	if (eap_get_config_identity(sm, &len)==((void  __far * )0) ||
	    eap_get_config_password(sm, &len)==((void  __far * )0))
		return ((void  __far * )0);
	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Received challenge" ));
	if (req_len<sizeof (*req)+1) {
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Too short challenge data " \
		 "(len %lu)" , (unsigned long  )req_len));
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	pos = (char  __far * )(req+1);
	challenge_len = *pos++;
	len = req_len-sizeof (*req)-1;
	if (challenge_len!=16) {
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Invalid challenge length " \
		 "%lu" , (unsigned long  )challenge_len));
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	if (len<challenge_len) {
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Too short challenge" \
		 " packet: len=%lu challenge_len=%lu" , (unsigned long  )len, (unsigned long  )challenge_len));
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	if (data->passwd_change_challenge_valid) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Using challenge from the " \
		 "failure message" ));
		challenge = data->passwd_change_challenge;
	}
	else
		challenge = pos;
	pos += challenge_len;
	len -= challenge_len;
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: Authentication Servername" , pos, len));
	ret->ignore = FALSE;
	ret->methodState = METHOD_MAY_CONT;
	ret->decision = DECISION_FAIL;
	ret->allowNotifications = TRUE;
	return _wpa_s22_eap_mschapv2_challenge_reply(sm, data, id, req->mschapv2_id, challenge,
                                              respDataLen);
}

/*** BeginHeader _wpa_s22_eap_mschapv2_password_changed */
// From "eap_mschapv2.c":368
void _wpa_s22_eap_mschapv2_password_changed(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data);
/*** EndHeader */
_wpa_debug
void _wpa_s22_eap_mschapv2_password_changed(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data) {
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap_mschapv2.c":371

	config = eap_get_config(sm);

	if (config &&
	    config->new_password) {
		_WPA_MSG((sm->msg_ctx, MSG_INFO, "CTRL-EVENT-PASSWORD-CHANGED " \
		 "EAP-MSCHAPV2: Password changed successfully" ));
		data->prev_error = 0;
		_sys_free(config->password);
		config->password = config->new_password;
		config->new_password = ((void  __far * )0);
		config->password_len = config->new_password_len;
		config->new_password_len = 0;
	}
}

/*** BeginHeader _wpa_s22_eap_mschapv2_success */
// From "eap_mschapv2.c":398
char __far * _wpa_s22_eap_mschapv2_success(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                         struct eap_method_ret __far * ret, struct eap_mschapv2_hdr __far * req,
                                         size_t req_len, char id, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_success(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                         struct eap_method_ret __far * ret, struct eap_mschapv2_hdr __far * req,
                                         size_t req_len, char id, size_t __far * respDataLen) {
	struct eap_hdr __far * resp; 	// From "eap_mschapv2.c":404
	struct eap_mschapv2_hdr __far * ms; 	// From "eap_mschapv2.c":405
	char __far * pos; 	// From "eap_mschapv2.c":406
	char recv_response[20]; 	// From "eap_mschapv2.c":407
	size_t len; 	// From "eap_mschapv2.c":408
	char __far * rpos; 	// From "eap_mschapv2.c":409


	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Received success" ));
	len = req_len-sizeof (*req);
	pos = (char  __far * )(req+1);
	if (!data->auth_response_valid ||
	    len<42 ||
	    pos[0]!='S' ||
	    pos[1]!='=' ||
	    hexstr2bin((char  __far * )(pos+2), recv_response, 20) ||
	    memcmp(data->auth_response, recv_response, 20) ) {
		_WPA_PRINTF((MSG_WARNING, "EAP-MSCHAPV2: Invalid authenticator " \
		 "response in success request" ));
		ret->methodState = METHOD_DONE;
		ret->decision = DECISION_FAIL;
		return ((void  __far * )0);
	}
	pos += 42;
	len -= 42;
	while (len>0 &&
	    *pos==' ') {
		pos++;
		len--;
	}
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: Success message" , pos, len));
	_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Authentication succeeded" ));
	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_MSCHAPV2, respDataLen, 1, EAP_CODE_RESPONSE,
                      id, &rpos);
	if (resp==((void  __far * )0)) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Failed to allocate " \
		 "buffer for success response" ));
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	ms = (struct eap_mschapv2_hdr  __far * )rpos;
	ms->op_code = 3;
	ret->methodState = METHOD_DONE;
	ret->decision = DECISION_UNCOND_SUCC;
	ret->allowNotifications = FALSE;
	data->success = 1;
	if (data->prev_error==648)
		_wpa_s22_eap_mschapv2_password_changed(sm, data);
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_failure_txt */
// From "eap_mschapv2.c":460
int _wpa_s22_eap_mschapv2_failure_txt(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                      char __far * txt);
/*** EndHeader */
_wpa_debug
int _wpa_s22_eap_mschapv2_failure_txt(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                      char __far * txt) {
	char __far * pos; 	// From "eap_mschapv2.c":463
	char __far * msg /* = ""  */; 	// From "eap_mschapv2.c":463
	int retry /* = 1 */; 	// From "eap_mschapv2.c":464
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap_mschapv2.c":465

	union  {

		struct  {
			int hex_len;

		} __s3;

	} __u; 	// From "eap_mschapv2.c":462

	msg = "" ;
	retry = 1;
	config = eap_get_config(sm);

	pos = txt;
	if (pos &&
	    strncmp(pos, "E=" , 2)==0) {
		pos += 2;
		data->prev_error = _f_atoi(pos);
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: error %d" , data->prev_error));
		pos = _f_strchr(pos, ' ');
		if (pos)
			pos++;
	}
	if (pos &&
	    strncmp(pos, "R=" , 2)==0) {
		pos += 2;
		retry = _f_atoi(pos);
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: retry is %lsallowed" , (char  __far * )(retry
                                                                               ==1 ?
		  ""  :
		  "not " )));
		pos = _f_strchr(pos, ' ');
		if (pos)
			pos++;
	}
	if (pos &&
	    strncmp(pos, "C=" , 2)==0) {
		pos += 2;
		__u.__s3.hex_len = (_x509_ptrdiff_t)(_f_strchr(pos, ' ')-(char  __far * )pos);
		if (__u.__s3.hex_len==16*2) {
			if (hexstr2bin(pos, data->passwd_change_challenge, 16)) {
				_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: invalid " \
				 "failure challenge" ));
			}
			else {
				_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: failure " \
				 "challenge" , data->passwd_change_challenge, 16));
				data->passwd_change_challenge_valid = 1;
			}
		}
		else {
			_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: invalid failure " \
			 "challenge len %d" , __u.__s3.hex_len));
		}
		pos = _f_strchr(pos, ' ');
		if (pos)
			pos++;
	}
	else {
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: required challenge field " \
		 "was not present in failure message" ));
	}
	if (pos &&
	    strncmp(pos, "V=" , 2)==0) {
		pos += 2;
		data->passwd_change_version = _f_atoi(pos);
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: password changing " \
		 "protocol version %d" , data->passwd_change_version));
		pos = _f_strchr(pos, ' ');
		if (pos)
			pos++;
	}
	if (pos &&
	    strncmp(pos, "M=" , 2)==0) {
		pos += 2;
		msg = pos;
	}
	_WPA_MSG((sm->msg_ctx, MSG_WARNING, "EAP-MSCHAPV2: failure message: '%ls' (retry %lsallowed, error %d)" ,
           (char  __far * )(msg), (char  __far * )(retry==1 ?
	  ""  :
	  "not " ), data->prev_error));
	if (data->prev_error==648 &&
	    data->passwd_change_version==3 &&
	    config) {
		if (config->new_password==((void  __far * )0)) {
			_WPA_MSG((sm->msg_ctx, MSG_INFO, "EAP-MSCHAPV2: Password expired - password " \
			 "change required" ));
			eap_sm_request_new_password(sm);
		}
	}
	else if (retry==1 &&
	    config) {
		if (!config->mschapv2_retry)
			eap_sm_request_identity(sm);
		eap_sm_request_password(sm);
		config->mschapv2_retry = 1;
	}
	else if (config) {
		config->mschapv2_retry = 0;
	}
	return retry==1;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_change_password */
// From "eap_mschapv2.c":563
char __far * _wpa_s22_eap_mschapv2_change_password(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                                 struct eap_method_ret __far * ret,
                                                 struct eap_mschapv2_hdr __far * req,
                                                 char id, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_change_password(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                                 struct eap_method_ret __far * ret,
                                                 struct eap_mschapv2_hdr __far * req,
                                                 char id, size_t __far * respDataLen) {
	struct eap_hdr __far * resp; 	// From "eap_mschapv2.c":569
	int ms_len; 	// From "eap_mschapv2.c":570
	char __far * username; 	// From "eap_mschapv2.c":571
	char __far * password; 	// From "eap_mschapv2.c":571
	char __far * new_password; 	// From "eap_mschapv2.c":571
	char __far * pos; 	// From "eap_mschapv2.c":572
	size_t username_len; 	// From "eap_mschapv2.c":573
	size_t password_len; 	// From "eap_mschapv2.c":573
	size_t new_password_len; 	// From "eap_mschapv2.c":573
	struct eap_mschapv2_hdr __far * ms; 	// From "eap_mschapv2.c":574
	struct ms_change_password __far * cp; 	// From "eap_mschapv2.c":575


	username = eap_get_config_identity(sm, &username_len);
	password = eap_get_config_password(sm, &password_len);
	new_password = eap_get_config_new_password(sm, &new_password_len);
	if (username==((void  __far * )0) ||
	    password==((void  __far * )0) ||
	    new_password==((void  __far * )0))
		return ((void  __far * )0);
	username = _wpa_s22_eap_mschapv2_remove_domain(username, &username_len);
	ret->ignore = FALSE;
	ret->methodState = METHOD_MAY_CONT;
	ret->decision = DECISION_COND_SUCC;
	ret->allowNotifications = TRUE;
	ms_len = sizeof (*ms)+sizeof (*cp);
	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_MSCHAPV2, respDataLen, ms_len, EAP_CODE_RESPONSE,
                      id, &pos);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	ms = (struct eap_mschapv2_hdr  __far * )pos;
	ms->op_code = 7;
	ms->mschapv2_id = req->mschapv2_id+1;
	do {
		(ms->ms_length)[0] = ((word  )(ms_len))>>8;
		(ms->ms_length)[1] = ((word  )(ms_len))&0xff;
	} while (0);
	cp = (struct ms_change_password  __far * )(ms+1);
	new_password_encrypted_with_old_nt_password_hash(new_password, new_password_len,
                                                  password, password_len, cp->encr_password);
	old_nt_password_hash_encrypted_with_new_nt_password_hash(new_password, new_password_len,
                                                          password, password_len,
                                                          cp->encr_hash);
	if (os_get_random(cp->peer_challenge, 16)) {
		_sys_free(resp);
		return ((void  __far * )0);
	}
	_f_memset(cp->reserved, 0, 8);
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: auth_challenge" , data->passwd_change_challenge,
               16));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: peer_challenge" , cp->peer_challenge, 16));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: username" , username, username_len));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: new password" , new_password, new_password_len));
	generate_nt_response(data->passwd_change_challenge, cp->peer_challenge, username,
                      username_len, new_password, new_password_len, cp->nt_response);
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: NT-Response" , cp->nt_response, 24));
	generate_authenticator_response(new_password, new_password_len, cp->peer_challenge,
                                 data->passwd_change_challenge, username, username_len,
                                 cp->nt_response, data->auth_response);
	data->auth_response_valid = 1;
	_f_memset(cp->flags, 0, 2);
	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: TX identifier %d mschapv2_id %d " \
	 "(change pw)" , resp->identifier, ms->mschapv2_id));
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_failure */
// From "eap_mschapv2.c":668
char __far * _wpa_s22_eap_mschapv2_failure(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                         struct eap_method_ret __far * ret, struct eap_mschapv2_hdr __far * req,
                                         size_t req_len, char id, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_failure(struct eap_sm __far * sm, struct eap_mschapv2_data __far * data,
                                         struct eap_method_ret __far * ret, struct eap_mschapv2_hdr __far * req,
                                         size_t req_len, char id, size_t __far * respDataLen) {
	struct eap_hdr __far * resp; 	// From "eap_mschapv2.c":674
	char __far * msdata /* = (char  far * )(req+1) */; 	// From "eap_mschapv2.c":675
	char __far * buf; 	// From "eap_mschapv2.c":676
	size_t len /* = req_len-sizeof (*req) */; 	// From "eap_mschapv2.c":677
	int retry /* = 0 */; 	// From "eap_mschapv2.c":678
	struct eap_mschapv2_hdr __far * ms; 	// From "eap_mschapv2.c":679
	char __far * pos; 	// From "eap_mschapv2.c":680

	union  {

		struct  {
			struct wpa_ssid __far * config /* = eap_get_config(sm) */;

		} __s2;

	} __u; 	// From "eap_mschapv2.c":673

	msdata = (char  __far * )(req+1);
	len = req_len-sizeof (*req);
	retry = 0;

	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Received failure" ));
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: Failure data" , msdata, len));
	buf = _sys_malloc(len+1);
	if (buf) {
		_f_memcpy(buf, msdata, len);
		buf[len] = '\0';
		retry = _wpa_s22_eap_mschapv2_failure_txt(sm, data, buf);
		_sys_free(buf);
	}
	ret->ignore = FALSE;
	ret->methodState = METHOD_DONE;
	ret->decision = DECISION_FAIL;
	ret->allowNotifications = FALSE;
	if (data->prev_error==648 &&
	    data->passwd_change_version==3) {
		__u.__s2.config = eap_get_config(sm);

		if (__u.__s2.config &&
		    __u.__s2.config->new_password)
			return _wpa_s22_eap_mschapv2_change_password(sm, data, ret, req, id, respDataLen);
		if (__u.__s2.config &&
		    __u.__s2.config->pending_req_new_password)
			return ((void  __far * )0);
	}
	else if (retry &&
	    data->prev_error==691) {
		return ((void  __far * )0);
	}
	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_MSCHAPV2, respDataLen, 1, EAP_CODE_RESPONSE,
                      id, &pos);
	if (resp==((void  __far * )0))
		return ((void  __far * )0);
	ms = (struct eap_mschapv2_hdr  __far * )pos;
	ms->op_code = 4;
	return (char  __far * )resp;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_check_config */
// From "eap_mschapv2.c":732
int _wpa_s22_eap_mschapv2_check_config(struct eap_sm __far * sm);
/*** EndHeader */
_wpa_debug
int _wpa_s22_eap_mschapv2_check_config(struct eap_sm __far * sm) {
	size_t len; 	// From "eap_mschapv2.c":734


	if (eap_get_config_identity(sm, &len)==((void  __far * )0)) {
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Identity not configured" ));
		eap_sm_request_identity(sm);
		return  -1;
	}
	if (eap_get_config_password(sm, &len)==((void  __far * )0)) {
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Password not configured" ));
		eap_sm_request_password(sm);
		return  -1;
	}
	return 0;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_check_mslen */
// From "eap_mschapv2.c":752
int _wpa_s22_eap_mschapv2_check_mslen(struct eap_sm __far * sm, size_t len, struct eap_mschapv2_hdr __far * ms);
/*** EndHeader */
_wpa_debug
int _wpa_s22_eap_mschapv2_check_mslen(struct eap_sm __far * sm, size_t len, struct eap_mschapv2_hdr __far * ms) {
	size_t ms_len /* = ((word  )(((ms->ms_length)[0]<<8)|(ms->ms_length)[1])) */; 	// From "eap_mschapv2.c":755

	ms_len = ((word  )(((ms->ms_length)[0]<<8)|(ms->ms_length)[1]));

	if (ms_len==len)
		return 0;
	_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Invalid header: len=%lu " \
	 "ms_len=%lu" , (unsigned long  )len, (unsigned long  )ms_len));
	if (sm->workaround) {
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: workaround, ignore" \
		 " invalid ms_len %lu (len %lu)" , (unsigned long  )ms_len, (unsigned long  )len));
		return 0;
	}
	return  -1;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_copy_challenge */
// From "eap_mschapv2.c":776
void _wpa_s22_eap_mschapv2_copy_challenge(struct eap_mschapv2_data __far * data, char __far * reqData,
                                          size_t reqDataLen);
/*** EndHeader */
_wpa_debug
void _wpa_s22_eap_mschapv2_copy_challenge(struct eap_mschapv2_data __far * data, char __far * reqData,
                                          size_t reqDataLen) {
	_sys_free(data->prev_challenge);
	data->prev_challenge = _sys_malloc(reqDataLen);
	if (data->prev_challenge) {
		data->prev_challenge_len = reqDataLen;
		_f_memcpy(data->prev_challenge, reqData, reqDataLen);
	}
}

/*** BeginHeader _wpa_s22_eap_mschapv2_process */
// From "eap_mschapv2.c":803
char __far * _wpa_s22_eap_mschapv2_process(struct eap_sm __far * sm, void __far * priv,
                                         struct eap_method_ret __far * ret, char __far * reqData,
                                         size_t reqDataLen, size_t __far * respDataLen);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_process(struct eap_sm __far * sm, void __far * priv,
                                         struct eap_method_ret __far * ret, char __far * reqData,
                                         size_t reqDataLen, size_t __far * respDataLen) {
	struct eap_mschapv2_data __far * data /* = priv */; 	// From "eap_mschapv2.c":808
	struct wpa_ssid __far * config /* = eap_get_config(sm) */; 	// From "eap_mschapv2.c":809
	struct eap_hdr __far * req; 	// From "eap_mschapv2.c":810
	struct eap_mschapv2_hdr __far * ms; 	// From "eap_mschapv2.c":811
	int using_prev_challenge /* = 0 */; 	// From "eap_mschapv2.c":812
	char __far * pos; 	// From "eap_mschapv2.c":813
	size_t len; 	// From "eap_mschapv2.c":814

	data = priv;
	config = eap_get_config(sm);
	using_prev_challenge = 0;

	if (_wpa_s22_eap_mschapv2_check_config(sm)) {
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	if (config->mschapv2_retry &&
	    data->prev_challenge &&
	    data->prev_error==691) {
		_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: Replacing pending packet " \
		 "with the previous challenge" ));
		reqData = data->prev_challenge;
		reqDataLen = data->prev_challenge_len;
		using_prev_challenge = 1;
		config->mschapv2_retry = 0;
	}
	pos = eap_hdr_validate(EAP_VENDOR_IETF, EAP_TYPE_MSCHAPV2, reqData, reqDataLen,
                        &len);
	if (pos==((void  __far * )0) ||
	    len<sizeof (*ms)+1) {
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	ms = (struct eap_mschapv2_hdr  __far * )pos;
	if (_wpa_s22_eap_mschapv2_check_mslen(sm, len, ms)) {
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
	req = (struct eap_hdr  __far * )reqData;
	_WPA_PRINTF((MSG_DEBUG, "EAP-MSCHAPV2: RX identifier %d mschapv2_id %d" , req->identifier,
              ms->mschapv2_id));
	switch ((int)(ms->op_code)) {
		case 1:
		if (!using_prev_challenge)
			_wpa_s22_eap_mschapv2_copy_challenge(data, reqData, reqDataLen);
		return _wpa_s22_eap_mschapv2_challenge(sm, data, ret, ms, len, req->identifier,
                                         respDataLen);
		case 3:
		return _wpa_s22_eap_mschapv2_success(sm, data, ret, ms, len, req->identifier,
                                       respDataLen);
		case 4:
		return _wpa_s22_eap_mschapv2_failure(sm, data, ret, ms, len, req->identifier,
                                       respDataLen);
		default:
		_WPA_PRINTF((MSG_INFO, "EAP-MSCHAPV2: Unknown op %d - ignored" , ms->op_code));
		ret->ignore = TRUE;
		return ((void  __far * )0);
	}
}

/*** BeginHeader _wpa_s22_eap_mschapv2_isKeyAvailable */
// From "eap_mschapv2.c":870
Boolean _wpa_s22_eap_mschapv2_isKeyAvailable(struct eap_sm __far * sm, void __far * priv);
/*** EndHeader */
_wpa_debug
Boolean _wpa_s22_eap_mschapv2_isKeyAvailable(struct eap_sm __far * sm, void __far * priv) {
	struct eap_mschapv2_data __far * data /* = priv */; 	// From "eap_mschapv2.c":872

	data = priv;

	return data->success &&
	    data->master_key_valid;
}

/*** BeginHeader _wpa_s22_eap_mschapv2_getKey */
// From "eap_mschapv2.c":877
char __far * _wpa_s22_eap_mschapv2_getKey(struct eap_sm __far * sm, void __far * priv,
                                        size_t __far * len);
/*** EndHeader */
_wpa_debug
char __far * _wpa_s22_eap_mschapv2_getKey(struct eap_sm __far * sm, void __far * priv,
                                        size_t __far * len) {
	struct eap_mschapv2_data __far * data /* = priv */; 	// From "eap_mschapv2.c":879
	char __far * key; 	// From "eap_mschapv2.c":880
	int key_len; 	// From "eap_mschapv2.c":881

	data = priv;

	if (!data->master_key_valid ||
	    !data->success)
		return ((void  __far * )0);
	if (data->full_key) {
		key_len = 2*16;
	}
	else {
		key_len = 16;
	}
	key = _sys_malloc(key_len);
	if (key==((void  __far * )0))
		return ((void  __far * )0);
	if (data->full_key) {
		get_asymetric_start_key(data->master_key, key, 16, 0, 0);
		get_asymetric_start_key(data->master_key, key+16, 16, 1, 0);
	}
	else {
		get_asymetric_start_key(data->master_key, key, 16, 1, 0);
	}
	_WPA_HEXDUMP((MSG_DEBUG, "EAP-MSCHAPV2: Derived key" , key, key_len));
	*len = key_len;
	return key;
}

/*** BeginHeader eap_peer_mschapv2_register */
// From "eap_mschapv2.c":923
int eap_peer_mschapv2_register(void );
/*** EndHeader */
_wpa_debug
int eap_peer_mschapv2_register(void ) {
	struct eap_method __far * eap; 	// From "eap_mschapv2.c":925
	int ret; 	// From "eap_mschapv2.c":926


	eap = eap_peer_method_alloc(1, EAP_VENDOR_IETF, EAP_TYPE_MSCHAPV2, "MSCHAPV2" );
	if (eap==((void  __far * )0))
		return  -1;
	eap->init = _wpa_s22_eap_mschapv2_init;
	eap->deinit = _wpa_s22_eap_mschapv2_deinit;
	eap->process = _wpa_s22_eap_mschapv2_process;
	eap->isKeyAvailable = _wpa_s22_eap_mschapv2_isKeyAvailable;
	eap->getKey = _wpa_s22_eap_mschapv2_getKey;
	ret = eap_peer_method_register(eap);
	if (ret)
		eap_peer_method_free(eap);
	return ret;
}

/*** BeginHeader */

struct  {

	struct  {
		wpa_msg_cb_func wpa_msg_cb /* = ((void  far * )0) */;	// Hoisted from "wpa_all.c":550

		struct  {
			char ssid_txt[33];	// Hoisted from "wpa_all.c":590

		} __s156;

	} __s3;

	struct  {
		struct eap_method __far * eap_methods /* = ((void  far * )0) */;	// Hoisted from "eap_methods.c":25

	} __s7;

	struct  {
		struct eapol_callbacks eapol_cb /* =
		{
			eapol_sm_get_config,
			eapol_sm_get_bool,
			eapol_sm_set_bool,
			eapol_sm_get_int,
			eapol_sm_set_int,
			eapol_sm_get_eapReqData,
			eapol_sm_set_config_blob,
			eapol_sm_get_config_blob,
			eapol_sm_notify_pending
		} */;	// Hoisted from "eapol_sm.c":1716

	} __s8;

	struct  {

		struct  {
			int interface_count /* = 0 */;	// Hoisted from "wpa_supplicant.c":1968

		} __s76;

	} __s20;

} __wpa_globals; 	// From "wpa_all.c":8
/*** EndHeader */

/*** BeginHeader __wpa_initStatics */
// From "wpa_all.c":8
void __wpa_initStatics();
/*** EndHeader */
_wpa_debug
void __wpa_initStatics() {
#ifdef WPA_USE_EAP
   static const struct eapol_callbacks __s8_init =
		{
			_wpa_s8_eapol_sm_get_config,
			_wpa_s8_eapol_sm_get_bool,
			_wpa_s8_eapol_sm_set_bool,
			_wpa_s8_eapol_sm_get_int,
			_wpa_s8_eapol_sm_set_int,
			_wpa_s8_eapol_sm_get_eapReqData,
         _wpa_s8_eapol_sm_set_config_blob,
			_wpa_s8_eapol_sm_get_config_blob,
			_wpa_s8_eapol_sm_notify_pending
		};
#endif//def WPA_USE_EAP
	memset(&__wpa_globals, 0, sizeof __wpa_globals);
	{
		__wpa_globals.__s3.wpa_msg_cb = ((void  __far * )0);
		__wpa_globals.__s7.eap_methods = ((void  __far * )0);
#ifdef WPA_USE_EAP
   	_f_memcpy(&__wpa_globals.__s8.eapol_cb, &__s8_init, sizeof(__s8_init));
#endif
      /*
		__wpa_globals.__s8.eapol_cb =
		{
			_wpa_s8_eapol_sm_get_config,
			_wpa_s8_eapol_sm_get_bool,
			_wpa_s8_eapol_sm_set_bool,
			_wpa_s8_eapol_sm_get_int,
			_wpa_s8_eapol_sm_set_int,
			_wpa_s8_eapol_sm_get_eapReqData,
			_wpa_s8_eapol_sm_set_config_blob,
			_wpa_s8_eapol_sm_get_config_blob,
			_wpa_s8_eapol_sm_notify_pending
		};
      */
		__wpa_globals.__s20.__s76.interface_count = 0;

	}
}

/*** BeginHeader */
#endif // _WPA_H
/*** EndHeader */


