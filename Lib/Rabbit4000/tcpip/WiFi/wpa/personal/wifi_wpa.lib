//
//
// Embedded 802.11b/g wireless network interface
//
//

/*** BeginHeader */

/*
 * WPA Supplicant
 * Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Alternatively, this software may be distributed under the terms of BSD
 * license.
 *
 * See README and COPYING for more details.
 */

#define __static

#define SHA1_MAC_LEN 20

struct wpa_supplicant;
struct wpa_ie_data;

/* WPA IE version 1
 * 00-50-f2:1 (OUI:OUI type)
 * 0x01 0x00 (version; little endian)
 * (all following fields are optional:)
 * Group Suite Selector (4 octets) (default: TKIP)
 * Pairwise Suite Count (2 octets, little endian) (default: 1)
 * Pairwise Suite List (4 * n octets) (default: TKIP)
 * Authenticated Key Management Suite Count (2 octets, little endian)
 *    (default: 1)
 * Authenticated Key Management Suite List (4 * n octets)
 *    (default: unspec 802.1x)
 * WPA Capabilities (2 octets, little endian) (default: 0)
 */

struct wpa_ie_hdr {
	uint8 elem_id;
	uint8 len;
	uint8 oui[3];
	uint8 oui_type;
	uint16 version;
};

/* RSN IE version 1
 * 0x01 0x00 (version; little endian)
 * (all following fields are optional:)
 * Group Suite Selector (4 octets) (default: CCMP)
 * Pairwise Suite Count (2 octets, little endian) (default: 1)
 * Pairwise Suite List (4 * n octets) (default: CCMP)
 * Authenticated Key Management Suite Count (2 octets, little endian)
 *    (default: 1)
 * Authenticated Key Management Suite List (4 * n octets)
 *    (default: unspec 802.1x)
 * RSN Capabilities (2 octets, little endian) (default: 0)
 * PMKID Count (2 octets) (default: 0)
 * PMKID List (16 * n octets)
 */

struct rsn_ie_hdr {
	uint8 elem_id; /* WLAN_EID_RSN */
	uint8 len;
	uint16 version;
};


struct ieee802_1x_hdr {
	uint8 version;
	uint8 type;
	uint16 length;
	/* followed by length octets of data */
};

#define EAPOL_VERSION 2

enum { IEEE802_1X_TYPE_EAP_PACKET = 0,
       IEEE802_1X_TYPE_EAPOL_START = 1,
       IEEE802_1X_TYPE_EAPOL_LOGOFF = 2,
       IEEE802_1X_TYPE_EAPOL_KEY = 3,
       IEEE802_1X_TYPE_EAPOL_ENCAPSULATED_ASF_ALERT = 4
};

enum { EAPOL_KEY_TYPE_RC4 = 1, EAPOL_KEY_TYPE_RSN = 2,
       EAPOL_KEY_TYPE_WPA = 254 };


#define IEEE8021X_REPLAY_COUNTER_LEN 8
#define IEEE8021X_KEY_SIGN_LEN 16
#define IEEE8021X_KEY_IV_LEN 16

#define IEEE8021X_KEY_INDEX_FLAG 0x80
#define IEEE8021X_KEY_INDEX_MASK 0x03

struct ieee802_1x_eapol_key {
	uint8 type;
	uint16 key_length;
	/* does not repeat within the life of the keying material used to
	 * encrypt the Key field; 64-bit NTP timestamp MAY be used here */
	uint8 replay_counter[IEEE8021X_REPLAY_COUNTER_LEN];
	uint8 key_iv[IEEE8021X_KEY_IV_LEN]; /* cryptographically random number */
	uint8 key_index; /* key flag in the most significant bit:
		       * 0 = broadcast (default key),
		       * 1 = unicast (key mapping key); key index is in the
		       * 7 least significant bits */
	/* HMAC-MD5 message integrity check computed with MS-MPPE-Send-Key as
	 * the key */
	uint8 key_signature[IEEE8021X_KEY_SIGN_LEN];

	/* followed by key: if packet body length = 44 + key length, then the
	 * key field (of key_length bytes) contains the key in encrypted form;
	 * if packet body length = 44, key field is absent and key_length
	 * represents the number of least significant octets from
	 * MS-MPPE-Send-Key attribute to be used as the keying material;
	 * RC4 key used in encryption = Key-IV + MS-MPPE-Recv-Key */
};


#define WPA_NONCE_LEN 32
#define WPA_REPLAY_COUNTER_LEN 8

struct wpa_eapol_key {
	uint8 type;
	uint16 key_info;
	uint16 key_length;
	uint8 replay_counter[WPA_REPLAY_COUNTER_LEN];
	uint8 key_nonce[WPA_NONCE_LEN];
	uint8 key_iv[16];
	uint8 key_rsc[8];
	uint8 key_id[8]; /* Reserved in IEEE 802.11i/RSN */
	uint8 key_mic[16];
	uint16 key_data_length;
	uint8 key_data[32];
};

#define WPA_KEY_INFO_TYPE_MASK 						0x0007
#define WPA_KEY_INFO_TYPE_HMAC_MD5_RC4					0x0001
#define WPA_KEY_INFO_TYPE_HMAC_SHA1_AES				0x0002
#define WPA_KEY_INFO_KEY_TYPE 						0x0008 /* 1 = Pairwise, 0 = Group key */
/* bit4..5 is used in WPA, but is reserved in IEEE 802.11i/RSN */
#define WPA_KEY_INFO_KEY_INDEX_MASK					0x0030
#define WPA_KEY_INFO_KEY_INDEX_SHIFT 					4
#define WPA_KEY_INFO_INSTALL 							0x0040 /* pairwise */
#define WPA_KEY_INFO_TXRX 								0x0040 /* group */
#define WPA_KEY_INFO_ACK								0x0080
#define WPA_KEY_INFO_MIC								0x0100
#define WPA_KEY_INFO_SECURE							0x0200
#define WPA_KEY_INFO_ERROR								0x0400
#define WPA_KEY_INFO_REQUEST							0x0800
#define WPA_KEY_INFO_ENCR_KEY_DATA					0x1000 /* IEEE 802.11i/RSN only */

#define WPA_CAPABILITY_PREAUTH						0x0001

#define GENERIC_INFO_ELEM 								0xDD
#define RSN_INFO_ELEM 									0x30

enum {
	REASON_UNSPECIFIED = 1,
	REASON_DEAUTH_LEAVING = 3,
	REASON_INVALID_IE = 13,
	REASON_MICHAEL_MIC_FAILURE = 14,
	REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,
	REASON_IE_IN_4WAY_DIFFERS = 17,
	REASON_GROUP_CIPHER_NOT_VALID = 18,
	REASON_PAIRWISE_CIPHER_NOT_VALID = 19,
	REASON_AKMP_NOT_VALID = 20,
	REASON_UNSUPPORTED_RSN_IE_VERSION = 21,
	REASON_INVALID_RSN_IE_CAPAB = 22,
	REASON_IEEE_802_1X_AUTH_FAILED = 23,
	REASON_CIPHER_SUITE_REJECTED = 24,
};


/* TODO: make these configurable */
static const word dot11RSNAConfigPMKLifetime = 43200u;
static const int dot11RSNAConfigPMKReauthThreshold = 70;
static const int dot11RSNAConfigSATimeout = 60;
//static const int pmksa_cache_max_entries = 32;

static const int WPA_SELECTOR_LEN = 4;
static const uint8 WPA_OUI_TYPE[] = { 0x00, 0x50, 0xf2, 1 };
static const uint16 WPA_VERSION = 1;
static const uint8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x50, 0xf2, 1 };
static const uint8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x50, 0xf2, 2 };
static const uint8 WPA_CIPHER_SUITE_NONE[] = { 0x00, 0x50, 0xf2, 0 };
static const uint8 WPA_CIPHER_SUITE_WEP40[] = { 0x00, 0x50, 0xf2, 1 };
static const uint8 WPA_CIPHER_SUITE_TKIP[] = { 0x00, 0x50, 0xf2, 2 };
static const uint8 WPA_CIPHER_SUITE_WRAP[] = { 0x00, 0x50, 0xf2, 3 };
static const uint8 WPA_CIPHER_SUITE_CCMP[] = { 0x00, 0x50, 0xf2, 4 };
static const uint8 WPA_CIPHER_SUITE_WEP104[] = { 0x00, 0x50, 0xf2, 5 };



static const int RSN_SELECTOR_LEN = 4;
static const uint16 RSN_VERSION = 1;
static const uint8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x0f, 0xac, 1 };
static const uint8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x0f, 0xac, 2 };
static const uint8 RSN_CIPHER_SUITE_NONE[] = { 0x00, 0x0f, 0xac, 0 };
static const uint8 RSN_CIPHER_SUITE_WEP40[] = { 0x00, 0x0f, 0xac, 1 };
static const uint8 RSN_CIPHER_SUITE_TKIP[] = { 0x00, 0x0f, 0xac, 2 };
static const uint8 RSN_CIPHER_SUITE_WRAP[] = { 0x00, 0x0f, 0xac, 3 };
static const uint8 RSN_CIPHER_SUITE_CCMP[] = { 0x00, 0x0f, 0xac, 4 };
static const uint8 RSN_CIPHER_SUITE_WEP104[] = { 0x00, 0x0f, 0xac, 5 };

/* EAPOL-Key Key Data Encapsulation
 * GroupKey and STAKey require encryption, otherwise, encryption is optional.
 */
static const uint8 RSN_KEY_DATA_GROUPKEY[] = { 0x00, 0x0f, 0xac, 1 };
static const uint8 RSN_KEY_DATA_STAKEY[] = { 0x00, 0x0f, 0xac, 2 };
static const uint8 RSN_KEY_DATA_MAC_ADDR[] = { 0x00, 0x0f, 0xac, 3 };
static const uint8 RSN_KEY_DATA_PMKID[] = { 0x00, 0x0f, 0xac, 4 };


/*** EndHeader */



/* 1/4: PMKID
 * 2/4: RSN IE
 * 3/4: one or two RSN IEs + GTK IE (encrypted)
 * 4/4: empty
 * 1/2: GTK IE (encrypted)
 * 2/2: empty
 */

/*** BeginHeader wpa_selector_to_bitfield */
int wpa_selector_to_bitfield(uint8 *s);
/*** EndHeader */
_wifig_nodebug
__static int wpa_selector_to_bitfield(uint8 *s)
{
	if (memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == 0)
		return WPA_CIPHER_NONE;
	if (memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == 0)
		return WPA_CIPHER_WEP40;
	if (memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == 0)
		return WPA_CIPHER_TKIP;
	if (memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == 0)
		return WPA_CIPHER_CCMP;
	if (memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == 0)
		return WPA_CIPHER_WEP104;
	return 0;
}


/*** BeginHeader wpa_key_mgmt_to_bitfield */
int wpa_key_mgmt_to_bitfield(uint8 *s);
/*** EndHeader */
_wifig_nodebug
__static int wpa_key_mgmt_to_bitfield(uint8 *s)
{
	if (memcmp(s, WPA_AUTH_KEY_MGMT_UNSPEC_802_1X, WPA_SELECTOR_LEN) == 0)
		return WPA_KEY_MGMT_IEEE8021X;
	if (memcmp(s, WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X, WPA_SELECTOR_LEN) ==
	    0)
		return WPA_KEY_MGMT_PSK;
	return 0;
}


/*** BeginHeader rsn_selector_to_bitfield */
int rsn_selector_to_bitfield(uint8 *s);
/*** EndHeader */
_wifig_nodebug
__static int rsn_selector_to_bitfield(uint8 *s)
{
	if (memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == 0)
		return WPA_CIPHER_NONE;
	if (memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == 0)
		return WPA_CIPHER_WEP40;
	if (memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == 0)
		return WPA_CIPHER_TKIP;
	if (memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == 0)
		return WPA_CIPHER_CCMP;
	if (memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == 0)
		return WPA_CIPHER_WEP104;
	return 0;
}


/*** BeginHeader rsn_key_mgmt_to_bitfield */
int rsn_key_mgmt_to_bitfield(uint8 *s);
/*** EndHeader */
_wifig_nodebug
__static int rsn_key_mgmt_to_bitfield(uint8 *s)
{
	if (memcmp(s, RSN_AUTH_KEY_MGMT_UNSPEC_802_1X, RSN_SELECTOR_LEN) == 0)
		return WPA_KEY_MGMT_IEEE8021X;
	if (memcmp(s, RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X, RSN_SELECTOR_LEN) ==
	    0)
		return WPA_KEY_MGMT_PSK;
	return 0;
}


/*** BeginHeader rsn_pmkid */
void rsn_pmkid(uint8 *pmk, uint8 *aa, uint8 *spa, uint8 *pmkid);
/*** EndHeader */
_wifig_nodebug
__static void rsn_pmkid(uint8 *pmk, uint8 *aa, uint8 *spa, uint8 *pmkid)
{
	unsigned char hash[SHA1_MAC_LEN];
	unsigned char *addr[3];
	unsigned int len[3];

	addr[0] = "PMK Name"; 	len[0] = 8;
	addr[1] = aa; 				len[1] = ETH_ALEN;
	addr[2] = spa;				len[2] = ETH_ALEN;

	hmac_sha1_vector(pmk, PMK_LEN, 3, addr, len, hash);
	memcpy(pmkid, hash, PMKID_LEN);
}



/*** BeginHeader pmksa_cache_free_entry */
//SJH - changed prototype to avoid compiler warning...
void pmksa_cache_free_entry(struct wpa_supplicant *wpa_s,
				   void /*struct rsn_pmksa_cache*/ *entry);
/*** EndHeader */
#error "PSK session caching not implemented"
__static void pmksa_cache_free_entry(struct wpa_supplicant *wpa_s,
				   struct rsn_pmksa_cache *entry)
{
	free(entry);
	wpa_s->pmksa_count--;
	if (wpa_s->cur_pmksa == entry) {
		WPA_PRINTF((MSG_DEBUG, "RSN: removed current PMKSA entry"))
		/* TODO: should drop PMK and PTK and trigger new key
		 * negotiation */
		wpa_s->cur_pmksa = NULL;
	}
}


/*** BeginHeader pmksa_cache_expire */
void pmksa_cache_expire(void __far *eloop_ctx, void __far *timeout_ctx);
/*** EndHeader */
__static void pmksa_cache_expire(void __far *eloop_ctx, void __far *timeout_ctx)
{
	struct wpa_supplicant *wpa_s = eloop_ctx;
	long now;

	now = MS_TIMER;
	while (wpa_s->pmksa && wpa_s->pmksa->expiration - now < 0) {
		struct rsn_pmksa_cache *entry = wpa_s->pmksa;
		wpa_s->pmksa = entry->next;
		WPA_PRINTF((MSG_DEBUG, "RSN: expired PMKSA cache entry for "
			   MACSTR, MAC2STR(entry->aa)))
		pmksa_cache_free_entry(wpa_s, entry);
	}

	pmksa_cache_set_expiration(wpa_s);
}


/*** BeginHeader pmksa_cache_set_expiration */
void pmksa_cache_set_expiration(struct wpa_supplicant *wpa_s);
/*** EndHeader */
__static void pmksa_cache_set_expiration(struct wpa_supplicant *wpa_s)
{
	int sec;
	eloop_cancel_timeout(pmksa_cache_expire, wpa_s, NULL);
	if (wpa_s->pmksa == NULL)
		return;
	sec = wpa_s->pmksa->expiration - time(NULL);
	if (sec < 0)
		sec = 0;
	eloop_register_timeout(sec*1000L, pmksa_cache_expire, wpa_s, NULL);
}


/*** BeginHeader pmksa_cache_add */
void pmksa_cache_add(struct wpa_supplicant *wpa_s, uint8 *pmk,
			    size_t pmk_len, uint8 *aa, uint8 *spa);
/*** EndHeader */
#error
__static void pmksa_cache_add(struct wpa_supplicant *wpa_s, uint8 *pmk,
			    size_t pmk_len, uint8 *aa, uint8 *spa)
{
	struct rsn_pmksa_cache *entry, *pos, *prev;

	if (wpa_s->proto != WPA_PROTO_RSN || pmk_len > PMK_LEN)
		return;

	entry = malloc(sizeof(*entry));
	if (entry == NULL)
		return;
	memset(entry, 0, sizeof(*entry));
	memcpy(entry->pmk, pmk, PMK_LEN);
	entry->pmk_len = pmk_len;
	rsn_pmkid(pmk, aa, spa, entry->pmkid);
	entry->expiration = time(NULL) + dot11RSNAConfigPMKLifetime;
	entry->akmp = WPA_KEY_MGMT_IEEE8021X;
	memcpy(entry->aa, aa, ETH_ALEN);

	/* Replace an old entry for the same Authenticator (if found) with the
	 * new entry */
	pos = wpa_s->pmksa;
	prev = NULL;
	while (pos) {
		if (memcmp(aa, pos->aa, ETH_ALEN) == 0) {
			if (prev == NULL)
				wpa_s->pmksa = pos->next;
			else
				prev->next = pos->next;
			pmksa_cache_free_entry(wpa_s, pos);
			break;
		}
		prev = pos;
		pos = pos->next;
	}

	if (wpa_s->pmksa_count >= pmksa_cache_max_entries && wpa_s->pmksa) {
		/* Remove the oldest entry to make room for the new entry */
		pos = wpa_s->pmksa;
		wpa_s->pmksa = pos->next;
		WPA_PRINTF((MSG_DEBUG, "RSN: removed the oldest PMKSA cache "
			   "entry (for " MACSTR ") to make room for new one",
			   MAC2STR(pos->aa)))
		pmksa_cache_free_entry(wpa_s, pos);
	}

	/* Add the new entry; order by expiration time */
	pos = wpa_s->pmksa;
	prev = NULL;
	while (pos) {
		if (pos->expiration > entry->expiration)
			break;
		prev = pos;
		pos = pos->next;
	}
	if (prev == NULL) {
		entry->next = wpa_s->pmksa;
		wpa_s->pmksa = entry;
	} else {
		entry->next = prev->next;
		prev->next = entry;
	}
	wpa_s->pmksa_count++;
	WPA_PRINTF((MSG_DEBUG, "RSN: added PMKSA cache entry for " MACSTR,
		   MAC2STR(entry->aa)))
}


/*** BeginHeader pmksa_cache_free */
void pmksa_cache_free(struct wpa_supplicant *wpa_s);
/*** EndHeader */
#error
void pmksa_cache_free(struct wpa_supplicant *wpa_s)
{
	struct rsn_pmksa_cache *entry, *prev;

	entry = wpa_s->pmksa;
	wpa_s->pmksa = NULL;
	while (entry) {
		prev = entry;
		entry = entry->next;
		free(prev);
	}
	pmksa_cache_set_expiration(wpa_s);
	wpa_s->cur_pmksa = NULL;
}


/*** BeginHeader rsn_pmksa_cache */
struct rsn_pmksa_cache * pmksa_cache_get(struct wpa_supplicant *wpa_s,
					 uint8 *aa, uint8 *pmkid);
/*** EndHeader */
struct rsn_pmksa_cache * pmksa_cache_get(struct wpa_supplicant *wpa_s,
					 uint8 *aa, uint8 *pmkid)
{
	struct rsn_pmksa_cache *entry = wpa_s->pmksa;
	while (entry) {
		if ((aa == NULL || memcmp(entry->aa, aa, ETH_ALEN) == 0) &&
		    (pmkid == NULL ||
		     memcmp(entry->pmkid, pmkid, PMKID_LEN) == 0))
			return entry;
		entry = entry->next;
	}
	return NULL;
}


/*** BeginHeader pmksa_cache_list */
int pmksa_cache_list(struct wpa_supplicant *wpa_s, char *buf, size_t len);
/*** EndHeader */
int pmksa_cache_list(struct wpa_supplicant *wpa_s, char *buf, size_t len)
{
	int i, j;
	char *pos = buf;
	struct rsn_pmksa_cache *entry;
	long now;

	now = MS_TIMER;
	pos += snprintf(pos, buf + len - pos,
			"Index / AA / PMKID / expiration (in seconds)\n");
	i = 0;
	entry = wpa_s->pmksa;
	while (entry) {
		i++;
		pos += snprintf(pos, buf + len - pos, "%d " MACSTR " ",
				i, MAC2STR(entry->aa));
		for (j = 0; j < PMKID_LEN; j++)
			pos += snprintf(pos, buf + len - pos, "%02x",
					entry->pmkid[j]);
		pos += snprintf(pos, buf + len - pos, " %lds\n",
				(long) (entry->expiration - now >> 10));
		entry = entry->next;
	}
	return pos - buf;
}


/*** BeginHeader pmksa_candidate_free */
void pmksa_candidate_free(struct wpa_supplicant *wpa_s);
/*** EndHeader */
#error
void pmksa_candidate_free(struct wpa_supplicant *wpa_s)
{
	struct rsn_pmksa_candidate *entry, *prev;

	entry = wpa_s->pmksa_candidates;
	wpa_s->pmksa_candidates = NULL;
	while (entry) {
		prev = entry;
		entry = entry->next;
		free(prev);
	}
}


/*** BeginHeader wpa_parse_wpa_ie_wpa */
int wpa_parse_wpa_ie_wpa(uint8 *wpa_ie,
				size_t wpa_ie_len, struct wpa_ie_data *data);
#define le_to_host16(x) (x)
/*** EndHeader */
_wifig_nodebug
__static int wpa_parse_wpa_ie_wpa(uint8 *wpa_ie,
				size_t wpa_ie_len, struct wpa_ie_data *data)
{
	struct wpa_ie_hdr *hdr;
	uint8 *pos;
	int left;
	int i, count;

	data->proto = WPA_PROTO_WPA;
	data->pairwise_cipher = WPA_CIPHER_TKIP;
	data->group_cipher = WPA_CIPHER_TKIP;
	data->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
	data->capabilities = 0;

	if (wpa_ie_len == 0) {
		/* No WPA IE - fail silently */
		return -1;
	}

	if (wpa_ie_len < sizeof(struct wpa_ie_hdr)) {
		WPA_PRINTF((MSG_DEBUG, "wpwiw: ie len too short %u", wpa_ie_len))
		return -1;
	}

	hdr = (struct wpa_ie_hdr *) wpa_ie;

	if (hdr->elem_id != GENERIC_INFO_ELEM ||
	    hdr->len != wpa_ie_len - 2 ||
	    memcmp(&hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN) != 0 ||
	    le_to_host16(hdr->version) != WPA_VERSION) {
		WPA_PRINTF((MSG_DEBUG, "wpwiw: malformed ie or unknown version"))
		return -1;
	}

	pos = (uint8 *) (hdr + 1);
	left = wpa_ie_len - sizeof(*hdr);

	if (left >= WPA_SELECTOR_LEN) {
		data->group_cipher = wpa_selector_to_bitfield(pos);
		pos += WPA_SELECTOR_LEN;
		left -= WPA_SELECTOR_LEN;
	} else if (left > 0) {
		WPA_PRINTF((MSG_DEBUG, "wpwiw: ie length mismatch, %u too much", left))
		return -1;
	}

	if (left >= 2) {
		data->pairwise_cipher = 0;
		count = _WIFI_GET16(pos);
		pos += 2;
		left -= 2;
		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
			WPA_PRINTF((MSG_DEBUG, "wpwiw: ie count botch (pairwise), count %u left %u", count, left))
			return -1;
		}
		for (i = 0; i < count; i++) {
			data->pairwise_cipher |= wpa_selector_to_bitfield(pos);
			pos += WPA_SELECTOR_LEN;
			left -= WPA_SELECTOR_LEN;
		}
	} else if (left == 1) {
		WPA_PRINTF((MSG_DEBUG, "wpwiw: ie too short (for key mgmt)"))
		return -1;
	}

	if (left >= 2) {
		data->key_mgmt = 0;
		count = _WIFI_GET16(pos);
		pos += 2;
		left -= 2;
		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
			WPA_PRINTF((MSG_DEBUG, "wpwiw: ie count botch (key mgmt), count %u left %u", count, left))
			return -1;
		}
		for (i = 0; i < count; i++) {
			data->key_mgmt |= wpa_key_mgmt_to_bitfield(pos);
			pos += WPA_SELECTOR_LEN;
			left -= WPA_SELECTOR_LEN;
		}
	} else if (left == 1) {
		WPA_PRINTF((MSG_DEBUG, "wpwiw: ie too short (for capabilities)"))
		return -1;
	}

	if (left >= 2) {
		data->capabilities = _WIFI_GET16(pos);
		pos += 2;
		left -= 2;
	}

	if (left > 0) {
		WPA_PRINTF((MSG_DEBUG, "wpwiw: ie has %u trailing bytes", left))
		return -1;
	}

	return 0;
}


/*** BeginHeader wpa_parse_wpa_ie_rsn */
int wpa_parse_wpa_ie_rsn(uint8 *rsn_ie,
				size_t rsn_ie_len, struct wpa_ie_data *data);
/*** EndHeader */
_wifig_nodebug
__static int wpa_parse_wpa_ie_rsn(uint8 *rsn_ie,
				size_t rsn_ie_len, struct wpa_ie_data *data)
{
	struct rsn_ie_hdr *hdr;
	uint8 *pos;
	int left;
	int i, count;

	data->proto = WPA_PROTO_RSN;
	data->pairwise_cipher = WPA_CIPHER_CCMP;
	data->group_cipher = WPA_CIPHER_CCMP;
	data->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
	data->capabilities = 0;

	if (rsn_ie_len == 0) {
		/* No RSN IE - fail silently */
		return -1;
	}

	if (rsn_ie_len < sizeof(struct rsn_ie_hdr)) {
		WPA_PRINTF((MSG_DEBUG, "wpwir: ie len too short %u", rsn_ie_len))
		return -1;
	}

	hdr = (struct rsn_ie_hdr *) rsn_ie;

	if (hdr->elem_id != RSN_INFO_ELEM ||
	    hdr->len != rsn_ie_len - 2 ||
	    le_to_host16(hdr->version) != RSN_VERSION) {
		WPA_PRINTF((MSG_DEBUG, "wpwir: malformed ie or unknown version"))
		return -1;
	}

	pos = (uint8 *) (hdr + 1);
	left = rsn_ie_len - sizeof(*hdr);

	if (left >= RSN_SELECTOR_LEN) {
		data->group_cipher = rsn_selector_to_bitfield(pos);
		pos += RSN_SELECTOR_LEN;
		left -= RSN_SELECTOR_LEN;
	} else if (left > 0) {
		WPA_PRINTF((MSG_DEBUG, "wpwir: ie length mismatch, %u too much", left))
		return -1;
	}

	if (left >= 2) {
		data->pairwise_cipher = 0;
		count = _WIFI_GET16(pos);
		pos += 2;
		left -= 2;
		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
			WPA_PRINTF((MSG_DEBUG, "wpwir: ie count botch (pairwise), count %u left %u", count, left))
			return -1;
		}
		for (i = 0; i < count; i++) {
			data->pairwise_cipher |= rsn_selector_to_bitfield(pos);
			pos += RSN_SELECTOR_LEN;
			left -= RSN_SELECTOR_LEN;
		}
	} else if (left == 1) {
		WPA_PRINTF((MSG_DEBUG, "wpwir: ie too short (for key mgmt)"))
		return -1;
	}

	if (left >= 2) {
		data->key_mgmt = 0;
		count = _WIFI_GET16(pos);
		pos += 2;
		left -= 2;
		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
			WPA_PRINTF((MSG_DEBUG, "wpwir: ie count botch (key mgmt), count %u left %u", count, left))
			return -1;
		}
		for (i = 0; i < count; i++) {
			data->key_mgmt |= rsn_key_mgmt_to_bitfield(pos);
			pos += RSN_SELECTOR_LEN;
			left -= RSN_SELECTOR_LEN;
		}
	} else if (left == 1) {
		WPA_PRINTF((MSG_DEBUG, "wpwir: ie too short (for capabilities)"))
		return -1;
	}

	if (left >= 2) {
		data->capabilities = _WIFI_GET16(pos);
		pos += 2;
		left -= 2;
	}

	if (left > 0) {
		/* RSN IE could include PMKID data, but Authenticator should
		 * never include it, so no need to parse it in the Supplicant.
		 */
		WPA_PRINTF((MSG_DEBUG, "wpwir: ie has %u trailing bytes - ignored", left))
	}

	return 0;
}


/*** BeginHeader wpa_parse_wpa_ie */
int wpa_parse_wpa_ie(struct wpa_supplicant *wpa_s, uint8 *wpa_ie,
		     size_t wpa_ie_len, struct wpa_ie_data *data);
/*** EndHeader */
_wifig_nodebug
int wpa_parse_wpa_ie(struct wpa_supplicant *wpa_s, uint8 *wpa_ie,
		     size_t wpa_ie_len, struct wpa_ie_data *data)
{
	if (wpa_ie_len >= 1 && wpa_ie[0] == RSN_INFO_ELEM)
		return wpa_parse_wpa_ie_rsn(wpa_ie, wpa_ie_len, data);
	else
		return wpa_parse_wpa_ie_wpa(wpa_ie, wpa_ie_len, data);
}


/*** BeginHeader wpa_gen_wpa_ie_wpa */
int wpa_gen_wpa_ie_wpa(struct wpa_supplicant *wpa_s, uint8 *wpa_ie);
/*** EndHeader */
_wifig_nodebug
static int wpa_gen_wpa_ie_wpa(struct wpa_supplicant *wpa_s, uint8 *wpa_ie)
{
	uint8 *pos;
	struct wpa_ie_hdr *hdr;

	hdr = (struct wpa_ie_hdr *) wpa_ie;
	hdr->elem_id = GENERIC_INFO_ELEM;
	memcpy(&hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
	hdr->version = WPA_VERSION;
	pos = (uint8 *) (hdr + 1);

	if (wpa_s->group_cipher == WPA_CIPHER_CCMP) {
		memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == WPA_CIPHER_TKIP) {
		memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == WPA_CIPHER_WEP104) {
		memcpy(pos, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == WPA_CIPHER_WEP40) {
		memcpy(pos, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN);
	} else {
		WPA_PRINTF((MSG_WARNING, "Invalid group cipher (%d).",
			   wpa_s->group_cipher))
		return -1;
	}
	pos += WPA_SELECTOR_LEN;

	*pos++ = 1;
	*pos++ = 0;
	if (wpa_s->pairwise_cipher == WPA_CIPHER_CCMP) {
		memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
	} else if (wpa_s->pairwise_cipher == WPA_CIPHER_TKIP) {
		memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
	} else if (wpa_s->pairwise_cipher == WPA_CIPHER_NONE) {
		memcpy(pos, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN);
	} else {
		WPA_PRINTF((MSG_WARNING, "Invalid pairwise cipher (%d).",
			   wpa_s->pairwise_cipher))
		return -1;
	}
	pos += WPA_SELECTOR_LEN;

	*pos++ = 1;
	*pos++ = 0;
	if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X) {
		memcpy(pos, WPA_AUTH_KEY_MGMT_UNSPEC_802_1X, WPA_SELECTOR_LEN);
	} else if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK) {
		memcpy(pos, WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X,
		       WPA_SELECTOR_LEN);
	} else {
		WPA_PRINTF((MSG_WARNING, "Invalid key management type (%d).",
			   wpa_s->key_mgmt))
		return -1;
	}
	pos += WPA_SELECTOR_LEN;

	/* WPA Capabilities; use defaults, so no need to include it */

	hdr->len = (pos - wpa_ie) - 2;

	return pos - wpa_ie;
}


/*** BeginHeader wpa_gen_wpa_ie_rsn */
int wpa_gen_wpa_ie_rsn(struct wpa_supplicant *wpa_s, uint8 *rsn_ie);
/*** EndHeader */
_wifig_nodebug
__static int wpa_gen_wpa_ie_rsn(struct wpa_supplicant *wpa_s, uint8 *rsn_ie)
{
	uint8 *pos;
	struct rsn_ie_hdr *hdr;

	hdr = (struct rsn_ie_hdr *) rsn_ie;
	hdr->elem_id = RSN_INFO_ELEM;
	hdr->version = RSN_VERSION;
	pos = (uint8 *) (hdr + 1);

	if (wpa_s->group_cipher == WPA_CIPHER_CCMP) {
		memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == WPA_CIPHER_TKIP) {
		memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == WPA_CIPHER_WEP104) {
		memcpy(pos, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN);
	} else if (wpa_s->group_cipher == WPA_CIPHER_WEP40) {
		memcpy(pos, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN);
	} else {
		WPA_PRINTF((MSG_WARNING, "Invalid group cipher (%d).",
			   wpa_s->group_cipher))
		return -1;
	}
	pos += RSN_SELECTOR_LEN;

	*pos++ = 1;
	*pos++ = 0;
	if (wpa_s->pairwise_cipher == WPA_CIPHER_CCMP) {
		memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
	} else if (wpa_s->pairwise_cipher == WPA_CIPHER_TKIP) {
		memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
	} else if (wpa_s->pairwise_cipher == WPA_CIPHER_NONE) {
		memcpy(pos, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN);
	} else {
		WPA_PRINTF((MSG_WARNING, "Invalid pairwise cipher (%d).",
			   wpa_s->pairwise_cipher))
		return -1;
	}
	pos += RSN_SELECTOR_LEN;

	*pos++ = 1;
	*pos++ = 0;
	if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X) {
		memcpy(pos, RSN_AUTH_KEY_MGMT_UNSPEC_802_1X, RSN_SELECTOR_LEN);
	} else if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK) {
		memcpy(pos, RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X,
		       RSN_SELECTOR_LEN);
	} else {
		WPA_PRINTF((MSG_WARNING, "Invalid key management type (%d).",
			   wpa_s->key_mgmt))
		return -1;
	}
	pos += RSN_SELECTOR_LEN;

	/* RSN Capabilities */
	*pos++ = 0;
	*pos++ = 0;
#if 0
	if (wpa_s->cur_pmksa) {
		/* PMKID Count (2 octets, little endian) */
		*pos++ = 1;
		*pos++ = 0;
		/* PMKID */
		memcpy(pos, wpa_s->cur_pmksa->pmkid, PMKID_LEN);
		pos += PMKID_LEN;
	}
#endif
	hdr->len = (pos - rsn_ie) - 2;

	return pos - rsn_ie;
}


/*** BeginHeader wpa_gen_wpa_ie */
int wpa_gen_wpa_ie(struct wpa_supplicant *wpa_s, uint8 *wpa_ie);
/*** EndHeader */
_wifig_nodebug
int wpa_gen_wpa_ie(struct wpa_supplicant *wpa_s, uint8 *wpa_ie)
{
	if (wpa_s->proto == WPA_PROTO_RSN)
		return wpa_gen_wpa_ie_rsn(wpa_s, wpa_ie);
	else
		return wpa_gen_wpa_ie_wpa(wpa_s, wpa_ie);
}


/*** BeginHeader wpa_pmk_to_ptk */
void wpa_pmk_to_ptk(uint8 *pmk, size_t pmk_len, uint8 *addr1, uint8 *addr2,
			   uint8 *nonce1, uint8 *nonce2, uint8 *ptk, size_t ptk_len);
/*** EndHeader */
_wifig_nodebug
__static void wpa_pmk_to_ptk(uint8 *pmk, size_t pmk_len, uint8 *addr1, uint8 *addr2,
			   uint8 *nonce1, uint8 *nonce2, uint8 *ptk, size_t ptk_len)
{
	uint8 data[2 * ETH_ALEN + 2 * 32];

	/* PTK = PRF-X(PMK, "Pairwise key expansion",
	 *             Min(AA, SA) || Max(AA, SA) ||
	 *             Min(ANonce, SNonce) || Max(ANonce, SNonce)) */

	if (memcmp(addr1, addr2, ETH_ALEN) < 0) {
		memcpy(data, addr1, ETH_ALEN);
		memcpy(data + ETH_ALEN, addr2, ETH_ALEN);
	} else {
		memcpy(data, addr2, ETH_ALEN);
		memcpy(data + ETH_ALEN, addr1, ETH_ALEN);
	}

	if (memcmp(nonce1, nonce2, 32) < 0) {
		memcpy(data + 2 * ETH_ALEN, nonce1, 32);
		memcpy(data + 2 * ETH_ALEN + 32, nonce2, 32);
	} else {
		memcpy(data + 2 * ETH_ALEN, nonce2, 32);
		memcpy(data + 2 * ETH_ALEN + 32, nonce1, 32);
	}

	sha1_prf(pmk, pmk_len, "Pairwise key expansion", data, sizeof(data),
		 ptk, ptk_len);

	WPA_HEXDUMP((MSG_DEBUG, "WPA: PMK", pmk, pmk_len))
	WPA_HEXDUMP((MSG_DEBUG, "WPA: PTK", ptk, ptk_len))
}


/*** BeginHeader wpa_supplicant_get_ssid */
struct wpa_ssid * wpa_supplicant_get_ssid(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
struct wpa_ssid * wpa_supplicant_get_ssid(struct wpa_supplicant *wpa_s)
{
	struct wpa_ssid *entry;
	uint8 ssid[MAX_SSID_LEN];
	int ssid_len;
	uint8 bssid[ETH_ALEN];

	ssid_len = wpa_driver_wln_get_ssid(ssid);
	if (ssid_len < 0) {
		WPA_PRINTF((MSG_WARNING, "Could not read SSID from driver."))
		return NULL;
	}

	if (wpa_driver_wln_get_bssid(bssid) < 0) {
		WPA_PRINTF((MSG_WARNING, "Could not read BSSID from driver."))
		return NULL;
	}

	entry = wpa_s->conf->ssid;
	while (entry) {
		if (ssid_len == entry->ssid_len &&
		    memcmp(ssid, entry->ssid, ssid_len) == 0 &&
		    (!entry->bssid_set ||
		     memcmp(bssid, entry->bssid, ETH_ALEN) == 0))
			return entry;
		entry = entry->next;
	}

	return NULL;
}


/*** BeginHeader wpa_eapol_key_mic */
void wpa_eapol_key_mic(uint8 *key, int ver, uint8 *buf, size_t len, uint8 *mic);
/*** EndHeader */
_wifig_nodebug
__static void wpa_eapol_key_mic(uint8 *key, int ver, uint8 *buf, size_t len, uint8 *mic)
{
	uint8 hash[SHA1_MAC_LEN];
	if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
		// Args swapped with Rabbit version
		//hmac_md5(key, 16, buf, len, mic);
		hmac_md5(buf, len, key, 16, mic);
	} else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		hmac_sha1(key, 16, buf, len, hash);
		memcpy(mic, hash, 16);
	}
}

/*** BeginHeader inc_byte_array */
void inc_byte_array(uint8 *counter, size_t len);
/*** EndHeader */
_wifig_nodebug
void inc_byte_array(uint8 *counter, size_t len)
{
	int pos;
	pos = len - 1;
	while (pos >= 0) {
		++counter[pos];
		if (counter[pos])
			break;
		--pos;
	}
}

/*** BeginHeader wpa_supplicant_key_request */
void wpa_supplicant_key_request(struct wpa_supplicant *wpa_s,
				int error, int pairwise);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_key_request(struct wpa_supplicant *wpa_s,
				int error, int pairwise)
{
	auto uint8 rbuf[14+sizeof(struct ieee802_1x_hdr)+sizeof(struct wpa_eapol_key)];
	int rlen;
	struct ieee802_1x_hdr *hdr;
	struct wpa_eapol_key *reply;
	struct l2_ethhdr *ethhdr;
	int key_info, ver;
	uint8 bssid[ETH_ALEN];

	if (wpa_s->pairwise_cipher == WPA_CIPHER_CCMP)
		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
	else
		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;

	if (wpa_driver_wln_get_bssid(bssid) < 0) {
		WPA_PRINTF((MSG_WARNING, "Failed to read BSSID for EAPOL-Key request"))
		return;
	}

	rlen = sizeof(*ethhdr) + sizeof(*hdr) + sizeof(*reply)-32;
	//rbuf = malloc(rlen);
	//if (rbuf == NULL)
	//	return;

	memset(rbuf, 0, rlen);
	ethhdr = (struct l2_ethhdr *) rbuf;
	memcpy(ethhdr->h_dest, bssid, ETH_ALEN);
	memcpy(ethhdr->h_source, wpa_s->nic->hwa, ETH_ALEN);
	ethhdr->h_proto = htons(ETH_P_EAPOL);

	hdr = (struct ieee802_1x_hdr *) (ethhdr + 1);
	hdr->version = wpa_s->conf->eapol_version;
	hdr->type = IEEE802_1X_TYPE_EAPOL_KEY;
	hdr->length = htons(sizeof(*reply)-32);

	reply = (struct wpa_eapol_key *) (hdr + 1);
	reply->type = wpa_s->proto == WPA_PROTO_RSN ?
		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
	key_info = WPA_KEY_INFO_REQUEST | ver;
	if (wpa_s->ptk_set)
		key_info |= WPA_KEY_INFO_MIC;
	if (error)
		key_info |= WPA_KEY_INFO_ERROR;
	if (pairwise)
		key_info |= WPA_KEY_INFO_KEY_TYPE;
	reply->key_info = intel16(key_info);
	reply->key_length = 0;
	memcpy(reply->replay_counter, wpa_s->request_counter,
	       WPA_REPLAY_COUNTER_LEN);
	inc_byte_array(wpa_s->request_counter, WPA_REPLAY_COUNTER_LEN);

	reply->key_data_length = 0;

	if (key_info & WPA_KEY_INFO_MIC) {
		wpa_eapol_key_mic(wpa_s->ptk.mic_key, ver, (uint8 *) hdr,
			 rlen - sizeof(*ethhdr), reply->key_mic);
	}

	WPA_PRINTF((MSG_INFO, "WPA: Sending EAPOL-Key Request (error=%d pairwise=%d ptk_set=%d len=%d)",
		   error, pairwise, wpa_s->ptk_set, rlen))
	WPA_HEXDUMP((MSG_MSGDUMP, "WPA: TX EAPOL-Key Request", rbuf, rlen))
	wln_send(rbuf, rlen);
	//eapol_sm_notify_tx_eapol_key(wpa_s->eapol);
	//free(rbuf);
}


/*** BeginHeader wpa_supplicant_process_1_of_4 */
void wpa_supplicant_process_1_of_4(struct wpa_supplicant *wpa_s,
					  unsigned char *src_addr,
					  struct wpa_eapol_key *key, int ver);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_process_1_of_4(struct wpa_supplicant *wpa_s,
					  unsigned char *src_addr,
					  struct wpa_eapol_key *key, int ver)
{
	auto uint8 rbuf[14+sizeof(struct ieee802_1x_hdr)+sizeof(struct wpa_eapol_key)+200];
	auto int rlen;
	auto struct ieee802_1x_hdr *hdr;
	auto struct wpa_eapol_key *reply;
	auto struct l2_ethhdr *ethhdr;
	auto struct wpa_ptk *ptk;
	auto uint8 buf[8], wpa_ie_buf[WPA_MAX_IE_LEN], *wpa_ie, *pmkid;
	auto int wpa_ie_len;
	auto int keylen;
	auto uint8 mic[16];
	auto uint8 *pos, * end;
	auto word nlen;

	pmkid = NULL;
	wpa_s->wpa_state = WPA_4WAY_HANDSHAKE;
	WPA_PRINTF((MSG_DEBUG, "WPA: RX message 1 of 4-Way Handshake from " \
		   MACSTR " (ver=%d)", MAC2STR(src_addr), ver))


	if (wpa_s->proto == WPA_PROTO_RSN) {
		/* RSN: msg 1/4 should contain PMKID for the selected PMK */
		pos = key->key_data;
		end = pos + intel16(key->key_data_length);
		WPA_HEXDUMP((MSG_DEBUG, "RSN: msg 1/4 key data",
			    key->key_data, intel16(key->key_data_length)))
		while (pos + 1 < end) {
			if (pos + 2 + pos[1] > end) {
				WPA_PRINTF((MSG_DEBUG, "RSN: key data underflow (ie=%d len=%d)",
					   pos[0], pos[1]))
				break;
			}
			if (pos[0] == GENERIC_INFO_ELEM &&
			    pos + 1 + RSN_SELECTOR_LEN < end &&
			    pos[1] >= RSN_SELECTOR_LEN + PMKID_LEN &&
			    memcmp(pos + 2, RSN_KEY_DATA_PMKID,
				   RSN_SELECTOR_LEN) == 0) {
				pmkid = pos + 2 + RSN_SELECTOR_LEN;
				WPA_HEXDUMP((MSG_DEBUG, "RSN: PMKID from Authenticator", pmkid, PMKID_LEN))
				break;
			} else if (pos[0] == GENERIC_INFO_ELEM &&
				   pos[1] == 0)
				break;
			pos += 2 + pos[1];
		}
	}

	/* Check key length per UNH-IOL conformance testing */
	keylen = intel16(key->key_length);
	switch (wpa_s->pairwise_cipher) {
	case WPA_CIPHER_CCMP:
		if (keylen != 16) {
			WPA_PRINTF((MSG_WARNING, "WPA: Invalid CCMP key length %d (src=" MACSTR ")",
				   keylen, MAC2STR(src_addr)))
			return;
		}
		break;
	case WPA_CIPHER_TKIP:
		if (keylen != 32) {
			WPA_PRINTF((MSG_WARNING, "WPA: Invalid TKIP key length %d (src=" MACSTR ")",
				   keylen, MAC2STR(src_addr)))
			return;
		}
		break;
	}

	/* Check for key MIC == 0 per UNH-IOL conformance testing */
	memset(mic, 0, 16);
	if (memcmp(mic, key->key_mic, 16) != 0) {
		WPA_PRINTF((MSG_WARNING, "WPA: Non-zero EAPOL-Key MIC - dropping packet"))
		return;
	}

	if (wpa_s->assoc_wpa_ie_len) {
		/* The driver reported a WPA IE that may be different from the
		 * one that the Supplicant would use. Message 2/4 has to use
		 * the exact copy of the WPA IE from the Association Request,
		 * so use the value reported by the driver. */
		wpa_ie = wpa_s->assoc_wpa_ie;
		wpa_ie_len = wpa_s->assoc_wpa_ie_len;
	} else {
		wpa_ie = wpa_ie_buf;
		wpa_ie_len = wpa_gen_wpa_ie(wpa_s, wpa_ie);
		if (wpa_ie_len < 0) {
			WPA_PRINTF((MSG_WARNING, "WPA: Failed to generate WPA IE (for msg 2 of 4)."))
			return;
		}
		WPA_HEXDUMP((MSG_DEBUG, "WPA: WPA IE for msg 2/4",
			    wpa_ie, wpa_ie_len))
	}

	rlen = sizeof(*ethhdr) + sizeof(*hdr) + (sizeof(*reply)-32) + wpa_ie_len;
	//rbuf = malloc(rlen);
	//if (rbuf == NULL)
	//	return;

	memset(rbuf, 0, rlen);
	ethhdr = (struct l2_ethhdr *) rbuf;
	memcpy(ethhdr->h_dest, src_addr, ETH_ALEN);
	memcpy(ethhdr->h_source, wpa_s->nic->hwa, ETH_ALEN);
	ethhdr->h_proto = htons(ETH_P_EAPOL);

	hdr = (struct ieee802_1x_hdr *) (ethhdr + 1);
	hdr->version = wpa_s->conf->eapol_version;
	hdr->type = IEEE802_1X_TYPE_EAPOL_KEY;
	hdr->length = htons((sizeof(*reply)-32) + wpa_ie_len);

	reply = (struct wpa_eapol_key *) (hdr + 1);
	reply->type = wpa_s->proto == WPA_PROTO_RSN ?
		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
	reply->key_info = intel16(ver | WPA_KEY_INFO_KEY_TYPE |
				       WPA_KEY_INFO_MIC);
	reply->key_length = 0;
	memcpy(reply->replay_counter, key->replay_counter,
	       WPA_REPLAY_COUNTER_LEN);

	reply->key_data_length = intel16(wpa_ie_len);
	memcpy(reply->key_data, wpa_ie, wpa_ie_len);

	if (wpa_s->renew_snonce) {
		// Rabbit implementation of secure random numbers...
		for (nlen = 0; nlen < WPA_NONCE_LEN; nlen += 4)
			*(unsigned long *)(wpa_s->snonce + nlen) = seed_getbits(32);
		#if 0
		if (hostapd_get_rand(wpa_s->snonce, WPA_NONCE_LEN)) {
			wpa_msg(wpa_s, MSG_WARNING, "WPA: Failed to get random data for SNonce");
			return;
		}
		#endif

		wpa_s->renew_snonce = 0;
		WPA_HEXDUMP((MSG_DEBUG, "WPA: Renewed SNonce",
			    wpa_s->snonce, WPA_NONCE_LEN))
	}
	memcpy(reply->key_nonce, wpa_s->snonce, WPA_NONCE_LEN);
	ptk = &wpa_s->tptk;
	memcpy(wpa_s->anonce, key->key_nonce, WPA_NONCE_LEN);
#if 0
	if (pmkid && wpa_s->cur_pmksa &&
	    memcmp(pmkid, wpa_s->cur_pmksa->pmkid, PMKID_LEN) == 0) {
		WPA_HEXDUMP((MSG_DEBUG, "RSN: matched PMKID", pmkid, PMKID_LEN))
		memcpy(wpa_s->pmk, wpa_s->cur_pmksa->pmk, PMK_LEN);
		WPA_HEXDUMP((MSG_DEBUG, "RSN: PMK from PMKSA cache",
			    wpa_s->pmk, PMK_LEN))
		//eapol_sm_notify_cached(wpa_s->eapol);
	} else if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X && wpa_s->eapol) {
		int res, pmk_len;
		pmk_len = PMK_LEN;
		res = eapol_sm_get_key(wpa_s->eapol, wpa_s->pmk, PMK_LEN);
		if (res == 0) {
			WPA_HEXDUMP((MSG_DEBUG, "WPA: PMK from EAPOL state machines", wpa_s->pmk, PMK_LEN))
			wpa_s->pmk_len = pmk_len;
			pmksa_cache_add(wpa_s, wpa_s->pmk, pmk_len, src_addr,
					wpa_s->nic->hwa);
		} else {
			wpa_msg(wpa_s, MSG_WARNING,
				"WPA: Failed to get master session key from EAPOL state machines");
			wpa_msg(wpa_s, MSG_WARNING,
				"WPA: Key handshake aborted");
			return;
		}
	} else if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X) {
		if (!wpa_s->ext_pmk_received) {
			WPA_PRINTF((MSG_INFO, "WPA: Master session has not yet " \
				   "been received from the external IEEE " \
				   "802.1X Supplicant - ignoring WPA " \
				   "EAPOL-Key frame"))
			return;
		}
	}
#endif
	wpa_pmk_to_ptk(wpa_s->pmk, wpa_s->pmk_len, wpa_s->nic->hwa, src_addr,
		       wpa_s->snonce, key->key_nonce,
		       (uint8 *) ptk, sizeof(*ptk));
	/* Supplicant: swap tx/rx Mic keys */
	memcpy(buf, ptk->u.auth.tx_mic_key, 8);
	memcpy(ptk->u.auth.tx_mic_key, ptk->u.auth.rx_mic_key, 8);
	memcpy(ptk->u.auth.rx_mic_key, buf, 8);
	wpa_s->tptk_set = 1;
	wpa_eapol_key_mic(wpa_s->tptk.mic_key, ver, (uint8 *) hdr,
			  rlen - sizeof(*ethhdr), reply->key_mic);
	WPA_HEXDUMP((MSG_DEBUG, "WPA: EAPOL-Key MIC", reply->key_mic, 16))

	WPA_PRINTF((MSG_DEBUG, "WPA: Sending EAPOL-Key 2/4"))
	WPA_HEXDUMP((MSG_MSGDUMP, "WPA: TX EAPOL-Key 2/4", rbuf, rlen))
	wln_send(rbuf, rlen);
	//eapol_sm_notify_tx_eapol_key(wpa_s->eapol);
	//free(rbuf);
}


/*** BeginHeader wpa_report_ie_mismatch */
void wpa_report_ie_mismatch(struct wpa_supplicant *wpa_s,
				   const char *reason, const uint8 *src_addr,
				   const uint8 *wpa_ie, size_t wpa_ie_len,
				   const uint8 *rsn_ie, size_t rsn_ie_len);
/*** EndHeader */
_wifig_nodebug
__static void wpa_report_ie_mismatch(struct wpa_supplicant *wpa_s,
				   const char *reason, const uint8 *src_addr,
				   const uint8 *wpa_ie, size_t wpa_ie_len,
				   const uint8 *rsn_ie, size_t rsn_ie_len)
{
	wpa_msg(wpa_s, MSG_WARNING, "WPA: %s (src=" MACSTR ")",
		reason, MAC2STR(src_addr));

	if (wpa_s->ap_wpa_ie_len) {
		WPA_HEXDUMP((MSG_INFO, "WPA: WPA IE in Beacon/ProbeResp",
			    wpa_s->ap_wpa_ie, wpa_s->ap_wpa_ie_len))
	}
	if (wpa_ie) {
		if (!wpa_s->ap_wpa_ie_len) {
			WPA_PRINTF((MSG_INFO, "WPA: No WPA IE in Beacon/ProbeResp"))
		}
		WPA_HEXDUMP((MSG_INFO, "WPA: WPA IE in 3/4 msg",
			    wpa_ie, wpa_ie_len))
	}

	if (wpa_s->ap_rsn_ie_len) {
		WPA_HEXDUMP((MSG_INFO, "WPA: RSN IE in Beacon/ProbeResp",
			    wpa_s->ap_rsn_ie, wpa_s->ap_rsn_ie_len))
	}
	if (rsn_ie) {
		if (!wpa_s->ap_rsn_ie_len) {
			WPA_PRINTF((MSG_INFO, "WPA: No RSN IE in Beacon/ProbeResp"))
		}
		WPA_HEXDUMP((MSG_INFO, "WPA: RSN IE in 3/4 msg",
			    rsn_ie, rsn_ie_len))
	}

	wpa_supplicant_disassociate(wpa_s, REASON_IE_IN_4WAY_DIFFERS);
	wpa_supplicant_req_scan(wpa_s, 0);
}


/*** BeginHeader wpa_supplicant_process_3_of_4 */
void wpa_supplicant_process_3_of_4(struct wpa_supplicant *wpa_s,
					  unsigned char *src_addr,
					  struct wpa_eapol_key *key,
					  int extra_len, int ver);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_process_3_of_4(struct wpa_supplicant *wpa_s,
					  unsigned char *src_addr,
					  struct wpa_eapol_key *key,
					  int extra_len, int ver)
{
	auto uint8 rbuf[14+sizeof(struct ieee802_1x_hdr)+sizeof(struct wpa_eapol_key)];
	auto int rlen;
	auto struct ieee802_1x_hdr *hdr;
	auto struct wpa_eapol_key *reply;
	auto struct l2_ethhdr *ethhdr;
	auto int key_info, wpa_ie_len, rsn_ie_len, keylen, gtk_len;
	auto uint8 *wpa_ie, *rsn_ie, *gtk, *key_rsc;
	auto uint8 null_rsc[8];
	auto uint8 tmpbuf[8];
	auto uint8 *pos, *end;
	auto uint16 len;
	auto struct wpa_ssid *ssid;
	auto int alg, rsclen;
	auto int keyidx, tx, key_rsc_len;

	key_rsc_len = 0;
	wpa_ie_len = 0;
	rsn_ie_len = 0;
	gtk_len = 0;
	memset(null_rsc, 0, sizeof(null_rsc));
	ssid = wpa_s->current_ssid;
	wpa_ie = NULL;
	rsn_ie = NULL;
	gtk = NULL;

	wpa_s->wpa_state = WPA_4WAY_HANDSHAKE;
	WPA_PRINTF((MSG_DEBUG, "WPA: RX message 3 of 4-Way Handshake from " MACSTR " (ver=%d)", MAC2STR(src_addr), ver))

	key_info = intel16(key->key_info);

	pos = key->key_data;
	len = intel16(key->key_data_length);
	end = pos + len;
	WPA_HEXDUMP((MSG_DEBUG, "WPA: IE KeyData", pos, len))
		while (pos + 1 < end) {
			if (pos + 2 + pos[1] > end) {
				WPA_PRINTF((MSG_DEBUG, "WPA: key data underflow (ie=%d len=%d)", pos[0], pos[1]))
				break;
			}
			if (*pos == RSN_INFO_ELEM) {
	         rsn_ie = pos;
	         rsn_ie_len = pos[1] + 2;
	      } else if (*pos == GENERIC_INFO_ELEM && pos[1] >= 6 &&
	            memcmp(pos + 2, WPA_OUI_TYPE, WPA_SELECTOR_LEN) == 0
	            && pos[2 + WPA_SELECTOR_LEN] == 1 &&
	            pos[2 + WPA_SELECTOR_LEN + 1] == 0) {
	         wpa_ie = pos;
	         wpa_ie_len = pos[1] + 2;
			} else if (pos[0] == GENERIC_INFO_ELEM &&
				   pos[1] > RSN_SELECTOR_LEN + 2 &&
				   memcmp(pos + 2, RSN_KEY_DATA_GROUPKEY,
					  RSN_SELECTOR_LEN) == 0) {
				if (!(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
					WPA_PRINTF((MSG_WARNING, "WPA: GTK IE in unencrypted key data"))
					return;
				}
				gtk = pos + 2 + RSN_SELECTOR_LEN;
				gtk_len = pos[1] - RSN_SELECTOR_LEN;
			} else if (pos[0] == GENERIC_INFO_ELEM && pos[1] == 0)
				break;

			pos += 2 + pos[1];
		}

#ifndef NET_OS
#if 0		// Also not available on Rabbit
	/* Don't check IE from AP because PC card may not give us this */
	if ((wpa_ie && wpa_s->ap_wpa_ie &&
	     (wpa_ie_len != wpa_s->ap_wpa_ie_len ||
	      memcmp(wpa_ie, wpa_s->ap_wpa_ie, wpa_ie_len) != 0)) ||
	    (rsn_ie && wpa_s->ap_rsn_ie &&
	     (rsn_ie_len != wpa_s->ap_rsn_ie_len ||
	      memcmp(rsn_ie, wpa_s->ap_rsn_ie, rsn_ie_len) != 0))) {
		wpa_report_ie_mismatch(wpa_s,
			"IE in 3/4 msg does not match with IE in Beacon/ProbeResp",
				       src_addr, wpa_ie, wpa_ie_len,
				       rsn_ie, rsn_ie_len);
			return;
		}
#endif
#endif // NET_OS

	if (wpa_s->proto == WPA_PROTO_WPA &&
	    rsn_ie && wpa_s->ap_rsn_ie == NULL &&
	    ssid && (ssid->proto & WPA_PROTO_RSN)) {
		wpa_report_ie_mismatch(wpa_s, "Possible downgrade attack " \
				       "detected - RSN was enabled and RSN IE " \
				       "was in msg 3/4, but not in " \
				       "Beacon/ProbeResp",
				       src_addr, wpa_ie, wpa_ie_len,
				       rsn_ie, rsn_ie_len);
		return;
	}

	if (memcmp(wpa_s->anonce, key->key_nonce, WPA_NONCE_LEN) != 0) {
		WPA_PRINTF((MSG_WARNING, "WPA: ANonce from message 1 of 4-Way " \
			   "Handshake differs from 3 of 4-Way Handshake - drop" \
			   " packet (src=" MACSTR ")", MAC2STR(src_addr)))
		return;
	}

	keylen = intel16(key->key_length);
	switch (wpa_s->pairwise_cipher) {
	case WPA_CIPHER_CCMP:
		if (keylen != 16) {
			WPA_PRINTF((MSG_WARNING, "WPA: Invalid CCMP key length %d (src=" MACSTR ")",
				   keylen, MAC2STR(src_addr)))
			return;
		}
		break;
	case WPA_CIPHER_TKIP:
		if (keylen != 32) {
			WPA_PRINTF((MSG_WARNING, "WPA: Invalid TKIP key length %d (src=" MACSTR ")",
				   keylen, MAC2STR(src_addr)))
			return;
		}
		break;
	}

	rlen = sizeof(*ethhdr) + sizeof(*hdr) + sizeof(*reply)-32;
	//rbuf = malloc(rlen);
	//if (rbuf == NULL)
	//	return;

	memset(rbuf, 0, rlen);
	ethhdr = (struct l2_ethhdr *) rbuf;
	memcpy(ethhdr->h_dest, src_addr, ETH_ALEN);
	memcpy(ethhdr->h_source, wpa_s->nic->hwa, ETH_ALEN);
	ethhdr->h_proto = htons(ETH_P_EAPOL);

	hdr = (struct ieee802_1x_hdr *) (ethhdr + 1);
	hdr->version = wpa_s->conf->eapol_version;
	hdr->type = IEEE802_1X_TYPE_EAPOL_KEY;
	hdr->length = htons(sizeof(*reply)-32);

	reply = (struct wpa_eapol_key *) (hdr + 1);
	reply->type = wpa_s->proto == WPA_PROTO_RSN ?
		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
	reply->key_info = intel16(ver | WPA_KEY_INFO_KEY_TYPE |
				       WPA_KEY_INFO_MIC |
				       (key_info & WPA_KEY_INFO_SECURE));
	reply->key_length = 0;
	memcpy(reply->replay_counter, key->replay_counter,
	       WPA_REPLAY_COUNTER_LEN);

	reply->key_data_length = 0;

	memcpy(reply->key_nonce, wpa_s->snonce, WPA_NONCE_LEN);
	wpa_eapol_key_mic(wpa_s->ptk.mic_key, ver, (uint8 *) hdr,
			  rlen - sizeof(*ethhdr), reply->key_mic);

	WPA_PRINTF((MSG_DEBUG, "WPA: Sending EAPOL-Key 4/4"))
	WPA_HEXDUMP((MSG_MSGDUMP, "WPA: TX EAPOL-Key 4/4", rbuf, rlen))
	wln_send(rbuf, rlen);
	//eapol_sm_notify_tx_eapol_key(wpa_s->eapol);
	//free(rbuf);

	/* SNonce was successfully used in msg 3/4, so mark it to be renewed
	 * for the next 4-Way Handshake. If msg 3 is received again, the old
	 * SNonce will still be used to avoid changing PTK. */
	wpa_s->renew_snonce = 1;

	if (key_info & WPA_KEY_INFO_INSTALL) {
		WPA_PRINTF((MSG_DEBUG, "WPA: Installing PTK to the driver."))
		switch (wpa_s->pairwise_cipher) {
		case WPA_CIPHER_CCMP:
			alg = WPA_ALG_CCMP;
			keylen = 16;
			rsclen = 6;
			break;
		case WPA_CIPHER_TKIP:
			alg = WPA_ALG_TKIP;
			keylen = 32;
			rsclen = 6;
			break;
		case WPA_CIPHER_NONE:
			WPA_PRINTF((MSG_DEBUG, "WPA: Pairwise Cipher Suite: NONE - do not use pairwise keys"))
			return;
		default:
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported pairwise cipher %d", wpa_s->pairwise_cipher))
			return;
		}
		if (wpa_s->proto == WPA_PROTO_RSN) {
			key_rsc = null_rsc;
		} else {
			key_rsc = key->key_rsc;
			WPA_HEXDUMP((MSG_DEBUG, "WPA: RSC", key_rsc, rsclen))
		}

		if (wpa_driver_wln_set_key(alg, src_addr,
					   0, 1, key_rsc, rsclen,
					   (uint8 *) &wpa_s->ptk.tk1, keylen) < 0) {
			WPA_PRINTF((MSG_WARNING, "WPA: Failed to set PTK to the driver."))
		}
	}

	//if (key_info & WPA_KEY_INFO_SECURE) {
		/* MLME.SETPROTECTION.request(TA, Tx_Rx) */
		//eapol_sm_notify_portValid(wpa_s->eapol, TRUE);
	//}
	wpa_s->wpa_state = WPA_GROUP_HANDSHAKE;

	if (gtk) {
		WPA_HEXDUMP((MSG_DEBUG,
			    "WPA: received GTK in pairwise handshake",
			    gtk, gtk_len))

		keyidx = gtk[0] & 0x3;
		tx = !!(gtk[0] & 0x04);
		if (tx && wpa_s->pairwise_cipher != WPA_CIPHER_NONE) {
			/* Ignore Tx bit in GTK IE if a pairwise key is used.
			 * One AP seemed to set this bit (incorrectly, since Tx
			 * is only when doing Group Key only APs) and without
			 * this workaround, the data connection does not work
			 * because wpa_supplicant configured non-zero keyidx to
			 * be used for unicast. */
			WPA_PRINTF((MSG_INFO, "RSN: Tx bit set for GTK IE, but pairwise keys are used - ignore Tx bit"))
			tx = 0;
		}
		gtk += 2;
		gtk_len -= 2;
		WPA_HEXDUMP((MSG_DEBUG, "WPA: Group Key", gtk, gtk_len))

		switch (wpa_s->group_cipher) {
		case WPA_CIPHER_CCMP:
			if (gtk_len != 16) {
				WPA_PRINTF((MSG_WARNING, "WPA: Unsupported CCMP Group Cipher key length %d.",
					   gtk_len))
				return;
			}
			key_rsc_len = 6;
			alg = WPA_ALG_CCMP;
			break;
		case WPA_CIPHER_TKIP:
			if (gtk_len != 32) {
				WPA_PRINTF((MSG_WARNING, "WPA: Unsupported TKIP Group Cipher key length %d.",
					   gtk_len))
				return;
			}
			key_rsc_len = 6;
			alg = WPA_ALG_TKIP;
			break;
		case WPA_CIPHER_WEP104:
			if (gtk_len != 13) {
				WPA_PRINTF((MSG_WARNING, "WPA: Unsupported WEP104 Group Cipher key length %d.", gtk_len))
				return;
			}
			alg = WPA_ALG_WEP;
			break;
		case WPA_CIPHER_WEP40:
			if (gtk_len != 5) {
				WPA_PRINTF((MSG_WARNING, "WPA: Unsupported WEP40 Group Cipher key length %d.",
					   gtk_len))
				return;
			}
			alg = WPA_ALG_WEP;
			break;
		default:
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported Group Cipher %d", wpa_s->group_cipher))
			return;
		}

		WPA_PRINTF((MSG_DEBUG, "WPA: Installing GTK to the driver (keyidx=%d tx=%d).", keyidx, tx))
		WPA_HEXDUMP((MSG_DEBUG, "WPA: RSC", key->key_rsc, key_rsc_len))
		if (wpa_s->group_cipher == WPA_CIPHER_TKIP) {
			/* Swap Tx/Rx keys for Michael MIC */
			memcpy(tmpbuf, gtk + 16, 8);
			memcpy(gtk + 16, gtk + 24, 8);
			memcpy(gtk + 24, tmpbuf, 8);
		}
		if (wpa_s->pairwise_cipher == WPA_CIPHER_NONE) {
			if (wpa_driver_wln_set_key(alg,
						   "\xff\xff\xff\xff\xff\xff",
						   keyidx, 1, key->key_rsc,
						   key_rsc_len, gtk, gtk_len) <
			    0) {
				WPA_PRINTF((MSG_WARNING, "WPA: Failed to set GTK to the driver (Group only).")) }
		} else if (wpa_driver_wln_set_key(alg,
						  "\xff\xff\xff\xff\xff\xff",
						  keyidx, tx,
						  key->key_rsc, key_rsc_len,
						  gtk, gtk_len) < 0) {
			WPA_PRINTF((MSG_WARNING, "WPA: Failed to set GTK to the driver."))
		}

		wpa_msg(wpa_s, MSG_INFO, "WPA: Key negotiation completed with " MACSTR, MAC2STR(src_addr));
		eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
		wpa_supplicant_cancel_auth_timeout(wpa_s);
		wpa_s->wpa_state = WPA_COMPLETED;
#if 0
		if (key_info & WPA_KEY_INFO_SECURE) {
			/* MLME.SETPROTECTION.request(TA, Tx_Rx) */
			eapol_sm_notify_portValid(wpa_s->eapol, TRUE);
			if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK)
				eapol_sm_notify_eap_success(wpa_s->eapol,
							    TRUE);
			//rsn_preauth_candidate_process(wpa_s);
		}
#endif
	}
}


/*** BeginHeader wpa_supplicant_process_1_of_2 */
void wpa_supplicant_process_1_of_2(struct wpa_supplicant *wpa_s,
					  unsigned char *src_addr,
					  struct wpa_eapol_key *key,
					  int extra_len, int ver);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_process_1_of_2(struct wpa_supplicant *wpa_s,
					  unsigned char *src_addr,
					  struct wpa_eapol_key *key,
					  int extra_len, int ver)
{
	auto uint8 rbuf[14+sizeof(struct ieee802_1x_hdr)+sizeof(struct wpa_eapol_key)];
	auto int rlen;
	auto struct ieee802_1x_hdr *hdr;
	auto struct wpa_eapol_key *reply;
	auto struct l2_ethhdr *ethhdr;
	auto int key_info, keylen, keydatalen, maxkeylen, keyidx, key_rsc_len;
	auto int alg, tx;
	auto uint8 ek[32], tmpbuf[8], gtk[32];
	auto uint8 *gtk_ie;
	auto size_t gtk_ie_len;
	auto uint8 *pos, *end;

	key_rsc_len = 0;
	gtk_ie = NULL;
	gtk_ie_len = 0;

	wpa_s->wpa_state = WPA_GROUP_HANDSHAKE;
	WPA_PRINTF((MSG_DEBUG, "WPA: RX message 1 of Group Key Handshake from " MACSTR " (ver=%d)",
			MAC2STR(src_addr), ver))

	key_info = intel16(key->key_info);
	keydatalen = intel16(key->key_data_length);

	if (wpa_s->proto == WPA_PROTO_RSN) {
		pos = key->key_data;
		end = pos + keydatalen;
		while (pos + 1 < end) {
			if (pos + 2 + pos[1] > end) {
				WPA_PRINTF((MSG_DEBUG, "RSN: key data underflow (ie=%d len=%d)",
					   pos[0], pos[1]))
				break;
			}
			if (pos[0] == GENERIC_INFO_ELEM &&
			    pos + 1 + RSN_SELECTOR_LEN < end &&
			    pos[1] > RSN_SELECTOR_LEN + 2 &&
			    memcmp(pos + 2, RSN_KEY_DATA_GROUPKEY,
				   RSN_SELECTOR_LEN) == 0) {
				if (!(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
					WPA_PRINTF((MSG_WARNING, "WPA: GTK IE in unencrypted key data"))
					return;
				}
				gtk_ie = pos + 2 + RSN_SELECTOR_LEN;
				gtk_ie_len = pos[1] - RSN_SELECTOR_LEN;
				break;
			} else if (pos[0] == GENERIC_INFO_ELEM &&
				   pos[1] == 0)
				break;

			pos += 2 + pos[1];
		}

		if (gtk_ie == NULL) {
			WPA_PRINTF((MSG_INFO, "WPA: No GTK IE in Group Key message 1/2"))
			return;
		}
		maxkeylen = keylen = gtk_ie_len - 2;
	} else {
		keylen = intel16(key->key_length);
		maxkeylen = keydatalen;
		if (keydatalen > extra_len) {
			WPA_PRINTF((MSG_INFO, "WPA: Truncated EAPOL-Key packet: key_data_length=%d > extra_len=%d",
				   keydatalen, extra_len))
			return;
		}
		if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES)
			maxkeylen -= 8;
	}

	switch (wpa_s->group_cipher) {
	case WPA_CIPHER_CCMP:
		if (keylen != 16 || maxkeylen < 16) {
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported CCMP Group Cipher key length %d (%d).",
				   keylen, maxkeylen))
			return;
		}
		key_rsc_len = 6;
		alg = WPA_ALG_CCMP;
		break;
	case WPA_CIPHER_TKIP:
		if (keylen != 32 || maxkeylen < 32) {
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported TKIP Group Cipher key length %d (%d).",
				   keylen, maxkeylen))
			return;
		}
		key_rsc_len = 6;
		alg = WPA_ALG_TKIP;
		break;
	case WPA_CIPHER_WEP104:
		if (keylen != 13 || maxkeylen < 13) {
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported WEP104 Group Cipher key length %d (%d).",
				   keylen, maxkeylen))
			return;
		}
		alg = WPA_ALG_WEP;
		break;
	case WPA_CIPHER_WEP40:
		if (keylen != 5 || maxkeylen < 5) {
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported WEP40 Group Cipher key length %d (%d).",
				   keylen, maxkeylen))
			return;
		}
		alg = WPA_ALG_WEP;
		break;
	default:
		WPA_PRINTF((MSG_WARNING, "WPA: Unsupport Group Cipher %d",
			   wpa_s->group_cipher))
		return;
	}

	if (wpa_s->proto == WPA_PROTO_RSN) {
		WPA_HEXDUMP((MSG_DEBUG,
			    "WPA: received GTK in group key handshake",
			    gtk_ie, gtk_ie_len))
		keyidx = gtk_ie[0] & 0x3;
		tx = !!(gtk_ie[0] & 0x04);
		if (gtk_ie_len - 2 > sizeof(gtk)) {
			WPA_PRINTF((MSG_INFO, "WPA: Too long GTK in GTK IE (len=%d)", gtk_ie_len - 2))
			return;
		}
		memcpy(gtk, gtk_ie + 2, gtk_ie_len - 2);
	} else {
		keyidx = (key_info & WPA_KEY_INFO_KEY_INDEX_MASK) >>
			WPA_KEY_INFO_KEY_INDEX_SHIFT;
		if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
			memcpy(ek, key->key_iv, 16);
			memcpy(ek + 16, wpa_s->ptk.encr_key, 16);
			rc4_skip(ek, 32, 256, key->key_data, keydatalen);
			memcpy(gtk, key->key_data, keylen);
		}
	#if 1
		else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
			if (keydatalen % 8) {
				WPA_PRINTF((MSG_WARNING, "WPA: Unsupported AES-WRAP len %d", keydatalen))
				return;
			}
			if (aes_unwrap(wpa_s->ptk.encr_key, maxkeylen / 8,
				       key->key_data, gtk)) {
				WPA_PRINTF((MSG_WARNING, "WPA: AES unwrap failed - could not decrypt GTK"))
				return;
			}
		}
	#endif
		tx = !!(key_info & WPA_KEY_INFO_TXRX);
		if (tx && wpa_s->pairwise_cipher != WPA_CIPHER_NONE) {
			/* Ignore Tx bit in Group Key message if a pairwise key
			 * is used. Some APs seem to setting this bit
			 * (incorrectly, since Tx is only when doing Group Key
			 * only APs) and without this workaround, the data
			 * connection does not work because wpa_supplicant
			 * configured non-zero keyidx to be used for unicast.
			 */
			WPA_PRINTF((MSG_INFO, "WPA: Tx bit set for GTK, but pairwise keys are used - ignore Tx bit"))
			tx = 0;
		}
	}
	WPA_HEXDUMP((MSG_DEBUG, "WPA: Group Key", gtk, keylen))
	WPA_PRINTF((MSG_DEBUG, "WPA: Installing GTK to the driver (keyidx=%d tx=%d).", keyidx, tx))
	WPA_HEXDUMP((MSG_DEBUG, "WPA: RSC", key->key_rsc, key_rsc_len))
	if (wpa_s->group_cipher == WPA_CIPHER_TKIP) {
		/* Swap Tx/Rx keys for Michael MIC */
		memcpy(tmpbuf, gtk + 16, 8);
		memcpy(gtk + 16, gtk + 24, 8);
		memcpy(gtk + 24, tmpbuf, 8);
	}
	if (wpa_s->pairwise_cipher == WPA_CIPHER_NONE) {
		if (wpa_driver_wln_set_key(alg,
					   "\xff\xff\xff\xff\xff\xff",
					   keyidx, 1, key->key_rsc,
					   key_rsc_len, gtk, keylen) < 0) {
			WPA_PRINTF((MSG_WARNING, "WPA: Failed to set GTK to the driver (Group only).")) }
	} else if (wpa_driver_wln_set_key(alg,
					  "\xff\xff\xff\xff\xff\xff",
					  keyidx, tx,
					  key->key_rsc, key_rsc_len,
					  gtk, keylen) < 0) {
		WPA_PRINTF((MSG_WARNING, "WPA: Failed to set GTK to the driver."))
	}

	rlen = sizeof(*ethhdr) + sizeof(*hdr) + sizeof(*reply)-32;
	//rbuf = malloc(rlen);
	//if (rbuf == NULL)
	//	return;

	memset(rbuf, 0, rlen);
	ethhdr = (struct l2_ethhdr *) rbuf;
	memcpy(ethhdr->h_dest, src_addr, ETH_ALEN);
	memcpy(ethhdr->h_source, wpa_s->nic->hwa, ETH_ALEN);
	ethhdr->h_proto = htons(ETH_P_EAPOL);

	hdr = (struct ieee802_1x_hdr *) (ethhdr + 1);
	hdr->version = wpa_s->conf->eapol_version;
	hdr->type = IEEE802_1X_TYPE_EAPOL_KEY;
	hdr->length = htons(sizeof(*reply)-32);

	reply = (struct wpa_eapol_key *) (hdr + 1);
	reply->type = wpa_s->proto == WPA_PROTO_RSN ?
		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
	reply->key_info =
		intel16(ver | WPA_KEY_INFO_MIC | WPA_KEY_INFO_SECURE |
			     (key_info & WPA_KEY_INFO_KEY_INDEX_MASK));
	reply->key_length = 0;
	memcpy(reply->replay_counter, key->replay_counter,
		WPA_REPLAY_COUNTER_LEN);

	reply->key_data_length = intel16(0);

	wpa_eapol_key_mic(wpa_s->ptk.mic_key, ver, (uint8 *) hdr,
			  rlen - sizeof(*ethhdr), reply->key_mic);

	WPA_PRINTF((MSG_DEBUG, "WPA: Sending EAPOL-Key 2/2"))
	WPA_HEXDUMP((MSG_MSGDUMP, "WPA: TX EAPOL-Key 2/2", rbuf, rlen))
	wln_send(rbuf, rlen);
	//eapol_sm_notify_tx_eapol_key(wpa_s->eapol);
	//free(rbuf);

	wpa_msg(wpa_s, MSG_INFO, "WPA: Key negotiation completed with " MACSTR,
		MAC2STR(src_addr));
	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
	wpa_supplicant_cancel_auth_timeout(wpa_s);
	wpa_s->wpa_state = WPA_COMPLETED;
#if 0
	if (key_info & WPA_KEY_INFO_SECURE) {
		/* MLME.SETPROTECTION.request(TA, Tx_Rx) */
		eapol_sm_notify_portValid(wpa_s->eapol, TRUE);
		if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK)
			eapol_sm_notify_eap_success(wpa_s->eapol, TRUE);
		//rsn_preauth_candidate_process(wpa_s);
	}
#endif
}


/*** BeginHeader wpa_supplicant_verify_eapol_key_mic */
int wpa_supplicant_verify_eapol_key_mic(struct wpa_supplicant *wpa_s,
					       struct wpa_eapol_key *key,
					       int ver, uint8 *buf, size_t len);
/*** EndHeader */
_wifig_nodebug
__static int wpa_supplicant_verify_eapol_key_mic(struct wpa_supplicant *wpa_s,
					       struct wpa_eapol_key *key,
					       int ver, uint8 *buf, size_t len)
{
	auto uint8 mic[16];
	auto int ok;

	ok = 0;

	memcpy(mic, key->key_mic, 16);
	if (wpa_s->tptk_set) {
		memset(key->key_mic, 0, 16);
		wpa_eapol_key_mic(wpa_s->tptk.mic_key, ver, buf, len,
				  key->key_mic);
		if (memcmp(mic, key->key_mic, 16) != 0) {
			WPA_PRINTF((MSG_WARNING, "WPA: Invalid EAPOL-Key MIC when using TPTK - ignoring TPTK"))
		} else {
			ok = 1;
			wpa_s->tptk_set = 0;
			wpa_s->ptk_set = 1;
			memcpy(&wpa_s->ptk, &wpa_s->tptk, sizeof(wpa_s->ptk));
		}
	}

	if (!ok && wpa_s->ptk_set) {
		memset(key->key_mic, 0, 16);
		wpa_eapol_key_mic(wpa_s->ptk.mic_key, ver, buf, len,
				  key->key_mic);
		if (memcmp(mic, key->key_mic, 16) != 0) {
			WPA_PRINTF((MSG_WARNING, "WPA: Invalid EAPOL-Key MIC - dropping packet"))
			return -1;
		}
		ok = 1;
	}

	if (!ok) {
		WPA_PRINTF((MSG_WARNING, "WPA: Could not verify EAPOL-Key MIC - dropping packet"))
		return -1;
	}

	memcpy(wpa_s->rx_replay_counter, key->replay_counter,
	       WPA_REPLAY_COUNTER_LEN);
	wpa_s->rx_replay_counter_set = 1;
	return 0;
}


/*** BeginHeader wpa_supplicant_decrypt_key_data */
int wpa_supplicant_decrypt_key_data(struct wpa_supplicant *wpa_s,
					   struct wpa_eapol_key *key, int ver);
/*** EndHeader */
/* Decrypt RSN EAPOL-Key key data (RC4 or AES-WRAP) */
_wifig_nodebug
__static int wpa_supplicant_decrypt_key_data(struct wpa_supplicant *wpa_s,
					   struct wpa_eapol_key *key, int ver)
{
	auto uint8	 buf[512];
	auto uint8 ek[32];
	auto int keydatalen;

	keydatalen = intel16(key->key_data_length);

	WPA_HEXDUMP((MSG_DEBUG, "RSN: encrypted key data",
		    key->key_data, keydatalen))
	if (!wpa_s->ptk_set) {
		WPA_PRINTF((MSG_WARNING, "WPA: PTK not available, cannot decrypt EAPOL-Key key data."))
		return -1;
	}

	/* Decrypt key data here so that this operation does not need
	 * to be implemented separately for each message type. */
	if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
		memcpy(ek, key->key_iv, 16);
		memcpy(ek + 16, wpa_s->ptk.encr_key, 16);
		rc4_skip(ek, 32, 256, key->key_data, keydatalen);
	} else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
#ifdef WIFI_AES_ENABLED
		if (keydatalen % 8) {
			WPA_PRINTF((MSG_WARNING, "WPA: Unsupported AES-WRAP len %d", keydatalen))
			return -1;
		}
		keydatalen -= 8; /* AES-WRAP adds 8 bytes */
		if (aes_unwrap(wpa_s->ptk.encr_key, keydatalen / 8,
			       key->key_data, buf)) {
			//free(buf);
			WPA_PRINTF((MSG_WARNING, "WPA: AES unwrap failed - could not decrypt EAPOL-Key key data"))
			return -1;
		}
		memcpy(key->key_data, buf, keydatalen);
		key->key_data_length = intel16(keydatalen);
#else
		WPA_PRINTF((MSG_ERROR, "WPA: AES unsupported"))
		return -1;
#endif
	}
	WPA_HEXDUMP((MSG_DEBUG, "WPA: decrypted EAPOL-Key key data",
		    key->key_data, keydatalen))
	return 0;
}


/*** BeginHeader wpa_sm_rx_eapol */
void wpa_sm_rx_eapol(struct wpa_supplicant *wpa_s,
			    unsigned char *src_addr, unsigned char *buf,
			    size_t len);
/*** EndHeader */
_wifig_nodebug
__static void wpa_sm_rx_eapol(struct wpa_supplicant *wpa_s,
			    unsigned char *src_addr, unsigned char *buf,
			    size_t len)
{
	int plen, data_len, i;
	struct ieee802_1x_hdr *hdr;
	struct wpa_eapol_key *key;
	int key_info, extra_len, ver;

	hdr = (struct ieee802_1x_hdr *) buf;
	key = (struct wpa_eapol_key *) (hdr + 1);
	if (len < sizeof(*hdr) + sizeof(*key) - sizeof(key->key_data)) {
		WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL frame too short, len %u, expecting at least %u",
			   len, sizeof(*hdr) + sizeof(*key) - sizeof(key->key_data)))
		return;
	}
	plen = ntohs(hdr->length);
	data_len = plen + sizeof(*hdr);
	WPA_PRINTF((MSG_DEBUG, "IEEE 802.1X RX: version=%d type=%d length=%d",
		   hdr->version, hdr->type, plen))

	if (hdr->version < EAPOL_VERSION) {
		/* TODO: backwards compatibility */
	}
	if (hdr->type != IEEE802_1X_TYPE_EAPOL_KEY) {
		WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL frame (type %u) discarded, not a Key frame", hdr->type))
		return;
	}
	if (plen > len - sizeof(*hdr) || plen < sizeof(*key) - sizeof(key->key_data)) {
		WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL frame payload size %u invalid (frame size %u)", plen, len))
		return;
	}

	WPA_PRINTF((MSG_DEBUG, "  EAPOL-Key type=%d", key->type))
	if (key->type != EAPOL_KEY_TYPE_WPA && key->type != EAPOL_KEY_TYPE_RSN)
	{
		WPA_PRINTF((MSG_DEBUG, "WPA: EAPOL-Key type (%d) unknown, discarded", key->type))
		return;
	}

	WPA_HEXDUMP((MSG_MSGDUMP, "WPA: RX EAPOL-Key", buf, len))
	if (data_len < len) {
		WPA_PRINTF((MSG_DEBUG, "WPA: ignoring %d bytes after the IEEE 802.1X data", len - data_len))
	}
	key_info = intel16(key->key_info);
	ver = key_info & WPA_KEY_INFO_TYPE_MASK;
	if (ver != WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 &&
	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		WPA_PRINTF((MSG_INFO, "WPA: Unsupported EAPOL-Key descriptor version %d.", ver))
		return;
	}

	if (wpa_s->pairwise_cipher == WPA_CIPHER_CCMP &&
	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
		WPA_PRINTF((MSG_INFO, "WPA: CCMP is used, but EAPOL-Key descriptor version (%d) is not 2.", ver))
		if (wpa_s->group_cipher != WPA_CIPHER_CCMP &&
		    !(key_info & WPA_KEY_INFO_KEY_TYPE)) {
			/* Earlier versions of IEEE 802.11i did not explicitly
			 * require version 2 descriptor for all EAPOL-Key
			 * packets, so allow group keys to use version 1 if
			 * CCMP is not used for them. */
			WPA_PRINTF((MSG_INFO, "WPA: Backwards compatibility: allow invalid version for non-CCMP group keys"))
		} else
			return;
	}

	if (wpa_s->rx_replay_counter_set &&
	    memcmp(key->replay_counter, wpa_s->rx_replay_counter,
		   WPA_REPLAY_COUNTER_LEN) <= 0) {
		WPA_PRINTF((MSG_WARNING, "WPA: EAPOL-Key Replay Counter did not increase - dropping packet"))
		return;
	}

	if (!(key_info & WPA_KEY_INFO_ACK)) {
		WPA_PRINTF((MSG_INFO, "WPA: No Ack bit in key_info"))
		return;
	}

	if (key_info & WPA_KEY_INFO_REQUEST) {
		WPA_PRINTF((MSG_INFO, "WPA: EAPOL-Key with Request bit - dropped"))
		return;
	}

	if ((key_info & WPA_KEY_INFO_MIC) &&
	    wpa_supplicant_verify_eapol_key_mic(wpa_s, key, ver, buf,
						data_len))
		return;

	/* Check that error bit is not set per UNH-IOL conformance testing */
	if (key_info & WPA_KEY_INFO_ERROR) {
		WPA_PRINTF((MSG_INFO, "WPA: EAPOL-Key with Error bit - dropped"))
		return;
	}

	extra_len = data_len - sizeof(*hdr) - (sizeof(*key) - sizeof(key->key_data));

	if (intel16(key->key_data_length) > extra_len) {
		wpa_msg(wpa_s, MSG_INFO, "WPA: Invalid EAPOL-Key frame - key_data overflow (%d > %d)",
			intel16(key->key_data_length), extra_len);
		return;
	}

	if (wpa_s->proto == WPA_PROTO_RSN &&
	    (key_info & WPA_KEY_INFO_ENCR_KEY_DATA) &&
	    wpa_supplicant_decrypt_key_data(wpa_s, key, ver))
		return;

	if (key_info & WPA_KEY_INFO_KEY_TYPE) {
		if (wpa_s->proto == WPA_PROTO_WPA &&
		    (key_info & WPA_KEY_INFO_KEY_INDEX_MASK)) {
			WPA_PRINTF((MSG_WARNING, "WPA: Ignored EAPOL-Key (Pairwise) with non-zero key index"))
			return;
		}
		if (key_info & WPA_KEY_INFO_MIC) {
			/* Below "fix" breaks compatibility with NetGear AP(s), optional */
         #ifdef WPA_NONZERO_IV_COMPLIANT
         /* Added to fix Vantive #20131: key_iv should be 0 */
         if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES)
         {
             for (i = 0; i < 16; i++){
                 if (key->key_iv[i] != 0)
                     return; }
         }
         #endif

			/* 3/4 4-Way Handshake */
			wpa_supplicant_process_3_of_4(wpa_s, src_addr, key,
						      extra_len, ver);
		} else {
		    /* Added to fix Vantive #20132: key_rsc should be 0 */
		    for (i = 0; i < 8; i++){
		            if (key->key_rsc[i] != 0)
                        return;}

		    /* Added to fix Vantive #20131: key_iv should be 0 */
		    for (i = 0; i < 16; i++){
		            if (key->key_iv[i] != 0)
                        return;}

			/* 1/4 4-Way Handshake */
			wpa_supplicant_process_1_of_4(wpa_s, src_addr, key,
						      ver);
		}
	} else {
		if (key_info & WPA_KEY_INFO_MIC) {
		    /* Added to fix Vantive #20131: key_iv should be 0 */
	        if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES)
	        {
		        for (i = 0; i < 16; i++){
		            if (key->key_iv[i] != 0)
                        return;}
		    }

			/* 1/2 Group Key Handshake */
			wpa_supplicant_process_1_of_2(wpa_s, src_addr, key,
						      extra_len, ver);
		} else {
			WPA_PRINTF((MSG_WARNING, "WPA: EAPOL-Key (Group) without Mic bit - dropped"))
		}
	}
}


/*** BeginHeader wpa_supplicant_rx_eapol */
void wpa_supplicant_rx_eapol(unsigned char *src_addr,
			     unsigned char *buf, size_t len);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_rx_eapol(unsigned char *src_addr,
			     unsigned char *buf, size_t len)
{

	WPA_PRINTF((MSG_DEBUG, "RX EAPOL from " MACSTR, MAC2STR(src_addr)))
	WPA_HEXDUMP((MSG_MSGDUMP, "RX EAPOL", buf, len))

	if (wpa_s.eapol_received == 0) {
		/* Timeout for completing IEEE 802.1X and WPA authentication */
		wpa_supplicant_req_auth_timeout(
			&wpa_s, wpa_s.key_mgmt == WPA_KEY_MGMT_IEEE8021X ?
			20000 : 10000);
	}
	wpa_s.eapol_received++;

	if (wpa_s.countermeasures) {
		WPA_PRINTF((MSG_INFO, "WPA: Countermeasures - dropped EAPOL packet"))
		return;
	}

	/* Source address of the incoming EAPOL frame could be compared to the
	 * current BSSID. However, it is possible that a centralized
	 * Authenticator could be using another MAC address than the BSSID of
	 * an AP, so just allow any address to be used for now. The replies are
	 * still sent to the current BSSID (if available), though. */

	//memcpy(wpa_s->last_eapol_src, src_addr, ETH_ALEN);
	//eapol_sm_rx_eapol(wpa_s->eapol, src_addr, buf, len);
	wpa_sm_rx_eapol(&wpa_s, src_addr, buf, len);
}

