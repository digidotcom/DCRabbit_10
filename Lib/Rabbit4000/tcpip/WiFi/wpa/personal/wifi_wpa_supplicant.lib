//
// Embedded 802.11b/g wireless network interface
//

/*** BeginHeader wpa_s */

// This stuff used to be in l2_packet.h.........................
#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"

#ifndef ETH_P_EAPOL
#define ETH_P_EAPOL 0x888e
#endif

#ifndef ETH_P_RSN_PREAUTH
#define ETH_P_RSN_PREAUTH 0x88c7
#endif

struct l2_ethhdr {
	uint8 h_dest[ETH_ALEN];
	uint8 h_source[ETH_ALEN];
	uint16 h_proto;
};
//................................................................

#define PMKID_LEN 16

#if 0
struct rsn_pmksa_cache {
	struct rsn_pmksa_cache *next;
	uint8 pmkid[PMKID_LEN];
	uint8 pmk[PMK_LEN];
	size_t pmk_len;
	long expiration;
	int akmp; /* WPA_KEY_MGMT_* */
	uint8 aa[ETH_ALEN];
};

struct rsn_pmksa_candidate {
	struct rsn_pmksa_candidate *next;
	uint8 bssid[ETH_ALEN];
};
#endif

struct wpa_ptk {
	uint8 mic_key[16]; /* EAPOL-Key MIC Key (MK) */
	uint8 encr_key[16]; /* EAPOL-Key Encryption Key (EK) */
	uint8 tk1[16]; /* Temporal Key 1 (TK1) */
	union {
		uint8 tk2[16]; /* Temporal Key 2 (TK2) */
		struct {
			uint8 tx_mic_key[8];
			uint8 rx_mic_key[8];
		} auth;
	} u;
	int installed; /* 1 if key has already been installed to driver */
};
#define SIZE_OF_WPA_PTK (offsetof(struct wpa_ptk, installed))

struct wpa_gtk {
	char gtk[32];
	size_t gtk_len;
};

#ifdef CONFIG_IEEE80211W
struct wpa_igtk {
	u8 igtk[WPA_IGTK_MAX_LEN];
	size_t igtk_len;
};
#endif /* CONFIG_IEEE80211W */
 


struct wpa_supplicant {
	_WiFiGConfig * nic;			// This used to be l2 (level 2 stuff) - use Rabbit 'nic'.


	uint8 pmk[PMK_LEN];
	size_t pmk_len;
	uint8 snonce[WPA_NONCE_LEN];
	uint8 anonce[WPA_NONCE_LEN]; /* ANonce from the last 1/4 msg */
	struct wpa_ptk ptk, tptk;
	int ptk_set, tptk_set;
	int renew_snonce;
	//char *confname;
	struct wpa_config *conf;
	uint8 request_counter[WPA_REPLAY_COUNTER_LEN];
	int countermeasures;
	long last_michael_mic_error;
	uint8 rx_replay_counter[WPA_REPLAY_COUNTER_LEN];
	int rx_replay_counter_set;
	struct wpa_gtk gtk;
#ifdef CONFIG_IEEE80211W
	struct wpa_igtk igtk;
#endif /* CONFIG_IEEE80211W */
	uint8 bssid[ETH_ALEN];
	int reassociate; /* reassociation requested */
	struct wpa_ssid *current_ssid;
#define WPA_MAX_IE_LEN	80
	size_t assoc_wpa_ie_len;
	uint8 assoc_wpa_ie[WPA_MAX_IE_LEN];
	uint8 ap_wpa_ie[WPA_MAX_IE_LEN];
	size_t ap_wpa_ie_len;
	uint8 ap_rsn_ie[WPA_MAX_IE_LEN];
	size_t ap_rsn_ie_len;

	/* Selected configuration (based on Beacon/ProbeResp WPA IE) */
	int proto;
	int pairwise_cipher;
	int group_cipher;
	int key_mgmt;

	//void *events_priv; /* private data used by wpa_driver_events */

	struct wpa_ssid *prev_scan_ssid; /* previously scanned SSID;
					  * NULL = not yet initialized (start
					  * with broadcast SSID)
					  * BROADCAST_SSID_SCAN = broadcast
					  * SSID was used in the previous scan
					  */
#define BROADCAST_SSID_SCAN ((struct wpa_ssid *) 1)

	//SJH - no need to support multiple drivers, so changed to do direct
	//function calls instead of via pointers.
	//struct wpa_driver_ops *driver;

	struct eapol_sm *eapol;

	enum {
		WPA_DISCONNECTED, WPA_SCANNING, WPA_ASSOCIATING,
		WPA_ASSOCIATED, WPA_4WAY_HANDSHAKE, WPA_GROUP_HANDSHAKE,
		WPA_COMPLETED
	} wpa_state;

#if 0
	struct rsn_pmksa_cache *pmksa; /* PMKSA cache */
	int pmksa_count; /* number of entries in PMKSA cache */
	struct rsn_pmksa_cache *cur_pmksa; /* current PMKSA entry */
	struct rsn_pmksa_candidate *pmksa_candidates;

	struct l2_packet_data *l2_preauth;
	uint8 preauth_bssid[ETH_ALEN]; /* current RSN pre-auth peer or 00:00:00:00:00:00 if no pre-auth is in progress */
	struct eapol_sm *preauth_eapol;
#endif

	int eapol_received; /* number of EAPOL packets received after the previous association event */


	//unsigned char last_eapol_src[ETH_ALEN];

};

extern struct wpa_supplicant wpa_s;

struct wpa_ie_data {
	int proto;
	int pairwise_cipher;
	int group_cipher;
	int key_mgmt;
	int capabilities;
};

typedef
enum wpa_event_type {
	//SJH - v28282: the enum values are forced to be the same as the WLN_* values
	// because there is a direct call from to base driver to the WPA event
	// handler with no translation.
	EVENT_ASSOC = WLN_EVT_ASSOC,
	EVENT_DISASSOC = WLN_EVT_DISASSOC,
	EVENT_MICHAEL_MIC_FAILURE = WLN_EVT_MIC_FAIL,
	EVENT_SCAN_RESULTS = WLN_EVT_SCAN_RESULTS,
	EVENT_INTERFACE_STATUS = WLN_EVT_LINKUP,
	EVENT_ASSOCINFO = 100,
	EVENT_PMKID_CANDIDATE,
	EVENT_STKSTART
}  wpa_event_type;	// From "wpa_supplicant.h":136

union wpa_event_data {
	struct {
		/* Optional request information data: IEs included in AssocReq
		 * and AssocResp. If these are not returned by the driver,
		 * WPA Supplicant will generate the WPA IE. */
		uint8 *req_ies, *resp_ies;
		size_t req_ies_len, resp_ies_len;
	} assoc_info;
	struct {
		int unicast;
	} michael_mic_failure;
	struct {
		char ifname[20];
		enum {
			EVENT_INTERFACE_ADDED, EVENT_INTERFACE_REMOVED
		} ievent;
	} interface_status;
};



/*** EndHeader */

struct wpa_supplicant wpa_s;

/*
 * WPA Supplicant
 * Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Alternatively, this software may be distributed under the terms of BSD
 * license.
 *
 * See README and COPYING for more details.
 */


/*** BeginHeader wpa_printf, wpa_msg, wpa_debug_level */
#ifdef WPA_VERBOSE
	#define WPA_PRINTF(x) wpa_printf x;
#else
	#define WPA_PRINTF(x)
#endif

#ifdef __STDIO_LIB_VERSION
 	#define _WPA_STDIO_PTRQUAL __far
#else
 	#define _WPA_STDIO_PTRQUAL
#endif
#ifndef _MSG_ENUM_DEFINED
	enum { MSG_MSGDUMP, MSG_DEBUG, MSG_INFO, MSG_WARNING, MSG_ERROR, MSG_NONE };
	#define _MSG_ENUM_DEFINED
#endif
void wpa_printf(int level, char _WPA_STDIO_PTRQUAL *fmt, ...);
void wpa_msg(struct wpa_supplicant *wpa_s, int level, char _WPA_STDIO_PTRQUAL *fmt, ...);
extern int wpa_debug_level;
/*** EndHeader */

int wpa_debug_level;


__nodebug void __qe2wt(int c, char _WPA_STDIO_PTRQUAL *__printfbuf, int *__printfcnt, void * instparm)
{
	if (*__printfcnt < 160)
		__printfbuf[(*__printfcnt)++] = c;
}

void wpa_printf(int level, char _WPA_STDIO_PTRQUAL *fmt, ...)
{
#ifdef WPA_VERBOSE
	auto char msg[160];
	auto int len;
	auto char * args;
	#GLOBAL_INIT { wpa_debug_level = MSG_NONE; }

	if (level >= wpa_debug_level) {
	   args = (char*)&fmt + sizeof(fmt);
	   len = 0;
	   doprnt(__qe2wt, fmt, args, NULL, msg, &len);
	   printf("[%u] %*.*s\n", level, len, len, msg);
	}
#endif
}



void wpa_msg(struct wpa_supplicant *wpa_s, int level, char _WPA_STDIO_PTRQUAL *fmt, ...)
{
//DEVIDEA - this should send message back to app.
#ifdef WPA_VERBOSE
	auto char msg[160];
	auto int len;
	auto char * args;

   args = (char*)&fmt + sizeof(fmt);
   len = 0;
   doprnt(__qe2wt, fmt, args, NULL, msg, &len);
   printf("[%u] %*.*s\n", level, len, len, msg);
#endif
}


/*** BeginHeader wpa_hexdump */
#ifdef WPA_VERBOSE
	#ifndef WPA_NO_HEXDUMP
		#define WPA_HEXDUMP(x) wpa_hexdump x;
	#else
		#define WPA_HEXDUMP(x)
	#endif
#else
	#define WPA_HEXDUMP(x)
#endif
void wpa_hexdump(int level, const char *title, const uint8 *buf, size_t len);
/*** EndHeader */
__nodebug void wpa_hexdump(int level, const char *title, const uint8 *buf, size_t len)
{
#ifdef WPA_VERBOSE
	if (level < wpa_debug_level)
		return;
	printf("=== %s ===\n", title);
	mem_dump(buf, len);	// found in IP.LIB
#endif
}


/*** BeginHeader wpa_hexdump_ascii */
#ifdef WPA_VERBOSE
	#define WPA_HEXDUMP_ASCII(x) wpa_hexdump_ascii x;
#else
	#define WPA_HEXDUMP_ASCII(x)
#endif
void wpa_hexdump_ascii(int level, const char *title, const uint8 *buf, size_t len);
/*** EndHeader */
__nodebug void wpa_hexdump_ascii(int level, const char *title, const uint8 *buf, size_t len)
{
#ifdef WPA_VERBOSE
	if (level < wpa_debug_level)
		return;
	printf("=== %s ===\n", title);
	mem_dump(buf, len);	// found in IP.LIB
#endif
}




/*** BeginHeader wpa_eapol_set_wep_key */
int wpa_eapol_set_wep_key(struct wpa_supplicant *wpa_s, int unicast, int keyidx,
				 uint8 *key, size_t keylen);
/*** EndHeader */
/**
 * wpa_eapol_set_wep_key - set WEP key for the driver
 * @ctx: pointer to wpa_supplicant data
 * @unicast: 1 = individual unicast key, 0 = broadcast key
 * @keyidx: WEP key index (0..3)
 * @key: pointer to key data
 * @keylen: key length in bytes
 *
 * Returns 0 on success or < 0 on error.
 */
_wifig_nodebug
__static int wpa_eapol_set_wep_key(struct wpa_supplicant *wpa_s, int unicast, int keyidx,
				 uint8 *key, size_t keylen)
{
	if (!wpa_s)
		return -1;


	return wpa_driver_wln_set_key(WPA_ALG_WEP,
				      unicast ? wpa_s->bssid :
				      (uint8 *) "\xff\xff\xff\xff\xff\xff",
				      keyidx, unicast, "", 0, key, keylen);
}


/*** BeginHeader wpa_supplicant_notify_eapol_done */
void wpa_supplicant_notify_eapol_done(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_notify_eapol_done(struct wpa_supplicant *wpa_s)
{
	wpa_msg(wpa_s, MSG_DEBUG, "WPA: EAPOL processing complete");
	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
	wpa_supplicant_cancel_auth_timeout(wpa_s);
}


/*** BeginHeader wpa_ssid_txt */
const char * wpa_ssid_txt(uint8 *ssid, size_t ssid_len);
/*** EndHeader */
_wifig_nodebug
const char * wpa_ssid_txt(uint8 *ssid, size_t ssid_len)
{
	static char ssid_txt[MAX_SSID_LEN + 1];
   wifi_ssid_to_str (ssid_txt, ssid, ssid_len);
	return ssid_txt;
}


/*** BeginHeader wpa_supplicant_req_scan */
void wpa_supplicant_req_scan(struct wpa_supplicant *wpa_s, uint32 msec);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_req_scan(struct wpa_supplicant *wpa_s, uint32 msec)
{
	wpa_msg(wpa_s, MSG_DEBUG, "Setting scan request: %lu msec", msec);
	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
	eloop_register_timeout(msec, wpa_supplicant_scan, wpa_s, NULL);
}


/*** BeginHeader wpa_supplicant_cancel_scan */
void wpa_supplicant_cancel_scan(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_cancel_scan(struct wpa_supplicant *wpa_s)
{
	wpa_msg(wpa_s, MSG_DEBUG, "Cancelling scan request");
	eloop_cancel_timeout(wpa_supplicant_scan, wpa_s, NULL);
}


/*** BeginHeader wpa_supplicant_timeout */
void wpa_supplicant_timeout(void __far *eloop_ctx, void __far *timeout_ctx);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_timeout(void __far *eloop_ctx, void __far *timeout_ctx)
{
	struct wpa_supplicant *wpa_s;
	wpa_s = (struct wpa_supplicant *)(word)eloop_ctx;	// known to be near pointer
	wpa_msg(wpa_s, MSG_INFO, "Authentication with " MACSTR " timed out.",
		MAC2STR(wpa_s->bssid));
	wpa_s->reassociate = 1;

	// Disconnect if not associated or authentication required
	if (wpa_s->wpa_state == WPA_ASSOCIATING ||
		wpa_s->key_mgmt == WPA_KEY_MGMT_PSK ||
		wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X)
			wpa_supplicant_deauthenticate(wpa_s, REASON_IEEE_802_1X_AUTH_FAILED);

	wpa_supplicant_req_scan(wpa_s, 0);
}


/*** BeginHeader wpa_supplicant_req_auth_timeout */
void wpa_supplicant_req_auth_timeout(struct wpa_supplicant *wpa_s,
				     uint32 msec);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_req_auth_timeout(struct wpa_supplicant *wpa_s,
				     uint32 msec)
{
	wpa_msg(wpa_s, MSG_DEBUG, "Setting authentication timeout: %lu msec", msec);
	eloop_cancel_timeout(wpa_supplicant_timeout, wpa_s, NULL);
	eloop_register_timeout(msec, wpa_supplicant_timeout, wpa_s, NULL);
}


/*** BeginHeader wpa_supplicant_cancel_auth_timeout */
void wpa_supplicant_cancel_auth_timeout(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_cancel_auth_timeout(struct wpa_supplicant *wpa_s)
{
	wpa_msg(wpa_s, MSG_DEBUG, "Cancelling authentication timeout");
	eloop_cancel_timeout(wpa_supplicant_timeout, wpa_s, NULL);
}


/*** BeginHeader wpa_supplicant_initiate_eapol */
void wpa_supplicant_initiate_eapol(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_initiate_eapol(struct wpa_supplicant *wpa_s)
{
#if 0
	auto struct eapol_config eapol_conf;
	auto struct wpa_ssid *ssid;
	ssid = wpa_s->current_ssid;

	if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK) {
		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
		eapol_sm_notify_eap_fail(wpa_s->eapol, FALSE);
	}
	if (wpa_s->key_mgmt == WPA_KEY_MGMT_NONE)
		eapol_sm_notify_portControl(wpa_s->eapol, ForceAuthorized);
	else
		eapol_sm_notify_portControl(wpa_s->eapol, Auto);
	memset(&eapol_conf, 0, sizeof(eapol_conf));
	if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		eapol_conf.accept_802_1x_keys = 1;
		eapol_conf.required_keys = 0;
		if (ssid->eapol_flags & EAPOL_FLAG_REQUIRE_KEY_UNICAST) {
			eapol_conf.required_keys |= EAPOL_REQUIRE_KEY_UNICAST;
		}
		if (ssid->eapol_flags & EAPOL_FLAG_REQUIRE_KEY_BROADCAST) {
			eapol_conf.required_keys |=
				EAPOL_REQUIRE_KEY_BROADCAST;
		}
	}
	eapol_sm_notify_config(wpa_s->eapol, ssid, &eapol_conf);
#endif
}


/*** BeginHeader wpa_supplicant_set_non_wpa_policy */
void wpa_supplicant_set_non_wpa_policy(struct wpa_supplicant *wpa_s,
					      struct wpa_ssid *ssid);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_set_non_wpa_policy(struct wpa_supplicant *wpa_s,
					      struct wpa_ssid *ssid)
{
	auto int i;

	if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA)
		wpa_s->key_mgmt = WPA_KEY_MGMT_IEEE8021X_NO_WPA;
	else
		wpa_s->key_mgmt = WPA_KEY_MGMT_NONE;
	//free(wpa_s->ap_wpa_ie);
	//wpa_s->ap_wpa_ie = NULL;
	wpa_s->ap_wpa_ie_len = 0;
	//free(wpa_s->ap_rsn_ie);
	//wpa_s->ap_rsn_ie = NULL;
	wpa_s->ap_rsn_ie_len = 0;
	//free(wpa_s->assoc_wpa_ie);
	//wpa_s->assoc_wpa_ie = NULL;
	wpa_s->assoc_wpa_ie_len = 0;
	wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
	wpa_s->group_cipher = WPA_CIPHER_NONE;

	for (i = 0; i < NUM_WEP_KEYS; i++) {
		if (ssid->wep_key_len[i] > 5) {
			wpa_s->pairwise_cipher = WPA_CIPHER_WEP104;
			wpa_s->group_cipher = WPA_CIPHER_WEP104;
			break;
		} else if (ssid->wep_key_len[i] > 0) {
			wpa_s->pairwise_cipher = WPA_CIPHER_WEP40;
			wpa_s->group_cipher = WPA_CIPHER_WEP40;
			break;
		}
	}

	//wpa_s->cur_pmksa = FALSE;
}


/*** BeginHeader wpa_supplicant_select_config */
int wpa_supplicant_select_config(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static int wpa_supplicant_select_config(struct wpa_supplicant *wpa_s)
{
	auto struct wpa_ssid *ssid;

	if (wpa_s->conf->ap_scan)
		return 0;

	ssid = wpa_supplicant_get_ssid(wpa_s);
	if (ssid == NULL) {
		WPA_PRINTF((MSG_INFO, "No network configuration found for the current AP"))
		return -1;
	}

	WPA_PRINTF((MSG_DEBUG, "Network configuration found for the current AP"))
	wpa_supplicant_set_non_wpa_policy(wpa_s, ssid);

	wpa_s->current_ssid = ssid;
	wpa_supplicant_initiate_eapol(wpa_s);

	return 0;
}


/*** BeginHeader wpa_supplicant_cleanup */
void wpa_supplicant_cleanup(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_cleanup(struct wpa_supplicant *wpa_s)
{
	//free(wpa_s->assoc_wpa_ie);
	//wpa_s->assoc_wpa_ie = NULL;

	//free(wpa_s->ap_wpa_ie);
	//wpa_s->ap_wpa_ie = NULL;
	//free(wpa_s->ap_rsn_ie);
	//wpa_s->ap_rsn_ie = NULL;

	//free(wpa_s->confname);
	//wpa_s->confname = NULL;

	//eapol_sm_deinit(wpa_s->eapol);
	wpa_s->eapol = NULL;

	//rsn_preauth_deinit(wpa_s);

	//pmksa_candidate_free(wpa_s);
	//pmksa_cache_free(wpa_s);
}


/*** BeginHeader wpa_clear_keys */
void wpa_clear_keys(struct wpa_supplicant *wpa_s, uint8 *addr);
/*** EndHeader */
_wifig_nodebug
__static void wpa_clear_keys(struct wpa_supplicant *wpa_s, uint8 *addr)
{
	wpa_driver_wln_set_key(WPA_ALG_NONE,
			       "\xff\xff\xff\xff\xff\xff", 0, 0, NULL,
			       0, NULL, 0);
	wpa_driver_wln_set_key(WPA_ALG_NONE,
			       "\xff\xff\xff\xff\xff\xff", 1, 0, NULL,
			       0, NULL, 0);
	wpa_driver_wln_set_key(WPA_ALG_NONE,
			       "\xff\xff\xff\xff\xff\xff", 2, 0, NULL,
			       0, NULL, 0);
	wpa_driver_wln_set_key(WPA_ALG_NONE,
			       "\xff\xff\xff\xff\xff\xff", 3, 0, NULL,
			       0, NULL, 0);
	if (addr) {
		wpa_driver_wln_set_key(WPA_ALG_NONE, addr,
				       0, 0, NULL, 0, NULL, 0);
	}
}


/*** BeginHeader wpa_supplicant_stop_countermeasures */
void wpa_supplicant_stop_countermeasures(void __far *eloop_ctx,
						void __far *sock_ctx);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_stop_countermeasures(void __far *eloop_ctx,
						void __far *sock_ctx)
{
	auto struct wpa_supplicant *wpa_s;
	wpa_s = (struct wpa_supplicant *)(word)eloop_ctx;	// known to be root ptr

	if (wpa_s->countermeasures) {
		wpa_s->countermeasures = 0;

		wpa_msg(wpa_s, MSG_INFO, "WPA: TKIP countermeasures stopped");
		wpa_supplicant_req_scan(wpa_s, 0);
	}
}


/*** BeginHeader wpa_supplicant_mark_disassoc */
void wpa_supplicant_mark_disassoc(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_mark_disassoc(struct wpa_supplicant *wpa_s)
{
	wpa_s->wpa_state = WPA_DISCONNECTED;
	memset(wpa_s->bssid, 0, ETH_ALEN);
#if 0
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
	if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK)
		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
#endif
}


/*** BeginHeader wpa_supplicant_event */
void wpa_supplicant_event(struct wpa_supplicant *wpa_s, wpa_event_type event,
			  union wpa_event_data __far *data);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_event(struct wpa_supplicant *wpa_s, wpa_event_type event,
			  union wpa_event_data __far *data)
{
	auto int pairwise, l, len;
	auto long now;
	auto uint8 bssid[ETH_ALEN], *p;

	switch (event) {
	case EVENT_ASSOC:
		wpa_s->wpa_state = WPA_ASSOCIATED;
		WPA_PRINTF((MSG_DEBUG, "Association event - clear replay counter"))
		memset(wpa_s->rx_replay_counter, 0, WPA_REPLAY_COUNTER_LEN);
		wpa_s->rx_replay_counter_set = 0;
		wpa_s->renew_snonce = 1;
		if (wpa_driver_wln_get_bssid(bssid) >= 0 &&
		    memcmp(bssid, wpa_s->bssid, ETH_ALEN) != 0) {
			wpa_msg(wpa_s, MSG_DEBUG, "Associated to a new BSS: BSSID=" MACSTR, MAC2STR(bssid));
			memcpy(wpa_s->bssid, bssid, ETH_ALEN);
			if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK ||
				wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X)
					wpa_clear_keys(wpa_s, bssid);
			wpa_supplicant_select_config(wpa_s);
		}
		wpa_msg(wpa_s, MSG_INFO, "Associated with " MACSTR,
			MAC2STR(bssid));

		/* Set portEnabled first to FALSE in order to get EAP state
		 * machine out of the SUCCESS state and eapSuccess cleared.
		 * Without this, EAPOL PAE state machine may transit to
		 * AUTHENTICATING state based on obsolete eapSuccess and then
		 * trigger BE_AUTH to SUCCESS and PAE to AUTHENTICATED without
		 * ever giving chance to EAP state machine to reset the state.
		 */
	#if 0
		eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
		eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
		if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK)
			eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
		/* 802.1X::portControl = Auto */
		eapol_sm_notify_portEnabled(wpa_s->eapol, TRUE);
	#endif
		wpa_s->eapol_received = 0;
		if (wpa_s->key_mgmt == WPA_KEY_MGMT_NONE) {
			wpa_supplicant_cancel_auth_timeout(wpa_s);
		} else {
			/* Timeout for receiving the first EAPOL packet */
			wpa_supplicant_req_auth_timeout(wpa_s, 10000);
		}
		break;
	case EVENT_DISASSOC:
		if (wpa_s->wpa_state >= WPA_ASSOCIATED)
			wpa_supplicant_req_scan(wpa_s, 100);
		wpa_supplicant_mark_disassoc(wpa_s);
		wpa_msg(wpa_s, MSG_DEBUG, "Disconnect event - remove keys");
		if (wpa_s->key_mgmt != WPA_KEY_MGMT_NONE)
			wpa_clear_keys(wpa_s, wpa_s->bssid);
		break;
	case EVENT_MICHAEL_MIC_FAILURE:
		wpa_msg(wpa_s, MSG_WARNING, "Michael MIC failure detected");
		pairwise = (data && data->michael_mic_failure.unicast);
		wpa_supplicant_key_request(wpa_s, 1, pairwise);
		now = MS_TIMER;
		if (wpa_s->last_michael_mic_error &&
		    now - wpa_s->last_michael_mic_error <= 60) {
			/* initialize countermeasures */
			wpa_s->countermeasures = 1;
			wpa_msg(wpa_s, MSG_WARNING, "TKIP countermeasures started");


			wpa_supplicant_deauthenticate(
				wpa_s, REASON_MICHAEL_MIC_FAILURE);
			eloop_cancel_timeout(
				wpa_supplicant_stop_countermeasures, wpa_s,
				NULL);
			eloop_register_timeout(
				60000uL, wpa_supplicant_stop_countermeasures,
				wpa_s, NULL);
			/* TODO: mark the AP rejected for 60 second. STA is
			 * allowed to associate with another AP.. */
		}
		wpa_s->last_michael_mic_error = now;
		break;
	case EVENT_SCAN_RESULTS:
		wpa_supplicant_scan_results(wpa_s);
		break;
	case EVENT_ASSOCINFO:
		WPA_PRINTF((MSG_DEBUG, "Association info event"))
		WPA_HEXDUMP((MSG_DEBUG, "req_ies", data->assoc_info.req_ies,
			    data->assoc_info.req_ies_len))
		//if (wpa_s->assoc_wpa_ie) {
			//free(wpa_s->assoc_wpa_ie);
			//wpa_s->assoc_wpa_ie = NULL;
			wpa_s->assoc_wpa_ie_len = 0;
		//}

		p = data->assoc_info.req_ies;
		l = data->assoc_info.req_ies_len;

		/* Go through the IEs and make a copy of the WPA/RSN IE, if
		 * present. */
		while (l >= 2) {
			len = p[1] + 2;
			if (len > l) {
				WPA_HEXDUMP((MSG_DEBUG, "Truncated IE in assoc_info", p, l))
				break;
			}
			if ((p[0] == GENERIC_INFO_ELEM && p[1] >= 6 &&
			     (memcmp(&p[2], "\x00\x50\xF2\x01\x01\x00", 6) ==
			      0)) ||
			    (p[0] == RSN_INFO_ELEM && p[1] >= 2)) {
				//wpa_s->assoc_wpa_ie = malloc(len);
				//if (wpa_s->assoc_wpa_ie == NULL)
				//	break;
				if (len > WPA_MAX_IE_LEN)
					len = WPA_MAX_IE_LEN;
				wpa_s->assoc_wpa_ie_len = len;
				memcpy(wpa_s->assoc_wpa_ie, p, len);
				WPA_HEXDUMP((MSG_DEBUG, "assoc_wpa_ie",
					    wpa_s->assoc_wpa_ie,
					    wpa_s->assoc_wpa_ie_len))
				break;
			}
			l -= len;
			p += len;
		}
		break;
	default:
		WPA_PRINTF((MSG_INFO, "Unknown event %d", event))
		break;
	}
}




/*** BeginHeader wpa_supplicant_gen_assoc_event */
void wpa_supplicant_gen_assoc_event(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_gen_assoc_event(struct wpa_supplicant *wpa_s)
{
	auto struct wpa_ssid *ssid;
	auto union wpa_event_data data;

	ssid = wpa_supplicant_get_ssid(wpa_s);
	if (ssid == NULL)
		return;

	WPA_PRINTF((MSG_DEBUG, "Already associated with a configured network - generating associated event"))
	memset(&data, 0, sizeof(data));
	wpa_supplicant_event(wpa_s, EVENT_ASSOC, &data);
}


/*** BeginHeader wpa_supplicant_scan */
void wpa_supplicant_scan(void __far *eloop_ctx, void __far *timeout_ctx);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_scan(void __far *eloop_ctx, void __far *timeout_ctx)
{
	auto struct wpa_supplicant *wpa_s;
	auto struct wpa_ssid *ssid;
	wpa_s = (struct wpa_supplicant *)(word)eloop_ctx;
	if (!wpa_s->conf->ap_scan) {
		wpa_supplicant_gen_assoc_event(wpa_s);
		return;
	}

	if (wpa_s->wpa_state == WPA_DISCONNECTED)
		wpa_s->wpa_state = WPA_SCANNING;

	ssid = wpa_s->conf->ssid;
	if (wpa_s->prev_scan_ssid != BROADCAST_SSID_SCAN) {
		while (ssid) {
			if (ssid == wpa_s->prev_scan_ssid) {
				ssid = ssid->next;
				break;
			}
			ssid = ssid->next;
		}
	}
	while (ssid) {
		if (ssid->scan_ssid)
			break;
		ssid = ssid->next;
	}

	WPA_PRINTF((MSG_DEBUG, "Starting AP scan (%s SSID)",
		   ssid ? "specific": "broadcast"))
	if (ssid) {
		WPA_HEXDUMP_ASCII((MSG_DEBUG, "Scan SSID",
				  ssid->ssid, ssid->ssid_len))
		wpa_s->prev_scan_ssid = ssid;
	} else
		wpa_s->prev_scan_ssid = BROADCAST_SSID_SCAN;
#if 0
	if (wpa_s->driver->scan(wpa_s->ifname, wpa_s,
				ssid ? ssid->ssid : NULL,
				ssid ? ssid->ssid_len : 0)) {
		WPA_PRINTF((MSG_WARNING, "Failed to initiate AP scan."))
	}
#endif
}

/*** BeginHeader cipher_suite2driver */
wpa_cipher cipher_suite2driver(int cipher);
/*** EndHeader */
_wifig_nodebug
__static wpa_cipher cipher_suite2driver(int cipher)
{
	switch (cipher) {
	case WPA_CIPHER_NONE:
		return CIPHER_NONE;
	case WPA_CIPHER_WEP40:
		return CIPHER_WEP40;
	case WPA_CIPHER_WEP104:
		return CIPHER_WEP104;
	case WPA_CIPHER_CCMP:
		return CIPHER_CCMP;
	case WPA_CIPHER_TKIP:
	default:
		return CIPHER_TKIP;
	}
}


/*** BeginHeader key_mgmt2driver */
wpa_key_mgmt key_mgmt2driver(int key_mgmt);
/*** EndHeader */
_wifig_nodebug
__static wpa_key_mgmt key_mgmt2driver(int key_mgmt)
{
	switch (key_mgmt) {
	case WPA_KEY_MGMT_NONE:
	case WPA_KEY_MGMT_IEEE8021X_NO_WPA:
		return KEY_MGMT_NONE;
	case WPA_KEY_MGMT_IEEE8021X:
		return KEY_MGMT_802_1X;
	case WPA_KEY_MGMT_PSK:
	default:
		return KEY_MGMT_PSK;
	}
}


/*** BeginHeader wpa_supplicant_set_suites */
int wpa_supplicant_set_suites(struct wpa_supplicant *wpa_s,
				     struct wpa_scan_result *bss,
				     struct wpa_ssid *ssid,
				     uint8 *wpa_ie, int *wpa_ie_len);
/*** EndHeader */
_wifig_nodebug
__static int wpa_supplicant_set_suites(struct wpa_supplicant *wpa_s,
				     struct wpa_scan_result *bss,
				     struct wpa_ssid *ssid,
				     uint8 *wpa_ie, int *wpa_ie_len)
{
	auto struct wpa_ie_data ie;
	auto int sel, proto;
	auto uint8 *ap_ie;
	auto size_t ap_ie_len;

	if (bss->rsn_ie_len && (ssid->proto & WPA_PROTO_RSN)) {
		wpa_msg(wpa_s, MSG_DEBUG, "RSN: using IEEE 802.11i/D9.0");
		proto = WPA_PROTO_RSN;
		ap_ie = bss->rsn_ie;
		ap_ie_len = bss->rsn_ie_len;
	} else {
		wpa_msg(wpa_s, MSG_DEBUG, "WPA: using IEEE 802.11i/D3.0");
		proto = WPA_PROTO_WPA;
		ap_ie = bss->wpa_ie;
		ap_ie_len = bss->wpa_ie_len;
	}

	if (wpa_parse_wpa_ie(wpa_s, ap_ie, ap_ie_len, &ie)) {
		wpa_msg(wpa_s, MSG_WARNING, "WPA: Failed to parse WPA IE for the selected BSS.");
		return -1;
	}

	wpa_s->proto = proto;

	//free(wpa_s->ap_wpa_ie);
	//wpa_s->ap_wpa_ie = NULL;
	wpa_s->ap_wpa_ie_len = 0;
	if (bss->wpa_ie_len) {
		//wpa_s->ap_wpa_ie = malloc(bss->wpa_ie_len);
		//if (wpa_s->ap_wpa_ie == NULL) {
		//	WPA_PRINTF((MSG_INFO, "WPA: malloc failed"))
		//	return -1;
		//}
		memcpy(wpa_s->ap_wpa_ie, bss->wpa_ie, bss->wpa_ie_len);
		wpa_s->ap_wpa_ie_len = bss->wpa_ie_len;
	}

	//free(wpa_s->ap_rsn_ie);
	//wpa_s->ap_rsn_ie = NULL;
	wpa_s->ap_rsn_ie_len = 0;
	if (bss->rsn_ie_len) {
		//wpa_s->ap_rsn_ie = malloc(bss->rsn_ie_len);
		//if (wpa_s->ap_rsn_ie == NULL) {
		//	WPA_PRINTF((MSG_INFO, "WPA: malloc failed"))
		//	return -1;
		//}
		memcpy(wpa_s->ap_rsn_ie, bss->rsn_ie, bss->rsn_ie_len);
		wpa_s->ap_rsn_ie_len = bss->rsn_ie_len;
	}

	sel = ie.group_cipher & ssid->group_cipher;
	if (sel & WPA_CIPHER_CCMP) {
		wpa_s->group_cipher = WPA_CIPHER_CCMP;
	} else if (sel & WPA_CIPHER_TKIP) {
		wpa_s->group_cipher = WPA_CIPHER_TKIP;
	} else if (sel & WPA_CIPHER_WEP104) {
		wpa_s->group_cipher = WPA_CIPHER_WEP104;
	} else if (sel & WPA_CIPHER_WEP40) {
		wpa_s->group_cipher = WPA_CIPHER_WEP40;
	} else {
		WPA_PRINTF((MSG_WARNING, "WPA: Failed to select group cipher."))
		return -1;
	}

	sel = ie.pairwise_cipher & ssid->pairwise_cipher;
	if (sel & WPA_CIPHER_CCMP) {
		wpa_s->pairwise_cipher = WPA_CIPHER_CCMP;
	} else if (sel & WPA_CIPHER_TKIP) {
		wpa_s->pairwise_cipher = WPA_CIPHER_TKIP;
	} else if (sel & WPA_CIPHER_NONE) {
		wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
	} else {
		WPA_PRINTF((MSG_WARNING, "WPA: Failed to select pairwise cipher."))
		return -1;
	}

	sel = ie.key_mgmt & ssid->key_mgmt;
	if (sel & WPA_KEY_MGMT_IEEE8021X) {
		wpa_s->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
	} else if (sel & WPA_KEY_MGMT_PSK) {
		wpa_s->key_mgmt = WPA_KEY_MGMT_PSK;
	} else {
		WPA_PRINTF((MSG_WARNING, "WPA: Failed to select authenticated key management type."))
		return -1;
	}


	/* Starting new association, so clear the possibly used WPA IE from the
	 * previous association. */
	//free(wpa_s->assoc_wpa_ie);
	//wpa_s->assoc_wpa_ie = NULL;
	wpa_s->assoc_wpa_ie_len = 0;

	*wpa_ie_len = wpa_gen_wpa_ie(wpa_s, wpa_ie);
	if (*wpa_ie_len < 0) {
		WPA_PRINTF((MSG_WARNING, "WPA: Failed to generate WPA IE."))
		return -1;
	}
	WPA_HEXDUMP((MSG_DEBUG, "WPA: Own WPA IE", wpa_ie, *wpa_ie_len))

	if (ssid->key_mgmt & WPA_KEY_MGMT_PSK) {
		wpa_s->pmk_len = PMK_LEN;
		memcpy(wpa_s->pmk, ssid->psk, PMK_LEN);
	}
#if 0
	else if (wpa_s->cur_pmksa) {
		wpa_s->pmk_len = wpa_s->cur_pmksa->pmk_len;
		memcpy(wpa_s->pmk, wpa_s->cur_pmksa->pmk, wpa_s->pmk_len);
	} else {
		wpa_s->pmk_len = PMK_LEN;
		memset(wpa_s->pmk, 0, PMK_LEN);
		wpa_s->ext_pmk_received = 0;
	}
#endif
	return 0;
}


/*** BeginHeader wpa_supplicant_associate */
void wpa_supplicant_associate(struct wpa_supplicant *wpa_s,
				     struct wpa_scan_result *bss,
				     struct wpa_ssid *ssid);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_associate(struct wpa_supplicant *wpa_s,
				     struct wpa_scan_result *bss,
				     struct wpa_ssid *ssid)
{
	auto uint8 wpa_ie[80];
	auto int wpa_ie_len;
	auto int use_crypt;
	auto int algs;
	auto int cipher_pairwise, cipher_group;
	auto int i;

	algs = AUTH_ALG_OPEN_SYSTEM;
	wpa_s->reassociate = 0;
	wpa_msg(wpa_s, MSG_INFO, "Trying to associate with " MACSTR " (SSID='%s' freq=%d MHz)", MAC2STR(bss->bssid),
		wpa_ssid_txt(ssid->ssid, ssid->ssid_len), bss->freq);
	wpa_supplicant_cancel_scan(wpa_s);

#if 0
	if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		if (ssid->leap) {
			if (ssid->non_leap == 0)
				algs = AUTH_ALG_LEAP;
			else
				algs |= AUTH_ALG_LEAP;
		}
	}
#endif


	if ((bss->wpa_ie_len || bss->rsn_ie_len) &&
	    (ssid->key_mgmt & (WPA_KEY_MGMT_IEEE8021X | WPA_KEY_MGMT_PSK))) {
#if 0
		wpa_s->cur_pmksa = pmksa_cache_get(wpa_s, bss->bssid, NULL);
		if (wpa_s->cur_pmksa) {
			WPA_HEXDUMP((MSG_DEBUG, "RSN: PMKID",
				    wpa_s->cur_pmksa->pmkid, PMKID_LEN))
			eapol_sm_notify_pmkid_attempt(wpa_s->eapol);
		}
#endif
		if (wpa_supplicant_set_suites(wpa_s, bss, ssid,
					      wpa_ie, &wpa_ie_len)) {
			WPA_PRINTF((MSG_WARNING, "WPA: Failed to set WPA key management and encryption suites"))
			return;
		}
	} else {
		wpa_supplicant_set_non_wpa_policy(wpa_s, ssid);
		wpa_ie_len = 0;
	}

#define	CAP_PRIVACY		0x10

	wpa_clear_keys(wpa_s, bss->bssid);
	use_crypt = 1;
	cipher_pairwise = cipher_suite2driver(wpa_s->pairwise_cipher);
	cipher_group = cipher_suite2driver(wpa_s->group_cipher);
	if ((ssid->key_mgmt & WPA_KEY_MGMT_NONE) &&
		(bss->caps & CAP_PRIVACY) && wpa_ie_len == 0) {
		use_crypt = 0;
		for (i = 0; i < NUM_WEP_KEYS; i++) {
			if (ssid->wep_key_len[i]) {
				use_crypt = 1;
				wpa_eapol_set_wep_key(wpa_s,
						      i == ssid->wep_tx_keyidx,
						      i, ssid->wep_key[i],
						      ssid->wep_key_len[i]);
			}
		}
	}
#if 0
	if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		if ((ssid->eapol_flags &
		     (EAPOL_FLAG_REQUIRE_KEY_UNICAST |
		      EAPOL_FLAG_REQUIRE_KEY_BROADCAST)) == 0) {
			use_crypt = 0;
		} else {
			/* Assume that dynamic WEP-104 keys will be used and
			 * set cipher suites in order for drivers to expect
			 * encryption. */
			cipher_pairwise = cipher_group = CIPHER_WEP104;
		}
	}
#endif
	wpa_s->wpa_state = WPA_ASSOCIATING;
	wpa_driver_wln_associate(bss->bssid,
				 bss->ssid, bss->ssid_len, bss->freq,
				 wpa_ie, wpa_ie_len,
				 cipher_pairwise, cipher_group,
				 key_mgmt2driver(wpa_s->key_mgmt));

	/* Timeout for IEEE 802.11 authentication and association */
	wpa_supplicant_req_auth_timeout(wpa_s, 5000);

	wpa_s->current_ssid = ssid;
	wpa_supplicant_initiate_eapol(wpa_s);
}


/*** BeginHeader wpa_supplicant_disassociate */
void wpa_supplicant_disassociate(struct wpa_supplicant *wpa_s,
				 int reason_code);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_disassociate(struct wpa_supplicant *wpa_s,
				 int reason_code)
{
	auto uint8 *addr;
	addr = NULL;
	wpa_s->wpa_state = WPA_DISCONNECTED;
	if (memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0) {
		wpa_driver_wln_disassociate(wpa_s->bssid,
					    reason_code);
		addr = wpa_s->bssid;
	}
	wpa_clear_keys(wpa_s, addr);
	wpa_s->current_ssid = NULL;
#if 0
	eapol_sm_notify_config(wpa_s->eapol, NULL, NULL);
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
#endif
}


/*** BeginHeader wpa_supplicant_deauthenticate */
void wpa_supplicant_deauthenticate(struct wpa_supplicant *wpa_s,
				   int reason_code);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_deauthenticate(struct wpa_supplicant *wpa_s,
				   int reason_code)
{
	auto uint8 *addr;
	addr = NULL;
	wpa_s->wpa_state = WPA_DISCONNECTED;
	if (memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0) {
		wpa_driver_wln_disassociate(wpa_s->bssid,
					      reason_code);
		addr = wpa_s->bssid;
	}
	wpa_clear_keys(wpa_s, addr);
	wpa_s->current_ssid = NULL;
#if 0
	eapol_sm_notify_config(wpa_s->eapol, NULL, NULL);
	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
#endif
}




/*** BeginHeader wpa_supplicant_select_bss */
struct wpa_scan_result *
wpa_supplicant_select_bss(struct wpa_supplicant *wpa_s, struct wpa_ssid *group,
			  struct wpa_scan_result *results, int num,
			  struct wpa_ssid **selected_ssid);
/*** EndHeader */
_wifig_nodebug
__static struct wpa_scan_result *
wpa_supplicant_select_bss(struct wpa_supplicant *wpa_s, struct wpa_ssid *group,
			  struct wpa_scan_result *results, int num,
			  struct wpa_ssid **selected_ssid)
{
	auto struct wpa_ie_data ie;
	auto struct wpa_ssid *ssid;
	auto struct wpa_scan_result *bss, *selected;
	auto int i;

	selected = NULL;
	WPA_PRINTF((MSG_DEBUG, "Selecting BSS from priority group %d",
		   group->priority))

	bss = NULL;
	ssid = NULL;
	/* First, try to find WPA-enabled AP */
	for (i = 0; i < num && !selected; i++) {
		bss = &results[i];
		WPA_PRINTF((MSG_DEBUG, "%d: " MACSTR " ssid='%s' wpa_ie_len=%d rsn_ie_len=%d",
			   i, MAC2STR(bss->bssid),
			   wpa_ssid_txt(bss->ssid, bss->ssid_len),
			   bss->wpa_ie_len, bss->rsn_ie_len))
		if (bss->wpa_ie_len == 0 && bss->rsn_ie_len == 0) {
			WPA_PRINTF((MSG_DEBUG, "   skip - %s", "no WPA/RSN IE"))
			continue;
		}

		for (ssid = group; ssid; ssid = ssid->pnext) {
			if (ssid->ssid_len != 0 && /* allow broadcast SSID */
				(bss->ssid_len != ssid->ssid_len ||
			    memcmp(bss->ssid, ssid->ssid,
				   bss->ssid_len) != 0)) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "SSID mismatch"))
				continue;
			}
			if (ssid->bssid_set &&
			    memcmp(bss->bssid, ssid->bssid, ETH_ALEN) != 0) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "BSSID mismatch"))
				continue;
			}
			if (!(((ssid->proto & WPA_PROTO_RSN) &&
			       wpa_parse_wpa_ie(wpa_s, bss->rsn_ie,
						bss->rsn_ie_len, &ie) == 0) ||
			      ((ssid->proto & WPA_PROTO_WPA) &&
			       wpa_parse_wpa_ie(wpa_s, bss->wpa_ie,
						bss->wpa_ie_len, &ie) == 0))) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "could not parse WPA/RSN IE"))
				continue;
			}
			if (!(ie.proto & ssid->proto)) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "proto mismatch"))
				continue;
			}
			if (!(ie.pairwise_cipher & ssid->pairwise_cipher)) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "PTK cipher mismatch"))
				continue;
			}
			if (!(ie.group_cipher & ssid->group_cipher)) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "GTK cipher mismatch"))
				continue;
			}
			if (!(ie.key_mgmt & ssid->key_mgmt)) {
				WPA_PRINTF((MSG_DEBUG, "   skip - %s", "key mgmt mismatch"))
				continue;
			}

			selected = bss;
			*selected_ssid = ssid;
			WPA_PRINTF((MSG_DEBUG, "   selected"))
			break;
		}
	}

	/* If no WPA-enabled AP found, try to find non-WPA AP, if configuration
	 * allows this. */
	for (i = 0; i < num && !selected; i++) {
		bss = &results[i];
		for (ssid = group; ssid; ssid = ssid->pnext) {
			if ((ssid->ssid_len == 0 || /* allow broadcast SSID */
				(bss->ssid_len == ssid->ssid_len &&
			    memcmp(bss->ssid, ssid->ssid, bss->ssid_len) == 0))
			    &&
			    (!ssid->bssid_set ||
			     memcmp(bss->bssid, ssid->bssid, ETH_ALEN) == 0) &&
			    ((ssid->key_mgmt & WPA_KEY_MGMT_NONE) ||
			     (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA)))
			{
				selected = bss;
				*selected_ssid = ssid;
				WPA_PRINTF((MSG_DEBUG, "   selected non-WPA AP " MACSTR " ssid='%s'",
					   MAC2STR(bss->bssid),
					   wpa_ssid_txt(bss->ssid,
							bss->ssid_len)))
				break;
			}
		}
	}

	return selected;
}


/*** BeginHeader wpa_supplicant_scan_results */
void wpa_supplicant_scan_results(struct wpa_supplicant *wpa_s);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_scan_results(struct wpa_supplicant *wpa_s)
{
#define SCAN_AP_LIMIT 10
	auto struct wpa_scan_result results[SCAN_AP_LIMIT];
	auto int num, prio;
	auto struct wpa_scan_result *selected;
	auto struct wpa_ssid *ssid;

	selected = NULL;
	num = wpa_driver_wln_get_scan_results(results,
					      SCAN_AP_LIMIT);
	WPA_PRINTF((MSG_DEBUG, "Scan results: %d", num))
	if (num < 0) {
		WPA_PRINTF((MSG_DEBUG, "Failed to get scan results - try scanning again"))
		wpa_supplicant_req_scan(wpa_s, 1000);
		return;
	}
	if (num > SCAN_AP_LIMIT) {
		WPA_PRINTF((MSG_INFO, "Not enough room for all APs (%d < %d)",
			   num, SCAN_AP_LIMIT))
		num = SCAN_AP_LIMIT;
	}

	for (prio = 0; prio < wpa_s->conf->num_prio; prio++) {
		selected = wpa_supplicant_select_bss(wpa_s,
						     wpa_s->conf->pssid[prio],
						     results, num, &ssid);
		if (selected)
			break;
	}

	if (selected) {
		if (wpa_s->reassociate ||
		    memcmp(selected->bssid, wpa_s->bssid, ETH_ALEN) != 0) {
			wpa_supplicant_associate(wpa_s, selected, ssid);
		} else {
			WPA_PRINTF((MSG_DEBUG, "Already associated with the selected AP."))
		}
		//rsn_preauth_scan_results(wpa_s, results, num);
	} else {
		WPA_PRINTF((MSG_DEBUG, "No suitable AP found."))
		wpa_supplicant_req_scan(wpa_s, 5000);
	}
}



/*** BeginHeader wpa_set_params */
int wpa_set_params (wln_params *params_in);
/*** EndHeader */
//
// Create wpa_config and wpa_ssid structures from wireless parameters
//
_wifig_nodebug
int wpa_set_params (wln_params *params)
{
	static struct wpa_config config;
	static struct wpa_ssid ssid;

#if 0
	// List of allowed EAP methods
	static uint8 eap_methods[16];
#endif
	auto int i, cipher, key_mgmt;
	auto uint8 *p;
	#GLOBAL_INIT {memset(&config,0,sizeof(config));memset(&ssid,0,sizeof(ssid));}

	cipher = 0;
	if (params->encrypt & WLN_ENCR_OPEN)
		cipher |= WPA_CIPHER_NONE;
	if (params->encrypt & WLN_ENCR_WEP)
		cipher |= WPA_CIPHER_WEP40 | WPA_CIPHER_WEP104;
	if (params->encrypt & WLN_ENCR_TKIP)
		cipher |= WPA_CIPHER_TKIP;
#if 1
	if (params->encrypt & WLN_ENCR_CCMP)
		cipher |= WPA_CIPHER_CCMP;
#endif

	key_mgmt = 0;
	if (params->authen & (WLN_AUTH_OPEN|WLN_AUTH_SHAREDKEY))
		key_mgmt |= WPA_KEY_MGMT_NONE;
	if (params->authen & WLN_AUTH_WPA_PSK)
		key_mgmt |= WPA_KEY_MGMT_PSK;
	if (!key_mgmt)
		key_mgmt = WPA_KEY_MGMT_NONE;
#if 1
	if (params->authen & (WLN_AUTH_WEP_8021X|WLN_AUTH_LEAP))
		key_mgmt |= WPA_KEY_MGMT_IEEE8021X_NO_WPA;
	if (params->authen & WLN_AUTH_WPA_8021X)
		key_mgmt |= WPA_KEY_MGMT_IEEE8021X;
#endif

	// Create SSID (BSS) parameters
	ssid.ssid = params->ssid;
	ssid.ssid_len = params->ssid_len;
	memcpy (ssid.psk, params->wpa_psk, WLN_PSK_SIZE);
	ssid.psk_set = 1;
	ssid.pairwise_cipher = cipher;
	ssid.group_cipher = cipher;
	ssid.key_mgmt = key_mgmt;
	ssid.proto = WPA_PROTO_WPA|WPA_PROTO_RSN;
#if 0
	ssid.identity = params->identity;
	ssid.identity_len = strlen (params->identity);
	ssid.password = params->password;
	ssid.password_len = strlen (params->password);

	ssid.use_standard = ((params->options & WLN_OPT_VERIFYCERT) != 0);

	// Build list of allowed EAP methods
	p = eap_methods;
	if (params->eap_methods & WLN_EAP_LEAP)
		*p++ = EAP_TYPE_LEAP;
	if (params->eap_methods & WLN_EAP_PEAP)
		*p++ = EAP_TYPE_PEAP;
	if (params->eap_methods & WLN_EAP_TLS)
		*p++ = EAP_TYPE_TLS;
	if (params->eap_methods & WLN_EAP_TTLS)
		*p++ = EAP_TYPE_TTLS;

	// Only one phase 2 type allowed by EAP implementation.
	// Choose one in this order of perference.
	ssid.phase2 = NULL;
	if (params->eap_methods & WLN_EAP_MSCHAPV2) {
		*p++ = EAP_TYPE_MSCHAPV2;
		ssid.phase2 = "autheap=MSCHAPV2";
	}
	else if (params->eap_methods & WLN_EAP_MD5) {
		*p++ = EAP_TYPE_MD5;
		ssid.phase2 = "auth=MD5 autheap=MD5";
	}
	else if (params->eap_methods & WLN_EAP_GTC) {
		*p++ = EAP_TYPE_GTC;
		ssid.phase2 = "auth=GTC autheap=GTC";
	}
	else if (params->eap_methods & WLN_EAP_OTP) {
		*p++ = EAP_TYPE_OTP;
		ssid.phase2 = "auth=OTP autheap=OTP";
	}
	else if (params->eap_methods & WLN_EAP_TTLS_MSCHAPV2)
		ssid.phase2 = "auth=MSCHAPV2";
	else if (params->eap_methods & WLN_EAP_TTLS_MSCHAP)
		ssid.phase2 = "auth=MSCHAP";
	else if (params->eap_methods & WLN_EAP_TTLS_PAP)
		ssid.phase2 = "auth=PAP";
	else if (params->eap_methods & WLN_EAP_TTLS_CHAP)
		ssid.phase2 = "auth=CHAP";
	else if (params->eap_methods & WLN_EAP_TLS)
		ssid.phase2 = "auth=TLS autheap=TLS";

	*p = EAP_TYPE_NONE;
	ssid.eap_methods = eap_methods;

	// Require 802.1x keys if WEP with 802.1x and no default keys
	if ((key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) &&
		!(key_mgmt & WPA_KEY_MGMT_NONE))
			ssid.eapol_flags |= EAPOL_FLAG_REQUIRE_KEY_BROADCAST;
#else
	ssid.eap_methods = NULL;
#endif

	for (i = 0; i < NUM_WEP_KEYS; i++) {
		memcpy (ssid.wep_key[i], params->wep_key[i], params->wep_key_len[i]);
		ssid.wep_key_len[i] = params->wep_key_len[i];
	}
	ssid.wep_tx_keyidx = params->wep_key_id;

	// Create config with one SSID
	config.ssid = &ssid;
	config.pssid = &config.ssid;
	config.num_prio = 1;
	config.eapol_version = 1;
	config.ap_scan = 1;
	wpa_s.conf = &config;

	return 0;
}


/*** BeginHeader wpa_supplicant_eapol_cb */
void wpa_supplicant_eapol_cb(struct eapol_sm *eapol, int success, void *ctx);
/*** EndHeader */
_wifig_nodebug
__static void wpa_supplicant_eapol_cb(struct eapol_sm *eapol, int success, void *ctx)
{
#if 0
	// Authentication failure
	if (!success) {
		// Disconnect if authentication required
		if (wpa_s.key_mgmt == WPA_KEY_MGMT_IEEE8021X) {
			wpa_s.reassociate = 1;
			wpa_supplicant_deauthenticate(&wpa_s, REASON_IEEE_802_1X_AUTH_FAILED);
		}
		// Force port authorized to stop authentication retries.
		// This happens for WEP with both 802.1x and default keys allowed.
		else
			eapol_sm_notify_portControl(wpa_s.eapol, ForceAuthorized);
	}
#endif
}


//SJH - use direct calls now
//extern struct wpa_driver_ops wpa_driver_wln_ops; /* driver_wln.c */

/*** BeginHeader wpa_supplicant_init */
int wpa_supplicant_init(_WiFiGConfig * nic, wln_params *params);
/*** EndHeader */
_wifig_nodebug
int wpa_supplicant_init(_WiFiGConfig * nic, wln_params *params)
{
	memset(&wpa_s, 0, sizeof(wpa_s));

	eloop_init(&wpa_s);

	if (wpa_set_params (params) < 0) {
		WPA_PRINTF((MSG_ERROR, "Failed to set config.\n"))
		goto cleanup;
	}


	wpa_driver_wln_events_init(&wpa_s);

	wpa_s.nic = nic;


	wpa_s.renew_snonce = 1;
	if (wpa_supplicant_driver_init(&wpa_s, 0) < 0) {
		goto cleanup;
	}

	return 0;

cleanup:
	wpa_supplicant_terminate();
	return -1;
}


/*** BeginHeader wpa_supplicant_terminate */
void wpa_supplicant_terminate(void);
/*** EndHeader */
_wifig_nodebug
void wpa_supplicant_terminate(void)
{
	wpa_supplicant_deauthenticate(&wpa_s, REASON_DEAUTH_LEAVING);
	wpa_driver_wln_events_deinit(&wpa_s, &wpa_s);
	wpa_supplicant_cleanup(&wpa_s);

	eloop_terminate();
	eloop_destroy();
}


/*** BeginHeader wpa_supplicant_driver_init */
int wpa_supplicant_driver_init(struct wpa_supplicant *wpa_s,
				      int wait_for_interface);
/*** EndHeader */
_wifig_nodebug
__static int wpa_supplicant_driver_init(struct wpa_supplicant *wpa_s,
				      int wait_for_interface)
{
#if 0
	if (wpa_s->driver->set_wpa(wpa_s->ifname, 1) < 0) {
		WPA_PRINTF((MSG_ERROR, "Failed to enable WPA in the driver.\n"))
		return -1;
	}
#endif
	wpa_clear_keys(wpa_s, NULL);
	/* Make sure that TKIP countermeasures are not left enabled (could
	 * happen if wpa_supplicant is killed during countermeasures. */
	//wpa_s->driver->set_countermeasures(wpa_s->ifname, 0);

	//wpa_s->driver->set_drop_unencrypted(wpa_s->ifname, 1);

	wpa_s->prev_scan_ssid = BROADCAST_SSID_SCAN;
	wpa_supplicant_req_scan(wpa_s, 100);

	return 0;
}




