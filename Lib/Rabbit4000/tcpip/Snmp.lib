/*
* Copyright (c) 2008 Digi International Inc., All Rights Reserved
*
* This software contains proprietary and confidential information of Digi
* International Inc.  By accepting transfer of this copy, Recipient agrees
* to retain this software in confidence, to prevent disclosure to others,
* and to make no use of this software other than that for which it was
* delivered.  This is a published copyrighted work of Digi International
* Inc.  Except as permitted by federal law, 17 USC 117, copying is strictly
* prohibited.
*
* Restricted Rights Legend
*
* Use, duplication, or disclosure by the Government is subject to
* restrictions set forth in sub-paragraph (c)(1)(ii) of The Rights in
* Technical Data and Computer Software clause at DFARS 252.227-7031 or
* subparagraphs (c)(1) and (2) of the Commercial Computer Software -
* Restricted Rights at 48 CFR 52.227-19, as applicable.
*
* Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343
*/

/* SNMP bundled with Dynamic C.
 *
 *    snmp.lib
 *
 * Simple Network Management Protocol (Version 1).  Based on RFCs 1155-1157.
 * Makes extensive use of MIB.LIB.
 *
 * naming convention:
 *  _snmp_*			Internal SNMP functions
 *  snmp_*			Documented API.
 *
 * Assigned enterprise numbers (under 1.3.6.1.4.1) are
 *   12807 - Rabbit Semiconductor
 *   12817 - Z-World Inc.
 * Contact IANA for your own enterprise number if you develop
 * a product which requires a product-specific MIB.  You can also
 * temporarily place a MIB tree under 12807.3 or 12817.3, which is
 * reserved for OEM experimentation and is used by the
 * supplied demo code.
 */
/*** BeginHeader _snmp */

#if CC_VER < 0xA20
#fatal "This SNMP module must be used with Dynamic C version 10.21 or later."
#endif

#ifndef SNMP_H
#define SNMP_H

#ifdef SNMP_DEBUG
	#define _snmp_nodebug __debug
#else
	#define _snmp_nodebug __nodebug
#endif

/*
 * Configuration definitions
 */

#ifndef MIN_MTU
	#define MIN_MTU	ETH_MTU		// for compat with older tcp libs
#endif

// Define the largest size SNMP datagram supported (input or output).
// This must be at least 484 bytes to conform with RFC1157.
// Currently, this should not be larger than the default value (MIN_MTU-28)
// since outgoing fragmentation is not supported.  See dev note.
#ifndef SNMP_MAX_DATA
	#define SNMP_MAX_DATA	(MIN_MTU-28)
#endif
#if SNMP_MAX_DATA < 484
	#warnt "SNMP_MAX_DATA is less than the RFC1157 minimum value of 484"
	#warnt "- may be because ETH_MTU or PPP_MTU is too small"
#endif
#if SNMP_MAX_DATA > MIN_MTU - 28
	#warnt "SNMP_MAX_DATA is larger than ETH_MTU/PPP_MTU - 28"
	#warnt "- outgoing fragmentation not supported."
#endif


// Define largest octet string which may be retrieved or set via SNMP.
// Making this larger only affects the amount of stack space used by
// the SNMP handler functions.  It does not limit internal storage
// of string values in the MIB tree.  The largest practical size would
// be a few bytes less than SNMP_MAX_DATA.  The minimum allowable
// size is 2*SNMP_MAX_NAME.
#ifndef SNMP_MAX_STRING
	#define SNMP_MAX_STRING	128
#endif

// Define maximum number of variables supported in any one message.
// This has a bearing on stack space usage.  Each additional binding
// will require 4 more bytes of stack.
#ifndef SNMP_MAX_BINDINGS
	#define SNMP_MAX_BINDINGS			32
#endif

// Define maximum string length of community names (i.e. passwords)
#ifndef SNMP_MAX_COMMUNITY_NAME
	#define SNMP_MAX_COMMUNITY_NAME	16
#endif

// Define maximum number of distinct community names
#ifndef SNMP_MAX_COMMUNITIES
	#ifdef SNMP_TRAPS
		#define SNMP_MAX_COMMUNITIES	3
	#else
		#define SNMP_MAX_COMMUNITIES	2
	#endif
#endif

#if SNMP_MAX_COMMUNITIES < 1
	#warnt "SNMP_MAX_COMMUNITIES must be >= 1"
	#undef SNMP_MAX_COMMUNITIES
	#define SNMP_MAX_COMMUNITIES		1
#endif

#ifndef SNMP_PORT
	#define SNMP_PORT			161
#endif

#ifndef SNMP_TRAP_PORT
	#define SNMP_TRAP_PORT	162
#endif

// Specify the network interface to listen for SNMP messages.  May
// be set to a fixed interface, or IF_ANY to listen on all
// interfaces.
#ifndef SNMP_INTERFACE
	#define SNMP_INTERFACE IF_DEFAULT
#endif

// Specify the IP TOS for SNMP.
#ifndef SNMP_TOS
	#define SNMP_TOS IPTOS_RELIABLE
#endif

// Minimum interval between transmission of trap messages, specified
// in milliseconds.  Helps prevent inadvertent network overload.
// Must not be more than 30,000 milliseconds.
#ifndef SNMP_MIN_TRAP_INTVL
	#define SNMP_MIN_TRAP_INTVL 1000
#endif

// Maximum number of monitored variables.  Each monitored variable
// requires (SNMP_MAX_MON_DATA*2)+33 bytes of root data.
#ifndef SNMP_MAX_MONITOR
	#define SNMP_MAX_MONITOR	2
#endif

// Maximum number of additional variables sent with a monitor trap.
#ifndef SNMP_MAX_MON_DATA
	#define SNMP_MAX_MON_DATA	2
#endif

/*
 * Default communities.  Do not change these definitions.
 */
#define SNMP_PUBLIC				0
#define SNMP_PUBLIC_MASK		0x01
#define SNMP_PRIVATE				1
#define SNMP_PRIVATE_MASK		0x02

#ifdef SNMP_TRAPS
	#define SNMP_TRAPDEST		2
	#define SNMP_TRAPDEST_MASK	0x04
#endif

#ifndef SNMP_DFLT_READMASK
	#define SNMP_DFLT_READMASK		(SNMP_PUBLIC_MASK|SNMP_PRIVATE_MASK)
#endif

#ifndef SNMP_DFLT_WRITEMASK
	#define SNMP_DFLT_WRITEMASK	SNMP_PRIVATE_MASK
#endif

/*
 * Include MIB interface
 */

#ifndef MIB_H
	#use "mib.lib"
#endif

#if SNMP_MAX_STRING < 2*SNMP_MAX_NAME
	#fatal "SNMP_MAX_STRING must be at least 2*SNMP_MAX_NAME"
#endif

/*
 * Definitions
 */

// SNMP PDU types
#define SNMP_GETREQ			0xa0
#define SNMP_GETNEXTREQ		0xa1
#define SNMP_GETRSP			0xa2
#define SNMP_SETREQ			0xa3
#define SNMP_TRAPREQ			0xa4

// SNMP generic trap codes
#define SNMP_GT_coldStart					0
#define SNMP_GT_warmStart					1
#define SNMP_GT_linkDown					2
#define SNMP_GT_linkUp						3
#define SNMP_GT_authenticationFailure	4
#define SNMP_GT_egpNeighborLoss			5
#define SNMP_GT_enterpriseSpecific		6


typedef word snmp_errorcode;
#define SNMP_ERR_noError	0
#define SNMP_ERR_tooBig		1
#define SNMP_ERR_noSuchName	2
#define SNMP_ERR_badValue	3
#define SNMP_ERR_readOnly	4
#define SNMP_ERR_genErr		5

/*
 * This typedef is only for documentation purposes.  Indicates that the pointed-to data
 * is in xmem: the pointer is in the 0xE000-0xEFFF range, and the appropriate xpc value is
 * in _snmp.xpcget or _snmp.xpcput.
 */
typedef char		xmemchar;


/*
 * Data structures
 */

typedef struct {
	byte mask;				// This community access mask
	char name[SNMP_MAX_COMMUNITY_NAME+1];	// Name i.e. password
} snmp_community;

typedef struct
{
	char	version;
	word	c_index;		// Index of following name in local table
	byte	mask;			// Access mask of same entry
	char	community[SNMP_MAX_COMMUNITY_NAME+1];
	xmemchar * ptype;	// Pointer to type byte in original msg
	char	type;
	long	id;
	xmemchar* start;	// Start and end of variable bindings
	xmemchar* end;

	xmemchar* pdu_errorstatus;	// Pointer to LSB of value in original message
	xmemchar* pdu_errorindex;
	word	errorstatus;
	word	errorindex;
#ifdef SNMP_TRAPS
	int	genTrap;				// Generic trap number
	int	enterpriseTrap;	// Specific trap number
#endif

	// Variable bindings in this message
	int	variable_count;
	word	variables[SNMP_MAX_BINDINGS];	// Index of MIB tree element, or SNMP_NULL if not valid
	xmemchar * setvalue[SNMP_MAX_BINDINGS];	// Pointer to value (in input buffer) to set the variable to (SETREQ only)

} snmp_message;



// Struct used to store information about monitored variables.
typedef struct {
	word		index;			// MIB tree index of variable to monitor
	long		minval;			// Minimum and maximum normal range for variable
	long		maxval;
	char		issigned;		// 0 if comparison is unsigned (minval,maxval cast to unsigned long), else signed.
	word		minintvl;
	word		maxintvl;
	word		nmesg;
	longword	* ipaddr;		// IP address of trap message destination.  This is a pointer since all traps
									// are usually sent to the same mangagement agent.
	word		c_index;			// Community index to use (normally SNMP_TRAPDEST)
	int		trap_num;		// Trap number to send (enterprise-specific)
	word		noids;			// Number of variables in following list (1..SNMP_MAX_MON_DATA+1).  The zeroth entry
									// is the monitored variable itself.  Others are user-specified.
	word		indices[1+SNMP_MAX_MON_DATA];
	// Dynamic data...
	word		ntrans;			// Number of times message sent
	longword	nextsend;		// Time at which to send next trap (ms rel. MS_TIMER)
} snmp_monvar;

/*
 * Global struct
 */
typedef struct {
	/* The following 3 fields must be first fields in this struct! (Access from asm code) */
	unsigned short	xpcget;		// XPC value when getting a value from input buffer
	unsigned short	xpcput;		// XPC value when putting a value to output buffer
										//   (xpc for _snmp.outbuf)
	xmemchar * xmemseg;			// XPC window address of segmented form of _snmp.outbuf
	/* ---------------------------------------------------------------------------------- */

	word	next_comm;				// Next free entry
	snmp_community comm[SNMP_MAX_COMMUNITIES];
	int	state;					// State as follows
#define SNMP_S_INIT			0		// Initial
#define SNMP_S_WAITING		1		// Active and waiting for datagrams
#define SNMP_S_PAUSED		2		// Active, but currently suspended
	long	outbuf;					// Buffer for assembling outgoing datagram
	long	outbuf2;					// Buffer for UDP transmit
	word	outbuf2maxlen;			// UDP transmit buffer (maximum) length
	udp_Socket	sock;				// SNMP socket

	// These fields are for maintaining snmp timeticks, which (inconveniently) are 1/100th second
	// ticks.  Rather than adding yet another counter to the periodic interrupt, we fake it by
	// maintaining a 1/100 second count which is periodically updated to forestall wrap-around
	// problems.
	longword		ms_ref;			// Reference MS_TIMER count
	longword		tick_ref;		// Corresponding timetick counter at above ref. point
	word			upd_timeout;	// Update timeout value (ms)
	word			monitor_timeout;	// Monitor time interval counter (ms)

	// Various timetick epochs i.e. base timestamp values, to which timetick variables are referred.
	longword		start_epoch;	// Time when SNMP started.

#ifdef SNMP_TRAPS
	// Monitored variable information
 #if SNMP_MAX_MONITOR > 0
	snmp_monvar	mon[SNMP_MAX_MONITOR];
 #endif
#endif
} snmp_globals;

extern snmp_globals _snmp;

/*** EndHeader */

snmp_globals _snmp;


/*** BeginHeader snmp_add_community */
int snmp_add_community(char * cname, byte mask);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_add_community									<SNMP.LIB>

SYNTAX: int snmp_add_community(char * cname, byte mask)

KEYWORDS:      snmp, mib

DESCRIPTION:   Add a new community, cname with a given access mask, to the
               table of community names.  The size of the table is
               specified using SNMP_MAX_COMMUNITIES.  The first 3
               communities are automatically defined thus do not need to
               be added using this function.

PARAMETER1:    cname: community name as a null-terminated string with max
               length of SNMP_MAX_COMMUNITY_NAME.
PARAMETER1:    mask: access mask.  This specifies the access groups (one
               or more of 8 groups) to which this community belongs.
               Three groups are predefined:
                 SNMP_PUBLIC_MASK - public group with read-only access
                 SNMP_PRIVATE_MASK - private group with read/write access
                 SNMP_TRAPDEST_MASK - trap group with no access

RETURN VALUE:  -1: no room in table
               0..n: Number of entries in community table, after current
                 addition.  This is the community index, which is required
                 for other API functions.

SEE ALSO:      snmp_set_dflt_communities, snmp_set_community,
               snmp_community_name, snmp_community_mask
END DESCRIPTION **********************************************************/

_snmp_nodebug int snmp_add_community(char * cname, byte mask)
{
	if (_snmp.next_comm >= SNMP_MAX_COMMUNITIES)
		return -1;
	strncpy(_snmp.comm[_snmp.next_comm].name, cname, SNMP_MAX_COMMUNITY_NAME);
	_snmp.comm[_snmp.next_comm].mask = mask;
	return _snmp.next_comm++;
}



/*** BeginHeader snmp_set_dflt_communities */
int snmp_set_dflt_communities(char * public, char * private, char * trapdest);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_dflt_communities									<SNMP.LIB>

SYNTAX: int snmp_set_dflt_communities(char * public, char * private,
                                      char * trapdest)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the name (i.e. password string) of the first 3 default
               communities.  These communities are assigned the following
               access masks:
                 public: SNMP_PUBLIC_MASK - read-only access
                 private: SNMP_PRIVATE_MASK - read/write access
                 trapdest: SNMP_TRAPDEST_MASK - no local access, used when
                   sending traps to the network management agent.
               This function should be called once when the application
               in initialized.

               All parameters are null-terminated strings, with a maximum
               length of SNMP_MAX_COMMUNITY_NAME.

PARAMETER1:    public access password.
PARAMETER2:    private access password.
PARAMETER3:    trap password sent with trap messages.

RETURN VALUE:  0.

SEE ALSO:      snmp_add_community, snmp_set_community,
               snmp_community_name, snmp_community_mask
END DESCRIPTION **********************************************************/

_snmp_nodebug int snmp_set_dflt_communities(char * public, char * private, char * trapdest)
{
	strncpy(_snmp.comm[SNMP_PUBLIC].name, public, SNMP_MAX_COMMUNITY_NAME);
#if SNMP_MAX_COMMUNITIES >= 2
	strncpy(_snmp.comm[SNMP_PRIVATE].name, private, SNMP_MAX_COMMUNITY_NAME);
#endif
#ifdef SNMP_TRAPS
 #if SNMP_MAX_COMMUNITIES >= 3
	strncpy(_snmp.comm[SNMP_TRAPDEST].name, trapdest, SNMP_MAX_COMMUNITY_NAME);
 #endif
#endif
	return 0;
}



/*** BeginHeader snmp_set_community */
int snmp_set_community(word c_index, char * cname, byte mask);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_community									<SNMP.LIB>

SYNTAX: int snmp_set_community(word c_index, char * cname, byte mask)

KEYWORDS:      snmp, mib

DESCRIPTION:   Change the name (password string) and access mask for the
               community indexed by c_index.

PARAMETER1:    Community table index.  This is the value returned by
               snmp_add_community(), or may be SNMP_PUBLIC, SNMP_PRIVATE
               or SNMP_TRAPDEST for the predefined default communities.
PARAMETER2:    Community name as a null-terminated string with max
               length of SNMP_MAX_COMMUNITY_NAME.
PARAMETER3:    Access mask.  This specifies the access groups (one
               or more of 8 groups) to which this community belongs.
               Three groups are predefined:
                 SNMP_PUBLIC_MASK - public group with read-only access
                 SNMP_PRIVATE_MASK - private group with read/write access
                 SNMP_TRAPDEST_MASK - trap group with no access.

RETURN VALUE:  -1: the supplied index was outside the table bounds.
               Otherwise, returns the c_index parameter.

SEE ALSO:      snmp_add_community, snmp_set_dflt_communities,
               snmp_community_name, snmp_community_mask
END DESCRIPTION **********************************************************/

_snmp_nodebug int snmp_set_community(word c_index, char * cname, byte mask)
{
	if (c_index >= SNMP_MAX_COMMUNITIES)
		return -1;
	strncpy(_snmp.comm[c_index].name, cname, SNMP_MAX_COMMUNITY_NAME);
	_snmp.comm[c_index].mask = mask;
	return c_index;
}



/*** BeginHeader snmp_community_name */
char * snmp_community_name(word c_index, int * length);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_community_name									<SNMP.LIB>

SYNTAX: char * snmp_community_name(word c_index, int * length)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the name and, optionally, the length of the
               specified community.

PARAMETER1:    Community table index.  This is the value returned by
               snmp_add_community(), or may be SNMP_PUBLIC, SNMP_PRIVATE
               or SNMP_TRAPDEST for the predefined default communities.
PARAMETER2:    If not NULL, then the addressed location will be set with
               the community name string length.

RETURN VALUE:  NULL: the index was outside the table bounds.
               Otherwise, a pointer to the community name is returned.
               The data at this location should not be modified.

SEE ALSO:      snmp_add_community, snmp_set_dflt_communities,
               snmp_set_community, snmp_community_mask
END DESCRIPTION **********************************************************/

_snmp_nodebug char * snmp_community_name(word c_index, int * length)
{
	if (c_index >= SNMP_MAX_COMMUNITIES)
		return NULL;
	if (length)
		*length = strlen(_snmp.comm[c_index].name);
	return _snmp.comm[c_index].name;
}



/*** BeginHeader snmp_community_mask */
int snmp_community_mask(word c_index);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_community_mask									<SNMP.LIB>

SYNTAX: int snmp_community_mask(word c_index)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the community access mask of the specified
               community.

PARAMETER1:    Community table index.  This is the value returned by
               snmp_add_community(), or may be SNMP_PUBLIC, SNMP_PRIVATE
               or SNMP_TRAPDEST for the predefined default communities.

RETURN VALUE:  -1: the index was outside the table bounds.
               Otherwise, returns a value 0..255.

SEE ALSO:      snmp_add_community, snmp_set_dflt_communities,
               snmp_set_community, snmp_community_name
END DESCRIPTION **********************************************************/

_snmp_nodebug int snmp_community_mask(word c_index)
{
	if (c_index >= SNMP_MAX_COMMUNITIES)
		return -1;
	return _snmp.comm[c_index].mask;
}



/*** BeginHeader snmp_stop */
int snmp_stop(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_stop									<SNMP.LIB>

SYNTAX: int snmp_stop(void)

KEYWORDS:      snmp, mib

DESCRIPTION:   Temporarily suspend network access to the SNMP subsystem.
               Incoming SNMP messages are received but ignored while in
               the stopped state.  If the stopped state is maintained
               for less than about 1 second, then external agents will
               retransmit the request.  Otherwise, they may give up.

               This function is used when there is a substantial amount
               of MIB tree processing to be performed locally, and it
               is also desired to prevent asynchronous access to the
               MIB tree (e.g. to prevent race conditions).

RETURN VALUE:  0.

SEE ALSO:      snmp_start
END DESCRIPTION **********************************************************/

_snmp_nodebug int snmp_stop(void)
{
	_snmp.state |= SNMP_S_PAUSED;
	return 0;
}


/*** BeginHeader snmp_start */
int snmp_start(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_start									<SNMP.LIB>

SYNTAX: int snmp_start(void)

KEYWORDS:      snmp, mib

DESCRIPTION:   Restart the SNMP subsystem after calling snmp_stop().

RETURN VALUE:  0.

SEE ALSO:      snmp_stop
END DESCRIPTION **********************************************************/

_snmp_nodebug int snmp_start(void)
{
	_snmp.state &= ~SNMP_S_PAUSED;
	return 0;
}


/*** BeginHeader snmp_timeticks */
longword snmp_timeticks(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_timeticks									<SNMP.LIB>

SYNTAX: longword snmp_timeticks(void)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the current SNMP "timeticks" count.

RETURN VALUE:  Number of 1/100 second intervals since the application
               started.  This value counts from 0 to 2**31-1, then wraps
               around to zero.

SEE ALSO:      snmp_time_since
END DESCRIPTION **********************************************************/

_snmp_nodebug longword snmp_timeticks(void)
{
	auto long L;
	L = (word)(MS_TIMER - _snmp.ms_ref) / 10 + _snmp.tick_ref;
	return L & 0x7FFFFFFF;
}


/*** BeginHeader snmp_time_since */
longword snmp_time_since(longword epoch);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_time_since									<SNMP.LIB>

SYNTAX: longword snmp_time_since(longword epoch)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the number of SNMP "timeticks" elapsed since a
               specified "epoch".

PARAMETER1:    The reference epoch.  This should be a value obtained
               by a previous call to snmp_timeticks().

RETURN VALUE:  Number of 1/100 second intervals since "epoch".  This value
               counts from 0 to 2**31-1, then wraps around to zero.

SEE ALSO:      snmp_timeticks
END DESCRIPTION **********************************************************/

_snmp_nodebug longword snmp_time_since(longword epoch)
{
	auto long L;
	L = (word)(MS_TIMER - _snmp.ms_ref) / 10 + _snmp.tick_ref - epoch;
	return L & 0x7FFFFFFF;
}


/*** BeginHeader snmp_trap */
int snmp_trap(longword ipaddr, word c_index, int trap_num, word noids, word * indices);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_trap									<SNMP.LIB>

SYNTAX: int snmp_trap(longword ipaddr, word c_index, int trap_num,
                      word noids, word * indices)

KEYWORDS:      snmp, mib

DESCRIPTION:   Send an SNMPv1 trap message.  Traps are unsolicited
               messages sent to a network management agent, for example
               to inform the agent about an unusual condition.  Traps
               are not delivered reliably i.e. the message may be lost
               in the network.  There is no acknowledgement of trap
               receipt by the agent.

               You must #define SNMP_TRAPS to use this function.

PARAMETER1:    IP address of network management agent.
PARAMETER2:    Community table index.  This is the value returned by
               snmp_add_community(), or may be SNMP_TRAPDEST for the
               predefined default trap destination community.
PARAMETER3:    Trap number to use.  This must be >= 0.  Negative numbers
               are reserved for SNMP predefined trap types.  Otherwise,
               generic traps are sent.
PARAMETER4:    Number of MIB tree indices in the following list (may be
               zero).  This must be less than or equal SNMP_MAX_BINDINGS.
PARAMETER5:    Array of MIB tree indices.  Each element in this array is
               the MIB tree index of an object to send with the trap
               message.  Tree indices may be obtained using
               snmp_last_index() and other MIB functions.

RETURN VALUE:  -1: error, trap not sent because there was an error
               constructing the message (probably because too many or
               too long variables were specified), or because the
               message could not be sent using UDP.
               Otherwise, length of constructed message returned.

SEE ALSO:      snmp_monitor
END DESCRIPTION **********************************************************/

#ifndef SNMP_TRAPS
	#fatal "SNMP: cannot use snmp_trap() unless SNMP_TRAPS defined"
#endif

_snmp_nodebug int snmp_trap(longword ipaddr, word c_index, int trap_num, word noids, word * indices)
{
	auto snmp_message msg;
	auto xmemchar * end;
	auto int rval;
	auto word length;
	auto int iface;

	msg.type = SNMP_TRAPREQ;
	strcpy(msg.community, _snmp.comm[c_index].name);
	if (trap_num <= 0) {
		msg.genTrap = -trap_num;
		msg.enterpriseTrap = 0;
	}
	else {
		msg.genTrap = SNMP_GT_enterpriseSpecific;
		msg.enterpriseTrap = trap_num;
	}
	if (noids > SNMP_MAX_BINDINGS)
		noids = SNMP_MAX_BINDINGS;
	msg.variable_count = noids;
	memcpy(msg.variables, indices, noids<<1);

	iface = ip_iface(ipaddr, 0);
	if (iface == IF_ANY)
		iface = IF_DEFAULT;
	if ((end=_snmp_processmessage(_snmp.xmemseg,_snmp.xmemseg + SNMP_MAX_DATA,&msg,iface))) {
		if ((rval=udp_sendto(&_snmp.sock,(void __far *)_snmp.outbuf,length=end-_snmp.xmemseg,ipaddr,SNMP_TRAP_PORT))<(int)length) {
#ifdef SNMP_VERBOSE
			printf("SNMP: socket error sending trap (%d)\n",rval);
#endif
		}
#ifdef SNMP_VERBOSE
		else if (debug_on) printf("SNMP: sent trap length=%u\n", length);
#endif
	}
	else rval = -1;
	return rval;
}


/*** BeginHeader snmp_monitor */
int snmp_monitor(
			word index, long minval, long maxval, word minintvl, word maxintvl, word nmesg,
			longword * ipaddr, word c_index, int trap_num, word noids, word * indices
			);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_monitor									<SNMP.LIB>

SYNTAX: int snmp_monitor(word index, long minval, long maxval,
                         word minintvl, word maxintvl, word nmesg,
			                longword * ipaddr, word c_index, int trap_num,
			                word noids, word * indices)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set up automatic monitoring of a specified managed object.
               This monitors the object (which must be integer type), so
               that if the object goes outside the specified lower and
               upper bound, trap messages will be sent.

               This function overcomes some of the limitations of the
               normal snmp_trap() mechanism, in that it performs automatic
               retransmissions to practically ensure that the network
               management agent notices the condition.

               The managed object must exist in the MIB tree, and must
               not be deleted while it is being monitored.  Any given
               object can only be monitored once.  If the object is
               already being monitored, a call to this function with
               the same object (index) will change the monitor settings
               for that object.

               You must #define SNMP_TRAPS to use this function.

               The maximum number of different objects which may be
               monitored is specified by SNMP_MAX_MONITOR.

               When an object is monitored, it is periodically examined
               (at intervals of SNMP_MIN_TRAP_INTVL milliseconds).  If,
               at the time of examination, the object is outside the
               specified bounds then trap message are initiated.  After
               the first message is sent, another message will be sent
               minintvl seconds later.  Subsequent messages are sent
               at doubling time intervals up to a maximum of maxintvl.
               A maximum of nmesg messages will be sent for any "event".
               The time intervals and message counters are reset as soon
               as the object goes back inside the specified range.

PARAMETER1:    index: MIB tree index of the object to monitor.  This value
               may be obtained when the object is created, by calling
               snmp_last_index().
PARAMETER2:    minval: Minimum allowed value of object.
PARAMETER3:    maxval: Maximum allowed value of object.  If the object is
               stored with an SNMP type of SNMP_P_INTEGER, then the
               comparisons are done using signed arithmetic.  All other SNMP
               types are assumed to be unsigned, so unsigned arithmetic is
               performed.
PARAMETER4:    minintvl: Minimum interval, in seconds, between successive
               trap messages if the object goes outside the specified
               bounds.
PARAMETER5:    maxintvl: Maximum interval, in seconds, between messages.
PARAMETER6:    nmesg: Maximum number of messages to send while an object
               is outside bounds.  The message count is reset when the
               variable goes back inside bounds.
PARAMETER7:    ipaddr: address of the IP address of the network management
               agent to which trap messages should be directed.  A pointer
               is used for this parameter to allow sharing the same
               destination address between multiple monitor calls.  The
               pointer must point to static storage.
PARAMETER8:    c_index: Community table index.  This is the value returned
               by snmp_add_community(), or may be SNMP_TRAPDEST for the
               predefined default trap destination community.
PARAMETER9:    trap_num: Trap number to use.  This must be >= 0.  Negative
               numbers are reserved for SNMP predefined trap types.
               Otherwise, generic traps are sent.
PARAMETER10:   noids: Number of MIB tree indices in the following list (may
               be zero).  This must be less than or equal SNMP_MAX_BINDINGS.
PARAMETER11:   indices: Array of MIB tree indices.  Each element in this
               array is the MIB tree index of an object to send with the
               trap message.  Tree indices may be obtained using
               snmp_last_index() and other MIB functions.

RETURN VALUE:  -1: insufficient room in monitor table.
               -2: inappropriate object specified for monitoring (i.e.
                 it is not an integer type).  This will only be returned
                 if SNMP_DEBUG is defined, otherwise the check is not
                 performed.
               Otherwise: returns the monitor table index used for this
               object (0..SNMP_MAX_MONITOR-1).

SEE ALSO:      snmp_unmonitor, snmp_trap
END DESCRIPTION **********************************************************/

#ifndef SNMP_TRAPS
	#fatal "SNMP: cannot use snmp_monitor() unless SNMP_TRAPS defined"
#endif

_snmp_nodebug int snmp_monitor(
			word index, long minval, long maxval, word minintvl, word maxintvl, word nmesg,
			longword * ipaddr, word c_index, int trap_num, word noids, word * indices
			)
{
	auto mib_tree t;
	auto word i;
	auto snmp_monvar * mv;

	_mib_get_node(&t, index);
#ifdef SNMP_DEBUG
	// Check for valid data to monitor.  Must be a leaf node, with integer type.
	if (!(t.u.leaf.flags & MIB_LEAF) ||
		 (t.u.leaf.flags & MIB_TYPEMASK) != SNMP_SHORT &&
		 (t.u.leaf.flags & MIB_TYPEMASK) != SNMP_LONG) {
	#ifdef SNMP_VERBOSE
		printf("SNMP: snmp_monitor(%u): bad index\n", index);
	#endif
		return -2;
	}
#endif

#if SNMP_MAX_MONITOR > 0
	for (i = 0; i < SNMP_MAX_MONITOR; i++)
		if (_snmp.mon[i].index == index)
			goto found;
	for (i = 0; i < SNMP_MAX_MONITOR; i++)
		if (_snmp.mon[i].index == SNMP_NULL) {
found:
			mv = _snmp.mon + i;
			mv->index = index;
			mv->minval = minval;
			mv->maxval = maxval;
			mv->issigned = (t.u.leaf.flags & MIB_SNMPMASK) == SNMP_P_INTEGER << 4;
			mv->minintvl = minintvl;
			mv->maxintvl = maxintvl;
			mv->nmesg = nmesg;
			mv->ipaddr = ipaddr;
			mv->c_index = c_index;
			mv->trap_num = trap_num;
			if (noids > SNMP_MAX_MON_DATA)
				noids = SNMP_MAX_MON_DATA;
			mv->noids = noids+1;
			memcpy(mv->indices + 1, indices, noids << 1);
			mv->indices[0] = index;
			mv->ntrans = 0;
			return (int)i;
		}
#endif
	return -1;
}


/*** BeginHeader snmp_unmonitor */
int snmp_unmonitor(word index);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_unmonitor									<SNMP.LIB>

SYNTAX: int snmp_unmonitor(word index)

KEYWORDS:      snmp, mib

DESCRIPTION:   Stop monitoring the object that was previously monitored
               by snmp_monitor().  This function must be used if the
               object being monitored is to be deleted from the MIB tree.

               You must #define SNMP_TRAPS to use this function.

PARAMETER1:    index: MIB tree index of the object to unmonitor.

RETURN VALUE:  -1: the object is not currently being monitored.
               Otherwise returns the monitor table index.

SEE ALSO:      snmp_monitor, snmp_trap
END DESCRIPTION **********************************************************/

#ifndef SNMP_TRAPS
	#fatal "SNMP: cannot use snmp_unmonitor() unless SNMP_TRAPS defined"
#endif

_snmp_nodebug int snmp_unmonitor(word index)
{
	auto word i;

#if SNMP_MAX_MONITOR > 0
	for (i = 0; i < SNMP_MAX_MONITOR; i++)
		if (_snmp.mon[i].index == index) {
			_snmp.mon[i].index = SNMP_NULL;
			return (int)i;
		}
#endif
	return -1;
}

/*
 * xmem access routines
 */

/*** BeginHeader _snmp_gc, _snmp_pc, _snmp_gcs, _snmp_pcs */
__xmem int _snmp_gc(xmemchar * p);							// Get byte
__xmem xmemchar * _snmp_pc(xmemchar * p, int val);	// Put byte (returns p)
__xmem xmemchar * _snmp_gcs(xmemchar * p, char * q, word len);	// Get bytes p->q (returns incremented source addr, p+len)
__xmem char * _snmp_pcs(xmemchar * p, char * q, word len);	// Put bytes q->p (returns incremented source addr, q+len)
/*** EndHeader */

#asm __xmem
_snmp_gc::
	ex		jk',hl
	ld		hl,(_snmp+[snmp_globals]+xpcget)
	ex		jk,hl
	ex		jk',hl
	jp		_xmem_gc			; jump (it will LRET)

_snmp_pc::
	ex		jk',hl
	ld		hl,(_snmp+[snmp_globals]+xpcput)
	ex		jk,hl
	ex		jk',hl
	ex		de,hl
	ld		hl,(sp+5)		; val
	ex		de,hl
	jp		_xmem_pc			; jump (it will LRET)

_snmp_gcs::
	ex		jk',hl
	ld		hl,(_snmp+[snmp_globals]+xpcget)
	ex		jk,hl
	ex		jk',hl
	ex		de,hl				; DE = source addr (xpc window)
	ld		hl,(sp+7)		; Length
	ld		bc,hl
	ld		hl,(sp+5)		; Dest address (conventional root)
	ex		de,hl
	jp		_xmem_mvc		; jump (it will LRET)

_snmp_pcs::
	ex		jk',hl
	ld		hl,(_snmp+[snmp_globals]+xpcput)
	ex		jk,hl
	ex		jk',hl
	ex		de,hl				; DE = dest addr (xpc window)
	ld		hl,(sp+7)		; Length
	ld		bc,hl
	ld		hl,(sp+5)		; Source address (conventional root)
	jp		_xmem_mvc		; jump (it will LRET)

#endasm

/*** BeginHeader _snmp_parselength */
xmemchar* _snmp_parselength(xmemchar* start, xmemchar* end, word* length);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parselength(xmemchar* start, xmemchar* end, word* length)
{
	auto word val, tmp;

	if(start==NULL)
		return NULL;

	if((tmp = _snmp_gc(start++)) & 0x80) {
		val = *length = 0;
		tmp &= 0x7f;
		while (tmp--) {
			if (val & 0xff00u)
				return NULL;
			val = val << 8 | _snmp_gc(start++);
		}
	}
	else
		val = tmp;

	// No length can be over 4k
	if (start > end || val >= 4096)
		return NULL;

	*length = val;
	return start;
}

/*** BeginHeader _snmp_parseunsigned */
xmemchar* _snmp_parseunsigned(xmemchar* start, xmemchar* end, void* value, int valuebytes);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parseunsigned(xmemchar* start, xmemchar* end, void* value, int valuebytes)
{
	// This parses as if expected value is unsigned, but in fact requires the SNMP data
	// type to be 'integer' i.e. signed.
	auto word length,x;
	auto longword val;

	if(start==NULL || _snmp_gc(start++)!=SNMP_P_INTEGER)
		return NULL;

	start=_snmp_parselength(start,end,&length);

	if(start==NULL || (start+length)>end)
		return NULL;

	val=0;
	for(x=0;x<length;x++) {
		if(val&0xff000000uL)
			return NULL;
		val=(val<<8)|_snmp_gc(start++);
	}

	switch(valuebytes)
	{
		case 1:
			*((char*)value)=(char)val;
			break;

		case 2:
			*((word*)value)=(word)val;
			break;

		case 4:
			*((longword*)value)=val;
			break;

		default:
			return NULL;
	}

	return start;
}

/*** BeginHeader _snmp_parseoctetstr */
xmemchar* _snmp_parseoctetstr(xmemchar* start, xmemchar* end, char* value, int maxlen);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parseoctetstr(xmemchar* start, xmemchar* end, char* value, int maxlen)
{
	auto word length;

	if(start==NULL)
		return NULL;

	if(_snmp_gc(start++)!=SNMP_P_OCTETSTR)
		return NULL;

	start=_snmp_parselength(start,end,&length);

	if(start==NULL || (start+length)>end || length>(maxlen-1))
		return NULL;

	if (length)
		start = _snmp_gcs(start, value, length);
	value[length]=0;
	return start;
}

/*** BeginHeader _snmp_parsesequence */
xmemchar* _snmp_parsesequence(xmemchar* start, xmemchar* end, xmemchar** startseq, int* length);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsesequence(xmemchar* start, xmemchar* end, xmemchar** startseq, int* length)
{
	auto word _length;

	if(start==NULL)
		return NULL;

	if(_snmp_gc(start++)!=SNMP_P_SEQ)
		return NULL;

	start=_snmp_parselength(start,end,&_length);

	if(start==NULL || (start+_length)>end)
		return NULL;

	*startseq=start;

	if(length)
		*length=_length;

	return start+_length;
}

/*** BeginHeader _snmp_parsenull */
xmemchar* _snmp_parsenull(xmemchar* start, xmemchar* end);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsenull(xmemchar* start, xmemchar* end)
{
	if(start==NULL || (start+1)>end || _snmp_gc(start++)!=0)
		return NULL;

	return start;
}

/*** BeginHeader _snmp_ber2rler */
int _snmp_ber2rler(snmp_oid * oid, char * name, word namelen);
/*** EndHeader */

_snmp_nodebug int _snmp_ber2rler(snmp_oid * oid, char * name, word namelen)
{
	auto char * d, * s, * de, * se;
	auto oidlevel L;

	d = oid->oid;
	de = d + SNMP_MAX_NAME;
	s = name;
	se = s + namelen;
	while (s < se && d < de) {
		if (*s < 128)
			*d++ = *s++;
		else {
			L = 0;
			do {
				L = (L<<7) + (*s & 0x7F);
			} while (*s++ & 0x80 && s < se);
			if (L < 0xFEuL)
				*d++ = (char)L;
			else if (L < 0x10000uL) {
				*d++ = 0xFE;
				*d++ = (char)(L >> 8);
				*d++ = (char)L;
				*d++ = 0xFE;
			}
			else {
				*d++ = 0xFF;
				*(long *)d = intel(L);
				d += 4;
				*d++ = 0xFF;
			}
		}
	}
	if (d > de)
		return 1;
	oid->len = d - oid->oid;
	return 0;
}

/*** BeginHeader _snmp_parsevariable */
xmemchar* _snmp_parsevariable(xmemchar* start, xmemchar* end, snmp_message* msg);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsevariable(xmemchar* start, xmemchar* end, snmp_message* msg)
{
	auto char name[SNMP_MAX_NAME*2];
	auto snmp_parms p;
	auto word namelen;
	auto word index;
	auto int stype, ok;
	auto snmp_type vtype;
	auto word slen;

	if(start==NULL || _snmp_gc(start++)!=SNMP_P_OID)
		return NULL;

	namelen = _snmp_gc(start++);
	if (namelen > sizeof(name) || start + namelen >= end) {
#ifdef SNMP_VERBOSE
		printf("SNMP: var name too long\n");
#endif
		return NULL;
	}
	if (namelen)
		_snmp_gcs(start, name, namelen);
	// Translate from BER to RLER for our database
	if (_snmp_ber2rler(&p.stem, name, namelen))
		index = SNMP_NULL;
	else {
		if (msg->type == SNMP_GETNEXTREQ) {
			do {
				index = snmp_last_index(snmp_get_next(&p));
			} while (index != SNMP_NULL && !(p.last.u.leaf.rdmask & msg->mask));
		}
		else {
			index = snmp_last_index(snmp_get(&p));
			if (msg->type == SNMP_GETREQ) {
				if (!(p.last.u.leaf.rdmask & msg->mask))
					index = SNMP_NULL;
			}
			else if (msg->type == SNMP_SETREQ) {
				if (!(p.last.u.leaf.wrmask & msg->mask))
					index = SNMP_NULL;
			}
		}
	}
	msg->variables[msg->variable_count++] = index;
	if (index == SNMP_NULL) {
		msg->errorstatus = SNMP_ERR_noSuchName;
		msg->errorindex = msg->variable_count;
#ifdef SNMP_VERBOSE
		printf("SNMP: var %s not found\n", snmp_format_oid(&p.stem));
#endif
	}
	start += namelen;
	if (msg->type == SNMP_SETREQ && !msg->errorstatus) {
		vtype = snmp_last_type(&p);
		msg->setvalue[msg->variable_count-1] = start;
		stype = _snmp_gc(start++);
		start = _snmp_parselength(start, end, &slen);
		if (!start)
			return NULL;
		switch (stype) {
			case SNMP_P_INTEGER:
			case SNMP_P_COUNTER:
			case SNMP_P_GAUGE:
			case SNMP_P_TIMETICKS:
				ok =	vtype == SNMP_SHORT ||
						vtype == SNMP_LONG;
				break;
			case SNMP_P_OCTETSTR:
				ok =	vtype == SNMP_OCT && slen < p.last.u.leaf.maxlen-1 ||
						vtype == SNMP_FOCT && slen == p.last.u.leaf.maxlen ||
						vtype == SNMP_STR && p.last.u.leaf.maxlen >= slen;
				break;
			case SNMP_P_OID:
				ok =	vtype == SNMP_OID;
				break;
			case SNMP_P_IPADDR:
				ok =	slen == 4 && (vtype == SNMP_LONG || vtype == SNMP_FOCT && p.last.u.leaf.maxlen == 4);
				break;
			default:
				ok = 0;
		}
		if (!ok) {
			msg->errorstatus = SNMP_ERR_badValue;
			msg->errorindex = msg->variable_count;
#ifdef SNMP_VERBOSE
			printf("SNMP: var %s bad value\n", snmp_format_oid(&p.stem));
#endif
		}
	}
	return start;
}


/*** BeginHeader _snmp_parsevarbinding */
xmemchar* _snmp_parsevarbinding(xmemchar* start, xmemchar* end, snmp_message* msg);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsevarbinding(xmemchar* start, xmemchar* end, snmp_message* msg)
{
	auto int length;
	auto xmemchar *start_seq, *end_seq;

	if (!start)
		return NULL;

	end_seq=_snmp_parsesequence(start,end,&start_seq,&length);

	if (!msg->errorstatus) {
		if (msg->variable_count < SNMP_MAX_BINDINGS)
			start_seq = _snmp_parsevariable(start_seq, end_seq, msg);
		else {
			msg->errorstatus = SNMP_ERR_tooBig;
#ifdef SNMP_VERBOSE
			printf("SNMP: more than %u variable bindings\n", msg->variable_count);
#endif
		}
	}

	return end_seq;
}

/*** BeginHeader _snmp_parsevarbindings */
xmemchar* _snmp_parsevarbindings(xmemchar* start, xmemchar* end, snmp_message* msg);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsevarbindings(xmemchar* start, xmemchar* end, snmp_message* msg)
{
	auto int length;
	auto xmemchar *start_seq, *end_seq;

	if(start==NULL)
		return NULL;

	end_seq=_snmp_parsesequence(start,end,&start_seq,&length);

	msg->variable_count=0;

	if(end_seq!=NULL) {
		while(start_seq!=NULL && start_seq<end_seq)
			start_seq=_snmp_parsevarbinding(start_seq,end_seq,msg);
	}

	return end_seq;
}

/*** BeginHeader _snmp_parsepdu */
xmemchar* _snmp_parsepdu(xmemchar* start, xmemchar* end, snmp_message* msg);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsepdu(xmemchar* start, xmemchar* end, snmp_message* msg)
{
	auto char type;
	auto word length;

	if(start==NULL)
		return NULL;

	msg->ptype = start;
	msg->type=_snmp_gc(start++);
	start=_snmp_parselength(start,end,&length);

	if(start==NULL || (start+length)>end)
		return NULL;

	switch(msg->type) {
		case SNMP_GETREQ:
		case SNMP_SETREQ:
		case SNMP_GETNEXTREQ:
			start = _snmp_parseunsigned(start,end,&msg->id,4);
			msg->pdu_errorstatus = (start=_snmp_parseunsigned(start,end,&msg->errorstatus,2)) - 1;
			if (msg->errorstatus!=0) return NULL;
			msg->pdu_errorindex = (start=_snmp_parseunsigned(start,end,&msg->errorindex,2)) - 1;
			if (msg->errorindex!=0) return NULL;
			msg->start = start;
			start = msg->end = _snmp_parsevarbindings(start,end,msg);
			break;

		default:
			return NULL;
	}

	return start;
}

/*** BeginHeader _snmp_parsemessage */
xmemchar* _snmp_parsemessage(xmemchar* start, xmemchar* end, snmp_message* msg);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_parsemessage(xmemchar* start, xmemchar* end, snmp_message* msg)
{
	auto xmemchar *start_seq, *end_seq;
	auto int length;
	auto word c_index;

	end_seq=_snmp_parsesequence(start,end,&start_seq,&length);

	if(end_seq==NULL) {
#ifdef SNMP_VERBOSE
		printf("SNMP: bad initial sequence\n");
#endif
		return NULL;
	}

	start_seq=_snmp_parseunsigned(start_seq,end_seq,&msg->version,1);
	if (msg->version != 0) {
#ifdef SNMP_VERBOSE
		printf("SNMP: not version 1\n");
#endif
		return NULL;
	}
	start_seq=_snmp_parseoctetstr(start_seq,end_seq,msg->community,SNMP_MAX_COMMUNITY_NAME);
	msg->community[SNMP_MAX_COMMUNITY_NAME] = 0;	// Ensure null termination
	for (c_index = 0; c_index < _snmp.next_comm; c_index++)
		if (!strcmp(msg->community, _snmp.comm[c_index].name))
			break;
	if (c_index == _snmp.next_comm) {
#ifdef SNMP_VERBOSE
		printf("SNMP: unknown community '%s'\n", msg->community);
#endif
		return NULL;				// Community name not found
	}
	msg->mask = _snmp.comm[c_index].mask;

	start_seq=_snmp_parsepdu(start_seq,end_seq,msg);

	if(start_seq==NULL) {
#ifdef SNMP_VERBOSE
		printf("SNMP: error parsing PDU\n");
#endif
		return NULL;
	}
#ifdef SNMP_VERBOSE
	else {
		printf("SNMP: version=%d,community='%s',id=%08lx,type=%02x\n",
			msg->version+1,
			msg->community,
			msg->id,
			msg->type);
		if (debug_on >= 4) {
			printf("SNMP: pdu data = ");
			for(start_seq=msg->start;start_seq<msg->end;start_seq++)
				printf("%02x ",_snmp_gc(start_seq));
			printf("\n");
		}
	}
#endif
	return end_seq;
}



/*** BeginHeader _snmp_buildlength */
xmemchar* _snmp_buildlength(xmemchar* start, xmemchar* end, word value);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildlength(xmemchar* start, xmemchar* end, word value)
{
	auto word x;

	if (start==NULL)
		return NULL;

	if (value<0x80) x=1;
	else x=2;

	if ((start+x+1)>=end)
		return NULL;

	if (x==1)
		_snmp_pc(start++, (int)value);
	else {
		_snmp_pc(start++, 0x82);
		_snmp_pc(start++, (int)(value>>8));
		_snmp_pc(start++, (int)value);
	}
	return start;
}

/*** BeginHeader _snmp_buildint */
xmemchar* _snmp_buildint(xmemchar* start, xmemchar* end, unsigned long value, int type);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildint(xmemchar* start, xmemchar* end, unsigned long value, int type)
{
	auto word x;

	if (start==NULL || (start+5)>=end)
		return NULL;

	if (type == SNMP_P_IPADDR) x = 4;
	else if (value<0x80uL) x=1;
	else if (value<0x8000uL) x=2;
	else x=4;

	_snmp_pc(start++, type);
	_snmp_pc(start++, x);
	value = intel(value);
	_snmp_pcs(start, (char *)&value + 4 - x, x);
	return start+x;
}

/*** BeginHeader _snmp_buildoctetstr */
xmemchar* _snmp_buildoctetstr(xmemchar* start, xmemchar* end, char* str, word length, int type);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildoctetstr(xmemchar* start, xmemchar* end, char* str, word length, int type)
{
	if(start==NULL || (start+3+length)>=end)
		return NULL;

	_snmp_pc(start++, type);
	start=_snmp_buildlength(start,end,length);

	if(length) {
		_snmp_pcs(start, str, length);
		start+=length;
	}

	return start;
}

/*** BeginHeader _snmp_buildsequence */
xmemchar* _snmp_buildsequence(xmemchar* start, xmemchar* end, xmemchar** length_fixup, word length, int sequence_ch);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildsequence(xmemchar* start, xmemchar* end, xmemchar** length_fixup, word length, int sequence_ch)
{
	if(start==NULL)
		return NULL;

	if(length>1) {
		if((start+4)<end) {
			_snmp_pc(start++, sequence_ch);

			if(length_fixup)
				*length_fixup=start;
			_snmp_pcs(start, "\x82\x00\x00", 3);
			return start + 3;
		}
	} else if(start<end) {
		_snmp_pc(start, 0x00);
		return start + 1;
	}

	return NULL;
}

/*** BeginHeader _snmp_fixupsequence */
xmemchar* _snmp_fixupsequence(xmemchar* length_fixup, xmemchar* end);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_fixupsequence(xmemchar* length_fixup, xmemchar* end)
{
	auto int diff;
	auto unsigned short xpc;
	auto int lenflag;

	if(length_fixup==NULL || end==NULL)
		return NULL;

	// Temporarily swap xpcs, since reading from output buffer
	xpc = _snmp.xpcget;
	_snmp.xpcget = _snmp.xpcput;
	lenflag = _snmp_gc(length_fixup);	// Get length flag stored in output buffer
	_snmp.xpcget = xpc;

	if(lenflag==0x81) {
		diff=(end-length_fixup)-2;
		length_fixup++;
		_snmp_pc(length_fixup, diff);
	} else if (lenflag==0x82) {
		diff=(end-length_fixup)-3;
		length_fixup++;
		_snmp_pc(length_fixup++, diff>>8);
		_snmp_pc(length_fixup, diff);
	} else {
		diff = (end-length_fixup)-1;
		if(diff<128)
			_snmp_pc(length_fixup, diff);
		else
			return NULL;
	}

	return end;
}

/*** BeginHeader _snmp_buildoid */
xmemchar* _snmp_buildoid(xmemchar* start, xmemchar* end, char* name, word name_length);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildoid(xmemchar* start, xmemchar* end, char* name, word name_length)
{
	if((start+3+name_length)>=end)
		return NULL;


	_snmp_pc(start++, SNMP_P_OID);
	start=_snmp_buildlength(start,end,name_length);

	if (name_length)
		_snmp_pcs(start, name, name_length);

	return start+name_length;
}

/*** BeginHeader _snmp_rler2ber */
word _snmp_rler2ber(snmp_oid * oid, char * name);
/*** EndHeader */

_snmp_nodebug word _snmp_rler2ber(snmp_oid * oid, char * name)
{
	auto char * s, * se, * d, * de;
	auto oidlevel v;
	auto word rlen;

	// Translate from RLER to BER encoding of OID.
	s = oid->oid;
	se = s + oid->len;
	d = name;
	while (s < se) {
		if (*s < 0x80)
			*d++ = *s++;
		else {
			if (*s < 0xFE)
				v = *s++;
			else if (*s == 0xFE) {
				v = intel16(*(word *)(s+1));
				s += 4;
			}
			else {
				v = intel(*(longword *)(s+1));
				s += 6;
			}
			if (v < (1uL<<14))
				rlen = 1;
			else if (v < (1uL<<21))
				rlen = 2;
			else if (v < (1uL<<28))
				rlen = 3;
			else
				rlen = 4;
			d += rlen;
			de = d + 1;
			*d = (byte)v & 0x7F;
			while (rlen--) {
				v >>= 7;
				*--d = (byte)v | 0x80;
			}
			d = de;
		}
	}
	return d - name;
}

/*** BeginHeader _snmp_setvars */
int _snmp_setvars(snmp_parms * p, snmp_message * msg, int commit, char * buf, word buflen);
/*** EndHeader */

_snmp_nodebug int _snmp_setvars(snmp_parms * p, snmp_message * msg, int commit, char * buf, word buflen)
{
	// Set variables.  Done in two stages (commit=0 followed by commit=1).
	// In the first stage, the callback routine (if any) may reject the
	// update.  If there is any reject, the second stage is not performed.
	// Otherwise, the second stage is performed with no check for errors.
	// If a variable has no callback function, then the value is set directly
	// and assumed to be OK.  The new value has already passed basic validation
	// for setting into the given variable.
	// buf/buflen indicate a character buffer which can be used for temporary data.
	auto xmemchar * start, * end;
	auto word x, index, slen, stype, bad;
	auto snmp_type vtype;
	auto long L;
	auto snmp_oid oid;
	auto int cbretval;

	for (x=0; x < msg->variable_count; x++) {
		index = msg->variables[x];
		start = msg->setvalue[x];
		end = start + 4096;	// Dummy end value
		snmp_get_indexed(p, index);
		vtype = snmp_last_type(p);
		// Get the value to set
		stype = _snmp_gc(start++);
		start = _snmp_parselength(start, end, &slen);
		if (!commit && start == NULL) {
			msg->errorstatus = SNMP_ERR_genErr;
			msg->errorindex = x + 1;	// report as 1-based index
#ifdef SNMP_VERBOSE
			printf("SNMP: var at index %d, start == NULL (==> SNMP_ERR_genErr).\n",
			       msg->errorindex);
#endif
			return 0;
		}
		cbretval = 0;
		switch (stype) {
			case SNMP_P_INTEGER:
			case SNMP_P_COUNTER:
			case SNMP_P_GAUGE:
			case SNMP_P_TIMETICKS:
				if ((_snmp_gc(start) & 0x80) && (stype == SNMP_P_INTEGER))
					L = -1L;
				else
					L = 0;
				_snmp_gcs(start, (char *)&L + 4 - slen, slen);
			integral:
				L = intel(L);
				if (stype == SNMP_P_TIMETICKS) {
#ifdef SNMP_VERBOSE
					printf("SNMP: ticks %lu -> epoch %lu\n", L, snmp_timeticks() - L);
#endif
					L = snmp_timeticks() - L;	// Convert to equivalent base epoch
				}
				slen = 4;
				bad = vtype == SNMP_SHORT
				      && (stype == SNMP_P_INTEGER ? (L < -32768L || L > 32767L)
				      									 : ((longword)L > 65535uL))
				      || p->last.u.leaf.cb
				         && (cbretval = p->last.u.leaf.cb(p, 1, commit, &L, &slen, 4));
				break;
			case SNMP_P_OCTETSTR:
				bad = slen >= buflen;
				if (!bad) {
					_snmp_gcs(start, buf, slen);
			stringal:
				   bad = p->last.u.leaf.cb
				         && (cbretval = p->last.u.leaf.cb(p, 1, commit, buf, &slen, buflen));
				}
				break;
			case SNMP_P_OID:
				bad = slen >= buflen;
				if (!bad) {
					_snmp_gcs(start, buf, slen);
					//slen = sizeof(oid);
					bad = _snmp_ber2rler(&oid, buf, slen) ||
							p->last.u.leaf.cb
							&& (cbretval = p->last.u.leaf.cb(p, 1, commit, &oid, &slen, sizeof(oid)));
				}
				break;
			case SNMP_P_IPADDR:
				_snmp_gcs(start, (char *)&L, 4);
				if (vtype == SNMP_LONG)
					goto integral;
				memcpy(buf, &L, 4);
				goto stringal;
		}
		if (!commit && bad) {
			if (cbretval > 0 && cbretval < SNMP_ERR_genErr)
				msg->errorstatus = cbretval;
			else
				msg->errorstatus = SNMP_ERR_genErr;
			msg->errorindex = x+1;
#ifdef SNMP_VERBOSE
			printf("SNMP: var %s denied, code %d\n", snmp_format_oid(&p->stem), cbretval);
#endif
			return 0;
		}
		if (commit) {
			// Set the new value.
			switch (vtype) {
				case SNMP_SHORT:
					if (p->last.u.leaf.flags & MIB_FAR)
						root2xmem(p->last.u.leaf.v.x, &L, 2);
					else
						*p->last.u.leaf.v.i = (int)L;
					break;
				case SNMP_LONG:
					if (p->last.u.leaf.flags & MIB_FAR)
						root2xmem(p->last.u.leaf.v.x, &L, 4);
					else
						*p->last.u.leaf.v.L = L;
					break;
				case SNMP_STR:
					buf[slen++] = 0;	// Null terminate it
				case SNMP_FOCT:
					if (p->last.u.leaf.flags & MIB_FAR)
						root2xmem(p->last.u.leaf.v.x, buf, slen);
					else
						memcpy(p->last.u.leaf.v.s, buf, slen);
					break;
				case SNMP_OCT:
					if (p->last.u.leaf.flags & MIB_FAR) {
						root2xmem(p->last.u.leaf.v.x, &slen, 2);
						root2xmem(p->last.u.leaf.v.x + 2, buf, slen);
					}
					else {
						*p->last.u.leaf.v.i = slen;
						memcpy(p->last.u.leaf.v.s + 2, buf, slen);
					}
					break;
				case SNMP_OID:
					if (p->last.u.leaf.flags & MIB_FAR)
						root2xmem(p->last.u.leaf.v.x, &oid, sizeof(snmp_oid));
					else
						memcpy(p->last.u.leaf.v.o, &oid, sizeof(snmp_oid));
					break;
			}
		}
	}
	return 1;
}

/*** BeginHeader _snmp_buildvariables */
xmemchar* _snmp_buildvariables(xmemchar* start, xmemchar* end, snmp_message* msg);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildvariables(xmemchar* start, xmemchar* end, snmp_message* msg)
{
	auto snmp_oid oid;
	auto char name[SNMP_MAX_STRING];
	auto longword ipaddr;
	auto long L;
	auto snmp_parms p;
	auto word index, rlen;
	auto word x, st;
	auto snmp_type mt;
	auto xmemchar * fixup_seq2;

	if(start==NULL) return NULL;

#ifdef SNMP_VERBOSE
	if (debug_on >= 4) printf("SNMP: _snmp_buildvariables\n");
#endif

	if (msg->type == SNMP_SETREQ) {
		if (!_snmp_setvars(&p, msg, 0, name, sizeof(name)))
			return NULL;
		_snmp_setvars(&p, msg, 1, name, sizeof(name));
	}

	for(x=0;x<msg->variable_count;x++) {
		start=_snmp_buildsequence(start,end,&fixup_seq2,2,SNMP_P_SEQ);
		snmp_get_indexed(&p, index = msg->variables[x]);
		st = (p.last.u.leaf.flags & MIB_SNMPMASK) >> 4;
		mt = (snmp_type)(p.last.u.leaf.flags & MIB_TYPEMASK);

		start = _snmp_buildoctetstr(start, end, name, _snmp_rler2ber(&p.stem, name), SNMP_P_OID);

		switch (mt) {
			case SNMP_SHORT:
				if (st == SNMP_P_INTEGER)
					L = snmp_last_int(&p);			// Sign extended
				else
					L = (word)snmp_last_int(&p);	// All others are unsigned
				goto integral;
			case SNMP_LONG:
				L = snmp_last_long(&p);
				if (st == SNMP_P_IPADDR) {
					ipaddr = intel(L);
					memcpy(name, &ipaddr, 4);
				}
			integral:
				rlen = 4;
				if (p.last.u.leaf.cb)
					p.last.u.leaf.cb(&p, 0, 0, &L, &rlen, 4);
				break;
			case SNMP_OID:
				snmp_last_objectID(&p, &oid);
				rlen = sizeof(oid);
				if (p.last.u.leaf.cb)
					p.last.u.leaf.cb(&p, 0, 0, &oid, &rlen, sizeof(oid));
				break;
			default:
				rlen = snmp_last_len(&p);
				L = snmp_last_xmem(&p);
				if (mt == SNMP_OCT)
					L += 2;		// Skip length word
				if (rlen > sizeof(name))
					rlen = sizeof(name);
				xmem2root(name, L, rlen);
				if (p.last.u.leaf.cb)
					p.last.u.leaf.cb(&p, 0, 0, name, &rlen, sizeof(name));
				break;
		}

		switch (st) {
			case SNMP_P_IPADDR:
			case SNMP_P_OCTETSTR:
				start = _snmp_buildoctetstr(start, end, name, rlen, st);
				break;
			case SNMP_P_OID:
				start = _snmp_buildoctetstr(start, end, name, _snmp_rler2ber(&oid, name), SNMP_P_OID);
				break;
			case SNMP_P_TIMETICKS:
#ifdef SNMP_VERBOSE
				printf("SNMP: ticks since %lu = %lu\n", L, snmp_time_since(L));
#endif
				L = snmp_time_since(L);
				// fall through
			default:
				start = _snmp_buildint(start, end, L, st);
				break;
		}
		start=_snmp_fixupsequence(fixup_seq2,start);
	}

	return start;
}


/*** BeginHeader _snmp_buildpdu */
xmemchar* _snmp_buildpdu(xmemchar* start, xmemchar* end, snmp_message* msg, int iface);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_buildpdu(xmemchar* start, xmemchar* end, snmp_message* msg, int iface)
{
#ifdef SNMP_TRAPS
	auto char name[SNMP_MAX_NAME*2];
	auto word namelength;
	auto snmp_oid oid;
#endif
	auto xmemchar *pdu_seq, *fixup_seq1;

	if(start==NULL || (start+4)>end)
		return NULL;

#ifdef SNMP_VERBOSE
	if (debug_on >= 4) printf("SNMP: _snmp_buildpdu  i/f = %d\n", iface);
#endif

#ifdef SNMP_TRAPS
	if (msg->type == SNMP_TRAPREQ) {
		start=_snmp_buildsequence(start,end,&pdu_seq,2,SNMP_TRAPREQ);
		snmp_set_oid(&oid, 5, "\x2B\006\001\004\001");
	#ifdef SNMP_ENTERPRISE
		_mib_append_oid(&oid, SNMP_ENTERPRISE);
	#endif
		namelength = _snmp_rler2ber(&oid, name);
		start=_snmp_buildoid(start,end,name,namelength); 	// sysObjectID
		start=_snmp_buildint(start,end,_if_tab[iface].ipaddr,SNMP_P_IPADDR);	// Interface Network address
		start=_snmp_buildint(start,end,msg->genTrap,SNMP_P_INTEGER);			// generic trap code
		start=_snmp_buildint(start,end,msg->enterpriseTrap,SNMP_P_INTEGER);	// enterprise-specific trap code
		start=_snmp_buildint(start,end,snmp_time_since(_snmp.start_epoch),SNMP_P_TIMETICKS);	// timestamp
	}
	else {
#endif
		start=_snmp_buildsequence(start,end,&pdu_seq,2,SNMP_GETRSP);

		start=_snmp_buildint(start,end,msg->id,SNMP_P_INTEGER); // id
		start=_snmp_buildint(start,end,0,SNMP_P_INTEGER);	// error status
		start=_snmp_buildint(start,end,0,SNMP_P_INTEGER);	// error index
#ifdef SNMP_TRAPS
	}
#endif

	start=_snmp_buildsequence(start,end,&fixup_seq1,2,SNMP_P_SEQ);
	if (msg->variable_count)
		start=_snmp_buildvariables(start,end,msg);
	start=_snmp_fixupsequence(fixup_seq1,start);
	start=_snmp_fixupsequence(pdu_seq,start);
	return start;
}


/*** BeginHeader _snmp_processmessage */
xmemchar* _snmp_processmessage(xmemchar* start, xmemchar* end, snmp_message* msg, int iface);
/*** EndHeader */

_snmp_nodebug xmemchar* _snmp_processmessage(xmemchar* start, xmemchar* end, snmp_message* msg, int iface)
{
	auto int rval,x;
	auto xmemchar* fixup_seq;

	if(start==NULL)
		return NULL;

	start=_snmp_buildsequence(start,end,&fixup_seq,2,SNMP_P_SEQ);
	start=_snmp_buildint(start,end,0,SNMP_P_INTEGER); // version
	start=_snmp_buildoctetstr(start,end,msg->community,strlen(msg->community), SNMP_P_OCTETSTR);
	start=_snmp_buildpdu(start,end,msg,iface);
	start=_snmp_fixupsequence(fixup_seq,start);
	return start;
}



/*** BeginHeader _snmp_check_mon */
void _snmp_check_mon(void);
/*** EndHeader */

_snmp_nodebug void _snmp_check_mon(void)
{
	// Assumes caller holds global TCP lock.  Called from _snmp_tick to check all monitored
	// variables and send trap if any variable is outside its range.
	auto word i;
	auto snmp_monvar * mv;
	auto snmp_parms p;
	auto long L;
	auto int sendtrap;
	auto longword intvl;

	for (i = 0; i < SNMP_MAX_MONITOR; i++) {
		if (_snmp.mon[i].index == SNMP_NULL)
			continue;
		mv = _snmp.mon + i;
		snmp_get_indexed(&p, mv->index);
		if ((p.last.u.leaf.flags & MIB_TYPEMASK) == SNMP_SHORT)
			if (mv->issigned)
				L = snmp_last_int(&p);
			else
				L = (word)snmp_last_int(&p);
		else
			L = snmp_last_long(&p);
		if (mv->issigned)
			sendtrap = L < mv->minval || L > mv->maxval;
		else
			sendtrap = (longword)L < (longword)mv->minval || (longword)L > (longword)mv->maxval;
		if (!sendtrap)
			mv->ntrans = 0;
		else if ((!mv->nmesg || mv->ntrans < mv->nmesg) &&
			      (!mv->ntrans || chk_timeout(mv->nextsend))) {
			if (mv->maxintvl >> mv->ntrans < mv->minintvl)
				intvl = mv->maxintvl * 1000L;
			else
				intvl = mv->minintvl * 1000L << mv->ntrans;
			if (mv->ntrans < (mv->nmesg ? mv->nmesg : 32))
				mv->ntrans++;
			mv->nextsend = _SET_TIMEOUT(intvl);
#ifdef SNMP_VERBOSE
			if (debug_on) {
				if (mv->issigned)
					printf("SNMP: signed var %u (=%ld) out of range (%ld..%ld)\n", mv->index, L, mv->minval, mv->maxval);
				else
					printf("SNMP: unsigned var %u (=%lu) out of range (%lu..%lu)\n", mv->index, L, mv->minval, mv->maxval);
				printf("SNMP: sending monitor trap %d, trans #%u\n", mv->trap_num, mv->ntrans);
			}
#endif
			snmp_trap(*mv->ipaddr, mv->c_index, mv->trap_num, mv->noids, mv->indices);
		}
	}
}


/*** BeginHeader _snmp_handler */
int _snmp_handler(int event, udp_Socket * s, ll_Gather * g, _udp_datagram_info * udi);
/*** EndHeader */

_snmp_nodebug int _snmp_handler(int event, udp_Socket * s, ll_Gather * g, _udp_datagram_info * udi)
{
	// This function is the UDP data handler for the SNMP socket.  Since SNMP is a simple
	// request-reply protocol, it is most efficient to handle SNMP datagrams immediately
	// they are available in the network receive buffer.  This avoids having to copy the
	// datagram into the socket receive buffer.
	auto snmp_message msg;
	auto int rval;
	auto xmemchar * end, * start;
	auto word length, adj;

	if (event != UDP_DH_INDATA)
		return 0;

#ifdef SNMP_VERBOSE
	if (debug_on)
		printf("SNMP: packet received from %08lx:%d i/f %d\n",
				udi->remip, udi->remport, udi->iface);
#endif
	if (_snmp.state & SNMP_S_PAUSED) {
#ifdef SNMP_VERBOSE
		if (debug_on) printf("SNMP: ignored (paused)\n");
#endif
		goto finish;
	}

	// Compute segmented address from g->data2.
	#asm
		ld		iy,(sp+@sp+g)
		ld		bcde,(iy+[ll_Gather]+data2)	; bcde = ll_Gather.data2 (char far *)
		call	dkcLongLogicalToPhysical		; bcde = 32-bit physical address
		ld		hl,de
		ld		a, c									; ahl contains 24-bit linear address
		_LIN2SEG										; JK/HL is now segmented address
		ld		(sp+@sp+start),hl					; xpc window address in 'start'
		ex		jk,hl
		ld		(_snmp+[snmp_globals]+xpcget),hl
	#endasm
	length = g->len2;
	if (!_snmp_parsemessage(start,start+length,&msg))
		// Discard if bad parse, version number or unknown community
		goto finish;

	// dev note: handle outgoing fragmentation.  Datagram is currently limited to MTU size - 28.
   // Larger will cause the socket error message to be printed (if verbose).  App should check for this.
   // If too big datagrams are attempted, this will unnecessarily tie up the target host waiting for
   // the following fragments (which will never come).
	if (!msg.errorstatus &&
			(end=_snmp_processmessage(_snmp.xmemseg,_snmp.xmemseg + SNMP_MAX_DATA,&msg, udi->iface))) {
		if ((rval=udp_write(s,(void __far *)_snmp.outbuf,length=end-_snmp.xmemseg,0,udi))<(int)length) {
#ifdef SNMP_VERBOSE
			printf("SNMP: socket error (%d)\n",rval);
#endif
		}
#ifdef SNMP_VERBOSE
		else if (debug_on) printf("SNMP: sent reply length=%u\n", rval);
#endif
	}
	else {
		if (!msg.errorstatus)
			msg.errorstatus = SNMP_ERR_tooBig;
		// Insert error status and index, and return original request as a get response
		xmem2xmem(_snmp.outbuf, (long)g->data2, length);
		adj = _snmp.xmemseg - start;
		_snmp_pc(msg.ptype + adj, SNMP_GETRSP);
		_snmp_pc(msg.pdu_errorstatus + adj, msg.errorstatus);
		_snmp_pc(msg.pdu_errorindex + adj, msg.errorindex);
		if ((rval=udp_write(s,(void __far *)_snmp.outbuf,length,0,udi))<length) {
#ifdef SNMP_VERBOSE
			printf("SNMP: socket error (%d)\n",rval);
#endif
		}
#ifdef SNMP_VERBOSE
		else if (debug_on) printf("SNMP: sent error reply length=%u\n", rval);
#endif
	}

finish:
	return 1;	// We have handled it.  Do not buffer.
}


/*** BeginHeader _snmp_tick */
int _snmp_tick(void);
/*** EndHeader */

_snmp_nodebug int _snmp_tick(void)
{
	// Assumes caller holds global TCP lock.  This is called from tcp_tick().
	auto longword tt;

	// Update timetick counter.  This is done approx. every 30 seconds
	if (_CHK_SHORT_TIMEOUT(_snmp.upd_timeout)) {
		tt = (word)(MS_TIMER - _snmp.ms_ref) / 10;
		_snmp.tick_ref += tt;
		_snmp.ms_ref += tt * 10;
		_snmp.upd_timeout = _SET_SHORT_TIMEOUT(30000);
#ifdef SNMP_VERBOSE
		printf("SNMP: tt = %lu  tick_ref = %lu  ms_ref = %lu\n", tt, _snmp.tick_ref, _snmp.ms_ref);
#endif
	}

	if (_snmp.state == SNMP_S_INIT || (!sock_alive(&_snmp.sock) && _snmp.state != SNMP_S_PAUSED)) {
		_snmp.start_epoch = snmp_timeticks();
		_snmp.monitor_timeout = _SET_SHORT_TIMEOUT(SNMP_MIN_TRAP_INTVL);
		// Last 2 parms (1,0) indicate no RX buffer provided, since all received
		// datagrams are consumed immediately by the handler function.
		udp_extopen(&_snmp.sock, SNMP_INTERFACE, SNMP_PORT, -1, 0,
						_snmp_handler, 1, 0);
		// But we do now use a transmit buffer to avoid needless ARP resolution failures
		// when sending traps.
		_snmp.sock.wr.buf = (char __far *)_snmp.outbuf2;
		_snmp.sock.wr.maxlen = _snmp.outbuf2maxlen;
		sock_set_tos(&_snmp.sock, SNMP_TOS);
		_snmp.state = SNMP_S_WAITING;
	}
	else {

#ifdef SNMP_TRAPS
	#if SNMP_MAX_MONITOR > 0
		// Check monitored variables and send trap if requested
		if (_CHK_SHORT_TIMEOUT(_snmp.monitor_timeout)) {
			_snmp.monitor_timeout = _SET_SHORT_TIMEOUT(SNMP_MIN_TRAP_INTVL);
			if (!(_snmp.state & SNMP_S_PAUSED))
				_snmp_check_mon();
		}
	#endif
#endif

	}
}





/*** BeginHeader _snmp_init */
void _snmp_init();
#funcchain _GLOBAL_INIT _snmp_init
/*** EndHeader */

__nodebug
void _snmp_init()
{
	// This is called once only, at premain time.

	memset(&_snmp, 0, sizeof(_snmp));
	_snmp.comm[SNMP_PUBLIC].mask = SNMP_PUBLIC_MASK;
	_snmp.next_comm = SNMP_PUBLIC+1;
#if SNMP_MAX_COMMUNITIES >= 2
	_snmp.comm[SNMP_PRIVATE].mask = SNMP_PRIVATE_MASK;
	_snmp.next_comm = SNMP_PRIVATE+1;
#endif
#ifdef SNMP_TRAPS
 #if SNMP_MAX_COMMUNITIES >= 3
	_snmp.comm[SNMP_TRAPDEST].mask = SNMP_TRAPDEST_MASK;
	_snmp.next_comm = SNMP_TRAPDEST+1;
 #endif
#endif
	_snmp.outbuf2maxlen = SNMP_MAX_DATA+sizeof(_udp_datagram_info);
	_snmp.outbuf2 = xalloc(_snmp.outbuf2maxlen);
			// ...UDP transmit buffer
	_snmp.outbuf = xalloc(SNMP_MAX_DATA);	// Output datagram assembly
	// Now compute segmented address of outbuf (outbuf is in BCDE from above statement)
	#asm
		ex		de,hl								; (16 LSBs of paddr ->HL)
		ld		a,c								; (8 MSBs of paddr)
		_LIN2SEG									; JK/HL is now segmented address
		ld		(_snmp+[snmp_globals]+xmemseg),hl
		ex		jk,hl
		ld		(_snmp+[snmp_globals]+xpcput),hl
	#endasm

#ifdef SNMP_TRAPS
	// Monitored variable information
 #if SNMP_MAX_MONITOR > 0
 	for (_snmp.monitor_timeout = 0; _snmp.monitor_timeout < SNMP_MAX_MONITOR; _snmp.monitor_timeout++)
		_snmp.mon[_snmp.monitor_timeout].index = SNMP_NULL;
 #endif
#endif

}



/*** BeginHeader */
#endif
/*** EndHeader */