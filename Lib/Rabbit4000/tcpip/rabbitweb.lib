/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 *	rabbitweb.lib -- RabbitWeb HTTP enhancements support
 *
 *    This library includes the library support for the RabbitWeb HTTP
 *    enhancements.
 *
 *    This deprecated version of the RabbitWeb library uses xmem addressing
 *    to retain backward compatability with pre-10.60 releases of Dynamic C.
 *
 *    Define the macro USE_LEGACY_RABBITWEB in your project settings to make
 *    use of this version instead of RWEB_HTTP.LIB and its support libraries in
 *    Lib/Rabbit4000/RabbitWeb.
 */

/*** BeginHeader */

#if CC_VER < 0xA20
	#fatal "This library must be used with Dynamic C version 10.21 or later."
#endif

// RabbitWeb bundled with Dynamic C.
// These numbers keep track of the type of block that is encountered by the
// ZHTML parser.  They are used in the ZHTMLBlockContext structure.
enum {
	_ZHTML_BLOCK_IF,
   _ZHTML_BLOCK_FOR
};

// These numbers represent the various types of comparisons that are allowed in
// if and for statements in the ZHTML parser.  They are used in the
// ZHTMLBlockContext structure.
enum {
	_ZHTML_COMP_LT,	// <
	_ZHTML_COMP_GT,	// >
	_ZHTML_COMP_LE,	// <=
	_ZHTML_COMP_GE,	// >=
	_ZHTML_COMP_EQ,	// ==
	_ZHTML_COMP_NE		// !=
};

// These numbers represent the different step operators used in for loops
// (++, --, +=, and -=).  These are used in the calculation of the step member
// of the ZHTMLBlockContext structure.
enum {
	_ZHTML_STEPOP_INC,	// ++
   _ZHTML_STEPOP_DEC,	// --
   _ZHTML_STEPOP_PE,		// +=
   _ZHTML_STEPOP_ME		// -=
};

// This structure records information on an if or for block in the ZHTML
// parser.
typedef struct {
	char blocktype;	// Keeps track of whether the given block is an if block or
							// a for block
   long loopbegin;	// Offset into the HTML page of the beginning of the loop
   char var;			// The index of the loop variable $A-$Z that is used for
   						// this for loop
   int step;			// The number that should be added to the loop variable
   						// every time we loop
   int end;				// The number to which the loop variable should be compared
   						// when the loop condition is being tested
   char comparison;	// The type of comparison that should be done for the loop
   						// check
} ZHTMLBlockContext;

// This structure keeps information on a particular variable during the ZHTML
// parsing process.
typedef struct {
	void *valptr;			// A pointer to the calculated value of the variable
	// Each of the members below (except for newval) are the same as the
	// corresponding members in the _Web_Var_Info structure (see
	// RWEB_SUPPORT.LIB).
	_Web_Var_Type type;
	_rweb_fcnptr *guardptr;
	_rweb_fcnptr *updateptr;
	char auth;
	unsigned int groups;
	unsigned int perm;
	int *bounds;
	_Web_Select select;
   int newval;				// Keeps track of the index into _http_post_changed[] of
   							// a changed variable
} ZHTMLVarInfo;

// This structure keeps information during the parsing process of a ZHTML file.
typedef struct {
	void *state;		// A pointer to the HttpState associated with this parser
							// instance
	int command;		// The command that was recognized by the parser for the
							// current statement
   char __far *p;		// A pointer to the current position in the parsing of the
   						// ZHTML statement
   char __far *tagend;	// A pointer to the end of the ZHTML tag
   char __far *varbegin;	// During parsing, this is used to point to the beginning
   						// of a variable
	ZHTMLVarInfo varinfo;	// During parsing, this is used to store information
									// on a parsed variable
   char __far *buffer;	// A pointer to the output buffer
   char error;			// A boolean value that indicates whether we are processing
   						// in error mode or not
   int nesting;		// Keeps track of the current nesting level of blocks
   int skipping;		// If 0, then it indicates that we aren’t skipping ZHTML
   						// statements (due to a failed conditional).  If non-zero,
   						// then it indicates that we are skipping, and the value is
   						// the nesting level at which we started skipping.
   char truth;			// A boolean value that is used to keep track of whether a
   						// conditional expression evaluated to TRUE or FALSE
   int tempvars[26];	// An array of temporary loop variable values that are used in for loops
	// Keeps track of the if and for blocks that are nested around the current
	// parser position
   ZHTMLBlockContext context[RWEB_ZHTML_MAXBLOCKS];
} ZHTMLParser;

// This variable is 0 normally, and is set to the server number that has the
// lock when ZHTML POST processing is being done.  Since there is a single
// ZHTML POST buffer, as well as some other global data structures, then this
// is necessary.  However, reads of .zhtml files are allowed to happen at any
// time.
int _zhtml_lock;

// This global array will keep track of the wildcarded array dimensions that
// must be used in _web_getwildval().
int _zhtml_dims[9];

// This determines the size of the buffer that holds the POST request for
// RWEB.  This buffer is located in xmem.
#ifndef RWEB_POST_MAXBUFFER
	#define RWEB_POST_MAXBUFFER	2048
#endif

// This determines the maximum length of a variable.  This really only pertains
// to string variables.
#ifndef RWEB_ZHTML_MAXVARLEN
	#define RWEB_ZHTML_MAXVARLEN	256
#endif

// This determines the maximum number of variables that an RWEB POST request
// can supply in a single request.  That is, only this many variables can be
// updated at once.
#ifndef RWEB_POST_MAXVARS
	#define RWEB_POST_MAXVARS	64
#endif


// HTTP POST variable buffer
char _http_post_var[RWEB_ZHTML_MAXVARLEN];

// Offset into the HTTP POST variable buffer (used to copy multiple strings into
// the buffer when executing guards)
int _http_post_var_offset;

// Some global information for WEB_ERROR()--protected by a lock
int _rweb_post_changed_index;	// Index into the _http_post_changed[] array
											// for the variable currently being checked
long _rweb_weberror_buffer;		// Pointer to xmem buffer for WEB_ERROR()
											// messages
int _rweb_weberror_buffer_len;	// Length of the WEB_ERROR() xmem buffer

// Size of the xmem WEB_ERROR() buffer.  This is limited to 32767 bytes.
#ifndef RWEB_WEB_ERROR_MAXBUFFER
	#define RWEB_WEB_ERROR_MAXBUFFER		512
#elif (RWEB_WEB_ERROR_MAXBUFFER > 32767)
	#fatal "RWEB_WEB_ERROR_MAXBUFFER must be <= 32767"
#endif

// The following structure is used to keep information on each variable
// accepted and processed in POST requests (for the HTTP enhancements).
struct {
	int nameoffset;		// offset into POST buffer of variable name
	int valoffset;			// offset into POST buffer of variable value
   _Web_Var_Info *info;	// pointer to variable info
   int vartype;			// type of the variable
   int strlen;				// length of the changed string value (if the variable
   							// is a string)
   void *varptr;			// pointer to the "real" value of the variable
	int *bounds;			// bounds for a string or array variable type
	#define _RWEB_ERROR_MASK 0x8000	// The high bit indicates an error on this
												// variable
   unsigned int error;	// The high bit indicates if there is an error on this
   							// variable.  The other bits are the offset into the
   							// WEB_ERROR buffer of an associated error string (0 if
   							// no error string).
   unsigned long newval;	// new value for non-string values
} _http_post_changed[RWEB_POST_MAXVARS];
int _http_post_changed_len;

// defines for future XML support
#define RWEB_CHECKED    " checked"
#define RWEB_SELECTED   " selected"
#define RWEB_CLOSETAG   ">"
/*** EndHeader */


/*** BeginHeader zhtml_varnamexmem2root */
int zhtml_varnamexmem2root(char *dest, int offset);
/*** EndHeader */

// Copies a variable name from the POST buffer to a root destination.  This
// also decodes the munging that was done to represent array brackes ('[' and
// ']').
//
// dest   -- Root detination buffer for the variable name.
// offset -- Offset into the POST buffer of the variable name.
// Return -- Offset into the POST buffer of the variable value on success, and
//           -1 on error.

_http_nodebug
int zhtml_varnamexmem2root(char *dest, int offset)
{
   auto int ch_temp;
   auto char ch;
   auto int i;
   auto int open;

	_http_assert(dest != NULL);

   i = 0;
	// open keeps track of if a '[' has been encountered
   open = 1;
   // Keep copying until we exceed the post buffer (the normal case of ending
   // at the end of the variable name is handled within this while loop).
   while ((offset + i) < _http_post_len) {
		ch_temp = xgetint(_http_post + offset + i);
   	ch = (char)(ch_temp & 0x00ff);
      if (ch != '=') {
      	// This does the unmunging of the '[' and ']' characters.  They will
      	// be represented by '+', so we must replace all '+' characters by '['
      	// or ']' as appropriate.
      	if (ch == '+') {
         	if (open) {
            	ch = '[';
               open = 0;
            }
            else {
            	ch = ']';
               open = 1;
            }
         }
         // Check if the variable name is too long
      	if (i >= RWEB_ZHTML_MAXVARLEN) {
         	return -1;
         }
      	dest[i] = ch;
      }
      else {
      	// We're at the end of the name--return the offset to the value
      	if (i+1 >= RWEB_ZHTML_MAXVARLEN) {
         	return -1;
         }
         dest[i] = '\0';
         return i+1;
      }
      i++;
   }
   // Error--end of the POST buffer
   return -1;
}

/*** BeginHeader zhtml_checkvars */
int zhtml_checkvars(HttpState_p state);
/*** EndHeader */

// Check the variables received in the POST buffer.  It iterates through all of
// the variables received in the POST buffer to check (and record) if the value
// changed.  It then iterates through the list of changed variables and checks
// each of the guards.  Variables that have failing guards are marked as being
// in error.
//
// state  -- The current state of the HTTP server.
// Return -- 0 if no errors found, 1 if errors were found, 2 if there was an
//           authentication problem (the user has no write access to one or more
//           of the POSTed variables).

_http_nodebug
int zhtml_checkvars(HttpState_p state)
{
   auto int offset;
   auto int i,j;
   auto void *ptr;
   auto int ival;
   auto _rweb_fcnptr *fplist;
   auto _rweb_fcnptr fp;
   auto char error_found;
   auto ZHTMLVarInfo varinfo;
   auto int retval;
   auto int index;
   auto int error;
   auto int change_index;
#ifdef RABBITWEB_VERBOSE
	auto char _var_name[40];
	auto char _var_value[40];
#endif

   offset = 0;
   error_found = 0;

	// Iterate through variables
   while (offset != -1) {
   	// Copy out this variable name
      ival = zhtml_varnamexmem2root(_http_post_var, offset);
#ifdef RABBITWEB_VERBOSE
		snprintf (_var_name, sizeof(_var_name), "%s", _http_post_var);
#endif
   	// Find this variable in _web_var_info[]
		i = zhtml_matchbest(_http_post_var, &varinfo, 0);
      if (i >= 0) {
      	// Got a match
			// Check if we have access to the variable
         if (zhtml_check_variable_access(state, &varinfo, 1)) {
         	// No write access to the variable
            return 2;
         }
			// Check if this variable is already in the changed list (that is, it
			// must have been submitted more than once in this update)
			for (change_index = 0; change_index < _http_post_changed_len;
			     change_index++) {
				if (zhtml_varcmp(_http_post_var,
				                _http_post_changed[change_index].nameoffset) >= 0) {
					// It is already in the list
					break;
				}
			}
      	// Check if the value actually changed
#ifdef RABBITWEB_VERBOSE
			zhtml_varxmem2root(_var_value, sizeof(_var_value),
	    		offset + ival, _DK_TSTRING, "", &error);
#endif
         if (varinfo.select.ptr16 == NULL) {
	         ptr = zhtml_varxmem2root(_http_post_var, RWEB_ZHTML_MAXVARLEN,
	                                  offset + ival, varinfo.type.simple,
	                                  varinfo.valptr, &error);
         }
         else {
         	// It's a selection variable, so we're copying a string value
	         ptr = zhtml_varxmem2root(_http_post_var, RWEB_ZHTML_MAXVARLEN,
	                                  offset + ival, _DK_TSTRING,
	                                  varinfo.valptr, &error);
			}
         // Must convert the value appropriately and compare for differences
         retval = zhtml_checkchanged(ptr, varinfo.valptr, varinfo.type.simple,
                                     varinfo.select);
         if ((retval != 0) || (error != 0)) {
         	// Value has changed
#ifdef RABBITWEB_VERBOSE
	    		printf("RWEB: %s has changed to '%s'\n", _var_name, _var_value);
#endif
         	// Check if we have filled the _http_post_changed array
				if (change_index >= RWEB_POST_MAXVARS) {
					// We have filled it.  We have to just skip to the next variable.
#ifdef RABBITWEB_VERBOSE
					printf("RWEB: ERROR! Too many variables have been received!\n");
#endif
			   	offset = zhtml_findnextvar(offset);
			   	continue;
			   }
            // Record that this variable has changed.  This saves off all the
            // pertinent information on this variable.
            _http_post_changed[change_index].nameoffset = offset;
            _http_post_changed[change_index].valoffset = offset + ival;
            _http_post_changed[change_index].info = &(_web_var_info[i]);
            _http_post_changed[change_index].vartype = varinfo.type.simple;
            if (varinfo.type.simple == _DK_TSTRING) {
            	_http_post_changed[change_index].strlen = strlen(ptr);
            }
            _http_post_changed[change_index].varptr = varinfo.valptr;
            _http_post_changed[change_index].bounds = varinfo.bounds;
				// If retval > 0, then we have a new value for the variable (see
				// the call of zhtml_checkchanged() above).
				if (retval > 0) {
					// Copy the new value into the http_post_changed information
            	zhtml_copynewval(&(_http_post_changed[change_index].newval), ptr,
            	                 varinfo.type.simple);
            	// This is triggered if zhtml_varxmem2root found an error in
            	// the variable--for instance, "240u0" for an integer.
            	if (!error) {
		           	_http_post_changed[change_index].error = 0;
		         }
		         else {
		           	_http_post_changed[change_index].error = _RWEB_ERROR_MASK;
		           	error_found = 1;
		         }
            }
            // If retval < 0, there was an error from zhtml_checkchanged(), so
            // we must report it as an error.
            else {
					// Copy the new value into the http_post_changed information
            	zhtml_copynewval(&(_http_post_changed[change_index].newval),
            	                 varinfo.valptr, varinfo.type.simple);
					// Mark an error on this variable
	           	_http_post_changed[change_index].error = _RWEB_ERROR_MASK;
               error_found = 1;
            }
            // Only increase _http_post_changed_len if we were adding a new
            // entry and not just modifying a previous one
            if (change_index == _http_post_changed_len) {
	            _http_post_changed_len++;
	         }
			}
			// Value has not changed
			else {
				// If this variable was already in the change list, then we need
				// to now mark that entry as unchanged.  This is done by
				// invalidating the value offset.
				if (change_index < _http_post_changed_len) {
					_http_post_changed[change_index].valoffset = -1;
				}
			}
      }
		// Check the next variable
   	offset = zhtml_findnextvar(offset);
	}

	// Clear out the WEB_ERROR() buffer -- Note that we don't use the first byte
	// of this buffer.  This lets us use the value 0 to indicate that there is no
	// WEB_ERROR() message for a particular variable, thus saving space in the
	// _http_post_changed[] array.
	_rweb_weberror_buffer_len = 1;

	// Check guards for each changed variable
	for (i = 0; i < _http_post_changed_len; i++) {
		// Check if this entry has been invalidated
		if (_http_post_changed[i].valoffset < 0) {
			continue;
		}
		_rweb_post_changed_index = i;
      // Copy out this variable name again
      zhtml_varnamexmem2root(_http_post_var, _http_post_changed[i].nameoffset);
#ifdef RABBITWEB_VERBOSE
		snprintf (_var_name, sizeof(_var_name), "%s", _http_post_var);
		printf ("checking guards for %s\n", _var_name);
#endif
      // If this is a string, check the length
      if (_http_post_changed[i].vartype == _DK_TSTRING) {
         if (zhtml_checkstrlen(_http_post_changed[i].strlen,
                               _http_post_changed[i].bounds) != 0) {
            // String too long
            _http_post_changed[i].error |= _RWEB_ERROR_MASK;
            error_found = 1;
         }
      }

      // Find all matches so that we can call each guard
      j = 0;
      while (_web_var_info[j].name != NULL) {
         retval = zhtml_matchnames(&(_web_var_info[j]), _http_post_var,
         													_zhtml_dims, NULL, NULL, 0);
         if (retval < 0) {
            // Error in the variable name--just break out here
            break;
         }
         else if (retval == 0) {
            // Call the guard(s)
            fplist = _web_var_info[j].guardptr;
            if (fplist) {
               while (*fplist) {
                  fp = *fplist++;
                  // Clear the post variable buffer offset back to 0
						_http_post_var_offset = 0;
                  // The following actually calls each guard
                  if (!fp(_zhtml_dims)) {
#ifdef RABBITWEB_VERBOSE
                     printf("RWEB: Variable %s failed the error check - %s\n",
                     	_var_name, _web_var_info[j].name);
#endif
                     _http_post_changed[i].error |= _RWEB_ERROR_MASK;
                     error_found = 1;
                     break;
                  }
               }
            }
         }
         j++;
      }
	}

	return (int)error_found;
}

/*** BeginHeader WEB_ERROR */
int WEB_ERROR(char *error);
/*** EndHeader */

// This function is called explicitly by the user from guard expressions.  It
// is used to associate an error message with a variable so that the message
// can be displayed within a ZHTML file.  This function always returns 0 so that
// it can evaluate to FALSE in a guard expression (hence indicating an error).
// For example, it can be used in a guard like this:
//   #web temp (($temp < 30)?WEB_ERROR("too low"):1)
// Note that this function determines which variable is referred to by the use
// of global information.
//
// error  -- Error message to associate with the variable.
// Return -- Always returns 0.

_http_nodebug
int WEB_ERROR(char *error)
{
	auto int len;

	_http_assert(error != NULL);

	// We must copy out the given error string into an xmem buffer
	len = strlen(error) + 1; // include the NULL terminator in the len
	if (_rweb_weberror_buffer_len + len >= RWEB_WEB_ERROR_MAXBUFFER) {
		// String is too large--we have to drop the WEB_ERROR() message
#ifdef RABBITWEB_VERBOSE
		printf("RWEB: WEB_ERROR() message has overflowed the xmem buffer!\n");
#endif
		return 0;
	}
	root2xmem(_rweb_weberror_buffer + _rweb_weberror_buffer_len, error, len);
	// Update the appropriate _http_post_changed[] entry
	_http_post_changed[_rweb_post_changed_index].error |=
	   _rweb_weberror_buffer_len;
	// Update the length of the WEB_ERROR() xmem buffer
	_rweb_weberror_buffer_len += len;
	// Return a FALSE value
	return 0;
}

/*** BeginHeader zhtml_copynewval */
void zhtml_copynewval(void *dest, void *src, int type);
/*** EndHeader */

// Copy the given value (in src) to the destination (in dest) given the type.
// As a special case, strings are not copied--they are handled specially in the
// calling function.
//
// dest -- Destination of the value.
// src  -- Source of the value.
// type -- Type of the variable.

_http_nodebug
void zhtml_copynewval(void *dest, void *src, int type)
{
	_http_assert(dest != NULL);

	switch (type) {
   case _DK_T_CHAR:
   	*((char *)dest) = *((char *)src);
      return;
   case _DK_TSIGNEDCHAR:
   	*((signed char *)dest) = *((signed char *)src);
      return;
	case _DK_TINT:
   	*((int *)dest) = *((int *)src);
      return;
   case _DK_TUNSIGNED:
   	*((unsigned int *)dest) = *((unsigned int *)src);
      return;
   case _DK_TLONG:
   	*((long *)dest) = *((long *)src);
      return;
   case _DK_TULONG:
   	*((unsigned long *)dest) = *((unsigned long *)src);
      return;
   case _DK_TFLOAT:
   	*((float *)dest) = *((float *)src);
      return;
   case _DK_TSTRING:
   	// Don't copy strings
		return;
   }
}

/*** BeginHeader zhtml_checkstrlen */
int zhtml_checkstrlen(int len, int *bounds);
/*** EndHeader */

// Check if the given length is greater than the string length indicated in the
// bounds array.
//
// len    -- Length to check
// bounds -- Contains the length of the string in the last element of this
//        array.
// Return -- 0 on success, -1 on error (string too long).

_http_nodebug
int zhtml_checkstrlen(int len, int *bounds)
{
	_http_assert(bounds != NULL);

	// Check the string length
	if (len >= zhtml_getstrsize(bounds)) {
		return -1;
	}
	return 0;
}

/*** BeginHeader zhtml_getstrsize */
int zhtml_getstrsize(int *bounds);
/*** EndHeader */

// Get the size of a string, given the array bounds for the variable.  The
// string length will be the last entry in the array bounds.
//
// bounds -- An array of array bounds.
// Return -- Length of the string.

_http_nodebug
int zhtml_getstrsize(int *bounds)
{
	auto int i;

	_http_assert(bounds != NULL);

	// The maximum length of the string is given by the last dimension
	i = 0;
	while (bounds[i] != 0) {
		i++;
	}
	return bounds[i-1];
}

/*** BeginHeader zhtml_checkchanged */
int zhtml_checkchanged(void *val, void *oldval, int type, _Web_Select select);
/*** EndHeader */

// Check if a variable value has changed from the committed value.  This does
// some special processing for selection variables (which is needed if
// select.ptr16 is not NULL).
//
// val    -- New value of the variable.
// oldval -- Committed value of the variable.
// type   -- Type of the variable to check.
// select -- Selection information on this variable if it is a selection type
//           (i.e., if select.ptr16 is not NULL).
// Return -- 1 if the value changed, 0 if it did not change, and -1 on error.

_http_nodebug
int zhtml_checkchanged(void *val, void *oldval, int type, _Web_Select select)
{
	auto int is32;
	auto _Web_Select16 *ptr16;
	auto _Web_Select32 *ptr32;
	auto char *name;
	auto char *newname;

	// Check if this is a selection type variable
	if (select.ptr16 != NULL) {
		// It is a selection variable

		// Much of the complication below comes from the fact that selection
		// variables can support both 16-bit and 32-bit integers.  is32 keeps
		// track of whether this variable is a 16-bit or 32-bit integer.
	   is32 = zhtml_select_is32(type);
	   if (is32 < 0) {
	      // Not a proper type for a selection variable
	      return -1;
	   }

	   ptr16 = select.ptr16;
	   ptr32 = select.ptr32;
	   if (is32) {
	      if (ptr32 == NULL) {
	         // Not a selection variable
	         return -1;
	      }
	      name = ptr32->name;
	   }
	   else {
	      if (ptr16 == NULL) {
	         // Not a selection variable
	         return -1;
	      }
	      name = ptr16->name;
	   }
		// Check for the selection value within the list
		newname = (char *)val;
	   while (name != NULL) {
	   	if (strcmp(newname, name) == 0) {
	   		// We have our match--ptr16 or ptr32 will point to the correct value
	   		// information
	   		break;
	   	}
	   	else {
	   		// No match--must skip to the next selection name
	   		if (is32) {
	   			ptr32++;
	   			name = ptr32->name;
	   		}
	   		else {
	   			ptr16++;
	   			name = ptr16->name;
	   		}
	   	}
	   }
	   // Make sure we didn't exit the loop because we reached the end of the
	   // list
	   if (name == NULL) {
	   	// Not a valid selection
         return -1;
	   }

		// Copy the value out appropriately.  This mocks up the selection variable
		// to look like a normal variable for the code below.
		switch (type) {
		case _DK_TINT:
      	*((int *)val) = ptr16->value;
         break;
		case _DK_TUNSIGNED:
			*((unsigned int *)val) = ptr16->value;
         break;
		case _DK_TLONG:
      	*((long *)val) = ptr32->value;
         break;
		case _DK_TULONG:
      	*((unsigned long *)val) = ptr32->value;
      	break;
		default:
			// Error
			return -1;
		}
	}

	// Check the new value against the old value to see if it has changed.
	switch (type) {
	   case _DK_T_CHAR:
	      return (*((char *)val) != *((char *)oldval));

	   case _DK_TSIGNEDCHAR:
	      return (*((signed char *)val) != *((signed char *)oldval));

	   case _DK_TINT:
	      return (*((int *)val) != *((int *)oldval));

	   case _DK_TUNSIGNED:
	      return (*((unsigned int *)val) != *((unsigned int *)oldval));

	   case _DK_TLONG:
	      return (*((long *)val) != *((long *)oldval));

	   case _DK_TULONG:
	      return (*((unsigned long *)val) != *((unsigned long *)oldval));

	   case _DK_TFLOAT:
	      return (*((float *)val) != *((float *)oldval));

	   case _DK_TSTRING:
	      return (strcmp((char *)val, (char *)oldval) != 0);
   }
}

/*** BeginHeader zhtml_findnextvar */
int zhtml_findnextvar(int offset);
/*** EndHeader */

// Skip to the next variable in the POST buffer.
//
// offset -- Originating offset into the POST buffer.
// Return -- Offset into POST buffer of the next variable name on success, or
//           -1 on error.

_http_nodebug
int zhtml_findnextvar(int offset)
{
	auto int found;
   auto int ch;

	_http_assert(offset >= 0);

	// Go through the buffer until we find an '&' (or have exceeded the buffer)
   found = 0;
   while ((!found) && (offset < _http_post_len)) {
   	ch = xgetint(_http_post + offset++);
      if (((char)(ch & 0x00ff)) == '&') {
      	found = 1;
      }
   }
   if (found) {
   	return offset;
   }
   else {
   	return -1;
   }
}

/*** BeginHeader zhtml_varcmp */
int zhtml_varcmp(char *name, int offset);
/*** EndHeader */

// Checks a variable name against a name contained in the POST buffer to see
// if they are the same.  It returns the offset into the POST buffer of the
// variable value on success, and -1 on error.
//
// name   -- Name of the variable in root memory.
// offset -- Offset into the POST buffer of a variable name.
// Return -- Offset of the beginning of the variable value on success, -1 on
//           error.

_http_nodebug
int zhtml_varcmp(char *name, int offset)
{
   auto int ch_temp;
   auto char ch;
   auto int i;
   auto int open;

	_http_assert(offset >= 0);

	// Continue until we have exceeded the buffer (the normal case of going until
	// the end of one name or the other is handled within the while loop).
   i = 0;
   open = 1;
   while ((offset + i) < _http_post_len) {
   	ch_temp = xgetint(_http_post + offset + i);
      ch = (char)(ch_temp & 0x00ff);
      // This handles the array bracket munging
      if (ch == '+') {
      	if (open) {
         	ch = '[';
            open = 0;
         }
         else {
         	ch = ']';
            open = 1;
         }
      }
      // Check if it is a match
      if ((ch == '=') && (name[i] == '\0')) {
      	// We have a match--return the index of the beginning of the var
         return i+1;
      }
      // Check if it isn't a match
      else if (((ch == '=') && (name[i] != '\0')) ||
               ((name[i] == '\0') && (ch != '=')) ||
               ((tolower(ch) != tolower(name[i])))) {
			// Definitely not a match
      	return -1;
      }
      // We have a partial match so far...
      i++;
   }
   // We hit the end of the POST buffer, so we definitely don't have a match
   return -1;
}

/*** BeginHeader _web_getnewval */
void *_web_getnewval(char *name, int type, void *curval);
/*** EndHeader */

// This function is called from the guards for a #web-registered variable.  It
// is used for lookups that do not involve arrays.  It looks up the information
// for the given variable (given the name, the type, and a pointer to the
// current commited value).
//
// name   -- Name of the variable to look up.
// type   -- The type of the variable to look up.
// curval -- A pointer to the current, committed value of the variable.
// Return -- A pointer to the looked-up value.

_http_nodebug
void *_web_getnewval(char *name, int type, void *curval)
{
   auto void *ptr;
   auto int i;

#ifdef RABBITWEB_VERBOSE
   printf("RWEB: Checking variable %s\n", name);
#endif
	// Go through the list of changed variables until we find a match
   for (i = 0; i < _http_post_changed_len; i++) {
   	if (zhtml_varcmp(name, _http_post_changed[i].nameoffset) >= 0) {
      	// We got a match
         if (type != _DK_TSTRING) {
         	// It's not a string variable, so just pass out a pointer to the
         	// saved new value
	         ptr = (void *)(&(_http_post_changed[i].newval));
         }
         else {
         	// It is a string variable, so we must copy out the variable
			   ptr = zhtml_varxmem2root(_http_post_var + _http_post_var_offset,
			                         RWEB_ZHTML_MAXVARLEN - _http_post_var_offset,
			                         _http_post_changed[i].valoffset, type,
			                         curval, NULL);
				// Only increment the offset into the post variable buffer if the
				// string was actually copied into the buffer.  zhtml_varxmem2root()
				// will return the old value (curval) if it can't perform the copy.
				if (ptr != curval) {
					_http_post_var_offset += strlen(ptr) + 1;
				}
#ifdef RABBITWEB_VERBOSE
				else {
					printf("RWEB: String variable(s) too long for guard check!\n");
				}
#endif
         }
         return ptr;
      }
   }
   // No match--return old value
   return curval;
}


/*** BeginHeader _web_getwildval */
void *_web_getwildval(char *s, int *dims);
/*** EndHeader */

// This function is called from the guards for a #web-registered variable.  It
// is used whenever the requested variable's value involves an array (and,
// hence, potentially wildcarded dimensions).  It looks up the information for
// the given variable (given the name, s, the _Web_Var_Info structure for the
// variable associated with the calling guard expression, wvi, and the
// dimensions of any array indices, dims).
//
// Note that the dims parameter is no longer being used in this function.  This
// is a workaround for a compiler problem, although actually the workaround is
// a perfectly good fix.  The library now keeps track of the dims array instead
// of passing it back and forth through the guard function.
//
// s      -- A pointer to the variable name too look up.
// wvi    -- The _Web_Var_Info structure for the variable associated with the
//           guard that is performing the lookup.
// dims   -- An array of dimensions for each array index in the variable that is
//           being looked up.
// Return -- A pointer to the variable value.

_http_nodebug
void *_web_getwildval(char *s, int *dims)
{
	auto ZHTMLVarInfo varinfo;
   auto int i;
   auto void *ptr;

#ifdef RABBITWEB_VERBOSE
	printf("RWEB: Checking wildcarded variable\n");
#endif
	i = zhtml_substitutedims(_http_post_var, s, _zhtml_dims, RWEB_ZHTML_MAXVARLEN);
	if (i < 0) {
		return NULL;
	}

	// Get the variable information
	i = zhtml_matchbest(_http_post_var, &varinfo, 0);
	if (i < 0) {
   	return NULL;
   }
   // Find in POST buffer
   for (i = 0; i < _http_post_changed_len; i++) {
		if (zhtml_varcmp(_http_post_var, _http_post_changed[i].nameoffset) >= 0) {
      	// We got a match
         if (_http_post_changed[i].vartype != _DK_TSTRING) {
         	// It's not a string variable, so just pass out a pointer to the
         	// saved new value
         	ptr = (void *)(&(_http_post_changed[i].newval));
         }
         else {
         	// It is a string variable, so we must copy out the variable
	         ptr = zhtml_varxmem2root(_http_post_var + _http_post_var_offset,
	                               RWEB_ZHTML_MAXVARLEN - _http_post_var_offset,
	                               _http_post_changed[i].valoffset,
	                               _http_post_changed[i].vartype,
	                               varinfo.valptr, NULL);
				// Only increment the offset into the post variable buffer if the
				// string was actually copied into the buffer.  zhtml_varxmem2root()
				// will return the old value (curval) if it can't perform the copy.
				if (ptr != varinfo.valptr) {
					_http_post_var_offset += strlen(ptr) + 1;
				}
#ifdef RABBITWEB_VERBOSE
				else {
					printf("RWEB: String variable(s) too long for guard check!\n");
				}
#endif
         }
         return ptr;
      }
   }
   // No match--return old value
   return varinfo.valptr;
}

/*** BeginHeader zhtml_skipvarname */
int zhtml_skipvarname(int offset);
/*** EndHeader */

// Skip past the name of a variable in the POST buffer to the value of the
// variable (after '=').
//
// offset -- Offset into the POST buffer
// Return -- Offset of the variable's value in the POST buffer, or -1 on error.

_http_nodebug
int zhtml_skipvarname(int offset)
{
	auto int ch_temp;
	auto char ch;
   auto int i;

	_http_assert(offset >= 0);

	// Loop over the buffer data until we exceed the buffer (the usual case of
	// reaching the end of the variable name is handled within the while loop).
   i = 0;
   while((offset + i) < _http_post_len) {
   	ch_temp = xgetint(_http_post + offset + i);
      ch = (char)(ch_temp & 0x00ff);
      if (ch == '=') {
      	// We found the '=' we are looking for (which indicates the end of the
      	// variable name).  Return the offset to the next byte if we can.
			if (offset+i+1 < _http_post_len) {
	      	return offset+i+1;
	      }
	      else {
	      	return -1;
	      }
      }
      i++;
   }
   return -1;
}

/*** BeginHeader zhtml_findpostvar */
int zhtml_findpostvar(char *name);
/*** EndHeader */

// Find the given variable name within the POST buffer.
//
// name   -- Variable name to search for.
// Return -- Offset of the variable in the POST buffer if found, -1 if not
//           found.

_http_nodebug
int zhtml_findpostvar(char *name)
{
	auto int offset;

   offset = 0;
	// Loop until there are no more post variables
   while (offset >= 0) {
		if (zhtml_varcmp(name, offset) >= 0) {
      	// We have a match
			return offset;
      }
      else {
      	// We don't have a match--try the next variable
         offset = zhtml_findnextvar(offset);
      }
   }
   // No match in the entire POST buffer
   return -1;
}

/*** BeginHeader zhtml_gobble_whitespace */
char *zhtml_gobble_whitespace(char *buffer);
/*** EndHeader */

// Skip the whitespace pointed to by buffer.
//
// buffer -- Buffer which may contain whitespace to skip.
// Return -- Pointer to the first character in buffer that is not whitespace

_http_nodebug
char *zhtml_gobble_whitespace(char *buffer)
{
	while (isspace(*buffer)) {
		buffer++;
	}
	return buffer;
}

/*** BeginHeader zhtml_varxmem2root */
void *zhtml_varxmem2root(char *rootdest, int destlen, int offset, int type,
                         void *oldval, int *error);
/*** EndHeader */

// Copies a variable value from the POST xmem buffer to a root destination
// buffer.  It converts the string source value to the variable's type's
// native representation.  If there is a problem with converting to the native
// type, then the old, committed value is returned instead (but the variable is
// still flagged as being "in error").
//
// rootdest -- Destination buffer for the value
// destlen  -- Length of the destination buffer
// offset   -- Offset into POST buffer of the variable value
// type     -- Type of the variable
// oldval   -- Pointer to the committed value of the variable
// error    -- OUTPUT.  Indicate if the variable is in error (problem converting
//             to native type).
// Return   -- Pointer to the variable value in native form

_http_nodebug
void *zhtml_varxmem2root(char *rootdest, int destlen, int offset, int type,
                         void *oldval, int *error)
{
	auto long var;
	auto unsigned long ulvar;
   auto float floatvar;
   auto int varlen;
   auto char *endptr;

	_http_assert(rootdest != NULL);
	_http_assert(offset >= 0);

	if (error) *error = 0;
   // Copy the value to a temporary buffer
	varlen = zhtml_copyvalue(rootdest, (long)(_http_post + offset), destlen);
  	if (varlen < 0) {
   	// Error--just return the old value
   	if (error) *error = 1;
     	return oldval;
   }

	switch (type) {
	case _DK_TSIGNEDCHAR:
	case _DK_T_CHAR:
	   // Read the character
	   var = rootdest[0];
	   endptr = zhtml_gobble_whitespace(&(rootdest[1]));
	   if (*endptr != '\0') {
	   	// Error--just return the old value
	   	if (error) *error = 1;
	   	return oldval;
	   }
     	*((char *)rootdest) = (char)var;
   	break;
	case _DK_TINT:
	   // Read the integer
	   var = _n_strtol(rootdest, &endptr, 10);
	   endptr = zhtml_gobble_whitespace(endptr);
	   if (*endptr != '\0') {
	      // Error--just return the old value
         if (error) *error = 1;
	      return oldval;
	   }
	   // Check the allowable range of this type
	   if (var > INT_MAX) {
      	*((int *)rootdest) = INT_MAX;
	   }
	   else if (var < INT_MIN) {
      	*((int *)rootdest) = INT_MIN;
	   }
	   else {
	     	*((int *)rootdest) = (int)var;
	   }
   	break;
	case _DK_TUNSIGNED:
	   // Read the integer
	   var = _n_strtol(rootdest, &endptr, 10);
	   endptr = zhtml_gobble_whitespace(endptr);
	   if (*endptr != '\0') {
	      // Error--just return the old value
         if (error) *error = 1;
	      return oldval;
	   }
	   // Check the allowable range of this type
	   if (var > UINT_MAX) {
      	*((unsigned int *)rootdest) = (unsigned int)UINT_MAX;
	   }
	   else if (var < 0) {
      	*((unsigned int *)rootdest) = 0;
	   }
	   else {
	     	*((unsigned int *)rootdest) = (unsigned int)var;
	   }
   	break;
	case _DK_TLONG:
	   // Read the long
	   var = _n_strtol(rootdest, &endptr, 10);
	   endptr = zhtml_gobble_whitespace(endptr);
	   if (*endptr != '\0') {
	      // Error--just return the old value
         if (error) *error = 1;
	      return oldval;
	   }
     	*((long *)rootdest) = (long)var;
   	break;
	case _DK_TULONG:
	   // Read the long
	   ulvar = _n_strtoul(rootdest, &endptr, 10);
	   endptr = zhtml_gobble_whitespace(endptr);
	   if (*endptr != '\0') {
	      // Error--just return the old value
         if (error) *error = 1;
	      return oldval;
	   }
     	*((unsigned long *)rootdest) = ulvar;
   	break;
	case _DK_TFLOAT:
	   // Read the integer
	   floatvar = _n_strtod(rootdest, &endptr);
	   endptr = zhtml_gobble_whitespace(endptr);
	   if (*endptr != '\0') {
	      // Error--just return the old value
         if (error) *error = 1;
	      return oldval;
	   }
     	*((float *)rootdest) = floatvar;
   	break;
	case _DK_TSTRING:
		// Do nothing, since the string has already been copied
   	break;
   }

   return rootdest;
}

/*** BeginHeader zhtml_copyvalue */
int zhtml_copyvalue(char __far *dest, long src, int len);
/*** EndHeader */

// Copies a variable value (in string form) from the POST request into a
// destination buffer (still in string form).  It will URL decode the value
// as it is copied, and will null-terminate the destination string.
//
// dest   -- The destination buffer.
// src    -- The source buffer (part of the POST request).
// len    -- Size of the destination buffer
// Return -- Number of bytes written to dest on success, -1 on error (value
//           too long).
_http_nodebug
int zhtml_copyvalue(char __far *dest, long src, int len)
{
	auto long end;
	auto int nl;

	_http_assert(dest != NULL);

	// First, find the end of the value
   end = (long)_f_memchr((void __far *)src, '&', (int)((_http_post + _http_post_len) - src));
   if (end == 0) {
   	// Must be at the end of the POST
      end = (long)(_http_post + _http_post_len);
   }
   if ((end - src - 1) > len) {
   	// The value is too long to copy out
   	return -1;
   }
   _f_memcpy(dest, (char __far *)src, nl = (int)(end - src));
   dest[nl] = '\0';
   // URL decode the copied string
   http_urldecode(dest, dest, len);
   return strlen(dest);
}

/*** BeginHeader zhtml_applychanges */
int zhtml_applychanges(HttpState_p state);
/*** EndHeader */

// This function applies the variable changes that have been saved in the
// _http_post_changed[] array.  This is only done after the guards for each
// changed variable have been checked and have passed.  After the changes have
// been applied, the #web_update functions for each changed variable are
// called.  Note that most of the input to this function comes from the global
// _http_post_changed[] array.
//
// state  -- The current HTTP server state.
// Return -- Always returns 0.

_http_nodebug
int zhtml_applychanges(HttpState_p state)
{
	auto int i;
	auto _rweb_fcnptr *fplist;
   auto _rweb_fcnptr fp;

	// Loop through the list of changed variables
   for (i = 0; i < _http_post_changed_len; i++) {
   	// Check if this entry has been invalidated (this happens if the variable
   	// comes through more than once, and the last time it comes in the value
   	// is the same as the committed value)
   	if (_http_post_changed[i].valoffset < 0) {
   		continue;
   	}
   	// Copy out the value
		switch (_http_post_changed[i].vartype) {
      case _DK_TSIGNEDCHAR:
	   case _DK_T_CHAR:
      	*(char *)(_http_post_changed[i].varptr) =
      	   *((char *)(&(_http_post_changed[i].newval)));
	      break;
	   case _DK_TINT:
      	*(int *)(_http_post_changed[i].varptr) =
      	   *((int *)(&(_http_post_changed[i].newval)));
	      break;
	   case _DK_TUNSIGNED:
      	*(unsigned int *)(_http_post_changed[i].varptr) =
      	   *((unsigned int *)(&(_http_post_changed[i].newval)));
	      break;
	   case _DK_TLONG:
      	*(long *)(_http_post_changed[i].varptr) =
      	   *((long *)(&(_http_post_changed[i].newval)));
	      break;
	   case _DK_TULONG:
      	*(unsigned long *)(_http_post_changed[i].varptr) =
      	   *((unsigned long *)(&(_http_post_changed[i].newval)));
			break;
	   case _DK_TFLOAT:
      	*(float *)(_http_post_changed[i].varptr) =
      	   *((float *)(&(_http_post_changed[i].newval)));
	      break;
	   case _DK_TSTRING:
	      zhtml_varxmem2root(_http_post_var, RWEB_ZHTML_MAXVARLEN,
	                         _http_post_changed[i].valoffset,
	                         _http_post_changed[i].vartype,
	                         _http_post_changed[i].varptr, NULL);
      	strcpy((char *)_http_post_changed[i].varptr,
                (char *)_http_post_var);
	      break;
      }
	}
   // Now we need to loop through again and call the update function(s) for
   // each variable
   // Note that compiler-generated wrappers around each update function keeps
   // track of whether it has already been called or not.  The memset() below
   // clears the array that keeps track of if each function has already been
   // called.

#ifdef RABBITWEB_VERBOSE
	printf("RWEB: Calling update functions\n");
#endif
   memset(_web_update_entry_ary, 0, _web_update_entry_ary_sz);
   for (i = 0; i < _http_post_changed_len; i++) {
   	fplist = (_http_post_changed[i].info)->updateptr;
      if (fplist) {
	      while (*fplist) {
	         fp = *fplist++;
	         fp();
	      }
      }
	}
   return 0;
}

/*** BeginHeader zhtml_memstr */
void __far *zhtml_memstr(void __far *src, char __far *str, int n);
/*** EndHeader */

// Finds a given string (exact match) within a buffer of length len.
//
// src    -- The buffer in which to look for the string
// str    -- The string to search for
// n      -- The length of the src buffer
// Return -- a location pointer for the found string, or NULL if not found

_http_nodebug
void __far *zhtml_memstr(void __far *src, char __far *str, int n)
{
	auto int found;
   auto char __far *loc;
   auto int len;

   found = 0;
   len = strlen(str);
   while (!found) {
   	// Look for the first character
   	loc = _f_memchr(src, str[0], n);
      // Did we get it?  If so, do we have enough room to check the rest of the
      // string?
      if (!loc || (loc + len > (char __far *)src + n)) {
      	return NULL;
      }
      // Check for the rest of the string
      if (memcmp(loc+1, str+1, len-1) == 0) {
      	found = 1;
      }
      else {
      	// Wasn't found...advance the pointers
         n -= (int)((loc + 1) - (char __far *)src);
			// Check if we possibly have enough room for a match
         if (n < len) {
         	return NULL;
         }
         src = loc + 1;
      }

   }
   return loc;
}

/*** BeginHeader zhtml_check_variable_access */
int zhtml_check_variable_access(HttpState_p state, ZHTMLVarInfo *info,
                                int write);
/*** EndHeader */

// This function checks the access to the given variable.  It checks whether
// read or write access is being requested against the access restrictions for
// the variable.
//
// state  -- The HttpState structure, which contains the current method of
//           authentication.
// info   -- The information on the variable on which we are checking access
// write  -- !0 if write mode is being queried, 0 for read mode
// Return -- 0 for success (has access), -1 for no access

_http_nodebug
int zhtml_check_variable_access(HttpState_p state, ZHTMLVarInfo *info, int write)
{
	auto int userid;
   auto word usergroup;
   auto char server_auth;
   auto char auth;

	auth = info->auth;
	// Check if SSL is needed to access this variable
	if (auth & 0x08) {
		if (! _IS_HTTPS(state)) {
			return -1;
		}
		auth &= (~0x08);
	}
	if ((auth == 0) && (info->groups == 0) && (info->perm == 0)) {
   	// No auth information--default to OK
      return 0;
   }
	// We need to have authenticated to get user information, so check if we
	// *have* authenticated first
	if (state->auth_meth == HTTP_NO_AUTH) {
	   // If auth == 0, then there isn't really any userid information.  Rather,
	   // if groups is 0xffff, then read permission is given, and if perms is
	   // also 0xffff, then read-write permission is given.
	   if (auth == 0) {
	      if (write) {
	         if (info->perm == 0xffff) {
	            return 0;
	         }
	         else {
	            return -1;
	         }
	      }
	      else {
	         if (info->groups == 0xffff) {
	            return 0;
	         }
	         else {
	            return -1;
	         }
	      }
	   }
	}
	// Get the information on the current user
	userid = sauth_getuserid(state->username,
	                         _IS_HTTPS(state) ? SERVER_HTTPS : SERVER_HTTP);
	if (userid < 0) {
		// No such user
		return -1;
	}
   if ((auth == 0) && (info->groups != 0)) {
   	// Group access is restricted, but no auth is specified, so any auth will
   	// do other than "none"
      auth = 0xff & (~HTTP_NO_AUTH);
   }
	// Check the type of authentication
   server_auth = state->auth_meth;
   if (!(server_auth & auth)) {
      return -1;
   }
   // Get the user group
	sauth_getusermask(userid, &usergroup, NULL);
   // Check the group access
   if (!write) {
   	// Checking read access
   	if (info->groups & usergroup) {
      	// We have access
         return 0;
      }
      else {
      	return -1;
      }
   }
   else {
   	// Checking write access
   	if (info->perm & usergroup) {
      	// We have access
         return 0;
      }
      else {
      	return -1;
      }
   }
}

/*** BeginHeader zhtml_error */
void zhtml_error(ZHTMLParser *parser, char *string);
/*** EndHeader */

// A convenience function for writing an error to the output buffer.
//
// parser -- The current state of the ZHTML parser.
// string -- The error string to write to the output buffer.

_http_nodebug
void zhtml_error(ZHTMLParser *parser, char *string)
{
	auto int len;

	len = snprintf(parser->buffer, HTTP_MAXBUFFER, "ZHTML ERROR:  %s\n", string);
	if (len >= HTTP_MAXBUFFER) {
		parser->buffer[HTTP_MAXBUFFER-1] = '\0';
	}
}

/*** BeginHeader zhtml_parse_statement */
int zhtml_parse_statement(ZHTMLParser *parser);

enum {
	ZHTML_CMD_NONE,
   ZHTML_CMD_ECHO,
   ZHTML_CMD_PRINTF,
   ZHTML_CMD_IF,
   ZHTML_CMD_FOR,
   ZHTML_CMD_CLOSEBLOCK,
   ZHTML_CMD_VARNAME,
   ZHTML_CMD_PRINT_OPT,
   ZHTML_CMD_PRINT_SELECT,
   ZHTML_CMD_FIELD_CHECKBOX,
   ZHTML_CMD_FIELD_RADIO
};
/*** EndHeader */

// Parses a complete ZHTML statement, enclose by <?z ... ?> tags.  The main
// portion of this function is a large switch statement which does the parsing
// for all the different commands.  This function returns the number of bytes
// written to the output buffer.
//
// parser -- The current state of the ZHTML parser.
// Return -- The number of bytes written to the output buffer.

_http_nodebug
int zhtml_parse_statement(ZHTMLParser *parser)
{
	auto char buf[20];
   auto long number;
   auto int index;
   auto ZHTMLBlockContext *block;
   auto int loopvar;
   auto int end;
   auto int stepop;
   auto int retval;
   auto char __far *oldp;

	parser->buffer[0] = '\0';
	parser->command = ZHTML_CMD_NONE;
   // Skip whitespace
   zhtml_parse_whitespace(parser);
   // Read the command
   zhtml_parse_command(parser);
   // Go ahead and skip any whitespace after the command
   zhtml_parse_whitespace(parser);
   switch (parser->command) {
	// Handles the case of a missing or invalid command
   case ZHTML_CMD_NONE:
   	zhtml_error(parser, "Missing or invalid command");
      break;
   // Handles an "echo" or "print" statement
   case ZHTML_CMD_ECHO:
      // The "echo" command simply takes a variable as the argument
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
		retval = zhtml_parse_echo_error(parser);
		if (retval == -2) {
			// zhtml_parse_echo_error() issues its own errors
			break;
		}
		else if (retval == -1) {
			// Not an error() expression
	      loopvar = zhtml_parse_loopvariable(parser);
	      if (loopvar >= 0) {
	         // It is a loop variable--fake it up to look like a regular variable
	         parser->varinfo.valptr = &(parser->tempvars[loopvar]);
	         parser->varinfo.newval = -1;
	         parser->varinfo.type.simple = _DK_TINT;
	      }
	      else if (zhtml_parse_variable(parser, &(parser->varinfo)) == 0) {
	         // Check access to the variable
	         if (zhtml_check_variable_access(parser->state,
	                                         &(parser->varinfo), 0) < 0) {
	            // Error--don't have access to the variable
	            zhtml_error(parser, "No read access to variable");
	            break;
	         }
	      }
	      else {
	      	zhtml_error(parser, "Unknown variable");
	      	break;
	      }
         // Get the value and print it out
         zhtml_output_variable(parser, parser->buffer, NULL);
      }

      // Parse out whitespace and then the end of the statement
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_closeparen(parser) < 0) {
      	zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
	// Handles a "printf" statement
   case ZHTML_CMD_PRINTF:
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
   	if (zhtml_parse_printfspec(parser, buf) < 0) {
      	zhtml_error(parser, "Invalid printf format specifier");
         break;
      }
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_comma(parser) < 0) {
      	zhtml_error(parser, "Expecting ','");
         break;
      }
      zhtml_parse_whitespace(parser);
	   loopvar = zhtml_parse_loopvariable(parser);
	   if (loopvar < 0) {
	      // No loop variable...maybe a regular variable?
	      if (zhtml_parse_variable(parser, &(parser->varinfo)) < 0) {
	         zhtml_error(parser, "Unknown variable");
	         break;;
	      }
	      // Check access to the variable
	      if (zhtml_check_variable_access(parser->state,
	                                      &(parser->varinfo), 0) < 0) {
	         // Error--don't have access to the variable
	         zhtml_error(parser, "No read access to variable");
	         break;
	      }
	   }
	   else {
	   	// It is a loop variable--fake it up to look like a regular variable
	   	parser->varinfo.valptr = &(parser->tempvars[loopvar]);
	   	parser->varinfo.newval = -1;
	   	parser->varinfo.type.simple = _DK_TINT;
	   }
      // Check access to the variable
      if (zhtml_check_variable_access(parser->state,
                                      &(parser->varinfo), 0) < 0) {
      	// Error--don't have access to the variable
         zhtml_error(parser, "No read access to variable");
         break;
      }
		// Output the variable
      zhtml_output_variable(parser, parser->buffer, buf);
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_closeparen(parser) < 0) {
      	zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
	// Handles an "if" statement
   case ZHTML_CMD_IF:
		if (parser->nesting >= RWEB_ZHTML_MAXBLOCKS) {
			zhtml_error(parser, "if/for nesting level too deep!");
			break;
		}
   	// Set the type of block, since this "if" statement will be defining a
   	// new block
   	parser->context[parser->nesting].blocktype = _ZHTML_BLOCK_IF;
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_conditional(parser) < 0) {
      	// zhtml_parse_conditional() generates its own errors
         break;
      }
      zhtml_parse_whitespace(parser);
		if (zhtml_parse_closeparen(parser) < 0) {
         zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_openbrace(parser) < 0) {
      	zhtml_error(parser, "Expecting '{'");
         break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);

		// Increment the nesting level (due to new block)
      parser->nesting++;
      // Check the result of the expression
      if (!parser->truth && !parser->skipping) {
      	// Need to start skipping data--indicate the nesting level at which we
      	// started skipping
			parser->skipping = parser->nesting;
      }
   	break;
   // Handles a "for" statment
   case ZHTML_CMD_FOR:
		if (parser->nesting >= RWEB_ZHTML_MAXBLOCKS) {
			zhtml_error(parser, "if/for nesting level too deep!");
			break;
		}
   	block = &(parser->context[parser->nesting]);
      // Set the type of block
   	block->blocktype = _ZHTML_BLOCK_FOR;
		if (zhtml_parse_openparen(parser) < 0) {
         zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
      // Determine which of $A-$Z is the loop variable
      block->var = zhtml_parse_loopvariable(parser);
      if (block->var < 0) {
         zhtml_error(parser, "Expecting loop variable $A-$Z");
         break;
      }
      zhtml_parse_whitespace(parser);
		if (zhtml_parse_equals(parser) < 0) {
         zhtml_error(parser, "Expecting '='");
         break;
      }
      zhtml_parse_whitespace(parser);
      // Get the starting value of the loop variable
      if (zhtml_parse_number(parser, &number, 0) < 0) {
      	// zhtml_parse_number generates its own errors
         break;
      }
      // Save off the starting value of the temporary loop variable
      parser->tempvars[block->var] = (int)number;
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_semicolon(parser) < 0) {
      	zhtml_error(parser, "Expecting ';'");
         break;
      }
      zhtml_parse_whitespace(parser);
      // Get the loop variable, and make sure it matches the first loop variable
      loopvar = zhtml_parse_loopvariable(parser);
      if (loopvar < 0) {
         zhtml_error(parser, "Expecting loop variable $A-$Z");
         break;
      }
      if (loopvar != block->var) {
      	zhtml_error(parser, "Inconsistent loop variables");
         break;
      }
      zhtml_parse_whitespace(parser);
      // Get the conditional operator
      block->comparison = zhtml_parse_comparison(parser);
      if (block->comparison < 0) {
      	zhtml_error(parser, "Expecting a conditional operator");
         break;
      }
      zhtml_parse_whitespace(parser);
		// Get the ending number (the number that the temporary variable will be
		// compared against on each loop through)
      if (zhtml_parse_number(parser, &number, 0) < 0) {
      	// zhtml_parse_number generates its own errors
         break;
      }
      block->end = (int)number;
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_semicolon(parser) < 0) {
      	zhtml_error(parser, "Expecting ';'");
         break;
      }
      zhtml_parse_whitespace(parser);
      // Get the loop variable, and make sure it matches the first loop variable
      loopvar = zhtml_parse_loopvariable(parser);
      if (loopvar < 0) {
         zhtml_error(parser, "Expecting loop variable $A-$Z");
         break;
      }
      if (loopvar != block->var) {
      	zhtml_error(parser, "Inconsistent loop variables");
         break;
      }
      zhtml_parse_whitespace(parser);
      // Get the step operator of the for statement
      stepop = zhtml_parse_stepop(parser);
      if (stepop < 0) {
      	zhtml_error(parser, "Expecting '++', '--', '+=', or '-='");
         break;
      }
      if ((stepop == _ZHTML_STEPOP_PE) ||
          (stepop == _ZHTML_STEPOP_ME)) {
			// Need to get an integer as well, since the operator was += or -=
	      zhtml_parse_whitespace(parser);
	      if (zhtml_parse_number(parser, &number, 0) < 0) {
	      	// zhtml_parse_number generates its own errors
	         break;
	      }
         block->step = (int)number;
      }
      else {
      	// An increment or decrement operation
      	block->step = 1;
      }
      // Negate the step value if this is a '--' or '-=' operation
      if ((stepop == _ZHTML_STEPOP_DEC) ||
          (stepop == _ZHTML_STEPOP_ME)) {
   		block->step = -block->step;
      }
      zhtml_parse_whitespace(parser);
		if (zhtml_parse_closeparen(parser) < 0) {
         zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_openbrace(parser) < 0) {
      	zhtml_error(parser, "Expecting '{'");
         break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
      // Save off the beginning offset of the for loop
      parser->context[parser->nesting].loopbegin =
         ((HttpState_p )parser->state)->endOffs;
      // Increment the block nesting level
      parser->nesting++;
      // Check if we even meet the test condition this first time through
		if (!zhtml_check_condition((long)parser->tempvars[block->var],
		                           block->comparison,
                                 (long)block->end)) {
			if (!parser->skipping) {
				parser->skipping = parser->nesting;
         }
      }
   	break;
	// Handles the '}' close block mechanism
	case ZHTML_CMD_CLOSEBLOCK:
		// Check if there is really a block to close
		if (!parser->nesting) {
      	zhtml_error(parser, "No matching '{'");
         break;
      }
   	block = &(parser->context[parser->nesting - 1]);
      // Check if this is a for loop we're "closing"
      if ((block->blocktype == _ZHTML_BLOCK_FOR) && !parser->skipping) {
      	parser->tempvars[block->var] += block->step;
			if (!zhtml_check_condition((long)parser->tempvars[block->var],
			                           block->comparison,
                                    (long)block->end)) {
         	// The for loop has ended
            parser->nesting--;
	         zhtml_parse_whitespace(parser);
	         zhtml_parse_end(parser);
         }
         else {
         	// We need to rewind the HTML file back to the beginning of the for
            // loop block
            if (http_seek((HttpState_p )parser->state, block->loopbegin) < 0) {
            	// Not a seekable resource
               zhtml_error(parser,
                  "For loops cannot be used with a non-seekable resource");
					parser->nesting--;
					zhtml_parse_whitespace(parser);
               zhtml_parse_end(parser);
               break;
            }
				((HttpState_p )parser->state)->ssiEnd = NULL;
         }
      }
      // It's an if statement that we're closing, or we're currently skipping
      // content
      else {
      	// Reduce our nesting level
      	parser->nesting--;
      	// See if we've gotten back down to the last failure level
      	if (parser->nesting < parser->skipping) {
      		parser->skipping = 0;
      	}
	      zhtml_parse_whitespace(parser);
	      zhtml_parse_end(parser);
      }
      break;
	// Handles the "varname" statement (does munging of variable names so that
	// they can be transmitted in an HTTP POST)
   case ZHTML_CMD_VARNAME:
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
      // Does the munging of the variable name
      if (zhtml_copy_varname(parser, parser->buffer, HTTP_HALFBUF, 1) < 0) {
      	zhtml_error(parser, "Expecting variable");
      	break;
      }
		if (zhtml_parse_closeparen(parser) < 0) {
         zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
   // Handles a "checkbox" statement
   case ZHTML_CMD_FIELD_CHECKBOX:
      // The "checkbox" command simply takes a variable as the argument
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);

		oldp = parser->p;
      if (zhtml_parse_variable(parser, &(parser->varinfo)) == 0) {
         // Check access to the variable
         if (zhtml_check_variable_access(parser->state,
                                         &(parser->varinfo), 0) < 0) {
            // Error--don't have access to the variable
            zhtml_error(parser, "No read access to variable");
            break;
         }
      } else {
         zhtml_error(parser, "Unknown variable");
         break;
      }

      if (zhtml_get_numericvariable(&(parser->varinfo), &number) < 0) {
         zhtml_error(parser, "Expecting a variable of integral type");
         break;
      }

      // Get the value and print it out
	   parser->p = oldp;
      zhtml_output_checkbox(parser, parser->buffer, (int) number);

      // Parse out whitespace and then the end of the statement
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_closeparen(parser) < 0) {
      	zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
   // Handles a "radio" statement
   case ZHTML_CMD_FIELD_RADIO:
      // The "radio button" command takes a variable and value as its arguments
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);

		oldp = parser->p;
      if (zhtml_parse_variable(parser, &(parser->varinfo)) == 0) {
         // Check access to the variable
         if (zhtml_check_variable_access(parser->state,
                                         &(parser->varinfo), 0) < 0) {
            // Error--don't have access to the variable
            zhtml_error(parser, "No read access to variable");
            break;
         }
      } else {
         zhtml_error(parser, "Unknown variable");
         break;
      }

      if (zhtml_get_numericvariable(&(parser->varinfo), &number) < 0) {
         zhtml_error(parser, "Expecting a variable of integral type");
         break;
      }

      // Get the value and print it out
	   parser->p = oldp;
      zhtml_output_radio(parser, parser->buffer, (int) number);

      // Parse out whitespace and then the end of the statement
      zhtml_parse_whitespace(parser);
      if (zhtml_parse_closeparen(parser) < 0) {
      	zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
   // Handles the "print_opt" command
   case ZHTML_CMD_PRINT_OPT:
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
		// Parse the variable--information on it will be in parser->varinfo
      if (zhtml_parse_variable(parser, &(parser->varinfo)) < 0) {
         zhtml_error(parser, "Unknown variable");
         break;
      }
      // Check access to the variable
      if (zhtml_check_variable_access(parser->state,
                                      &(parser->varinfo), 0) < 0) {
         // Error--don't have access to the variable
         zhtml_error(parser, "No read access to variable");
         break;
      }
      zhtml_parse_whitespace(parser);
      // Check if there is a ',' (which indicates the optional second
      // parameter)
      if (zhtml_parse_comma(parser) == 0) {
      	// There is an optional second parameter.  It specifies which
      	// selection value to print (rather than the default current value).
      	zhtml_parse_whitespace(parser);
      	if (zhtml_parse_number(parser, &number, 0) < 0) {
      		// zhtml_parse_number() generates its own errors
      		break;
      	}
	      if ((number < 0) || (number > INT_MAX)) {
	         zhtml_error(parser, "Selection index out of range");
	         break;
	      }
	      index = (int)number;
      	zhtml_parse_whitespace(parser);
      }
      else {
      	// No optional second parameter, so it prints the current value of the
      	// selection variable.
			if (zhtml_get_numericvariable(&(parser->varinfo), &number) < 0) {
				zhtml_error(parser, "Expecting a variable of integral type");
				break;
			}
			index = zhtml_select_index(&(parser->varinfo), number);
			if (index < 0) {
				zhtml_error(parser, "Select variable has invalid value");
				break;
			}
      }
		// We now have the selection variable's numeric value--we must look up
		// the corresponding string value
		zhtml_output_selectionstring(parser, &(parser->varinfo), index);
		if (zhtml_parse_closeparen(parser) < 0) {
         zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
	// Handles the "print_select" statement
   case ZHTML_CMD_PRINT_SELECT:
		if (zhtml_parse_openparen(parser) < 0) {
      	zhtml_error(parser, "Expecting '('");
			break;
      }
      zhtml_parse_whitespace(parser);
		// Parse the variable--information on it will be in parser->varinfo
      if (zhtml_parse_variable(parser, &(parser->varinfo)) < 0) {
         zhtml_error(parser, "Unknown variable");
         break;
      }
      // Check access to the variable
      if (zhtml_check_variable_access(parser->state,
                                      &(parser->varinfo), 0) < 0) {
         // Error--don't have access to the variable
         zhtml_error(parser, "No read access to variable");
         break;
      }
      if (zhtml_output_print_select(parser) < 0) {
      	// zhtml_output_print_select() generates its own errors
      	break;
      }
      zhtml_parse_whitespace(parser);
		if (zhtml_parse_closeparen(parser) < 0) {
         zhtml_error(parser, "Expecting ')'");
			break;
      }
      zhtml_parse_whitespace(parser);
      zhtml_parse_end(parser);
   	break;
   }
	// Returns the length of the data in the output buffer
	return strlen(parser->buffer);
}

/*** BeginHeader zhtml_parse_echo_error */
int zhtml_parse_echo_error(ZHTMLParser *parser);
/*** EndHeader */

// Outputs the corresponding WEB_ERROR() message for a given variable whose
// value is in error.  Note that this is for the error() function within an
// echo() or print() statement--if it is within an if statement, then another
// function parses it (zhtml_parse_error()).
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 on success, -1 if it is not an error() function, -2 on error.

_http_nodebug
int zhtml_parse_echo_error(ZHTMLParser *parser)
{
	auto char __far *oldp;
	auto int i;
	auto int offset;
	auto long addr;
	auto long endaddr;
	auto long len;

	// Save the old parser pointer
	oldp = parser->p;
   if (!memcmp(parser->p, "error", 5) &&
       zhtml_isspace_or_paren(*(parser->p+5))) {
   	parser->p += 5;
   }
   else {
   	// Not an error--return -1 indicates simple that this is not an error(),
   	// whereas returning -2 indicates a legitimate parsing problem
   	return -1;
   }
   if (zhtml_parse_openparen(parser) < 0) {
   	zhtml_error(parser, "Expecting '('");
		return -2;
   }
   zhtml_parse_whitespace(parser);
   // Read off the variable name
   if (zhtml_copy_varname(parser, _http_post_var,
                          RWEB_ZHTML_MAXVARLEN, 0) < 0) {
   	zhtml_error(parser, "Invalid variable name");
   	return -2;
   }
   // Look for the variable in the list of posted variables
   for (i = 0; i < _http_post_changed_len; i++) {
   	if (zhtml_varcmp(_http_post_var, _http_post_changed[i].nameoffset) >= 0) {
      	// We got a match--does this variable have an associated error message?
     		offset = _http_post_changed[i].error & (~_RWEB_ERROR_MASK);
      	if (offset) {
      		// It has an associated error message
      		addr = _rweb_weberror_buffer + offset;
      		endaddr = (long)_f_memchr((void __far *)addr,
      						'\0', RWEB_WEB_ERROR_MAXBUFFER);
      		len = endaddr - addr;
      		if (len >= HTTP_HALFBUF) {
      			len = HTTP_HALFBUF - 1;
      		}
      		_f_memcpy(parser->buffer, (char __far *)addr, (int)len);
      		parser->buffer[(int)len] = '\0';
      	}
      	break;
      }
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_closeparen(parser) < 0) {
   	zhtml_error(parser, "Expecting ')'");
		return -2;
   }
   return 0;
}

/*** BeginHeader zhtml_output_print_select */
int zhtml_output_print_select(ZHTMLParser *parser);
/*** EndHeader */

// Outputs the "<OPTION>foo <OPTION> bar <OPTION SELECTED> baz ..." type list
// for a given selection variable.  This is a convenience function for
// creating an HTML pulldown menu from a selection variable.
//
// parser -- The current state of the ZHTML parser
// Return -- 0 on success, -1 on error

_http_nodebug
int zhtml_output_print_select(ZHTMLParser *parser)
{
	auto long number;
	auto int index;
	auto int i;
	auto int is32;
	auto _Web_Select16 *ptr16;
	auto _Web_Select32 *ptr32;
	auto char *name;
   auto char __far *p;

   // Figure out the index that is currently selected
   if (zhtml_get_numericvariable(&(parser->varinfo), &number) < 0) {
      zhtml_error(parser, "Expecting a variable of integral type");
      return -1;
   }
   index = zhtml_select_index(&(parser->varinfo), number);
   if (index < 0) {
      zhtml_error(parser, "Select variable has invalid value");
      return -1;
   }

	// Find the first name in the list of selection values
   is32 = zhtml_select_is32(parser->varinfo.type.simple);
   if (is32 < 0) {
   	// Invalid selection type
   	zhtml_error(parser, "Select variable is of invalid type");
   	return -1;
   }
   ptr16 = parser->varinfo.select.ptr16;
   ptr32 = parser->varinfo.select.ptr32;
	if (is32) {
		if (ptr32 == NULL) {
			// Not a selection variable
			zhtml_error(parser, "Not a selection variable");
			return -1;
		}
		name = ptr32->name;
	}
	else {
		if (ptr16 == NULL) {
			// Not a selection variable
			zhtml_error(parser, "Not a selection variable");
			return -1;
		}
		name = ptr16->name;
	}

	// Print out the selection list
	i = 0;
   p = parser->buffer;
   *p = '\0';
   while (name != NULL) {
   	p += sprintf (p, "<option%s>%s\r\n",
   		(i == index) ? RWEB_SELECTED : "", name);
   	if (is32) {
   		ptr32++;
   		name = ptr32->name;
   	}
   	else {
   		ptr16++;
   		name = ptr16->name;
   	}
   	i++;
   }
	return 0;
}

/*** BeginHeader zhtml_select_index */
int zhtml_select_index(ZHTMLVarInfo *varinfo, unsigned long value);
/*** EndHeader */

// Given a selection variable, find the index of a selection variable value
// that corresponds to a given value.
//
// varinfo -- Information on the selection variable
// value   -- The value that we want to match with a particular selection
//            variable value
// Return  -- The index of the corresponding selection value on success, and
//            -1 on error

_http_nodebug
int zhtml_select_index(ZHTMLVarInfo *varinfo, unsigned long value)
{
	auto int is32;
	auto _Web_Select16 *ptr16;
	auto _Web_Select32 *ptr32;
	auto char *name;
	auto int i;

	// Initialization
	// Get the first name in the selection list
	is32 = zhtml_select_is32(varinfo->type.simple);
	if (is32 < 0) {
		// Not a proper type for a selection variable
		return -1;
	}
	ptr16 = varinfo->select.ptr16;
	ptr32 = varinfo->select.ptr32;
	if (is32) {
		if (ptr32 == NULL) {
			// Not a selection variable
			return -1;
		}
		name = ptr32->name;
	}
	else {
		if (ptr16 == NULL) {
			// Not a selection variable
			return -1;
		}
		name = ptr16->name;
	}

	// Find the selection variable index whose value matches the given value
	i = 0;
	while (name != NULL) {
		if (is32) {
			if (value == ptr32->value) {
				return i;
			}
			ptr32++;
			name = ptr32->name;
		}
		else {
			if ((unsigned int)value == ptr16->value) {
				return i;
			}
			ptr16++;
			name = ptr16->name;
		}
		i++;
	}
	// Not a valid selection value
	return -1;
}

/*** BeginHeader zhtml_select_is32 */
int zhtml_select_is32(int type);
/*** EndHeader */

// Indicates whether the given variable type is 32-bit (returns 1), 16-bit
// (returns 0), or not an integral type (return -1).
//
// type   -- The type to check.
// Return -- 1 if it is a 32-bit integral type, 0 if it is a 16-bit integral
//           type, and -1 if it is neither.

_http_nodebug
int zhtml_select_is32(int type)
{
	if ((type == _DK_TINT) || (type == _DK_TUNSIGNED)) {
		return 0;
	}
	else if ((type == _DK_TLONG) || (type = _DK_TULONG)) {
		return 1;
	}
	else {
		return -1;
	}
}

/*** BeginHeader zhtml_select_numitems */
int zhtml_select_numitems(ZHTMLVarInfo *varinfo);
/*** EndHeader */

// This function determines the number of items (possible values) in a selection
// variable.
//
// varinfo -- Information on the selection variable.
// Return  -- Number of items on success, -1 on error.

_http_nodebug
int zhtml_select_numitems(ZHTMLVarInfo *varinfo)
{
	auto _Web_Select16 *ptr16;
	auto _Web_Select32 *ptr32;
	auto char *name;
	auto int i;
	auto int is32;

	is32 = zhtml_select_is32(varinfo->type.simple);
	if (is32 < 0) {
		// Not a proper type for a selection variable
		return -1;
	}
	ptr16 = varinfo->select.ptr16;
	ptr32 = varinfo->select.ptr32;
	if (is32) {
		if (ptr32 == NULL) {
			// Not a selection variable
			return -1;
		}
		name = ptr32->name;
	}
	else {
		if (ptr16 == NULL) {
			// Not a selection variable
			return -1;
		}
		name = ptr16->name;
	}
	// Find the last selection value index
	i = 0;
	while (name != NULL) {
		if (is32) {
			ptr32++;
			name = ptr32->name;
		}
		else {
			ptr16++;
			name = ptr16->name;
		}
		i++;
	}
	return i;
}

/*** BeginHeader zhtml_output_selectionstring */
int zhtml_output_selectionstring(ZHTMLParser *parser, ZHTMLVarInfo *varinfo,
                                 int index);
/*** EndHeader */

// Outputs the selection value corresponding to the given index for the given
// selection variable.  Note that this output the string value, not the numeric
// value.
//
// parser  -- The current state of the ZHTML parser.
// varinfo -- The information on the selection variable.
// index   -- The index of the value which we are outputting.
// Return  -- 0 on success, -1 on error.

_http_nodebug
int zhtml_output_selectionstring(ZHTMLParser *parser, ZHTMLVarInfo *varinfo,
                                 int index)
{
	auto int type;
	auto int numitems;
	auto int is32;
	auto int len;

	// Find the number of items in the selection array
	numitems = zhtml_select_numitems(varinfo);
	if (numitems < 0) {
		// Not a selection variable
		return -1;
	}
	if (index >= numitems) {
		// Index out of range
		return -1;
	}

	// Initialization
	type = varinfo->type.simple;
	if ((type == _DK_TINT) || (type == _DK_TUNSIGNED)) {
		is32 = 0;
	}
	else if ((type == _DK_TLONG) || (type == _DK_TULONG)) {
		is32 = 1;
	}

	// Copy out the selection string value
	if (is32) {
		len = strlen(varinfo->select.ptr32[index].name);
		if (len >= HTTP_MAXBUFFER) {
			len = HTTP_MAXBUFFER - 1;
		}
		_f_memcpy(parser->buffer, varinfo->select.ptr32[index].name, len);
	}
	else {
		len = strlen(varinfo->select.ptr16[index].name);
		if (len >= HTTP_MAXBUFFER) {
			len = HTTP_MAXBUFFER - 1;
		}
		_f_strcpy(parser->buffer, varinfo->select.ptr16[index].name);
	}
	parser->buffer[len] = '\0';

	return 0;
}

/*** BeginHeader zhtml_copy_varname */
int zhtml_copy_varname(ZHTMLParser *parser, char __far *dest, int len, int encode);
/*** EndHeader */

// Parse a varname() statement.  The varname() statement takes the given
// variable name, and performs loop variable substitutions.  Also, if the
// encode parameter is set, it will encode the variable name so that it can be
// transmitted in an HTTP POST.
//
// parser -- The current state of the ZHTML parser.
// dest   -- The destination buffer for writing out the variable name.
// len    -- The maximum length of the destination buffer.
// encode -- Indicates if the variable name should be encoded for subsequent
//           transmission in an HTTP POST request.
// Return -- 0 on success, -1 on error.

_http_nodebug
int zhtml_copy_varname(ZHTMLParser *parser, char __far *dest, int len, int encode)
{
	auto int i;
   auto char __far *src;
   auto char c;
   auto int num;
   auto int retval;

	_http_assert(dest != NULL);

	i = 0;
   src = parser->p;
   if (*src != '$') {
      return -1;
   }
   src++;
   c = *src;
	// Continue looping over data until we've reached the end or an invalid
	// character
	while ((i < len-1) && (isalnum(c) || (strchr (".@[]_$", c) != NULL))) {
		if (src >= parser->tagend) {
			// The variable name wasn't terminated properly--we've gobbled up
			// characters past the end of the ZHTML tag
			return -1;
		}
		// Do the '[' and ']' munging
		if (encode && ((*src == '[') || (*src == ']'))) {
      	*dest = ' ';
	      dest++;
	      i++;
      }
      else if (*src == ' ') {
      	// Skip over spaces
      }
      else if (*src == '$') {
      	// Handle loop variables
      	src++;
      	if (src >= parser->tagend) {
      		// Past the end of the ZHTML tag
      		return -1;
      	}
      	if ((*src < 'A') || (*src > 'Z')) {
      		return -1;
      	}
      	num = *src - 'A';
      	retval = snprintf(dest, len-1-i, "%d", parser->tempvars[num]);
      	if (retval >= (len-1-i)) {
      		// Filled the buffer
      		return -1;
      	}
      	i += retval;
      	dest += retval;
      }
      else {
      	*dest = *src;
	      dest++;
	      i++;
      }
      src++;
      c = *src;
   }
   if (i == len-1) {
   	return -1;
   }
   else {
   	*dest = '\0';
   }
   parser->p = src;
   return 0;
}

/*** BeginHeader zhtml_output_variable */
void zhtml_output_variable(ZHTMLParser *parser, char __far *dest, char *spec);
/*** EndHeader */

// Output the value of the given variable (info contained in the parser state).
// The value is output to the destination buffer using the given printf()-style
// format specifier (or a default specifier if that is NULL).
//
// parser -- The current state of the ZHTML parser.
// dest   -- The destination for the value.
// spec   -- A format specifier for printing the variable, or NULL if a default
//           appropriate to the variable type should be used.

_http_nodebug
void zhtml_output_variable(ZHTMLParser *parser, char __far *dest, char *spec)
{
	auto int len;

	_http_assert(dest != NULL);

   // Do we have a newer version of this variable than is pointed to by varinfo?
   if ((parser->varinfo.newval >= 0) &&
   	(_http_post_changed[parser->varinfo.newval].valoffset != -1)) {
   	// We do have a newer version.  We'll just copy it out from the POST
   	// buffer.
   	zhtml_copyvalue(dest, (long)(_http_post +
   	   _http_post_changed[parser->varinfo.newval].valoffset),
   	   RWEB_ZHTML_MAXVARLEN);
      return;
   }

   // We're printing the older version of the variable.  We will use the default
   // printf-specifier.
	switch (parser->varinfo.type.simple) {
  	case _DK_T_CHAR:
   	if (spec == NULL) {
      	spec = "%c";
      }
      sprintf(dest, spec, *((char *)parser->varinfo.valptr));
   	break;
  	case _DK_TSIGNEDCHAR:
   	if (spec == NULL) {
      	spec = "%c";
      }
      sprintf(dest, spec, *((signed char *)parser->varinfo.valptr));
   	break;
   case _DK_TINT:
   	if (spec == NULL) {
      	spec = "%d";
      }
      sprintf(dest, spec, *((int *)parser->varinfo.valptr));
   	break;
   case _DK_TUNSIGNED:
   	if (spec == NULL) {
      	spec = "%u";
      }
      sprintf(dest, spec, *((unsigned *)parser->varinfo.valptr));
   	break;
   case _DK_TLONG:
   	if (spec == NULL) {
      	spec = "%ld";
      }
      sprintf(dest, spec, *((long *)parser->varinfo.valptr));
   	break;
   case _DK_TULONG:
   	if (spec == NULL) {
      	spec = "%lu";
      }
      sprintf(dest, spec, *((unsigned long *)parser->varinfo.valptr));
   	break;
   case _DK_TFLOAT:
   	if (spec == NULL) {
      	spec = "%f";
      }
      sprintf(dest, spec, *((float *)parser->varinfo.valptr));
   	break;
   case _DK_TSTRING:
   	if (spec == NULL) {
      	spec = "%s";
      }
      len = snprintf(dest, HTTP_MAXBUFFER, spec,
                     (char *)parser->varinfo.valptr);
      if (len >= HTTP_MAXBUFFER-1) {
      	dest[HTTP_MAXBUFFER-1] = '\0';
      }
   	break;
   default:
   	break;
   }
}

/*** BeginHeader zhtml_output_checkbox */
void zhtml_output_checkbox(ZHTMLParser *parser, char __far *dest, int checked);
/*** EndHeader */

// Output HTML for a checkbox form element.  Since unchecked checkboxes are
// not submitted as part of an HTML form, we must include a hidden field with
// a value of 0 to detect an unchecked checkbox.
//
// Usage in zhtml file:
// 	<input <?z field_checkbox($somevar) ?> >
// Expands to:
// 	<input type="hidden" name="somevar" value="0">
// 	<input type="checkbox" name="somevar" value="1" checked >
//
// parser  -- The current state of the ZHTML parser.
// dest    -- The destination for the checkbox.
// checked -- Set to 1 if the checkbox is checked

_http_nodebug
void zhtml_output_checkbox(ZHTMLParser *parser, char __far *dest, int checked)
{
	auto int len;
	char __far *oldp;
	char __far *p;

	_http_assert(dest != NULL);

	// p points into the output buffer and moves through it as we insert text
	p = dest;

	// output the hidden field
	p += sprintf (p, "type=\"hidden\" name=\"");

	// copy the varname from the parser to our output buffer, and rewind
	// the parser so we can do it again for the checkbox field
	oldp = parser->p;
	zhtml_copy_varname (parser, p, RWEB_ZHTML_MAXVARLEN, 1);
	parser->p = oldp;

	// find end of string (after the varname copied by zhtml_copy_varname)
	while (*p) p++;

	// print the hidden field's closing quote for name property and add
	// value="0" property
	p += sprintf (p, "\" value=\"0\"" RWEB_CLOSETAG);

	// output the start of the checkbox field
	p += sprintf (p, "<input type=\"checkbox\" name=\"");
	zhtml_copy_varname (parser, p, RWEB_ZHTML_MAXVARLEN, 1);
	// find end of string (after the varname copied by zhtml_copy_varname)
	while (*p) p++;

	// print the checkbox field's closign quote for the name property and add
	// value="1" property and optional checked property
	p += sprintf (p, "\" value=\"1\"%s", checked ? RWEB_CHECKED : "");
}

/*** BeginHeader zhtml_output_radio */
void zhtml_output_radio(ZHTMLParser *parser, char __far *dest, int checked_value);
/*** EndHeader */

// Output HTML for a radio button form element.
//
// Usage in zhtml file:
// 	<input <?z field_radio($somevar, 5) ?> >
// Expands to:
// 	<input type="radio" name="somevar" value="5" checked >
//
// parser        -- The current state of the ZHTML parser.
// dest          -- The destination for the radio button.
// checked_value -- The variable's current value, used in decision to include
//                  "checked" property in input button's tag

_http_nodebug
void zhtml_output_radio(ZHTMLParser *parser, char __far *dest, int checked_value)
{
	auto int len;
   auto long value;
	char __far *p;

	_http_assert(dest != NULL);

	// p points into the output buffer and moves through it as we insert text
	p = dest;

	// set the type and name properties of the radio button
	p += sprintf (p, "type=\"radio\" name=\"");
	zhtml_copy_varname (parser, p, RWEB_ZHTML_MAXVARLEN, 1);
	// find end of string (after the varname copied by zhtml_copy_varname)
	while (*p) p++;
	*p++ = '"';			// add closing quote of name property

   zhtml_parse_whitespace(parser);
   if (zhtml_parse_comma(parser) < 0) {
      zhtml_error(parser, "Expecting ','");
      return;
   }
   zhtml_parse_whitespace(parser);

   // get the value property for the radio button
   if (zhtml_parse_number(parser, &value, 0) < 0) {
      // zhtml_parse_number generates its own errors
      return;
   }

	// add the value and optional checked properties to the radio button
	p += sprintf (p, " value=\"%d\"%s", (int) value,
   	(checked_value == (int) value) ? RWEB_CHECKED : "");
}

/*** BeginHeader zhtml_get_numericvariable */
int zhtml_get_numericvariable(ZHTMLVarInfo *varinfo, long *dest);
/*** EndHeader */

// Given the variable information in varinfo, this function extracts the
// numeric value.  If the variable is not of numeric type (not including a
// float), it returns with a failure.  This function is used in many places
// where a numeric value is needed by the parser (for instance, for loop
// ranges).  The value is placed into the dest buffer.
//
// varinfo -- Information on the variable for which we are getting the value.
//            In particular, this indicates whether we are looking for the
//            new value of the variable, or the committed value.
// dest    -- The destination buffer for the value.
// Return  -- 0 on success, -1 on error.

_http_nodebug
int zhtml_get_numericvariable(ZHTMLVarInfo *varinfo, long *dest)
{
	auto int type;
   auto long temp;
   auto void *ptr;

	_http_assert(dest != NULL);

   // Check that the type of the variable is numeric
   type = varinfo->type.simple;
   if ((type != _DK_T_CHAR) && (type != _DK_TINT) && (type != _DK_TUNSIGNED) &&
       (type != _DK_TSIGNEDCHAR) && (type != _DK_TLONG) && (type != _DK_TULONG))
   {
		return -1;
   }

   // Do we have a newer version of this variable than is pointed to by varinfo?
   if ((varinfo->newval >= 0) &&
   		(_http_post_changed[varinfo->newval].valoffset != -1)) {
   	ptr = &(_http_post_changed[varinfo->newval].newval);
   }
   else {
   	ptr = varinfo->valptr;
   }

	// Copy out the value to the destination
   switch (type) {
   case _DK_TSIGNEDCHAR:
      *dest = (long)(*((signed char *)ptr));
      break;
   case _DK_T_CHAR:
      *dest = (long)(*((char *)ptr));
      break;
   case _DK_TINT:
      *dest = (long)(*((int *)ptr));
      break;
   case _DK_TUNSIGNED:
      *dest = (long)(*((unsigned int *)ptr));
      break;
   case _DK_TLONG:
      *dest = *((long *)ptr);
      break;
   case _DK_TULONG:
      *dest = (long)(*((unsigned long *)ptr));
      break;
   }
   return 0;
}

/*** BeginHeader zhtml_parse_whitespace */
int zhtml_parse_whitespace(ZHTMLParser *parser);
/*** EndHeader */

// Parse out any sort of whitespace until the next non-whitespace character.
//
// parser -- The current state of the ZHTML parser.
// Return -- Always returns 0, since whitespace is always optional.

_http_nodebug
int zhtml_parse_whitespace(ZHTMLParser *parser)
{
	while (isspace(*(parser->p))) parser->p++;
   return 0;
}

/*** BeginHeader zhtml_parse_auth */
int zhtml_parse_auth(ZHTMLParser *parser);
/*** EndHeader */

// Parse an auth() expression.  The auth() expression takes two parameters.
// The first is a variable, and the second is "ro" or "rw" to determine if the
// user has read or read/write access, respectively.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 for success, -1 if it is not an auth() expression, -2 on error.

_http_nodebug
int zhtml_parse_auth(ZHTMLParser *parser)
{
   auto int not;
   auto char __far *oldp;
   auto int write;
   auto HttpState_p state;
   auto int have_access;

	write = 0;
	state = (HttpState_p )(parser->state);

	// Save off the old pointer
	oldp = parser->p;
	if (*(parser->p) == '!') {
   	// Invert the sense of the test
   	not = 1;
      parser->p++;
	   zhtml_parse_whitespace(parser);
   }
   else {
   	not = 0;
   }
   if (!memcmp(parser->p, "auth", 4) &&
       zhtml_isspace_or_paren(*(parser->p+4))) {
   	parser->p += 4;
   }
   else {
		// Go back from the '!', if necessary
		parser->p = oldp;
   	return -1;
   }
   if (zhtml_parse_openparen(parser) < 0) {
   	zhtml_error(parser, "Expecting '('");
		return -2;
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_variable(parser, &(parser->varinfo)) < 0) {
      // Error--didn't find variable
      zhtml_error(parser, "Unknown variable");
		return -2;
   }
   zhtml_parse_whitespace(parser);
	if (zhtml_parse_comma(parser) < 0) {
		zhtml_error(parser, "Expecting ','");
		return -2;
	}
   zhtml_parse_whitespace(parser);
   if (!memcmp(parser->p, "\"rw\"", 4)) {
   	// Checking write access
		write = 1;
	}
	else if (memcmp(parser->p, "\"ro\"", 4)) {
		zhtml_error(parser, "Expecting \"ro\" or \"rw\"");
		return -2;
	}
	parser->p += 4;
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_closeparen(parser) < 0) {
   	zhtml_error(parser, "Expecting ')'");
		return -2;
   }

	// Now check the access
   if (zhtml_check_variable_access(state, &(parser->varinfo), write) == 0) {
   	// We have access
   	have_access = 1;
   }
   else {
   	// No access
   	have_access = 0;
   }
	// Figure out the truth value of the expression
   if ((have_access && !not) || (!have_access && not)) {
   	parser->truth = 1;
   }
   else {
   	parser->truth = 0;
   }

   return 0;
}

/*** BeginHeader zhtml_parse_error */
int zhtml_parse_error(ZHTMLParser *parser);
/*** EndHeader */

// Parse an error() expression.  The error() expression with no parameters
// simply indicates whether there is an error in the received variables (from a
// POST).  With a variable as a parameter, it indicates whether that specific
// variable is in error.  Note that for an error() expression encountered
// within an echo() or print() statement, a different function is used to
// parse it, since the semantics are different.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 for success, -1 if it is not an error() expression, -2 on error.

_http_nodebug
int zhtml_parse_error(ZHTMLParser *parser)
{
	auto int i;
   auto int not;
   auto int in_error;
   auto char __far *oldp;

	// Save off the old pointer
	oldp = parser->p;
	if (*(parser->p) == '!') {
   	// Invert the sense of the test
   	not = 1;
      parser->p++;
	   zhtml_parse_whitespace(parser);
   }
   else {
   	not = 0;
   }
   if (!memcmp(parser->p, "error", 5) &&
       zhtml_isspace_or_paren(*(parser->p+5))) {
   	parser->p += 5;
   }
   else {
		// Go back from the '!', if necessary
		parser->p = oldp;
   	return -1;
   }
   if (zhtml_parse_openparen(parser) < 0) {
   	zhtml_error(parser, "Expecting '('");
		return -2;
   }
   zhtml_parse_whitespace(parser);
   // Are we simply testing for error mode?
   if (*(parser->p) == ')') {
   	parser->p++;
		// Figure out the truth value of the expression
      if ((parser->error && !not) || (!parser->error && not)) {
      	parser->truth = 1;
      }
      else {
      	parser->truth = 0;
      }
		return 0;
   }
   if (zhtml_parse_variable(parser, &(parser->varinfo)) < 0) {
      // Error--didn't find variable
      zhtml_error(parser, "Unknown variable");
		return -2;
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_closeparen(parser) < 0) {
   	zhtml_error(parser, "Expecting ')'");
		return -2;
   }

   // Check if this variable is in error
   // Note that _http_post_var still contains the name of the variable from
   // the zhtml_parse_variable() call above
   in_error = 0;
   for (i = 0; i < _http_post_changed_len; i++) {
		if (zhtml_varcmp(_http_post_var, _http_post_changed[i].nameoffset) >= 0) {
      	// We got a match
      	in_error = _http_post_changed[i].error;
      	break;
      }
   }

   // If we didn't find the variable in the list, then it wasn't in error
   if (i == _http_post_changed_len) {
   	in_error = 0;
   }

	// Figure out the truth value of the expression
   if ((in_error && !not) || (!in_error && not)) {
   	parser->truth = 1;
   }
   else {
   	parser->truth = 0;
   }
   return 0;
}

/*** BeginHeader zhtml_parse_updating */
int zhtml_parse_updating(ZHTMLParser *parser);
/*** EndHeader */

// Parse an updating() expression.  The updating() function takes no parameters
// and simply determines if the ZHTML page is being displayed from a POST (that
// is, with new values coming in) rather than from a GET.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 on success, -1 if it is not an updating() expression, -2 on
//           error.

_http_nodebug
int zhtml_parse_updating(ZHTMLParser *parser)
{
   auto int not;
   auto char __far *oldp;
   auto char method;

	// Save off the old pointer
	oldp = parser->p;
	if (*(parser->p) == '!') {
   	// Invert the sense of the test
   	not = 1;
      parser->p++;
	   zhtml_parse_whitespace(parser);
   }
   else {
   	not = 0;
   }
   if (!memcmp(parser->p, "updating", 8) &&
       zhtml_isspace_or_paren(*(parser->p+8))) {
   	parser->p += 8;
   }
   else {
		// Go back from the '!', if necessary
   	parser->p = oldp;
   	return -1;
   }
   if (zhtml_parse_openparen(parser) < 0) {
   	zhtml_error(parser, "Expecting '('");
		return -2;
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_closeparen(parser) < 0) {
      zhtml_error(parser, "Expecting ')'");
		return -2;
   }

	// Check if the method is POST
	method = ((HttpState_p )(parser->state))->method;
	if (((method == HTTP_METHOD_POST) && !not) ||
	    ((method != HTTP_METHOD_POST) && not)) {
		parser->truth = 1;
	}
	else {
		parser->truth = 0;
	}
	return 0;
}

/*** BeginHeader zhtml_parse_selected */
int zhtml_parse_selected(ZHTMLParser *parser);
/*** EndHeader */

// Parse a selected() expression.  The selected() function takes two
// parameters:  the first is a selection variable, and the second is an index
// into the list of possible values the selection variable can take on.  If the
// current value of the selection variable corresponds to the given index, then
// the expression is TRUE.  This is often used to generate a list of values
// for a selection variable, with the currently selected value "marked" somehow.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 for success, -1 if it is not a selected() expression, -2 on
//           error.

_http_nodebug
int zhtml_parse_selected(ZHTMLParser *parser)
{
   auto int not;
   auto int index;
   auto int selindex;
   auto long number;

	if (*(parser->p) == '!') {
   	// Invert the sense of the test
   	not = 1;
      parser->p++;
	   zhtml_parse_whitespace(parser);
   }
   else {
   	not = 0;
   }
   if (!memcmp(parser->p, "selected", 8) &&
       zhtml_isspace_or_paren(*(parser->p+8))) {
   	parser->p += 8;
   }
   else {
   	return -1;
   }
   if (zhtml_parse_openparen(parser) < 0) {
   	zhtml_error(parser, "Expecting '('");
		return -2;
   }
   zhtml_parse_whitespace(parser);

   // Parse the variable--information on it will be in parser->varinfo
   if (zhtml_parse_variable(parser, &(parser->varinfo)) < 0) {
      zhtml_error(parser, "Unknown variable");
		return -2;
   }
   // Check access to the variable
   if (zhtml_check_variable_access(parser->state, &(parser->varinfo), 0) < 0) {
      // Error--don't have access to the variable
      zhtml_error(parser, "No read access to variable");
      return -2;
   }
   if (zhtml_get_numericvariable(&(parser->varinfo), &number) < 0) {
      zhtml_error(parser, "Expecting a variable of integral type");
		return -2;
   }
   selindex = zhtml_select_index(&(parser->varinfo), number);
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_comma(parser) < 0) {
   	zhtml_error(parser, "Expecting ','");
   	return -2;
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_number(parser, &number, 0) < 0) {
      // zhtml_parse_number() generates its own errors
      return -2;
   }
   if ((number < 0) || (number > INT_MAX)) {
      zhtml_error(parser, "Selection index out of range");
      return -2;
   }
   index = (int)number;
   if (zhtml_parse_closeparen(parser) < 0) {
      zhtml_error(parser, "Expecting ')'");
		return -2;
   }
   if (((selindex == index) && !not) ||
       ((selindex != index) && not)) {
   	parser->truth = 1;
   }
   else {
   	parser->truth = 0;
   }
   return 0;
}

/*** BeginHeader zhtml_parse_conditional */
int zhtml_parse_conditional(ZHTMLParser *parser);
/*** EndHeader */

// Parse a conditional expression.  This can be error(), updating(), selected(),
// or a comparison (e.g., "$A == 2").  The truth result of this conditional
// expression is placed in the parser->truth variable.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 on success, -1 on error.

_http_nodebug
int zhtml_parse_conditional(ZHTMLParser *parser)
{
   auto char comparison;
   auto long number1;
   auto long number2;
   auto char __far *oldp;
   auto int retval;

	oldp = parser->p;

	// Is this auth()?
	retval = zhtml_parse_auth(parser);
	if (retval == 0) {
		return 0;
	}
	else if (retval == -2) {
		// zhtml_parse_auth() generated an error
		return -1;
	}
	// Is this error()?
	retval = zhtml_parse_error(parser);
	if (retval == 0) {
		return 0;
	}
	else if (retval == -2) {
		// zhtml_parse_error() generated an error
		return -1;
	}
	// Is this updating()?
	parser->p = oldp;
	retval = zhtml_parse_updating(parser);
	if (retval == 0) {
		return 0;
	}
	else if (retval == -2) {
		// zhtml_parse_updating() generated an error
		return -1;
	}
	// Is this selected()?
	parser->p = oldp;
	retval = zhtml_parse_selected(parser);
	if (retval == 0) {
		return 0;
	}
	else if (retval == -2) {
		// zhtml_parse_selected generated an error
		return -1;
	}
	// Get the first number
	parser->p = oldp;
	if (zhtml_parse_number(parser, &number1, 0) < 0) {
		// zhtml_parse_number() generates its own errors
		return -1;
	}
	zhtml_parse_whitespace(parser);
	// Get the conditional operator
	comparison = zhtml_parse_comparison(parser);
	if (comparison < 0) {
	   zhtml_error(parser, "Expecting a conditional operator");
      return -1;
	}
	zhtml_parse_whitespace(parser);
	// Get the number
	if (zhtml_parse_number(parser, &number2, 0) < 0) {
		// zhtml_parse_number() generates its own errors
      return -1;
	}
   // Check the condition
   parser->truth = zhtml_check_condition(number1, comparison, number2);
   return 0;
}

/*** BeginHeader zhtml_parse_character */
int zhtml_parse_character(ZHTMLParser *parser, int c);
#define zhtml_parse_openparen(p)			zhtml_parse_character(p, '(')
#define zhtml_parse_closeparen(p)		zhtml_parse_character(p, ')')
#define zhtml_parse_openbrace(p)			zhtml_parse_character(p, '{')
#define zhtml_parse_comma(p)				zhtml_parse_character(p, ',')
#define zhtml_parse_equals(p)				zhtml_parse_character(p, '=')
#define zhtml_parse_semicolon(p)			zhtml_parse_character(p, ';')

// Parse the end of a <?z ... ?> tag.  In particular, it looks for the the
// ending '?' character.
#define zhtml_parse_end(p)					zhtml_parse_character(p, '?')
/*** EndHeader */

// Parse a single character.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 on success, -1 on failure.

_http_nodebug
int zhtml_parse_character(ZHTMLParser *parser, int c)
{
	if (*(parser->p) != c) return -1;
   parser->p++;
   return 0;
}

/*** BeginHeader zhtml_isspace_or_paren */
int zhtml_isspace_or_paren(char c);
/*** EndHeader */

// Determines if the given character is a space or open parenthesis.  This is
// often used to determine the end of a "function" name (which can be followed
// by whitespace or a '(' ).
//
// c -- The character being queried.
// Return -- 0 if not a space or '(', !0 if it is.

_http_nodebug
int zhtml_isspace_or_paren(char c)
{
	return isspace(c) || (c == '(');
}

/*** BeginHeader zhtml_parse_command */
int zhtml_parse_command(ZHTMLParser *parser);
/*** EndHeader */

// Parse out a command name (including '}', or the loop close, as a command
// name).  Information on the parsed command is placed in the parser data
// structure.
//
// parser -- The current state of the ZHTML parser.
// Return -- 0 on success, -1 on error.

typedef struct {
	char	*command;
	int	map;
} zhtmlCommandMap;

const zhtmlCommandMap	zhtml_commands[] = {
	{ "echo", ZHTML_CMD_ECHO },
	{ "print", ZHTML_CMD_ECHO },
	{ "printf", ZHTML_CMD_PRINTF },
	{ "if", ZHTML_CMD_IF },
	{ "for", ZHTML_CMD_FOR },
	{ "varname", ZHTML_CMD_VARNAME },
	{ "print_opt", ZHTML_CMD_PRINT_OPT },
	{ "print_select", ZHTML_CMD_PRINT_SELECT },
	{ "field_checkbox", ZHTML_CMD_FIELD_CHECKBOX },
   { "field_radio", ZHTML_CMD_FIELD_RADIO }
};

_http_nodebug
int zhtml_parse_command(ZHTMLParser *parser)
{
	int i, cmdlen;

	for (i = 0; i < sizeof(zhtml_commands) / sizeof(zhtml_commands[0]); i++) {
		cmdlen = strlen (zhtml_commands[i].command);
	   if (!memcmp(parser->p, zhtml_commands[i].command, cmdlen) &&
	       zhtml_isspace_or_paren(*(parser->p+cmdlen))) {
	      parser->p += cmdlen;
	      parser->command = zhtml_commands[i].map;
	      return 0;
	   }
	}

   // close brace?
   if ((*(parser->p) == '}') && isspace(*(parser->p+1))) {
   	parser->p += 1;
      parser->command = ZHTML_CMD_CLOSEBLOCK;
      return 0;
   } else {
   	parser->command = ZHTML_CMD_NONE;
   	return -1;
   }
}

/*** BeginHeader zhtml_parse_printfspec */
int zhtml_parse_printfspec(ZHTMLParser *parser, char *buf);
/*** EndHeader */

// Parses out a printf-style specifier for the printf() statement and places in
// in the provided buf.
//
// parser -- The current state of the ZHTML parser.
// buf    -- The destination for writing out the printf-style specifier (with
//           the " characters stripped).
// Return -- 0 on success, -1 on error

_http_nodebug
int zhtml_parse_printfspec(ZHTMLParser *parser, char *buf)
{
	auto int i;

	_http_assert(buf != NULL);

	if (*(parser->p) != '\"') {
   	return -1;
   }
   parser->p++;
   i = 0;
   while ((*(parser->p) != '\"') && (i < 20)) {
   	buf[i] = *(parser->p);
   	i++;
      parser->p++;
   }
   if (i == 20) {
   	return -1;
   }
   buf[i] = '\0';
   parser->p++;
   return 0;
}

/*** BeginHeader zhtml_memcpy_substitute */
int zhtml_memcpy_substitute(ZHTMLParser *parser, char *dest, int destlen,
                            char __far *src, int srclen);
/*** EndHeader */

// Takes the given src string and copies it to the dest string while performing
// loop variable substitution (for array indices).
//
// parser  -- The current state of the ZHTML parser.  In particular, it has the
//            current loop variable values.
// dest    -- The destination buffer.
// destlen -- The maximum length of the destination buffer.
// src     -- The source buffer.
// srclen  -- The maximum length of the source buffer.
// Return  -- Number of bytes written to the dest buffer on success, -1 on error

_http_nodebug
int zhtml_memcpy_substitute(ZHTMLParser *parser, char *dest, int destlen,
                            char __far *src, int srclen)
{
	auto char *orig_dest;
   auto int retval;
   auto int var;

	_http_assert(dest != NULL);

	orig_dest = dest;
   while (srclen > 0) {
		retval = zhtml_copytochar(dest, src, '$',
		                          (destlen < srclen)?destlen:srclen);
      dest += retval;
      src += retval;
      srclen -= retval;
      destlen -= retval;
      if (*src == '$') {
      	// Need to substitue in $A-$Z value
      	// Skip past '$'
			src++;
			srclen--;
			if (srclen <= 0) {
				return -1;
			}
			var = *src - 'A';
			if ((var < 0) || (var > 25)) {
				return -1;
			}
			retval = snprintf(dest, destlen, "%d", parser->tempvars[var]);
			if (retval >= destlen) {
				dest[destlen-1] = '\0';
				dest += destlen-1;
				// We've filled the buffer already
				return (dest - orig_dest);
			}
			// Skip past 'A'-'Z'
			dest += retval;
			destlen -= retval;
			src++;
			srclen--;
      }
   }
   return (dest - orig_dest);
}

/*** BeginHeader zhtml_parse_variablename */
int zhtml_parse_variablename(ZHTMLParser *parser, ZHTMLVarInfo *info,
                             int dimsonly);
/*** EndHeader */

// Parses out a variable name, substitutes any loop variables into the array
// indices, and does a lookup for the best match for the variable.  Information
// on the variable is passed out in the info structure.
//
// parser   -- The current state of the ZHTML parser
// info     -- OUTPUT.  Information on the matching variable is passed out in
//             this structure.
// dimsonly -- This lookup is being done for the count() function, which is only
//             interested in array dimension bounds.
// Return   -- 0 on success, -1 on error.

_http_nodebug
int zhtml_parse_variablename(ZHTMLParser *parser, ZHTMLVarInfo *info,
                             int dimsonly)
{
	auto char c;
	auto int len;
   auto int retval;

	_http_assert(info != NULL);

   c = *(parser->p);
   // Check for a valid first character (A-Z_a-z)
   if (isalpha(c) || (c == '_')) {
		parser->varbegin = parser->p;
   }
   else {
   	return -1;
   }
   parser->p++;
   c = *(parser->p);
   // Check for a valid variable character (.0-9@A-Z[]_a-z$)
	while (isalnum(c) || (strchr (".@[]_$", c) != NULL)) {
	   parser->p++;
	   c = *(parser->p);
   }
   // End of the variable reached.  Now need to look it up.  parser->varbegin
   // points to the beginning, parser->p points to the end.
   // Copy out the string to the _http_post_var buffer
   len = (int)(parser->p - parser->varbegin);
   if (len >= RWEB_ZHTML_MAXVARLEN) {
   	return -1;
   }
   len = zhtml_memcpy_substitute(parser, _http_post_var,
                                 RWEB_ZHTML_MAXVARLEN, parser->varbegin,
                                 len);
   if (len < 0) {
   	return -1;
   }
	if (len < RWEB_ZHTML_MAXVARLEN-1) {
	   _http_post_var[len] = '\0';
	}
	else {
		return -1;
	}

	retval = zhtml_matchbest(_http_post_var, info, dimsonly);
   if (retval < 0) {
   	return -1;
   }
   else {
   	return 0;
   }
}

/*** BeginHeader zhtml_matchbest */
int zhtml_matchbest(char *p, ZHTMLVarInfo *info, int dimsonly);
/*** EndHeader */

// Find the best match for given variable.  dimsonly indicates that this
// lookup is being done for a count() function, which is only interested in
// array bound information.  Information on the match is passed out in the info
// structure.
//
// p -- The variable to match
// info -- OUTPUT.  Information on the variable is returned in this structure.
// dimsonly -- This lookup is being done for a count() function, which is only
//             interested in array bounds information
// Return   -- Index into the _web_var_info array of the best match, or -1 for
//             error.

_http_nodebug
int zhtml_matchbest(char *p, ZHTMLVarInfo *info, int dimsonly)
{
	auto int i;
   auto int maxlen;
   auto int maxdims;
   auto int match;
   auto int retval;
	auto int vartype;
   auto char *varptr;
   auto int *bounds;
	auto int matchlen;
	auto int matchdims;

	_http_assert(info != NULL);

	i = 0;
	maxlen = 0;
	maxdims = 0;
	match = -1;
   while (_web_var_info[i].name != NULL) {
	   retval = zhtml_matchnames(&(_web_var_info[i]), p, NULL, &matchlen,
	                             &matchdims, dimsonly);
	   if (retval < 0) {
	      // Error in the variable name--just return here
	      return -1;
	   }
      else if (retval == 0) {
	      if ((matchlen > maxlen) ||
	          ((matchlen == maxlen) && (matchdims > maxdims))) {
	         maxlen = matchlen;
	         maxdims = matchdims;
	         match = i;
	      }
      }
      i++;
   }
   if (match < 0) {
   	// No match
   	return -1;
   }
   else {
   	// Look up information on this variable
		retval = zhtml_getvarinfo(&vartype, &varptr, &bounds,
		                          &(_web_var_info[match]), p, dimsonly);
      if (retval < 0) {
      	// Error getting the information
      	return -1;
      }
      // Got the type and pointer to the variable
      info->valptr = (void *)varptr;
      info->type.simple = vartype;
      info->guardptr = _web_var_info[match].guardptr;
      info->updateptr = _web_var_info[match].updateptr;
      info->auth = _web_var_info[match].auth;
      info->groups = _web_var_info[match].groups;
      info->perm = _web_var_info[match].perm;
      info->bounds = bounds;
      info->select = _web_var_info[match].select;
		return match;
   }
}

/*** BeginHeader zhtml_parse_variable */
int zhtml_parse_variable(ZHTMLParser *parser, ZHTMLVarInfo *varinfo);
/*** EndHeader */

// Parses out a normal, non-loop-variable.  This variable can be indicated by
// a '$' or '@' character, depending on whether the user wants the newest or the
// committed value of the variable.  Information on the parsed variable is
// placed into the varinfo structure.
//
// parser  -- The current state of the ZHTML parser
// varinfo -- OUTPUT.  Information on the parsed variable is passed out in this
//            structure.
// Return  -- 0 on success, -1 on error

_http_nodebug
int zhtml_parse_variable(ZHTMLParser *parser, ZHTMLVarInfo *varinfo)
{
	auto char c;
   auto int i;

	_http_assert(varinfo != NULL);

	// Check if the variable is leading with a '$' (newest version of the
   // variable available) or a '@' (committed version of the variable)
	if (*(parser->p) == '$') {
   	if (parser->error) {
      	varinfo->newval = 0;
      }
      else {
      	varinfo->newval = -1;
      }
   }
   else if (*(parser->p) == '@') {
   	varinfo->newval = -1;
   }
   else {
   	return -1;
   }
   parser->p++;

	i = zhtml_parse_variablename(parser, varinfo, 0);
   if (i < 0) {
   	return -1;
   }
   else {
   	// We found the variable--are we both in error mode and looking for a
      // newer version of the variable?
      // _http_post_var already contains the name of the variable
      if (parser->error && (varinfo->newval >= 0)) {
      	// Look for a new version of the variable
         for (i = 0; i < _http_post_changed_len; i++) {
         	// We still have the variable name in _http_post_var from
            // zhtml_parse_variablename()
            if ((_http_post_changed[i].valoffset >= 0) &&
                (zhtml_varcmp(_http_post_var,
                              _http_post_changed[i].nameoffset) >= 0)) {
            	// We have found the appropriate variable entry
               varinfo->newval = i;
               break;
            }
         }
         if (i == _http_post_changed_len) {
         	// We didn't find the variable in the POST buffer
            varinfo->newval = -1;
         }
      }
   }
   return 0;
}

/*** BeginHeader zhtml_isvarchar */
int zhtml_isvarchar(char c);
/*** EndHeader */

// Indicates whether the given character is a valid variable character.
//
// c      -- Character to check
// Return -- 1 if it is a valid variable character, 0 if it is not

_http_nodebug
int zhtml_isvarchar(char c)
{
	// valid characters are letters, numbers, [, _, ] and .
	return (isalnum(c) || (strchr ("[_].", c) != NULL));
}

/*** BeginHeader zhtml_parse_loopvariable */
int zhtml_parse_loopvariable(ZHTMLParser *parser);
/*** EndHeader */

// Parse a loop variable ($A - $Z).  The index of the loop variable (0-25) is
// returned.
//
// parser -- The current state of the ZHTML parser
// Return -- index of the loop variable on success, -1 on error.

_http_nodebug
int zhtml_parse_loopvariable(ZHTMLParser *parser)
{
   auto int var;

	// Must start with '$'
	if (*(parser->p) != '$') {
   	return -1;
	}
   parser->p++;
   // Next value must be 'A'-'Z'
   var = *(parser->p) - 'A';
   if (zhtml_isvarchar(*(parser->p + 1))) {
   	// The variable name doesn't end there
      parser->p--;
   	return -1;
   }
   if ((var < 0) || (var > 25)) {
   	return -1;
   }
   parser->p++;
	return var;
}

/*** BeginHeader zhtml_parse_number */
int zhtml_parse_number(ZHTMLParser *parser, long *number, int nocount);
/*** EndHeader */

// Parse out a numeric expression.  This can be a count() function, a loop
// variable, a regular variable of integral type, or a numeric literal.  If the
// nocount parameter is set, then the parser will not check for a count()
// expression.  This is used to prevent recursion, since zhtml_parse_count()
// can call zhtml_parse_number().
//
// parser -- The current state of the ZHTML parser
// number -- OUTPUT.  The result of the numeric expression.
// Return -- 0 on success, -1 on error.

_http_nodebug
int zhtml_parse_number(ZHTMLParser *parser, long *number, int nocount)
{
   auto char __far *p;
   auto int retval;
   auto int loopvar;
   auto ZHTMLVarInfo varinfo;

	_http_assert(number != NULL);

	// Save off the original parser pointer
	p = parser->p;

	// Is this a count() function?
	// nocount prevents us from parsing a count() function.  This is needed to
	// prevent recursion, since count() can take a number (which could be a
	// count) as a parameter).
	if (!nocount) {
	   retval = zhtml_parse_count(parser, number);
	} else {
		// count() not allowed
		retval = -1;
	}
   if (retval == 0) {
      // It was a count() function, and number has been filled in
      return 0;
   }
   else if (retval < -1) {
   	zhtml_error(parser, "Error in count() function");
   	return -1;
   }

   // Not a count() function...Is this a loop variable?
   parser->p = p;		// Restore the original parser pointer
	loopvar = zhtml_parse_loopvariable(parser);
	if (loopvar >= 0) {
		*number = parser->tempvars[loopvar];
		return 0;
	}

   // Not a loop variable...Is this a regular variable?
   parser->p = p;		// Restore the original parser pointer
	retval = zhtml_parse_variable(parser, &varinfo);
	if (retval == 0) {
	   if (zhtml_get_numericvariable(&varinfo, number) < 0) {
	      zhtml_error(parser, "Variable not of integral type");
	      return -1;
	   }
		return 0;
	}

   // Must be an integer
   parser->p = p;		// Restore the original parser pointer
   *number = _f_strtol(parser->p, &p, 10);
   if (!isspace(*p) && (*p != ';') && (*p != ')')) {
   	zhtml_error(parser, "Expecting a number, variable, or count()");
      return -1;
   }
   parser->p = p;

	return 0;
}

/*** BeginHeader zhtml_parse_count */
int zhtml_parse_count(ZHTMLParser *parser, long *number);
/*** EndHeader */

// Parse a count() exression.  This expression is used to give the size of a
// specific dimension for an array (the second integral parameter gives the
// index of the array for which we want a count--0 for a one-dimensional array)
// or the number of options for a selection variable (in which case there is no
// second parameter).  This is often used for the bounds in for loops.
//
// parser -- The current state of the ZHTML parser
// number -- OUTPUT.  The result of the count() expression.
// Return -- 0 on success, -1 if this was not a count expression, -2 on error

_http_nodebug
int zhtml_parse_count(ZHTMLParser *parser, long *number)
{
	auto ZHTMLVarInfo info;
	auto int index;
	auto int numbounds;
	auto int *bounds;

	_http_assert(number != NULL);

   if (memcmp(parser->p, "count", 5) ||
       !zhtml_isspace_or_paren(*(parser->p+5))) {
   	// Not a count
   	return -1;
   }
   parser->p += 5;
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_openparen(parser) < 0) {
   	zhtml_error(parser, "Expecting '('");
      return -2;
   }
   if (*parser->p != '$') {
   	zhtml_error(parser, "Not a valid variable");
   	return -2;
   }
   parser->p++;
   if (zhtml_parse_variablename(parser, &info, 1) < 0) {
   	zhtml_error(parser, "Not a valid variable");
   	return -2;
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_comma(parser) < 0) {
   	// No comma, so this must be a selection variable
   	if (info.select.ptr16 == NULL) {
   		// Not a selection variable
   		zhtml_error(parser, "Not a selection variable");
   		return -2;
   	}
   	*number = zhtml_select_numitems(&info);
   	if (*number < 0) {
   		zhtml_error(parser, "Not a selection variable");
   		return -2;
   	}
   }
   else {
   	// Parsed a comma, so there is a number following that gives the nth
   	// dimension that we want the bound for
   	zhtml_parse_whitespace(parser);
   	if (zhtml_parse_number(parser, number, 1) < 0) {
      	// zhtml_parse_number generates its own errors
   		return -2;
   	}
   	// Calculate the number of bounds
   	bounds = info.bounds;
   	if (bounds == NULL) {
   		zhtml_error(parser, "Expecting a selection variable or array");
   		return -2;
   	}
   	numbounds = 0;
   	while (bounds[numbounds] != 0) {
   		numbounds++;
   	}
   	if ((*number < 0) || (*number >= numbounds)) {
			zhtml_error(parser, "Index out of range for this array");
   		return -2;
   	}
   	index = (int)*number;
   	*number = (long)bounds[index];
   }
   zhtml_parse_whitespace(parser);
   if (zhtml_parse_closeparen(parser) < 0) {
   	zhtml_error(parser, "Expecting ')'");
      return -2;
   }
	return 0;
}

/*** BeginHeader zhtml_parse_comparison */
int zhtml_parse_comparison(ZHTMLParser *parser);
/*** EndHeader */

// Parse out a comparison operator (<=, <, >=, etc.).
//
// parser -- The current state of the ZHTML parser
// Return -- The type of comparison operator parsed, or -1 on error

_http_nodebug
int zhtml_parse_comparison(ZHTMLParser *parser)
{
	if (strncmp(parser->p, "<=", 2) == 0) {
   	parser->p += 2;
   	return _ZHTML_COMP_LE;
   }
   else if (*(parser->p) == '<') {
   	parser->p++;
   	return _ZHTML_COMP_LT;
   }
   else if (strncmp(parser->p, ">=", 2) == 0) {
   	parser->p += 2;
   	return _ZHTML_COMP_GE;
   }
   else if (*(parser->p) == '>') {
   	parser->p++;
   	return _ZHTML_COMP_GT;
   }
   else if (strncmp(parser->p, "==", 2) == 0) {
   	parser->p += 2;
   	return _ZHTML_COMP_EQ;
   }
   else if (strncmp(parser->p, "!=", 2) == 0) {
   	parser->p += 2;
   	return _ZHTML_COMP_NE;
   }
   else {
   	return -1;
   }
}

/*** BeginHeader zhtml_parse_stepop */
int zhtml_parse_stepop(ZHTMLParser *parser);
/*** EndHeader */

// Parse out a step operator (++, --, +=, or -=).
//
// parser -- The current state of the ZHTML parser
// Return -- The type of step operator parsed, or -1 on error.

_http_nodebug
int zhtml_parse_stepop(ZHTMLParser *parser)
{
	if (strncmp(parser->p, "++", 2) == 0) {
   	parser->p += 2;
      return _ZHTML_STEPOP_INC;
   }
	else if (strncmp(parser->p, "--", 2) == 0) {
   	parser->p += 2;
      return _ZHTML_STEPOP_DEC;
   }
	else if (strncmp(parser->p, "+=", 2) == 0) {
   	parser->p += 2;
      return _ZHTML_STEPOP_PE;
   }
	else if (strncmp(parser->p, "-=", 2) == 0) {
   	parser->p += 2;
      return _ZHTML_STEPOP_ME;
   }
	return -1;
}

/*** BeginHeader zhtml_check_condition */
int zhtml_check_condition(long number1, char comparison, long number2);
/*** EndHeader */

// Given two values and the type of comparison, check the given comparison.
//
// number1    -- Value of the first number
// comparison -- The type of comparison to perform (<, >, <=, etc.)
// number2    -- Value of the second number
// Return     -- 0 for failed comparison, !0 for successful comparison

_http_nodebug
int zhtml_check_condition(long number1, char comparison, long number2)
{
   switch (comparison) {
   case _ZHTML_COMP_LT:
      return (number1 < number2);
   case _ZHTML_COMP_GT:
      return (number1 > number2);
   case _ZHTML_COMP_LE:
      return (number1 <= number2);
   case _ZHTML_COMP_GE:
      return (number1 >= number2);
   case _ZHTML_COMP_EQ:
      return (number1 == number2);
   case _ZHTML_COMP_NE:
      return (number1 != number2);
   }
}

/*** BeginHeader zhtml_copytochar */
int zhtml_copytochar(char __far *dest, char __far *src, char c, int len);
/*** EndHeader */

// Copy from the src buffer to the dest buffer until a given character (c) is
// encountered (note that c is not copied to the destination).  The destination
// buffer is also NOT null-terminated.
//
// dest   -- The destination buffer
// src    -- The source buffer
// c      -- The character to which we will copy
// len    -- The maximum length of the destination buffer
// Return -- The number of bytes copied to the dest buffer

_http_nodebug
int zhtml_copytochar(char __far *dest, char __far *src, char c, int len)
{
	auto int i;

	_http_assert(dest != NULL);

	i = 0;
	while ((*src != c) && (*src != '\0')) {
		if (i >= len) {
			return i;
		}
		else {
	      *dest = *src;
	      dest++;
	      src++;
	      i++;
      }
   }
   return i;
}

/*** BeginHeader zhtml_substitutedims */
int zhtml_substitutedims(char *dest, char *src, int *dims, int len);
/*** EndHeader */

// Reads the src string, substitutes wildcarded dimensions (using the dims
// array to provide the substitutions), and writes the result into the dest
// string (with len providing the maximum length of the dest string).
//
// dest   -- The destination buffer
// src    -- The source buffer
// dims   -- The array of wildcarded dimensions
// len    -- The maximum length of the dest buffer
// Return -- 0 on success, -1 on failure

_http_nodebug
int zhtml_substitutedims(char *dest, char *src, int *dims, int len)
{
	auto int i;
   auto char dim[7];
   auto int num;
   auto int numdims;

	_http_assert(dest != NULL);

	// Calculate the number of array dims
	numdims = 0;
	if (dims) {
		while (dims[numdims] >= 0) {
			numdims++;
		}
	}

   while (*src != '\0') {
		i = zhtml_copytochar(dest, src, '@', len);
		if (i >= len) {
			// Filled the destination buffer
			return -1;
		}
      dest += i;
      src += i;
      len -= i;
      if (*src == '@') {
      	// We have an array substitution to handle
			src++;
         if (*src != '[') {
         	return -1;
         }
         src++;
         i = zhtml_copytochar(dim, src, ']', 5);
         if (i > 5) {
         	return -1;
         }
         dim[i] = '\0';
         src += i;
         if (*src != ']') {
         	return -1;
         }
         src++;
         // Figure out the dimension
			num = atoi(dim);
         if ((num < 0) || (num > (numdims - 1))) {
         	// Dimension out of range
         	return -1;
         }
			num = dims[num];
         i = snprintf(dest, len, "%d", num);
         if (i >= len) {
         	// Filled the destination buffer
         	return -1;
         }
         dest += i;
         len -= i;
      }
   }
	// Must be at the end of the string
	if (len > 0) {
		*dest = '\0';
      return 0;
   }
   else {
   	return -1;
   }
}

/*** BeginHeader zhtml_matchnames */
int zhtml_matchnames(_Web_Var_Info *wvi, char *p, int dims[], int *matchlen,
                     int *matchdims, int dimsonly);
/*** EndHeader */

// Attempt to match a given name with a given _Web_Var_Info structure.  This
// function only checks the portion of the name given as part of a #web
// statement, not the rest of the name (which could include further structure
// members if an entire structure was registered in a #web statement).  It
// returns the length of the match and the number of dimensions that match,
// which can be used to determine the best match.
//
// Additionally, it saves off a list of wildcarded dimensions.  That is, if the
// _Web_Var_Info name contains a wildcarded dimension ("[@]"), then the value
// of the corresponding dimension in p is saved.
//
// wvi       -- The _Web_Var_Info structure with which to attempt a match
// p         -- The name to match
// dims      -- OUTPUT.  If NULL, it is ignored.  If not NULL, it is filled
//              with the wildcarded array dimensions
// matchlen  -- OUTPUT.  If NULL, it is ignored.  If not NULL, it is filled
//              with the length of the match (used for best match heuristics).
// matchdims -- OUTPUT.  If NULL, it is ignored.  If not NULL, it is filled
//              with the number of dimenstions matched (used for best match
//              heuristics).
// dimsonly  -- We are doing this match for the ZHTML count() function, which
//              is matching only to get a dimension bound.  zhtml_matchnames
//              handles dimensions in a different way in this case.
// Return    -- < 0 for error, > 0 for no match, and 0 for a match.

_http_nodebug
int zhtml_matchnames(_Web_Var_Info *wvi, char *p, int dims[], int *matchlen,
                     int *matchdims, int dimsonly)
{
   auto _Web_Struct_Mem_Info *meminfo;
   auto char *wviname;
   auto char index[6];
   auto int temp;
   auto int num;
   auto char *p_orig;
   auto int in_array_index;
   auto int numdims;
   auto char *temp_p;

	// This function checks if the names match--that is, can this be a match
   // at all?  It also saves off the values of wildcarded dimensions.
	numdims = 0;
   meminfo = NULL;
   wviname = wvi->name;
   p_orig = p;
   if (matchdims) {
		*matchdims = 0;
   }
   in_array_index = 0;

	// Continue until we reach the end of the wviname
   while (*wviname != '\0') {
   	if (in_array_index) {
			if (*wviname != '@') {
         	// This is a specific match
            if (matchdims) {
					(*matchdims)++;
            }
         }
         in_array_index = 0;
      }
   	if (*wviname == '@') {
      	// Must be a wildcard--save off the index from p
			temp = zhtml_copytochar(index, p, ']', 5);
         if (temp > 5) {
         	return -1;
         }
         index[temp] = '\0';
         if (dims != NULL) {
				dims[numdims] = atoi(index);
         }
	      numdims++;
         p += temp;
         wviname++;
      }
		else if (*wviname == '.') {
      	// Need to descend to the next level
			if (*p != '.') {
         	// No match
         	return 1;
         }
         p++;
         if (meminfo == NULL) {
				// We're in the first level of the wvi structure
				meminfo = wvi->type.ptr->ptr;
         }
         else {
         	meminfo = meminfo->type.ptr->ptr;
         }
         wviname = meminfo->name;
         continue;
		}
      else if (*wviname == '[') {
      	if (dimsonly) {
      		// We are ignoring dimensions as part of the match
      		if ((*p != '[') && (*p != '.') && (*p != '\0')) {
      			// Not a match
      			return 1;
      		}
      		// Need to skip past the dimensions since we are ignoring
      		// dimensions in this match--probably because we are doing this
      		// match for the count() function
      		temp_p = _n_strchr(p, '.');
      		if ((temp_p != NULL) && (strchr(wviname, '.') != NULL)) {
      			// Still matching--must continue
      			p = temp_p;
      			wviname = _n_strchr(wviname, '.');
      			continue;
      		}
      		else
      		{
      			// No further '.' in p and no further '.' in wviname--match
      			// and return
      			// OR further '.' in p and no further '.' in wviname--also
      			// match and return
      			break;
      		}
      	}
      	else {
      		// We are NOT ignoring dimensions
	         if (*p != '[') {
	            // No match
	            return 1;
	         }
	         in_array_index = 1;
	      }
      }
      // Variable names are case-insensitive in HTTP
      else if (tolower(*wviname) != tolower(*p)) {
      	return 1;
      }
      wviname++;
      p++;
   }
   if ((*p != '.') && (*p != '[') && (*p != '\0')) {
   	// Not a match, actually
      return 1;
   }
   // We have a match
   if (matchlen) {
	   *matchlen = p - p_orig;
   }
	if (dims != NULL) {
	   dims[numdims] = -1;
   }
   return 0;
}

/*** BeginHeader zhtml_matchstructure */
_Web_Struct_Mem_Info *zhtml_matchstructure(_Web_Struct_Mem_List *list,
                                           char *name, int len);
/*** EndHeader */

// Searches through a structure member list for a member that matches the given
// name.  Note that this function is only used to search through the structure
// list when we have already descended through the part of the name specified
// as part of the #web statement.
//
// list   -- The structure member list in which to search
// name   -- The name of the structure member to locate (NOT null-terminated)
// len    -- The length of the name (since it isn't null-terminated)
// Return -- The structure member info if the member was found, or NULL on error

_http_nodebug
_Web_Struct_Mem_Info *zhtml_matchstructure(_Web_Struct_Mem_List *list,
                                           char *name, int len)
{
	auto _Web_Struct_Mem_Info *meminfo;

	_http_assert(list != NULL);

	meminfo = list->ptr;
	// Continue until the list is done (or we find a match)
	while (meminfo->name != NULL) {
		if ((strncmpi(name, meminfo->name, len) == 0) &&
		    (meminfo->name[len] == '\0')) {
			// Found the match
			return meminfo;
		}
      meminfo++;
	}
	// Did not find a match
	return NULL;
}

/*** BeginHeader zhtml_calculateoffset */
int zhtml_calculateoffset(char *p, int *bounds, int elesize, int is_string);
/*** EndHeader */

// Calculates the offset of the variable, given the name of the variable, the
// array bounds, the element size, and whether or not it is a string.  In
// particular, this function will check the array bounds in the variable name
// for the offset calculation and for errors (out of bounds).  It will also
// check for the right number of dimensions.
//
// p         -- The variable name (including array indices, possibly)
// bounds    -- The array bounds for the variable (if it is an array)
// elesize   -- The size of an element of this variable
// is_string -- Whether or not this variable is a string
// Return    -- The calculated offset of the element (0 if no array indices, or
//              if it is the first element of the array).  -1 if the bounds
//              check fails.

_http_nodebug
int zhtml_calculateoffset(char *p, int *bounds, int elesize, int is_string)
{
	auto int numdims;
   auto char index[6];
   auto int dim;
   auto int numbounds;
   auto int i;
   auto int product;
   auto int offset;
   auto int temp;

	offset = 0;

	// Calculate the number of array bounds
	numbounds = 0;
	if (bounds) {
		while (bounds[numbounds] > 0) {
			numbounds++;
		}
	}

	// Check the bounds of any array subscript before the next '.'
	numdims = 0;
	p += strcspn(p, ".[");
	while ((*p != '.') && (*p != '\0')) {
		// We are at a '['
		p++;
		temp = zhtml_copytochar(index, p, ']', 5);
      if (temp > 5) {
         return -1;
      }
      index[temp] = '\0';
      dim = atoi(index);
      if (numdims > numbounds) {
      	// Too many dimensions!
      	return -1;
      }
      if (dim >= bounds[numdims]) {
      	// Dimension too large
      	return -1;
      }
      numdims++;
      // It fit the bounds, so we can now calculate this part of the offset
      product = dim;
		for (i = numdims; i < numbounds; i++) {
			product *= bounds[i];
		}
		offset += product;
		p += strcspn(p, ".[");
	}

	// Check if this is a string, since strings use the last dimension as the
	// size of the string
	if (!is_string) {
	   if (numdims != numbounds) {
	      // Incorrect number of dimensions
	      return -1;
	   }
	}
	else {
		if (numdims != (numbounds - 1)) {
			// Incorrect number of dimensions
			return -1;
		}
	}

   // Multiply the calculated offset by the size of the element, unless
   // this is a string, in which case we've already used the element size
   // as the length of the string.
	if (!is_string) {
		offset *= elesize;
	}

	return offset;
}

/*** BeginHeader zhtml_gettypesize */
int zhtml_gettypesize(_Web_Var_Type type, int *bounds);
/*** EndHeader */

// Get the size of the given type.  bounds are passed in in case it is a
// string type.
//
// type   -- The type of the variable (_DK_T_CHAR, _DK_TINT, etc...)
// bounds -- The array bounds for the variable (only useful if this is a string
//           type variable).  Note that this is a structure passed in by value,
//           but it's OK in this case since the structure is only 2 bytes.
// Return -- The size of the variable

_http_nodebug
int zhtml_gettypesize(_Web_Var_Type type, int *bounds)
{
	// Check if it is a structure, and return the size of that structure if so
	if (type.simple >= _DK_TSTRUCT) {
   	return type.ptr->strsize;
   }
   // Return the size of the type
   else {
   	switch (type.simple) {
      case _DK_TSIGNEDCHAR:
      	return sizeof(signed char);
      case _DK_T_CHAR:
      	return sizeof(char);
      case _DK_TINT:
      	return sizeof(int);
      case _DK_TUNSIGNED:
      	return sizeof(unsigned int);
   	case _DK_TLONG:
      	return sizeof(long);
      case _DK_TULONG:
      	return sizeof(unsigned long);
		case _DK_TFLOAT:
      	return sizeof(float);
      case _DK_TSTRING:
      	_http_assert(bounds != NULL);
      	return zhtml_getstrsize(bounds);
      }
   }
   // Error!
   return -1;
}

/*** BeginHeader zhtml_getvarinfo */
int zhtml_getvarinfo(int *type, void **ptr, int **dims, _Web_Var_Info *wvi,
                     char *p, int dimsonly);
/*** EndHeader */

// Given information on a variable (name, _Web_Var_Info entry), find certain
// information about the variable (type, value pointer, array bounds).  This
// function walks the _Web_Var_Info structure for information on this variable.
// This involves navigating through structure members (it uses the '.' symbol
// to know when to do this) and calculating offsets using array bounds (done
// by looking for the '[' and ']' symbols).
//
// This function assumes that the part of the name has already been matched
// by zhtml_matchnames().  This function proceeds in three stages.  The first
// is to navigate through the structure until all of the wviname has been
// matched (that is, until the names in the _Web_Var_Info structure stop ending
// in '.').  The second is to match the first name (structure element, possibly)
// after the first stage.  The third is to match all remaining portions of the
// name.  The address is calculated all along the way in these stages, so that
// at the end the correct address has been obtained.  The final type and dims
// come from the final data structure to which we have navigated.
//
// If the dimsonly parameter is set, then instead of calculating all variable
// information, this function will only return the array bounds for the
// variable.
//
// Returns 0 if we got the variable info, -1 if there was an error.  It also
// fills in the type and ptr parameters with the type of the variable and a
// pointer to the value, respectively.
//
// type     -- OUTPUT.  This is filled in with the type of the variable.
// ptr      -- OUTPUT.  This is filled in with a pointer to the variable.
// dims     -- OUTPUT.  This is filled in with a pointer to the array of
//             array dimensions.
// wvi      -- INPUT.  The _Web_Var_Info structure for this variable.
// p        -- INPUT.  The full variable name (with wildcarded array indices
//             already filled in).
// dimsonly -- INPUT.  Only return information on the array bounds.
// Return   -- 0 for success, -1 on error

_http_nodebug
int zhtml_getvarinfo(int *type, void **ptr, int **dims, _Web_Var_Info *wvi,
                     char *p, int dimsonly)
{
	auto _Web_Struct_Mem_Info *meminfo;
	auto _Web_Struct_Mem_List *memlist;
	auto char *wviname;
	auto int *bounds;
	auto int elesize;
	auto char *address;
	auto int offset;
	auto int len;

	_http_assert(type != NULL);
	_http_assert(ptr != NULL);
	_http_assert(dims != NULL);

	// First, cover all of wviname--we know it matched earlier, so we can skip
	// right through it
	meminfo = NULL;
	wviname = wvi->name;
	bounds = wvi->dims;
	address = wvi->valptr;

	// ---- STAGE 1 ----
	// Continue this first phase until there is no '.' at the end of the name
	// (that is, the wviname is not continued)
	while (wviname[strlen(wviname) - 1] == '.') {
		// Need to check any array bounds at this level
		if (meminfo == NULL) {
			elesize = zhtml_gettypesize(wvi->type, bounds);
			*type = wvi->type.simple;
		}
		else {
			elesize = zhtml_gettypesize(meminfo->type, bounds);
			*type = meminfo->type.simple;
		}
		if (!dimsonly) {
	      offset = zhtml_calculateoffset(p, bounds, elesize,
	                                     (*type==_DK_TSTRING)?1:0);
	      if (offset < 0) {
	         return -1;
	      }
	      address += offset;
	   }
		p = _n_strchr(p, '.');
		if ((p == NULL) || (*(++p) == '\0')) {
			if (dimsonly) {
				// p *can* end before wviname in this case, since we're just looking
				// for dimensions
				*dims = bounds;
				return 0;
			}
			else {
				return -1;
			}
		}
		// Descend to the next level (we know we can, since this part of wviname
		// ends in a '.')
		if (meminfo == NULL) {
			meminfo = wvi->type.ptr->ptr;
		}
		else {
			meminfo = meminfo->type.ptr->ptr;
		}
		wviname = meminfo->name;
      bounds = meminfo->dims;
		address += meminfo->offset;
	}

	// ---- STAGE 2 ----
	// wviname does not end in a '.'.  However, we do already have the meminfo
	// information (understanding that meminfo could still be NULL at this
	// point, so we conditionally have the information in wvi).  Therefore, we
	// do not yet have to parse out the member name and search a member list.

   // Need to check any array bounds at this level
   if (meminfo == NULL) {
		elesize = zhtml_gettypesize(wvi->type, bounds);
		*type = wvi->type.simple;
   }
   else {
		elesize = zhtml_gettypesize(meminfo->type, bounds);
		*type = meminfo->type.simple;
   }
   if (!dimsonly) {
      offset = zhtml_calculateoffset(p, bounds, elesize,
                                     (*type==_DK_TSTRING)?1:0);
	   if (offset < 0) {
	      return -1;
	   }
	   address += offset;
	}
	// Need to advance p--either to another '.' or '\0' (and end)
	p = _n_strchr(p, '.');
	if (p == NULL) {
		// We're done with the match
		*ptr = address;
		*dims = bounds;
		return 0;
	}
	// Note that setting meminfo this time sets it to the start of a list of
	// structure members.  We must subsequently search for the right member in
	// that list.
	if (meminfo == NULL) {
		memlist = wvi->type.ptr;
	}
	else {
		memlist = meminfo->type.ptr;
	}

	// ---- STAGE 3 ----
	// We are descending through the wvi structure.  We must search out
	// structure members as we traverse the structure.  This continues until
	// p ends.  Note that at this point, meminfo *must* be pointing to something.
	while (p != NULL) {
		// Need to pick out the member name to pass to the matching function
		if (*(++p) == '\0') {
			// Can't end in a '.'!
			return -1;
		}
		len = strcspn(p, ".[");
		// Find the match
		meminfo = zhtml_matchstructure(memlist, p, len);
		if (meminfo == NULL) {
			// No such member--error!
			return -1;
		}
		// Have the member info
      address += meminfo->offset;
      bounds = meminfo->dims;
		elesize = zhtml_gettypesize(meminfo->type, bounds);
		*type = meminfo->type.simple;
		if (!dimsonly) {
	      offset = zhtml_calculateoffset(p, bounds, elesize,
	                                     (*type==_DK_TSTRING)?1:0);
	      if (offset < 0) {
	         return -1;
	      }
	      address += offset;
	   }

		// Find the next '.'
		p = _n_strchr(p, '.');
		if (p != NULL) {
			memlist = meminfo->type.ptr;
		}
	}
	// End of p, finally--return what we know
	*ptr = address;
	*dims = bounds;
	return 0;
}

/*** BeginHeader zhtml_acquire_lock */
int zhtml_acquire_lock(int servernum);
/*** EndHeader */

// Acquires a lock on the POST-processing enhancements global data structures.
// This prevents multiple HTTP POST requests from trampling each other--if a
// request is unable to get a lock, it is forced to wait.
//
// servernum -- The number of the current HTTP server.  Used to remember which
//              server has acquired the lock.
// Return    -- 1 for lock acquired, 0 for lock not acquired
_http_nodebug
int zhtml_acquire_lock(int servernum)
{
	if ((_zhtml_lock == -1) || (_zhtml_lock == servernum)) {
		_zhtml_lock = servernum;
		return 1;
	}
	else {
		return 0;
	}
}

/*** BeginHeader zhtml_release_lock */
void zhtml_release_lock(int servernum);
/*** EndHeader */

// Releases a lock on the POST-processing enhancements global data structures.
//
// servernum -- The number of the current HTTP server.  The lock is only
//              really released if this number matches the number remembered in
//              the lock.
_http_nodebug
void zhtml_release_lock(int servernum)
{
	if (_zhtml_lock == servernum) {
		_zhtml_lock = -1;
	}
}


