/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader */
#ifndef _HTTP_H
#define _HTTP_H

/*
 *    http.lib, with HTTPS support
 *
 *    Define HTTP_MAXSERVERS to the number of HTTP plus HTTPS servers.
 *    This defaults to 2.
 *
 *    - To use HTTPS, define the USE_HTTP_SSL and HTTP_SSL_SOCKETS
 *      macros.
 *    - The number of HTTP and HTTPS servers is determined by
 *      both HTTP_SSL_SOCKETS and HTTP_MAXSERVERS. One server
 *      is allocated for each HTTP ssl socket, and the remaining
 *      servers are allocated as HTTP servers, for example, with
 *      HTTP_MAXSERVERS defined as 4 and HTTP_SSL_SOCKETS defined
 *      as 1, there would be 3 HTTP servers and 1 HTTPS server.
 *
 *    HTTPS support issues:
 *    - HTTPS uses port 443 instead of the HTTP port 80.
 *    - Unlike the SSL/TLS implementation prior to this release (v2.0, 2007)
 *      this version simplifies use of SSL/TLS sockets so that all the
 *      TCP socket APIs work with either SSL/TLS or ordinary TCP sockets.
 *      Each API (such as sock_fastread, sock_writable etc.) performs the
 *      correct action depending on the socket type which is determined at
 *      run-time.  The new API function sock_secure() turns a TCP socket
 *      into an SSL/TLS socket.
 *
 */


// #define HTTP_DEBUG
// #define HTTP_VERBOSE

#ifdef HTTP_DEBUG
	#define _http_nodebug __debug
	#define _http_assert(exp) assert(exp)
#else
	#define _http_nodebug __nodebug
	#define _http_assert(exp)			// Define to nothing
#endif

#use "base64.lib"
#ifndef __ZSERVER_LIB
	#use "zserver.lib"
#endif

// HTTPS configuration macros
#ifdef USE_HTTP_SSL
	#define __HTTP_USE_SSL__ 1

	#ifndef HTTP_SSL_SOCKETS
   	#define HTTP_SSL_SOCKETS	1 // Default of 1 SSL socket
	#endif

   #ifndef _SSL_SOCK_H
		#use "ssl_sock.lib"
	#endif

   #if (SSL_MAX_CONNECTIONS < HTTP_SSL_SOCKETS)
		#fatal "SSL_MAX_CONNECTIONS  must be defined to be at least as large " \
             "as HTTP_SSL_SOCKETS"
   #endif
#else
	#define __HTTP_USE_SSL__ 0
#endif


/*
 *    user changeable options
 */

#ifndef HTTP_HOMEDIR
	#define HTTP_HOMEDIR	"/"
#endif

#ifndef HTTP_DFLTFILE
	#define HTTP_DFLTFILE "index.html"
#endif

#ifndef HTTP_MAXSERVERS
   #define HTTP_MAXSERVERS		2
#endif

#if (HTTP_MAXSERVERS > SSPEC_MAX_OPEN)
	#warns "SSPEC_MAX_OPEN (see documentation for ZServer.lib) should be at least as large as HTTP_MAXSERVERS"
#endif

#ifndef USE_HTTP_BASIC_AUTHENTICATION
	#define USE_HTTP_BASIC_AUTHENTICATION 1
#endif

#ifndef USE_HTTP_DIGEST_AUTHENTICATION
	#define USE_HTTP_DIGEST_AUTHENTICATION 0
#endif

#ifndef HTTP_DIGEST_NONCE_TIMEOUT
	#define HTTP_DIGEST_NONCE_TIMEOUT	900
#endif

#ifdef HTTP_SOCK_BUF_SIZE
	// This means that each server socket uses this much _web_malloc()'d memory
	// (instead of from the buffer pool)
	#ifdef USE_HTTP_UPLOAD
		#if __HTTP_USE_SSL__
			// The check below is to ensure a socket buffer sufficient to
			// contain 1MSS (1460) for transmit, and 16k for receive.  SSL
			// records may be up to this size, and we need the complete
			// record to be buffered before decryption and MAC check.  The
			// extra 36 accounts for the largest expansion we support, which
			// is currently AES (16 bytes padding) + SHA-1 (20 byte MAC)
			#if HTTP_SOCK_BUF_SIZE < 1460 + 16384 + 36
				#warns "When using HTTP upload with SSL/TLS, specify HTTP_SOCK_BUF_SIZE"
				#warns "to be at least 17880, otherwise some clients may not be supported."
			#endif
		#endif
	#endif
#else
	#if (HTTP_MAXSERVERS > MAX_TCP_SOCKET_BUFFERS)
	   #fatal "MAX_TCP_SOCKET_BUFFERS must be defined to be at least as large as HTTP_MAXSERVERS"
	#endif
#endif

/*
 * 	Max time (in seconds) that HTTP will remaining in any connected state.
 *    After timeout, the Rabbit will (force) close the connection.
 */
#ifndef HTTP_TIMEOUT
	#ifdef HTTP_DEBUG
		#define HTTP_TIMEOUT		3600
	#else
	   #ifdef USE_HTTP_SSL
	      // Need long timeout if using SSL, since 1024+ bit
	      // keys can otherwise timeout in HTTPS listen state.
	      #define HTTP_TIMEOUT    60
	   #else
	      #define HTTP_TIMEOUT    30
	   #endif
   #endif
#endif

#ifndef HTTP_PORT
	#define HTTP_PORT 80
#endif

#ifndef HTTPS_PORT
   #define HTTPS_PORT 443
#endif

#ifndef HTTP_IFACE
	#define HTTP_IFACE	IF_ANY
#endif


/*
 * 	If main program defines HTTP_USERDATA_SIZE, then "char userdata[]" to be
 * 	added to the HttpState structure.  If not defined, then it ain't there!
 * 	Define your structure _before_ #use http.lib
 *
 * 		struct UserStateData { char name[50]; int floor; int model; };
 * 		#define  HTTP_USERDATA_SIZE	(sizeof(struct UserStateData))
 * 		#use http.lib
 *
 * 	Cleared to zero when structure initialized.  Otherwise it is not touched.
 * 	Value must be greater than zero. In your own code, access it like:
 * 			mystate = (struct UserStateData *) state->userdata;
 */


/*SJH - improve code in the common case of 1 server.  This removes the
  array indexing operations on the http_servers struct. */
#if (HTTP_MAXSERVERS == 1)
	#define HTTP_X
	#define HTTP_SERVNO 0
	#define HTTP_DECL_INDEX auto HttpState * state;
	#define HTTP_FORALL_SERVERS { state = &http_servers;
	#define HTTP_END_FORALL_SERVERS }
#else
	#define HTTP_X [x]
	#define HTTP_SERVNO x
	#define HTTP_DECL_INDEX auto int x; auto HttpState * state;
	#define HTTP_FORALL_SERVERS for (x=0; x < HTTP_MAXSERVERS; x++) \
					{ state = &(http_servers HTTP_X);
	#define HTTP_END_FORALL_SERVERS }
#endif

/*
 *    internal server buffers (reduce at your own risk)
 */

 /*  Lynx V2 can send Accept: encoding strings of 250 to 600 bytes long!
  *  The TCP layer can buffer, but if you want to interoperate, make
  *  sure HTTP_MAXBUFFER is large.  It also affects POST methods.
  *  cgi_redirectto() uses about 200 chars during its processing.
  *  The buffer is also used to generate response headers, which can be 200
  *  or more chars long (or more, if using custom headers).
  *  Note: The HTTP buffer is now dynamically allocated (far memory) so the
  *  default buffer length is set to 1024.
  */
#ifndef HTTP_MAXBUFFER
   #define HTTP_MAXBUFFER     1024		// 512 is the minimum recommended
#endif

#ifndef HTTP_MAXURL
   #define HTTP_MAXURL        512
#endif

#ifndef HTTP_MAXNAME
   #define HTTP_MAXNAME       SSPEC_MAXNAME
#else
	#if HTTP_MAXNAME != SSPEC_MAXNAME
   	#fatal "HTTP_MAXNAME must be defined the same as SSPEC_MAXNAME"
   #endif
#endif

#ifndef HTTP_MAX_COND
   /* SJH - support for conditional SSI (error feedback etc) */
   #define HTTP_MAX_COND		4
#endif

// This macro must be defined to 1 to enable the HTTP enhancements
#ifndef USE_RABBITWEB
	#define USE_RABBITWEB		0
#endif

// This macro determines the maximum nesting level in the ZHTML scripting
// language (for "if" and "for" statements)
#ifndef RWEB_ZHTML_MAXBLOCKS
	#define RWEB_ZHTML_MAXBLOCKS	4
#endif

#define HTTPSPEC_UNUSED			SSPEC_UNUSED
#define HTTPSPEC_FILE			SSPEC_FILE
#define HTTPSPEC_VARIABLE		SSPEC_VARIABLE
#define HTTPSPEC_FUNCTION		SSPEC_FUNCTION
#define HTTPSPEC_CGI				SSPEC_CGI

/* HttpState.state's */

#define HTTP_INIT         		0
#define HTTPS_LISTEN				1     // Special listen state for HTTPS
#define HTTP_LISTEN       		2
#define HTTP_GETREQ       		3
#define HTTP_GETHEAD      		4
#define HTTP_HANDLEPOST			5
#define HTTP_PROCESS      		6
#define HTTP_SENDPAGE     		7
#define HTTP_HANDLER      		8
#define HTTP_WAITCLOSE    		9
#define HTTP_FINISHWRITE  		10
#define HTTP_DIE          		11
#define HTTP_OLDCGI       		12		// Old style CGI
// Following states used for parsing multipart content, and passing it to new-style CGIs.
#define HTTP_CGI_PROLOG			13		// Initial state (just read blank line after request headers, and possibly
												// reading prolog data).
#define HTTP_CGI_PARTHEAD		14		// Reading headers for an encapsulated part of a multipart
#define HTTP_CGI_PARTDATA		15		// Reading part data
#define HTTP_CGI_EPILOG			16		// Reading epilog data to EOF
#define HTTP_CGI_END				17		// End of part
#define HTTP_CGI_CONTINUE		18		// Call back CGI with no new incoming data and CGI_CONTINUE action code
#define HTTP_CGI_SENDBUF		19		// Sending null-terminated string in buffer
#define HTTP_CGI_SENDMORE		20		// Sending null-terminated string in buffer, then like CONTINUE
#define HTTP_REALLY_DIE       21		// Really close (after TLS close)
#define HTTP_WAIT_CN				22		// Wait for close notify to be sent after closing TLS

#define HTTP_METHOD_GET   		1
#define HTTP_METHOD_HEAD  		2
#define HTTP_METHOD_POST  		3

#define HTTP_VER_09       		1
#define HTTP_VER_10       		2
#define HTTP_VER_11       		3

// Content-Transfer-Encoding enumeration
#define CTE_BINARY      0     // The default
#define CTE_7BIT        1     // 7-bit safe ASCII
#define CTE_8BIT        2     // 8-bit ASCII
#define CTE_QP          3     // Quoted printable
#define CTE_BASE64      4     // Base 64

// Content-Disposition types
#define MIME_DISP_NONE			0
#define MIME_DISP_INLINE		1
#define MIME_DISP_ATTACHMENT	2
#define MIME_DISP_FORMDATA		3	// only this one is really relevant to us.

// New-style CGI "action" parameter values (returned by http_getAction()).
#define CGI_START			1		// Start of next part of multipart data
#define CGI_DATA			2		// Part data
#define CGI_END			3		// End of part
#define CGI_PROLOG		7		// Prolog data (before first part, after headers)
#define CGI_EPILOG		8		// Epilog data (after last part, before EOF)
#define CGI_HEADER		9		// Header line unrecognized by server
#define CGI_EOF			14		// End of socket (may also have last line of epilog data)
#define CGI_ABORT			15		// Abnormal end of socket (may need resource recovery)
#define CGI_CONTINUE		16		// Server is re-calling after write buffer shortage

// Recognized return codes from new-style CGI
#define CGI_OK				0		// CGI is still processing.  Get next socket data.
#define CGI_DONE			1		// CGI has finished processing.  Close socket.
#define CGI_MORE			2		// CGI needs callback without new incoming data.
#define CGI_SEND			3		// CGI put null-term string in state->buffer - write it out before calling back.
#define CGI_SEND_DONE	4		// Combination of CGI_SEND and CGI_DONE.
#define CGI_SEND_MORE	5		// Combination of CGI_SEND and CGI_MORE.


// Make a typedef for this (incomplete) type, since it is required for
// function prototypes in RabbitWeb, included following.
typedef struct HttpState_t __far * HttpState_fp;
typedef struct HttpState_t * HttpState_p;



#if USE_RABBITWEB
	#ifdef USE_LEGACY_RABBITWEB
		#define web_error WEB_ERROR
		#use "RABBITWEB.LIB"
	#else
		#use "RWEB_HTTP.LIB"
	#endif
#endif


#ifndef _web_malloc
	#define _web_malloc _sys_malloc
	#define _web_calloc _sys_calloc
	#define _web_realloc _sys_realloc
	#define _web_free _sys_free
#endif

/* the cookie stuff */
const char cookie_name[] = "DCRABBIT";

// Typedefs for backward compatibility.
typedef MIMETypeMap HttpType;
typedef ServerPermissions  HttpRealm;
typedef ServerSpec HttpSpec;

// Typedef for saving a list of HTTP headers
typedef char* HttpHeader;
// This macro is used by the user to end their list of HTTP headers
#define END_HTTP_HEADERS NULL

// By default, disable saving HTTP headers
#ifndef USE_HTTP_SAVED_HEADERS
	#define USE_HTTP_SAVED_HEADERS	0
#endif
#if USE_HTTP_SAVED_HEADERS
	// Set the default size of the saved headers buffer
	#ifndef HTTP_SAVED_HEADERS_SIZE
		#define HTTP_SAVED_HEADERS_SIZE		512
	#endif
	// Set the default maximum size of a single saved header
	#ifndef HTTP_SAVED_HEADER_MAX_SIZE
		#define HTTP_SAVED_HEADER_MAX_SIZE	128
	#endif
#endif


// Use these macros consistently for dealing with TCP and/or SSL sockets
#define _TCP_SOCK_OF_HTTP(state) (&(state)->s)
#if __HTTP_USE_SSL__
	#define _IS_HTTPS(state) ((state)->context.server == SERVER_HTTPS)
	#define _SOCK_OF_HTTP(state) ((state)->sock)
	#define _SSL_SOCK_OF_HTTP(state) ((state)->_n_ssl)
#else
	#define _IS_HTTPS(state) 	0
	#define _SOCK_OF_HTTP(state) _TCP_SOCK(state->sock)
	#define _SSL_SOCK_OF_HTTP(state) NULL	// should never be used
#endif

typedef struct HttpState_t {
	void * sock;		// Same as _n_ssl, or points to tcp_Socket instance ('s') below.
#if __HTTP_USE_SSL__
   ssl_Socket * _n_ssl;			// This is same as above.  When far pointers are completely
   									// supported, these fields will be replaced by a single
   									// (true) far pointer.
   SSL_Cert_t __far * cert; 		// Pointer to the certificate structure
#endif

	tcp_Socket s;

#ifdef HTTP_SOCK_BUF_SIZE
	// Pointer to _web_malloc()'d memory - this is initialized by http_init() so
	// don't zero it and leak that memory!
	char __far *	sockbuf;
#endif

   /* state information */
	char state, nextstate, laststate;

   // Resource referenced (handle to server spec table - flash, RAM, or virtual)
   int spec, subspec;

   // Server context.  This is basically constant for HTTP (no need to change directory etc.)
   // Exception is the 'userid' which is set when page is authenticated.
   ServerContext context;

   // MIME type
   const HttpType *type;
   MIMETypeMap * mime;

   // Resource permissions info
   word auth_meth;	// Authentication method(s) required
   word auth_used;	// Authentication method(s) in use
   word usergroup;	// User group (as from sauth_getusermask(context.userid))
   char * realm;		// Resource realm.

   int (*handler)();	// Handler function
   int (*exec)();		// Pointer to current SSI "exec" function
   int (*cgifunc)();	// Pointer to current CGI function

   long filelength, subfilelength;
   long pos, subpos;
   long timeout, main_timeout;
   unsigned abuffer;	// Allocated size of following main buffer
   char __far * buffer;// General buffer (base address).  Initialized in
   						// http_init() via _web_malloc().
   char __far * p;		// Pointer into the above (usually, unless redirect CGI)
   /* http request and header info */
   char method;
   char version;
#if USE_HTTP_SAVED_HEADERS
   /* Pointer to saved headers buffer */
	char __far * saved_headers;
#endif

   // Ext* fields used to transmit large strings of data e.g. as produced
   // when sending RabbitWeb hierarchy as JSON string.  Note that these
   // are not automatically zerod, since otherwise there may be a memory leak.
   char __far * extbuf;		// Start of extended buffer for send data.  This
   								// is allocated using _web_malloc() and is freed
   								// after contents transmitted using _web_free().
   char __far * extp;			// Position in above of next data to send.
   unsigned	extlen;			// Remaining length of data at extp.

   int headerlen;
   char tag[HTTP_MAXNAME];    // SSI tag, or field name for form data
   char value[HTTP_MAXNAME];	// SSI value, or file name for form data
   int  aurl;					// Allocated URL space in following
   char __far * url;			// URL from HTTP request line.  After initial parsing,
   								// it contains a null char which terminates the resource name,
   								// replacing the '?', then is followed by any query parameters.
   								// This is dynamically (re-)allocated.

	/***************************************************
	   Fields above this point are not zerod at start
	   of request.
	****************************************************/

#define HTTP_FIRST_FIELD_TO_ZERO		substate
	// All following fields are set to NULL/zero when the server socket gets a new request.
   /* rx/tx state variables */
   int substate;
   int subsubstate;
   long offset;
   long length;
	// Used in sending pages to keep track of offsets.
	// Also used in reading extra header information
	// (beyond end of allocated buffer).
   int headeroff;

   /* http request and header info */
   long content_length;		// This is initially set to the content-length header field.  It is
   								// decremented by a process in order to keep count of remaining data in
                           // the socket, since most browsers don't send FIN when finished (keep-alive).
   char connection;        /* Keep-Alive ??? */
   char content_type[40];	// Content type (MIME type).  For multipart, this gets overwritten
   								// for the MIME type of each part.
#ifdef USE_HTTP_UPLOAD
	long part_content_length;	// Content length of this part
   char skipcgi;				// Skip code: 1 = this part, 2 = all parts.
	char action;				// Current action code for CGI (CGI_START etc.)
	char transfer_encoding;	// Content-Transfer-Encoding (CTE_* definitions)
   char disposition;			// Content-Disposition type (MIME_DISP_* definitions)
   char got_boundary;		// If true, just read the end of a boundary string
   word boundary_len;		// Length of boundary string (including initial \r\n--)
	char boundary[74];		// Boundary separator for multipart/form-data.  Includes
   								// initial "\r\n--".  Not null term.
#endif
   char has_form;          /* 1 == has a GET style form, after the \0 byte in url[] */
   char finish_form;			/* after _form_error_buf lock released, just finishing up
   								 * form processing */
	char abort_notify;		/* indicates if a function needs to be called on abort */
	char cancel;				/* will be 1 when formepilog function is called on cancel,
									 * 0 otherwise */
   char username[HTTP_MAXNAME];
   char password[HTTP_MAXNAME];
   char cookie[HTTP_MAXNAME]; /* store the cookie value */

   char authenticated;		// Set to user authentication state:
#define HTTP_AUTH_NO		0		// Not authenticated, or authenticated but denied resource.
#define HTTP_AUTH_OK		1		// Authenticated, and allowed to access resource
#define HTTP_AUTH_STALE	2		// Auth OK, but stale nonce (digest auth only)
#define HTTP_AUTH_ANON	3		// No credentials, assuming anonymous user.  Not yet checked resource permissions.
   /* SJH - support for conditional SSI (error feedback etc) */
   int cond[HTTP_MAX_COND];		/* Condition numbers (default 0) */

	/* Fast SSI divides buffer into two halves.  First half is used for expansion of SSI constructs
      and included files.  2nd half is used to buffer the SSI source itself, but can also be
      overwritten by (hopefully rare) expansions which exceed the first half size.  Handling the latter
      case involves maintaining a 'trashed' pointer into the buffer.  If anything from the current SSI
      source file is trashed, it is re-read.  This is a slight inefficiency, but is much better than
      the previous char-by-char file access.
   */
#define HTTP_HALFBUF	(HTTP_MAXBUFFER>>1)
	char __far * ssiStart;	// If non-NULL, is the position in buffer of the start of an SSI construct <--# etc.
   char __far * ssiEnd;		// If > ssiStart, is the closing '>' of the SSI construct.  If NULL, then the end
   						// of the construct was not read in the current buffer.  If ssiStart is NULL but
                     // this is not, then this is the first byte of the next section to examine.
   char __far * ssiEOB;		// End of data in 2nd half buffer.
   char __far * trashed;	// If > ssiEnd, then some of the SSI source has to be re-read.  This and the above
   						// 3 fields are pointers into the state->buffer.
   long	endOffs;		// Source file offset corresponding to ssiEnd.  This is for seeking the file if
   						// a re-read is required.
   word	ssiFlags;
   #define SSIF_SEND_LIT	0x0001	// Sending (or sent) literal data from 2nd half, up to ssiStart (or
   											// end of buffer if ssiStart==0).
   #define SSIF_EOF			0x0002	// End of SSI source file encountered.
   #define SSIF_SHIFT		0x0004	// On reentry to shtml_handler, need to shift the bytes at end
   											// of buffer [p..ssiEOB) to start of buffer.
#if USE_RABBITWEB
	ZHTMLParser parser;	// Keeps track of the info needed for ZHTML parsing
#endif

   /*  Optional User Data.  Cleared on every new connection. */
#ifdef HTTP_USERDATA_SIZE
	char 	userdata[ HTTP_USERDATA_SIZE];
#endif

#if USE_HTTP_SAVED_HEADERS
	/* Saved headers buffer length */
	unsigned int saved_headers_len;
#endif

} HttpState;


int _http_uid_anon;

#if USE_HTTP_DIGEST_AUTHENTICATION
typedef struct {
	char nonce[41];
	char nc[9];
	char used;
	long timestamp;
} HTTPNonce;

#ifndef HTTP_MAX_NONCES
	#define HTTP_MAX_NONCES	5
#endif

HTTPNonce _http_nonces[HTTP_MAX_NONCES];
char _http_nonce_init[12];	/* Initial seed value for nonces */
#endif

enum {
	HTTP_NO_AUTH = SERVER_AUTH_NONE,
	HTTP_BASIC_AUTH = SERVER_AUTH_BASIC,
	HTTP_DIGEST_AUTH = SERVER_AUTH_DIGEST
};
int _http_auth_type;	/* Type of authentication supported */

#ifdef FORM_ERROR_BUF
	int _feblock;
	char _form_error_buf[FORM_ERROR_BUF];
	char* _febptr;
	char* _festrstart;
	int _febsize;
	byte _feparsing;
	int _fcharsread;
	byte _form_error;
	byte _feequal;

_http_nodebug int _lock_feb(int server_num)
{
	if (_feblock == -1) {
		_feblock = server_num;
		return 1;
	} else if (_feblock == server_num) {
		return 1;
	} else {
		return 0;
	}
}

_http_nodebug int _has_lock_feb(int server_num)
{
	if (_feblock == server_num) {
		return 1;
	} else {
		return 0;
	}
}

_http_nodebug void _unlock_feb(int server_num)
{
	if (_feblock == server_num) {
		_feblock = -1;
	}
}

#endif

int _http_disabled;		// Set non-zero to shutdown HTTP servers

#if (HTTP_MAXSERVERS == 1)
	HttpState http_servers;
#else
	HttpState http_servers[HTTP_MAXSERVERS];
#endif

#ifdef __ZIMPORT_LIB
	#if INPUT_COMPRESSION_BUFFERS < HTTP_MAXSERVERS
		#error "Not enough input compression buffers for the web server!"
		#fatal "INPUT_COMPRESSION_BUFFERS is less than HTTP_MAXSERVERS"
	#endif
#endif

#if USE_HTTP_DIGEST_AUTHENTICATION
	#use "md5.lib"
#endif

// Modes for the HTTP socket wrapper function http_sock_mode
typedef enum {
	HTTP_MODE_ASCII,
   HTTP_MODE_BINARY
} http_sock_mode_t;


/*** EndHeader */


/*** BeginHeader zhtml_getpost, _http_post, _http_post_len */
int zhtml_getpost(HttpState *state);
#ifdef USE_LEGACY_RABBITWEB
extern long _http_post;
#else
extern char __far * _http_post;
#endif
extern long _http_post_len;
/*** EndHeader */

// Get the POST request for HTTP enhancements processing.  This function is
// called repeatedly until the entire POST request has been read.
//
// state  -- The current state of the HTTP server.
// Return -- 0 if the POST request has been partially read (must be called
//           again), 1 if the POST request has been completely read, and -1
//           on error.
// This points to the POST buffer

#ifdef USE_LEGACY_RABBITWEB

long _http_post = 0;
long _http_post_len;


_http_nodebug
int zhtml_getpost(HttpState *state)
{
	// Get the full POST before proceeding
	auto int len;
	auto long bytes;

   if (state->content_length > RWEB_POST_MAXBUFFER) {
   	// POST is too long
   	return -1;
   }
   bytes = state->content_length - state->pos;
	len = (bytes > INT_MAX) ? INT_MAX : (int) bytes;
   len = http_sock_xfastread(state, _http_post + state->pos, len);

#ifdef RABBITWEB_VERBOSE
	printf("RWEB: Content-length: %ld, len: %d\n", state->content_length, len);
#endif
   if (len < 0) {
   	// Error
      return -1;
   }
	state->pos += len;
	// Check if we have the full POST
   if (state->pos == state->content_length) {
   	// We do have the full POST--indicate this by returning 1
   	_http_post_len = state->content_length;
      return 1;
   }

   return 0;
}

#else

char __far * _http_post = NULL;
long _http_post_len;


_http_nodebug
int zhtml_getpost(HttpState *state)
{
	// Get the full POST before proceeding
	auto int len;
	auto long bytes;

   bytes = state->content_length - state->pos;
	len = (bytes > INT_MAX) ? INT_MAX : (int) bytes;
   len = http_sock_xfastread(state, (long)_http_post + state->pos, len);

#ifdef RABBITWEB_VERBOSE
	printf("RWEB: Content-length: %ld, len: %d\n", state->content_length, len);
#endif
   if (len < 0) {
   	// Error
      return -1;
   }
	state->pos += len;
	// Check if we have the full POST
   if (state->pos == state->content_length) {
   	// We do have the full POST--indicate this by returning 1
   	_http_post_len = state->content_length;
      return 1;
   }

   return 0;
}
#endif	// legacy

/*** BeginHeader http_is_secure */
int http_is_secure(HttpState* state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_is_secure                  			<HTTP.LIB>

SYNTAX:	int http_is_secure(HttpState* state);

DESCRIPTION: Test if this HTTP server state represents a secure (SSL/TLS)
             server.

PARAMETER 1: HTTP state structure

RETURN VALUE: None

END DESCRIPTION **********************************************************/

_http_nodebug
int http_is_secure(HttpState* state) {
	return _IS_HTTPS(state);
}


// HTTP socket wrapper functions

/*** BeginHeader http_sock_mode */
void http_sock_mode(HttpState* state, http_sock_mode_t mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_mode                  			<HTTP.LIB>

SYNTAX: void http_sock_mode(HttpState* state, http_sock_mode_t mode);

DESCRIPTION: HTTP socket wrapper function for socket mode. This function
             can be used by CGI applications to set the mode of a socket
             associated with a particular HTTP server.

             Valid values for mode are as follows:
             HTTP_MODE_ASCII - Sets the associated socket to ASCII mode.
             HTTP_MODE_BINARY - Sets the associated socket to BINARY.

PARAMETER 1: HTTP state structure
PARAMETER 2: HTTP mode to use for the socket

RETURN VALUE: None

END DESCRIPTION **********************************************************/

_http_nodebug
void http_sock_mode(HttpState* state, http_sock_mode_t mode) {
	sock_mode(_SOCK_OF_HTTP(state), HTTP_MODE_BINARY == mode ? TCP_MODE_BINARY : TCP_MODE_ASCII);
}


/*** BeginHeader http_sock_extlisten */
int http_sock_extlisten(HttpState *state, int iface, word lport, longword ina,
                        word port, dataHandler_t datahandler, word reserved,
                        long buffer, int buflen );
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
http_sock_extlisten         				<HTTP.LIB>

SYNTAX: int http_sock_extlisten(HttpState *state, int iface, word lport,
						longword ina, word port, dataHandler_t datahandler,
                  word reserved, long buffer, int buflen );

DESCRIPTION: HTTP wrapper function for extended socket listen. This is a
             private function that should only be used within the HTTP
             library.

PARAMETER 1: HTTP state structure
PARAMETER 2: interface for the socket to use
PARAMETER 3: the port to listen on
PARAMETER 4: the local address
PARAMETER 5: the local port
PARAMETER 6: data handler function
PARAMETER 7: reserved parameter for future use
PARAMETER 8: socket buffer (if external buffer is desired)
PARAMETER 9: length of the external socket buffer

RETURN VALUE: Returns the value returned by the socket listen call.

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_extlisten(HttpState *state, int iface, word lport, longword ina,
                        word port, dataHandler_t datahandler, word reserved,
                        long buffer, int buflen )
{
	auto int rc;
	tcp_Socket * sock;

	sock = _TCP_SOCK_OF_HTTP(state);
   rc = tcp_extlisten(sock, iface, lport, ina, port,
                        datahandler, reserved, buffer, buflen);
   state->sock = sock;

#if __HTTP_USE_SSL__
	if (_IS_HTTPS(state))
	{
		if (state->_n_ssl)
			// clean up and de-allocate previous instance
   		sock_unsecure(state->_n_ssl);

		// OK, secure this socket and re-jig pointers so that HTTP server
		// points to secure socket rather than direct transport.
		// App data buffers are sized to be the same as the transport (TCP socket)
		// buffer sizes, and dynamically allocated.
	   rc = sock_secure(_TCP_SOCK_OF_HTTP(state), &state->_n_ssl,
	#ifdef TLS_OLDBUF
	                state->s.rd.maxlen, NULL,	// Read buffer
	                state->s.wr.maxlen, NULL,	// Write buffer
	#else
						// Using new style buffering, don't need same size buffer
						// on plaintext side.  Can use "normal" size.
						 TCP_BUF_SIZE>>2, NULL, // Read buffer (1/4)
	                TCP_BUF_SIZE*3>>2, NULL, // Write buffer (3/4)
#endif
	                0,	// Not a client
	                0,	// No special flags
	                0, 0, 0, 0,	//
						 state->cert,	// Use provided binary certificate
	                NULL,			// No CA required
	                NULL				// No session to resume
	                );
		if (!rc)
		{
	   	//state->_n_ssl = _ssl_downcast(state->_f_ssl);
	   	state->sock = state->_n_ssl;
	   }
	   else
	   	// Error securing socket, most likely because of malloc or other
	   	// resource failure.  Application is unlikely to expect, let alone
	   	// handle, this failure, so take safe path and exit.
	   	exit(rc);
		rc = 1;
	}
#endif
	return rc;
}


/*** BeginHeader http_sock_bytesready */
int http_sock_bytesready(HttpState *state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_bytesready							<HTTP.LIB>

SYNTAX: int http_sock_bytesready(HttpState *state);

DESCRIPTION: HTTP wrapper function for socket bytesready function. This
             function may be used by CGI applications to determine if there
             is data waiting on the socket associated with a particular
             HTTP server.

PARAMETER 1: HTTP state structure

RETURN VALUE: -1		no bytes waiting to be read
					0		in ASCII mode, a blank line is waiting to be read,
					      or, for UDP, an empty datagram is waiting to be read
					> 0	number of bytes waiting to be read

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_bytesready(HttpState *state) {
  	return sock_bytesready(_SOCK_OF_HTTP(state));
}

/*** BeginHeader http_sock_readable */
int http_sock_readable(HttpState *state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_readable							<HTTP.LIB>

SYNTAX: int http_sock_readable(HttpState *state);

DESCRIPTION: HTTP wrapper function for socket readable function. This
             function may be used by CGI applications to determine if a
             socket is readable or not. See sock_readable for more
             information.

PARAMETER 1: HTTP state structure

RETURN VALUE: If parameter is a TCP or SSL server:
					  0: socket is not readable.  It was aborted by the
                    application or the peer has closed the socket and all
                    pending data has been read by the application.  This
                    can be used as a definitive "EOF" indication for a
                    receive stream.
                 non-zero: the socket is readable.  The amount of data that
                    the socket would deliver is this value minus 1; which
                    may turn out to be zero if the socket's buffer is
                    temporarily empty, or the socket is not yet connected
                    to a peer.
               If parameter is a UDP server:
                 0: socket is not open.
                 non-zero: socket is open.  This value minus 1 equals the
                 size of the next datagram in the receive buffer, that
                 would be returned by udp_recvfrom() etc.  Note that
                 ICMP error messages are also considered if the socket
                 is set up to receive ICMP messages.

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_readable(HttpState *state) {
  	return sock_readable(_SOCK_OF_HTTP(state));
}

/*** BeginHeader http_sock_writable */
int http_sock_writable(HttpState *state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_writable							<HTTP.LIB>

SYNTAX: int http_sock_writable(HttpState *state);

DESCRIPTION: HTTP wrapper function for socket writable function. This
             function may be used by CGI applications to determine if a
             socket is writeable or not. See sock_writable for more
             information.

PARAMETER 1: HTTP state structure

RETURN VALUE: If parameter is a TCP or SSL server:
					  0: socket is not writable.  It was closed by the
                    application or it may have been aborted by the peer.
                 non-zero: the socket is writable.  The amount of data
                    that the socket would accept is this value minus 1;
                    which may turn out to be zero if the socket's buffer
                    is temporarily full.  On a freshly-established socket,
                    and at any other time when all data has been
                    acknowledged by the peer, the return value (minus one)
                    indicates the maximum socket transmit buffer size.
               If parameter is a UDP server:
                 0: socket is not open.
                 non-zero: socket is open.  This value minus 1 equals the
                 maximum size datagram payload that would be sent without
                 fragmentation at the IP level.
                 Note: the maximum payload depends on the interface which
                 is selected.  Since this is not known a-priori, the
                 interface with the largest MTU is arbitrarily selected.

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_writable(HttpState *state) {
  	return sock_writable(_SOCK_OF_HTTP(state));
}

/*** BeginHeader http_sock_cmp */
int http_sock_cmp(HttpState* state, word pos, int range, void* mem, int* len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_cmp							<HTTP.LIB>

SYNTAX: int http_sock_cmp(HttpState* state, word pos, int range,
                          void* mem, int* len)

DESCRIPTION: HTTP wrapper function for socket compare function. This
             function may be used by CGI applications to search the
             socket buffer for a particular string See sock_cmp for more
             information.

PARAMETER 1: HTTP state structure
PARAMETER 2: Initial position to start searching from.  0 means the first
             unread character in the socket buffer.
PARAMETER 3: Range of positions to search:
                 -1: search all available data, and set the return code
                     specially (see below).
                 0:  search all available data, but do not perform the
                     data availability test.
                 positive: search from 'pos' up to but not including
                     'pos'+'range'.  This refers to the first char of the
                     search string.
PARAMETER 4: Pointer to first character of string to search for.
PARAMETER 5: On entry to function: *len = length of string to search for.
             On return from function: *len will be set to the length
             	of the search string which was matched.  This may be less
               than the entry value only if a partial match of the string
               was found at the end of the available socket data, and
               the socket is still able to receive more data.

RETURN VALUE: 0: string not found in specified range.
              positive: number of characters to read (using e.g.
                  sock_fastread) so that the FIRST character of the search
                  string which matched would be the last character read.
              -1: this is only set if 'range' parameter is -1.  It means
                  that the string was not found, and the string could
                  never be found because the peer has closed the socket
                  and no more data will be forthcoming.

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_cmp(HttpState* state, word pos, int range, void* mem, int* len) {
	return sock_cmp(_SOCK_OF_HTTP(state), pos, range, mem, len);
}

/*** BeginHeader http_sock_tbleft */
long http_sock_tbleft(HttpState *state);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_tbleft							   <HTTP.LIB>

SYNTAX: long http_sock_tbleft(HttpState *state);

DESCRIPTION: HTTP wrapper function for socket tbleft function. This
             function may be used by CGI applications to determine how
             much space is left in the HTTP socket's transmit buffer.

PARAMETER 1: HTTP state structure

RETURN VALUE: Number of bytes remaining free space in transmit buffer

END DESCRIPTION **********************************************************/

_http_nodebug
long http_sock_tbleft(HttpState *state) {
 	return sock_tbleft(_SOCK_OF_HTTP(state));
}

/*** BeginHeader http_sock_gets */
int http_sock_gets(HttpState *state, byte __far * dp, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_gets									<HTTP.LIB>

SYNTAX: int http_sock_gets(HttpState *state, byte far * dp, int len);

DESCRIPTION: HTTP wrapper function for socket get string. This function
             can be used by CGI applications to retrieve a string waiting
             on an ASCII-mode socket associated with a particular HTTP
             server.

             See also http_sock_mode and sock_gets.

PARAMETER 1: HTTP server state
PARAMETER 2: Pointer to return buffer
PARAMETER 3: Maximum size of return buffer

RETURN VALUE:  0   if buffer is empty, or
					    if no '\r' or '\n' is read, but buffer had room *and*
					    the connection can get more data!
					> 0 is the length of the string
					-1  error

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_gets(HttpState *state, byte __far * dp, int len) {
  	return sock_gets(_SOCK_OF_HTTP(state), dp, len);
}

/*** BeginHeader http_sock_fastread */
int http_sock_fastread(HttpState *state, byte __far *dp, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_fastread 							<HTTP.LIB>

SYNTAX: int http_sock_fastread(HttpState *state, byte far *dp, int len);

DESCRIPTION: HTTP wrapper function for non-blocking reads (root). This
             function can be used to read data from a socket associated
             with a particular HTTP server. This function is intended for
             use in CGI applications.

PARAMETER 1: HTTP server state
PARAMETER 2: pointer to return buffer
PARAMETER 3: maximum length of return buffer

RETURN VALUE: number of bytes read or -1 if there was an error

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_fastread(HttpState *state, byte __far *dp, int len) {
	return sock_fastread(_SOCK_OF_HTTP(state), dp, len);
}

/*** BeginHeader http_sock_xfastread */
int http_sock_xfastread(HttpState *state, long dp, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_xfastread 							<HTTP.LIB>

SYNTAX: int http_sock_xfastread(HttpState *state, long dp, int len);

DESCRIPTION: HTTP wrapper function for non-blocking reads (xmem). This
             function can be used to read data from a socket associated
             with a particular HTTP server. This function is intended for
             use in CGI applications.

PARAMETER 1: HTTP server state
PARAMETER 2: pointer to return xmem buffer
PARAMETER 3: maximum length of return xmem buffer

RETURN VALUE: number of bytes read or -1 if there was an error

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_xfastread(HttpState *state, long dp, int len) {
	return sock_fastread(_SOCK_OF_HTTP(state), (void __far *)dp, len);
}

/*** BeginHeader http_sock_write */
int http_sock_write(HttpState *state, byte __far *dp, int len );
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_write							   <HTTP.LIB>

SYNTAX: int http_sock_write(HttpState *state, byte far *dp, int len );

DESCRIPTION: HTTP wrapper function for blocking writes. This function
             can be used to write data from a root buffer to a socket
             associated with a particular HTTP server. This function is
             intended for use in CGI applications.

PARAMETER 1: HTTP server state
PARAMETER 2: buffer containing data to be written
PARAMETER 3: maximum number of bytes to write to the socket

RETURN VALUE:  number of bytes written or -1 if there was an error

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_write(HttpState *state, byte __far *dp, int len ) {
	return sock_write(_SOCK_OF_HTTP(state), dp, len);
}

/*** BeginHeader http_sock_fastwrite */
int http_sock_fastwrite(HttpState *state, byte __far *dp, int len );
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_fastwrite							<HTTP.LIB>

SYNTAX: int http_sock_fastwrite(HttpState *state, byte far *dp, int len );

DESCRIPTION: HTTP wrapper function for non-blocking writes. This function
             can be used to write data from a root buffer to a socket
             associated with a particular HTTP server. This function is
             intended for use in CGI applications.

PARAMETER 1: HTTP server state
PARAMETER 2: buffer containing data to be written
PARAMETER 3: maximum number of bytes to write to the socket

RETURN VALUE:  number of bytes written or -1 if there was an error

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_fastwrite(HttpState *state, byte __far *dp, int len ) {
	return sock_fastwrite(_SOCK_OF_HTTP(state), dp, len);
}

/*** BeginHeader http_sock_xfastwrite */
int http_sock_xfastwrite(HttpState *state, long dp, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_sock_xfastwrite							<HTTP.LIB>

SYNTAX: int http_sock_xfastwrite(HttpState *state, long dp, int len);

DESCRIPTION: HTTP wtapper function for non-blocking writes. This function
             can be used to write the contents of an xmem buffer to a
             socket associated with a particular HTTP server.

PARAMETER 1: HTTP server state
PARAMETER 2: buffer containing data to be written, as an xmem address
				 obtained from, for example, xalloc().
PARAMETER 3: maximum number of bytes to write to the socket

RETURN VALUE:  number of bytes written or -1 if there was an error

END DESCRIPTION **********************************************************/

_http_nodebug
int http_sock_xfastwrite(HttpState *state, long dp, int len) {
	return sock_fastwrite(_SOCK_OF_HTTP(state), (char __far *)dp, len);
}


/*** BeginHeader http_get_sock */
tcp_Socket* http_get_sock(HttpState*);
/*** EndHeader */


/* START _FUNCTION DESCRIPTION ********************************************
http_get_sock								   <HTTP.LIB>

SYNTAX: tcp_Socket* http_get_sock(HttpState *state);

DESCRIPTION: This function allows direct access to an HTTP or HTTPS
             server's TCP socket. This will ALWAYS return the TCP socket
             associated with the server, even if that server is HTTPS.
             This is intended for READ-ONLY operations. Since this function
             returns a pointer to the actual socket, changing fields will
             directly affect the connection, and could lead to problems,
             especially with HTTPS servers.

PARAMETER 1: HTTP server state

RETURN VALUE: None

END DESCRIPTION **********************************************************/

// Return the socket regardless of state
_http_nodebug
tcp_Socket* http_get_sock(HttpState *state) {
  	// Just return the address of the TCP socket
  	return _TCP_SOCK_OF_HTTP(state);
}

/*
 *    internal utility functions
 */

/*** BeginHeader http_date_str */
char __far *http_date_str(char __far *buf);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_date_str                   		<HTTP.LIB>

SYNTAX: char far *http_date_str(char far *buf);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Print the date (timezone adjusted) into the given buffer using
		RFC 1123 format.  This assumes there is room!

PARAMETER1:	The buffer to write the date into. This requires at
		least 30 bytes in the destination buffer.

RETURN VALUE: 	A pointer to the string.

SEE ALSO: 	http_handler

END DESCRIPTION **********************************************************/
#include <lc_time.h>			// for _strftime()
_http_nodebug char __far *http_date_str(char __far *buf)
{
   auto long time;
   auto struct tm t;

   tm_rd(&t);
#ifndef RTC_IS_UTC
   rtc_timezone(&time, NULL);
   time = mktime(&t) - time;
#else
   time = mktime(&t);
#endif
   mktm(&t, time);

	// RFC 1123 format: "Sun, 06 Nov 1994 08:49:37 GMT"
	_strftime( buf, 30, "%a, %d %b %Y %H:%M:%S GMT", &t, &_lc_time_C);
   return buf;
}

/*** BeginHeader unbase64 */
void unbase64(char __far *dest, char __far *src);
/*** EndHeader */

/* takes a four-byte string in 'src', decodes it, and stores the ascii in 'dest' */
_http_nodebug void unbase64(char __far *dest, char __far *src)
{
   dest[0] = (base64_char(src[0]) << 2) + (base64_char(src[1]) >> 4);
   dest[1] = ((base64_char(src[1]) & 0xf) << 4) + (base64_char(src[2]) >> 2);
   dest[2] = ((base64_char(src[2]) & 0x3) << 6) + (base64_char(src[3]));
}

/*** BeginHeader http_getline */
int http_getline(HttpState* state);
/*** EndHeader */

_http_nodebug int http_getline(HttpState* state)
{
	auto int len, slen;
	auto word delim = DELIM_CRLF;

	len = sock_stringready(_SOCK_OF_HTTP(state), &delim, 0);
	// Check if we have leftover data from a previous line or header that was
	// too large to fit in the buffer.  If so, then we should dump it.
	if (state->headeroff) {
		if (len > 0)
			sock_fastread(_SOCK_OF_HTTP(state), NULL, len);
		if (delim)
			// This happens when we have completely read the remainder of the
			// overly-long header.
			state->headeroff = 0;
		return 0;
	}

	// Available string length (not counting delimiter if available)
	slen = len + (delim ? -2 : 0);

	if (len < 0 || !delim && slen+1 < state->abuffer)
		// Either error or we can accept a longer string.
		return 0;

	// We have a delimiter, or don't but have to read the maximum possible
	// length.
   if (!delim) {
#ifdef HTTP_VERBOSE
      printf("HTTP: line too long (%d/%d)\n", slen, state->abuffer-1);
#endif
   	slen = state->abuffer - 1;	// Max length we can read
      // Indicate that we need to dump the rest of the line on subsequent
      // calls to this function
      state->headeroff = 1;
   }

	// Read what we can into buffer
	sock_fastread(_SOCK_OF_HTTP(state), state->buffer, slen);
	state->buffer[slen] = 0;
	if (delim)
		// Read and discard the delimiter
		sock_fastread(_SOCK_OF_HTTP(state), NULL, 2);

#ifdef HTTP_VERBOSE
   printf("----HTTP: getline: '%ls'\n", state->buffer);
#endif
	return 1;
}

/*** BeginHeader http_getcontent */
int http_getcontent(HttpState* state);
/*** EndHeader */

/*
	This is only invoked if USE_HTTP_UPLOAD.  It gets the next chunk of data, looking for
	a boundary string to delimit parts of a multipart POST request.

   It returns:
    A +ve value (length of data in state->buffer) if the delimiter was not
    found, but there is more data.

    0 if there is no new data available

    -1 if a boundary (other than the last) is encountered.  Next call will return data
    following the boundary (i.e. part headers).  Note that the boundary has been
    consumed by the time this return code (and the next) is passed.  The caller can
    change the socket to ascii mode and use http_getline() until the end of header
    data, if required.  This function works the same whether the socket is in ascii
    mode or not.

    -2 if last boundary or EOF encountered, or socket not readable.

   A boundary starts with "\r\n--" and has a total length of state->boundary_len bytes.
   The socket need not be in ASCII mode.  The caller should not expect to get whole lines,
   since data is extracted without regard for CRLF delimiters.

   If there is no boundary string defined, this function just gets the next available data.

   This function decrements state->content_length by the number of bytes read (including boundaries).
 */
_http_nodebug int http_getcontent(HttpState* state)
{
	auto int len, blen, clen;

   if (state->got_boundary) {
   	// We just consumed boundary from the input stream.  Now looking for \r\n or
      // --\r\n.  If neither of these follow the boundary string, it is a sender error,
      // however we treat this as if it was provided (discarding the 2 chars in error).
      // Note: we wait for at least 4 more chars so that we don't need extra state variables.
      len = sock_readable(_SOCK_OF_HTTP(state));
      if (!len)
      	return -2;
      if (len < 5)
      	return 0;
     	state->got_boundary = 0;
      sock_fastread(_SOCK_OF_HTTP(state), state->buffer, 2);
      state->content_length -= 2;
      if (!memcmp(state->buffer, "--", 2)) {
         sock_fastread(_SOCK_OF_HTTP(state), NULL, 2);	// Discard the \r\n.
			state->content_length -= 2;
         return -2;	// End of all parts
      }
		return -1;		// End of part (not the last)
   }

	if (blen = state->boundary_len) {
   	if (state->state == HTTP_CGI_PROLOG) {
      	// Looking for first boundary: don't count initial CRLF.
         clen = 2;
         blen -= 2;
      }
      else
      	clen = 0;
		len = sock_cmp(_SOCK_OF_HTTP(state), 0, -1, state->boundary+clen, &blen);
      if (len > 0) {
      	// Found boundary (or start of what looks like one).  Len is
         // one more than number of chars before the start of the boundary.
#ifdef HTTP_VERBOSE
			printf("HTTP: found boundary at offs=%d, len=%d out of %d\n", len-1, blen+clen, state->boundary_len);
#endif
         if (--len > state->abuffer) {
         	// Boundary in socket, but cannot yet read up to start of boundary.
            sock_fastread(_SOCK_OF_HTTP(state), state->buffer, state->abuffer);
      		state->content_length -= state->abuffer;
            return state->abuffer;
         }
			sock_fastread(_SOCK_OF_HTTP(state), state->buffer, len);
     		state->content_length -= len;
         if (blen+clen == state->boundary_len) {
         	// Found complete boundary; consume it and set state
            state->got_boundary = 1;
            sock_fastread(_SOCK_OF_HTTP(state), NULL, blen);
     			state->content_length -= blen;
         }
         return len;
      }
		// Otherwise, len==-1 which means peer closed socket (the remaining data
      // cannot be interpreted as a boundary) or len==0 which means no boundary
      // in data, or len < -1 which is a maximum amount of data to read.
      if (len < -1) {
      	len = -len;
      	if (len > state->abuffer)
      		len = state->abuffer;
      }
      else
      	len = state->abuffer;
   }
   else
   	len = state->abuffer;
   // (Else) no boundary defined, just return everything available.
  	len = sock_fastread(_SOCK_OF_HTTP(state), state->buffer, len);
   if (len < 0)
    	return -2;
   else if (len) {
		state->content_length -= len;
		state->main_timeout = set_timeout(HTTP_TIMEOUT);
	}

   return len;
}

/*** BeginHeader http_parseget */
int http_parseget(HttpState* state);
/*** EndHeader */

_http_nodebug int http_parseget(HttpState* state)
{
	// NB: If this returns '1', then server must close the state->spec resource if it
   // is >= 0.  This is because this function now opens the resource.
   auto char __far *p;
   auto char __far *dest;
   auto char __far *getdata;
   auto unsigned val, len;

#ifdef HTTP_VERBOSE
	printf("HTTP: got \"%ls\"\n", state->buffer);
#endif

   if (!strncmp("GET ", state->buffer, 4) ) {
      state->method = HTTP_METHOD_GET;
      p = state->buffer + 4;
   } else if (!strncmp("POST ", state->buffer, 5) ) {
      state->method = HTTP_METHOD_POST;
      p = state->buffer + 5;
   } else if (!strncmp("HEAD ", state->buffer, 5) ) {
      state->method = HTTP_METHOD_HEAD;
      p = state->buffer + 5;
   } else {
      /* unknown command */
      state->state = HTTP_DIE;
      return 0;
   }

   /* store the url, and check if there is a URL-encoded form result in it. */
   dest = state->url;
   getdata = _f_strchr(p, ' ');
   if (getdata)
   	len = (int)(getdata - p);
   else
		len = strlen(p);
	if (len >= state->aurl) {
		// Make the URL buffer bigger if necessary.  Overall limit is the
		// size of the web buffer (line), so cannot allocate excessively.
		dest = _web_realloc(dest, len+1);
		if (dest) {
			state->url = dest;
			state->aurl = len+1;
		}
		else
			// failed to reallocate, just truncate current request (since it's
			// probably bogus anyway).
			len = state->aurl-1;
	}
	_f_strncpy(dest, p, len);
	p += len;
	dest[len] = 0;
	getdata = _f_strchr(dest, '?');
	if (getdata) {
		state->has_form = 1;
		*getdata++ = 0;     /* null-separate the URL and the form result */
	}
	// getdata used below


	// Default context...
   state->context.userid = -1;	// Set no user, open this just for the server.
   state->realm = NULL;
   state->mime = NULL;
   state->auth_meth = SERVER_AUTH_NONE;

   // Find the corresponding spec structure for the URL (or typically -ENOENT if error)
   state->spec = sspec_open(state->url, &state->context, O_READ, 0);

  	state->context.userid = _http_uid_anon;	// Don't yet know user ID, assume anonymous
   														// (which may be -1 unless overridden).
	if (state->spec >= 0) {
	   if (_http_uid_anon >= 0)
	      state->authenticated = HTTP_AUTH_ANON; // If there is an anon user, then it is authenticated.

	   // Get the permissions data we need now (before userid is determined)
	   sspec_getpermissions(state->spec, &state->realm, NULL, NULL, NULL, &state->auth_meth, &state->mime);
	   if (state->realm) {
#ifdef HTTP_VERBOSE
	      printf("HTTP: realm = %s\n", state->realm ? state->realm : "<null>");
#endif
	      if (state->auth_meth == SERVER_AUTH_DEFAULT)
	         state->auth_meth = _http_auth_type; // Old style behavior
	   }
	   else
	      state->auth_meth = SERVER_AUTH_NONE;   // For HTTP, force no auth if no realm string.
#if USE_HTTP_DIGEST_AUTHENTICATION
	   if (state->auth_meth & SERVER_AUTH_DIGEST)
	      state->auth_meth = SERVER_AUTH_DIGEST;
	   else
#endif
#if USE_HTTP_BASIC_AUTHENTICATION
	   if (state->auth_meth & SERVER_AUTH_BASIC)
	      state->auth_meth = SERVER_AUTH_BASIC;
	   else
#endif
	      state->auth_meth = SERVER_AUTH_NONE;
	}

   if (state->auth_meth == SERVER_AUTH_NONE)
   	state->authenticated = HTTP_AUTH_OK;

#ifdef HTTP_VERBOSE
	printf("HTTP: auth method = 0x%04X\n", state->auth_meth);
#endif

	// Parse the get data (if any).  Automatically set the cond[] variables according to
   // ...url...?A=1,B=5
   // where the 'A' is the value of cond[0], 'B' is cond[1] etc.  The CGI should reset any
   // cond[] variables to zero which it does not expect to be set by a GET request.
   // The allowable values for each variable are -32768..32767 (larger values are truncated
   // to low 16 bits).
   if (state->has_form) while (*getdata) {
		if (isalpha(*getdata) && getdata[1] == '=' && isdigit(getdata[2])) {
      	// Looks like a valid setting
			val = toupper(*getdata) - 'A';
         if (val < HTTP_MAX_COND)
         	state->cond[val] = (int)_f_strtol(getdata+2, &getdata, 10);
      }
      while (*getdata && *getdata != '&') getdata++;
      if (*getdata) getdata++;
   }

   state->version = HTTP_VER_09;
   if (*p != '\0') {
	   ++p;
	   if (!strncmp(p, "HTTP/1.0", 8))
	      state->version = HTTP_VER_10;
	   else if (!strncmp(p, "HTTP/1.1", 8))
	      state->version = HTTP_VER_11;
	}
   return 1;
}

/*** BeginHeader http_init_parthead */
void http_init_parthead(HttpState * h);
/*** EndHeader */
_http_nodebug void http_init_parthead(HttpState * h)
{
   h->state = HTTP_CGI_PARTHEAD;				// Next state: read part headers
   h->part_content_length = -1;				// Unknown part content length
   strcpy(h->content_type, "text/plain");	// Default content type
   h->tag[0] = 0;									// No "name=" (field name)
   h->transfer_encoding = CTE_BINARY;		// Default transfer encoding (null)
   h->disposition = MIME_DISP_NONE;			// No recognized Content-Disposition.
}

/*** BeginHeader http_is_saved_header */
int http_is_saved_header(char __far *header);
/*** EndHeader */

// Checks if a given header line is one that the user has configured to be
// saved.
//
// header -- The header line to check
// Return -- 1 if the header should be saved, 0 if it shouldn't

_http_nodebug
int http_is_saved_header(char __far *header)
{
	auto int i;
	auto namelen;

	// Loop through the list of headers to save
	i = 0;
	while (http_headers[i] != NULL) {
		namelen = strlen(http_headers[i]);
		if (!strncmpi(header, http_headers[i], namelen) &&
		    header[namelen] == ':') {
			// We have a match--this header should be saved
			return 1;
		}
		i++;
	}
	// Not saved
	return 0;
}

/*** BeginHeader http_save_header */
void http_save_header(HttpState* state);
/*** EndHeader */

// Saves a header to the header buffer.  If there is not enough space for the
// whole header, then it will write out part of it.  If the header buffer is
// full, then it will not write anything.
//
// state -- The current state of the HTTP server

_http_nodebug
void http_save_header(HttpState* state)
{
	auto int len;
	auto int bufremaining;

	// Get the length of the header
	len = strlen(state->buffer);
	// If the header is larger than the allowed size, then shorten it
	if (len >= HTTP_SAVED_HEADER_MAX_SIZE) {
		len = HTTP_SAVED_HEADER_MAX_SIZE - 1;
	}
	// If the header would overflow the buffer, then shorten it
	bufremaining = HTTP_SAVED_HEADERS_SIZE - state->saved_headers_len;
	if (len >= bufremaining) {
		len = bufremaining - 1;
	}
	if (len <= 0) {
		// No space for another header
		return;
	}
	// Copy out the buffer
	_f_memcpy(state->saved_headers + state->saved_headers_len,
	          state->buffer, len);
	// Copy out a NULL terminator
	state->saved_headers[state->saved_headers_len + len] = 0;
	// Increase the number of bytes used in the buffer
	state->saved_headers_len += len + 1;
}

/*** BeginHeader http_headernamecmp */
int http_headernamecmp(char __far * xheader, char __far *lheader);
/*** EndHeader */

// Compares a header name (lheader, null terminated) against a full
// header saved in an xmem buffer (xheader, colon terminated).
// This basically implements the compare function for the user lookup.
//
// xheader -- full header line
// lheader -- header name to match
// Return  -- 0 for success and !0 if no match

_http_nodebug
int http_headernamecmp(char __far * xheader, char __far *lheader)
{
	auto len = strlen(lheader);
	if (memcmp(xheader, lheader, len))
		return -1;
	return xheader[len] != ':';
}

/*** BeginHeader http_headervalue */
char __far * http_headervalue(char __far * ptr);
/*** EndHeader */

// Given a pointer to a header line stored in xmem, skip ahead over the header
// name to the header value.
//
// ptr    -- xmem pointer to the header line
// Return -- xmem pointer to the header value on success, NULL on error

_http_nodebug
char __far * http_headervalue(char __far * ptr)
{
	// This is only called when it is known that a colon follows the header name
	ptr = _f_strchr(ptr, ':') + 1;	// point past that colon
	while (isspace(*ptr)) ++ptr;		// skip any whitespace
	return ptr;
}



/*** BeginHeader http_getheader */
int http_getheader(HttpState *state, char __far *header, char __far *dest, int destlen);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_getheader                  		<HTTP.LIB>

SYNTAX: int http_getheader(HttpState *state, char far *header,
									char far *dest, int destlen);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Copy the named saved header into a destination buffer
		with a given length.  If the header is larger than the destination
		buffer, then it will truncate the buffer.

PARAMETER1:		The current HTTP state
PARAMETER2:		Named header to find and copy
PARAMETER3:		Destination buffer for the header (will always be null term)
PARAMETER4:		Maximum length of the destination buffer incl. the null term.

RETURN VALUE: 	Number of bytes in the header, or -1 on error (header not
					found).  Returned length does not include null terminator.

SEE ALSO: 	http_xgetheader

END DESCRIPTION **********************************************************/

_http_nodebug
int http_getheader(HttpState *state, char __far *header, char __far *dest, int destlen)
{
	auto char __far * ptr;
	auto int headerlen;

	ptr = http_ref_header(state, header);
	if (ptr && destlen > 0) {
		// Find the end of the header (known to be null terminated)
		headerlen = strlen(ptr);
		// If headerlen is larger than destlen, then shorten it
		if (headerlen >= destlen) {
			headerlen = destlen-1;
		}
		// Copy the header to the destination
		_f_memcpy(dest, ptr, headerlen);
		// NULL terminate it in case it isn't already
		dest[headerlen] = '\0';
		return headerlen - 1;	// Like strlen, don't include the NULL terminator
	}
	return -1;
}

/*** BeginHeader http_ref_header */
char __far * http_ref_header(HttpState *state, char __far *header);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_xgetheader                 		<HTTP.LIB>

SYNTAX: char far * http_ref_header(HttpState *state, char far *header);

DESCRIPTION: 	Return pointer to a named saved header.

					This is always null terminated, so you can compute the
					header length using strlen().

PARAMETER1:		The current HTTP state
PARAMETER2:		Named header to find

RETURN VALUE: 	Pointer to saved header.  This buffer is owned by the
					HTTP server, however it is safe to modify since the server
					does not make use of these headers.
					Returns NULL if not found.

SEE ALSO: 	http_getheader

END DESCRIPTION **********************************************************/

_http_nodebug
char __far * http_ref_header(HttpState *state, char __far *header)
{
	auto char __far * headerptr;

	headerptr = state->saved_headers;
	while (headerptr < state->saved_headers + state->saved_headers_len) {
		// Match the header name
		if (!http_headernamecmp(headerptr, header)) {
			// Found a match--advance to value
			return http_headervalue(headerptr);
		}
		// No match, so advance to next header
		headerptr += strlen(headerptr) + 1;
	}
	return NULL;
}


/*** BeginHeader http_xgetheader */
int http_xgetheader(HttpState *state, char __far *header, long *destptr);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_xgetheader                 		<HTTP.LIB>

SYNTAX: int http_xgetheader(HttpState *state,
								char far *header, long *destptr);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Get a long pointer to the named saved header, which has
		been stored in xmem.  This function returns the size of the header.

		This function deprecated.  Use http_ref_header().

PARAMETER1:		The current HTTP state
PARAMETER2:		Named header to find and copy
PARAMETER3:		The long pointer to the header will be placed here

RETURN VALUE: 	Number of bytes in the header, or -1 on error (header not
					found).

SEE ALSO: 	http_getheader, http_ref_header

END DESCRIPTION **********************************************************/

_http_nodebug
int http_xgetheader(HttpState *state, char __far *header, long *destptr)
{
	auto char __far * ptr;
   auto long addr;
	auto int headerlen;

	ptr = http_ref_header(state, header);
	if (ptr) {
		headerlen = strlen(ptr);
		*destptr = (long)ptr;
		return headerlen;
	}
	return -1;
}

/*** BeginHeader http_parsehead */
int http_parsehead(HttpState* state, int part);
/*** EndHeader */

_http_nodebug int http_parsehead(HttpState* state, int part)
{
   auto int temp, count;
   auto char __far *p;
   auto char __far *q;
   auto char __far *r;
   auto word req_auth;	// Acceptable authentication method(s)
#if USE_HTTP_DIGEST_AUTHENTICATION
	auto char __far * nonce;
	auto char __far * nc;
	auto char __far * cnonce;
	auto char __far * response;
#endif

#if USE_HTTP_SAVED_HEADERS
	if (http_is_saved_header(state->buffer)) {
		http_save_header(state);
#ifdef HTTP_VERBOSE
		printf("%ls will be saved\n", state->buffer);
#endif
	}
#endif

#ifdef HTTP_VERBOSE
	printf("HTTP: %shdr \"%ls\"\n",
		part ? "part " : "",
		state->buffer);
#endif

	if (!part) {
	   if (!strncmpi(state->buffer, "Cookie:", 7)) {

	      p = _f_strstr(state->buffer,cookie_name);
	      if(NULL != p) {
	         p += strlen(cookie_name) + 2;
	         _f_strncpy(state->cookie, p, HTTP_MAXNAME);
	         for(temp = 0; temp < HTTP_MAXNAME; temp++)
	            if(state->cookie[temp] == '"')
	               state->cookie[temp] = '\0';
	#ifdef HTTP_VERBOSE
	         printf("HTTP: cookie '%s'\n",state->cookie);
	#endif
	      }
	      return 0;
	   } /* END Cookie */

	   if (!strncmpi(state->buffer, "If-Modified-Since:", 18)) {
	      return 0;
	   } /* END If-Modified-Since */
   }

   if (!strncmpi(state->buffer, "Content-Length: ", 16)) {
#ifdef USE_HTTP_UPLOAD
		if (part)
      	state->part_content_length = atol(state->buffer + 16);
      else
#endif
      	state->content_length = atol(state->buffer + 16);
      return 0;
   } /* END Content-Length */

#ifdef USE_HTTP_UPLOAD
	if (!strncmpi(state->buffer, "Content-Disposition: ", 21)) {
   	p = state->buffer + 21;
      state->tag[0] = 0;
		if (q = _f_strchr(p, ';')) *q = 0;
      if (!strcmpi(p, "form-data")) {
      	state->disposition = MIME_DISP_FORMDATA;
      	while (q) {
            while (isspace(*++q));
            if (!strncmpi(q, "name=", 5)) {
            	q += 5;
               if (*q == '"') {
               	p = ++q;
                  if (q = _f_strchr(p, '"'))
                  	temp = (int)(q - p);	// length of name string
                  else
                  	temp = strlen(p);
               }
               else {
               	p = q;
               	if (q = _f_strchr(p, ';'))
                  	temp = (int)(q - p);
                  else
                  	temp = strlen(p);
               }
               if (temp > sizeof(state->tag)-1)
               	temp = sizeof(state->tag)-1;
               _f_memcpy(state->tag, p, temp);
               state->tag[temp] = 0;
               #ifdef HTTP_VERBOSE
               printf("HTTP: form-data name=\"%s\"\n", state->tag);
               #endif
            }
            else if (!strncmpi(q, "filename=", 9)) {
            	q += 9;
               if (*q == '"') {
               	p = ++q;
                  if (q = _f_strchr(p, '"'))
							temp = (int)(q - p);
                  else
                  	temp = strlen(p);

               }
               else {
               	p = q;
                  if (q = _f_strchr(p, ';'))
                  	temp = (int)(q - p);
                  else
                  	temp = strlen(p);
               }
               for (r = p + temp - 1; r > p; --r)
               	if (*r == '\\' || *r == '/') {
                  	temp -= (int)(r - p + 1);
							p = r + 1;
                     break;
                  }

               if(temp > sizeof(state->value)-1)
                  temp = sizeof(state->value)-1;
               _f_memcpy(state->value, p, temp);
               state->value[temp] = 0;
               #ifdef HTTP_VERBOSE
               printf("HTTP: form-data filename=\"%s\"\n", state->value);
               #endif
            }
            if (q = _f_strchr(q, ';'))
            	*q = 0;	// try next parm
            else
            	break;

         }
      }
      else if (!strcmpi(p, "inline"))
      	state->disposition = MIME_DISP_INLINE;
      else if (!strcmpi(p, "attachment"))
      	state->disposition = MIME_DISP_ATTACHMENT;
   }
#endif

   if (!strncmpi(state->buffer, "Content-Type: ", 14)) {
   	p = state->buffer + 14;
		if (q = _f_strchr(p, ';')) *q = 0;
      temp = strlen(p);
      if (temp > sizeof(state->content_type)-1) temp = sizeof(state->content_type)-1;
      _f_memcpy(state->content_type, state->buffer + 14, temp);
      state->content_type[temp] = 0;
#ifdef USE_HTTP_UPLOAD
		if (!part && !strcmpi(state->content_type, "multipart/form-data")) {
      	while (q) {
            while (isspace(*++q));
            if (!strncmpi(q, "boundary=", 9)) {
            	q += 9;
               if (*q == '"') {
               	p = ++q;
                  if (q = _f_strchr(p, '"'))
                  	temp = (int)(q - p);	// length of boundary string
                  else
                  	temp = strlen(p);
               }
               else {
               	p = q;
               	if (q = _f_strchr(p, ';'))
                  	temp = (int)(q - p);
                  else
                  	temp = strlen(p);
               }
               if (temp > sizeof(state->boundary)-4)
               	temp = sizeof(state->boundary)-4;
               memcpy(state->boundary, "\r\n--", 4);
               _f_memcpy(state->boundary+4, p, temp);
               state->boundary_len = temp+4;
               #ifdef HTTP_VERBOSE
               printf("HTTP: boundary=\"%*.*s\"\n", temp, temp, state->boundary+4);
               #endif
               break;
            }
            if (q = _f_strchr(q, ';')) *q = 0;	// try next parm
         }
      }
#endif
      return 0;
   } /* END Content-Type */

#if USE_HTTP_BASIC_AUTHENTICATION
   if (!part && (state->auth_meth & HTTP_BASIC_AUTH) &&
       !strncmpi(state->buffer, "Authorization: Basic ", 21)) {

      state->context.userid = -1;	// Providing credentials: zap the anon user (if any)

      state->p = state->buffer + 21;
      temp = strlen(state->p);
      p = state->p;

		/* decode username/password from BASE64 in-place */
		for (count = 0; count < temp / 4; count++) {
			unbase64(p + (3*count), state->p);
			state->p += 4;
		}
		*(p + (3*count)) = '\0';

		count = 0;
		while ((p[count] != '\0') && (p[count] != ':'))
			count++;
		if (p[count] == ':') {
			p[count] = '\0';
		}
		_f_strncpy(state->username, p, HTTP_MAXNAME);
		_f_strncpy(state->password, (p+count+1), HTTP_MAXNAME);

#ifdef HTTP_VERBOSE
      printf("HTTP: basic auth; username='%s', password='%s'\n",
         state->username, state->password);
#endif
		// Perform the authentication
		state->authenticated = http_basicauthentication(state);

      return 0;
   } /* END Authorization: Basic */
#endif

#if USE_HTTP_DIGEST_AUTHENTICATION
   if (!part && (state->auth_meth & HTTP_DIGEST_AUTH) &&
        !strncmpi(state->buffer, "Authorization: Digest ", 22)) {

      state->context.userid = -1;	// Providing credentials: zap the anon user (if any)

      state->p = state->buffer + 22;

      http_parsedigesthead(state, &nonce, &nc, &cnonce, &response);

		// Perform the authentication
		state->authenticated = http_digestauthentication(state, nonce, nc,
		                                                 cnonce, response);

		return 0;
   } /* END Authorization: Digest */
#endif

   return 1;
}

/*** BeginHeader http_getheaderoption */
char __far * http_getheaderoption(char __far * src);
/*** EndHeader */

_http_nodebug char __far * http_getheaderoption(char __far * src)
{
	auto char __far * end;
	auto int len;

	/* Find the end of the option value */
	if (*src == '\"') {
		src++;
		end = _f_strchr(src, '\"');
		if (end == NULL) {
			/* Error */
			return NULL;
		}
	}
	else {
		end = _f_strchr(src, ',');
		if (end == NULL) {
			/* Must be at the end of the line */
			end = _f_strchr(src, '\r');
			if (end == NULL) {
				/* Error */
				return NULL;
			}
		}
	}
	*end = '\0';

	return src;
}

/*** BeginHeader http_checknonce */
int http_checknonce(char __far * nonce, char __far * nc);
/*** EndHeader */

_http_nodebug int http_checknonce(char __far * nonce, char __far * nc)
{
	auto int i;
	auto long long1;
	auto long long2;

	for (i = 0; i < HTTP_MAX_NONCES; i++) {
		if (_http_nonces[i].used &&
		    (strcmp(_http_nonces[i].nonce, nonce) == 0)) {
			// Found a matching nonce
			// Check if the nonce has timed out
			if (HTTP_DIGEST_NONCE_TIMEOUT &&
			    ((SEC_TIMER - _http_nonces[i].timestamp) > (long)HTTP_DIGEST_NONCE_TIMEOUT)) {
				_http_nonces[i].used = 0;
				return 0;
			}
			// Check the nonce count
			long1 = atol(nc);
			long2 = atol(_http_nonces[i].nc);
			if (long1 <= long2) {
				// Old nonce count
				return 0;
			}
			// Good nonce
			return 1;
		}
	}

	// No matching nonce
	return 0;
}

/*** BeginHeader http_parsedigesthead */
int http_parsedigesthead(HttpState* state, char __far ** nonce, char __far ** nc,
                         char __far ** cnonce, char __far ** response);
/*** EndHeader */

_http_nodebug int http_parsedigesthead(HttpState* state, char __far ** nonce, char __far ** nc,
                                       char __far ** cnonce, char __far ** response)
{
	auto char __far * p;

	/* state->p points to the first option */

	while (*state->p != '\r') {
		/* Figure out the name of the option */
		p = _f_strchr(state->p, '=');
		if (!p) {
			return 0;
		}
		*(p++) = '\0';
		if (strcmpi(state->p, "username") == 0) {
			_f_strncpy(state->username, http_getheaderoption(p), HTTP_MAXNAME);
			state->username[HTTP_MAXNAME-1] = '\0';
		}
		else if (strcmpi(state->p, "nonce") == 0) {
			*nonce = http_getheaderoption(p);
		}
		else if (strcmpi(state->p, "nc") == 0) {
			*nc = http_getheaderoption(p);
		}
		else if (strcmpi(state->p, "cnonce") == 0) {
			*cnonce = http_getheaderoption(p);
		}
		else if (strcmpi(state->p, "response") == 0) {
			*response = http_getheaderoption(p);
		}
		else {
			http_getheaderoption(p);
		}

		/* Go forward to the next option */
		p += strlen(p) + 1;
		while ((*p == ' ') || (*p == ',')) {
			p++;
		}
		state->p = p;
	}
#ifdef HTTP_VERBOSE
	printf("HTTP: digest; username = '%s'\n", state->username);
#endif
	return 0;
}

/*** BeginHeader http_setcookie */
void http_setcookie(char __far * buf, char __far * value);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_setcookie                  		<HTTP.LIB>

SYNTAX: void http_setcookie(char far *buf, char far *value);

KEYWORDS:		tcpip, http

DESCRIPTION:	This utility generates a cookie on the client. This will
		store the text in value into a cookie-generation header that will
      be written to buf. The header placed in buf is not automatically
      sent to the web client.  Hence, it is the caller's responsibility
      to send the header in buf along with any other HTTP headers to the
      client.

		When a page is requested from the client, and the cookie is already
      set, the text of the cookie will be stored in state->cookie[]. This
      is a char*, and if no cookie was available, state->cookie[0] will
      equal '\0'.

PARAMETER1:		Buffer to store cookie-generation header
PARAMETER2:		Text to store in cookie-generation header

END DESCRIPTION **********************************************************/

_http_nodebug void http_setcookie(char __far *buf, char __far *value)
{
	sprintf(buf, "Set-Cookie: %s=\"%ls\"\r\n",
		cookie_name, value);
}


/*** BeginHeader http_genHeader */
void http_genHeader(HttpState* state, char __far * buf, int buflen,
			int code, const char __far * content_type, int more_hdrs, char __far * content);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_genHeader                  		<HTTP.LIB>

SYNTAX: void http_genHeader(HttpState* state, char far * buf, int buflen,
			int code, const char far * content_type,
			int more_hdrs, char far * content);

KEYWORDS:		tcpip, http

DESCRIPTION:	This function builds HTTP headers to send in response to a
					request.

PARAMETER1:		HTTP state pointer, as provided in the first parameter to
               the CGI function.
PARAMETER2:		Buffer to store headers and copy of content.
PARAMETER3:		Size of buffer.
PARAMETER4:		HTTP Status code (e.g., 200 for OK)
PARAMETER5:		Content type string or NULL for default of "text/html"
PARAMETER6:		0 = no more headers
					1 = caller will add headers
					2 = caller will add headers, but call custom headers function
						(if HTTP_CUSTOM_HEADERS is defined)
PARAMETER7:		If parameter 6 was non-zero, this parameter can include
					additional headers, followed by two \r\n pairs and then content
					for the response.  If parameter 6 is zero, this parameter
					is sent as page content only.

END DESCRIPTION **********************************************************/
_http_nodebug
void http_genHeader(HttpState* state, char __far * buf, int buflen,
			int code, const char __far * content_type, int more_hdrs, char __far * content)
{
	auto char * msg;
	auto char datestr[30];
	auto int offset;

#ifdef HTTP_VERBOSE
	printf("HTTP: sending %d for %ls, realm %s\n", code, state->url,
		state->realm ? state->realm : "(none)");
#endif

	offset = 0;

   switch (code)
   {
   	case 204:	msg = "No Content";				break;
      case 302:	msg = "Found"; 					break;	//state->p has next URL
      case 401:	msg = "Unauthorized";			break;
      case 403:	msg = "Forbidden";				break;
      case 404:	msg = "Not Found";				break;
      case 503:	msg = "Service Unavailable";	break;
   	default:		msg = "OK"; code = 200; 		break;
   }
   if (!content_type)
   {
   	content_type = "text/html";
   }
   if (state->version != HTTP_VER_09)
   {
   	// 1.0 or 1.1: generate headers
      offset += sprintf(buf + offset,
      	"HTTP/1.%c %d %s\r\n" \
         "Date: %ls\r\n" \
         "Server: Rabbit/%u.%02x\r\n" \
         "Connection: close\r\n"
        , state->version == HTTP_VER_11 ? '1' : '0'
        , code
        , msg
        , http_date_str(datestr)
        , CC_VER >> 8, CC_VER & 0x00FF
        );
      if (code == 302)
      {
      	// Add "Location:" header for "302 Found" response
			offset += sprintf(buf + offset, "Location: %ls\r\n", state->p);
      }
      if (code != 204)
      {
			// "204 No Content" response shouldn't include a Content-Type
      	offset += sprintf(buf + offset, "Content-Type: %ls\r\n", content_type);
      }
      if (! more_hdrs)
      {
      	// end headers with a blank line
			offset += sprintf(buf + offset, "\r\n");
      }
#ifdef HTTP_CUSTOM_HEADERS
	   if (more_hdrs == 2)
	   {
	      HTTP_CUSTOM_HEADERS(state, buf + offset, buflen - offset - 3);
	      offset += strlen(buf + offset);
	   }
#endif
   }
   // Add some content to display on the browser (this is the only thing for version 0.9)
   if (!more_hdrs && code != 200 && !content)
   {
	   offset += sprintf(&buf[offset],
	      "<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>" \
	      "<BODY>%d %s</BODY></HTML>"
        , code, msg
        , code, msg
        );
   }
   if (content)
   {
   	// Content may include additional headers (provided more_headers was true, and version > 0.9)
   	_f_strcpy(buf + offset, content);
   }
}

/*** BeginHeader http_send_404 */
void http_send_404(HttpState* state);
/*** EndHeader */

/*
 * send a 404-not found message
 * jumps to either FINISHWRITE or DIE, depending on if it finished or not
 */

_http_nodebug void http_send_404(HttpState* state)
{
   http_genHeader(state, state->buffer, state->abuffer,
                  404, NULL, 0, NULL);

	state->offset=0;
	state->length=strlen(state->buffer);
	state->state=HTTP_FINISHWRITE;
	state->nextstate=HTTP_DIE;
}

/*** BeginHeader http_send_403 */
void http_send_403(HttpState* state);
/*** EndHeader */

/*
 * send a 403-forbidden message
 * jumps to either FINISHWRITE or DIE, depending on if it finished or not
 */

_http_nodebug void http_send_403(HttpState* state)
{
   http_genHeader(state, state->buffer, state->abuffer,
                  403, NULL, 0, NULL);
	state->offset=0;
	state->length=strlen(state->buffer);
	state->state=HTTP_FINISHWRITE;
	state->nextstate=HTTP_DIE;
}

/*** BeginHeader http_send_503 */
void http_send_503(HttpState* state);
/*** EndHeader */

/*
 * send a 503-service unavailable message
 * jumps to either FINISHWRITE or DIE, depending on if it finished or not
 */

_http_nodebug void http_send_503(HttpState* state)
{
   http_genHeader(state, state->buffer, state->abuffer,
                  503, NULL, 0, NULL);
	state->offset=0;
	state->length=strlen(state->buffer);
	state->state=HTTP_FINISHWRITE;
	state->nextstate=HTTP_DIE;
}

/*** BeginHeader http_findnonceslot */
int http_findnonceslot(unsigned long time);
/*** EndHeader */

_http_nodebug int http_findnonceslot(unsigned long time)
{
	auto int i;
	auto int oldest;
	auto unsigned long age;

	// Find an empty slot, and keep track of the oldest timestamp
	oldest = -1;
	for (i = 0; i < HTTP_MAX_NONCES; i++) {
		if (_http_nonces[i].used) {
			if ((oldest == -1) ||
			    (time - _http_nonces[i].timestamp > age)) {
				oldest = i;
				age = time - _http_nonces[i].timestamp;
			}
		}
		else {
			break;
		}
	}
	if (i == HTTP_MAX_NONCES) {
		// Must pick the oldest
		i = oldest;
	}

	return i;
}

/*** BeginHeader http_makenonce */
char __far * http_makenonce(void);
/*** EndHeader */

_http_nodebug char __far * http_makenonce(void)
{
	auto int i;
	auto int oldest;
	auto unsigned long age;
	auto unsigned long time;
	auto char nonce[20];
	auto md5_state_t hash_state;

	time = SEC_TIMER;

	i = http_findnonceslot(time);

	// i now holds the index of the nonce entry to replace
	_http_nonces[i].timestamp = time;
	memcpy(nonce, (char *)(&time), 4);
	md5_init(&hash_state);
	md5_append(&hash_state, (char *)(&time), 4);
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, _http_nonce_init, 12);
	md5_finish(&hash_state, nonce+4);
	http_expandhash(_http_nonces[i].nonce, nonce, 20);
	_http_nonces[i].nonce[40] = '\0';
	strcpy(_http_nonces[i].nc, "00000000");
	_http_nonces[i].used = 1;

	return _http_nonces[i].nonce;
}

/*** BeginHeader http_send_401 */
void http_send_401(HttpState* state);
/*** EndHeader */

/*
 * sends a 401-unauthorized message
 */

_http_nodebug void http_send_401(HttpState* state)
{
   http_genHeader(state, state->buffer, state->abuffer,
                  401, NULL, 1, NULL);	// More headers follow

#if USE_HTTP_BASIC_AUTHENTICATION
	if (state->auth_meth & HTTP_BASIC_AUTH) {
		sprintf(state->buffer + strlen(state->buffer),
        "WWW-Authenticate: Basic realm=\"%s\"\r\n\r\n",
        state->realm ? state->realm : "");
	}
#endif
#if USE_HTTP_DIGEST_AUTHENTICATION
	if (state->auth_meth & HTTP_DIGEST_AUTH) {
		sprintf(state->buffer + strlen(state->buffer),
        "WWW-Authenticate: Digest realm=\"%s\", qop=\"auth\", nonce=\"",
        state->realm ? state->realm : "");

		// Generate the nonce
		_f_strcat(state->buffer, http_makenonce());
		if (state->authenticated == HTTP_AUTH_STALE) {
			_f_strcat(state->buffer, "\", stale=true\r\n\r\n");
		}
		else {
			_f_strcat(state->buffer, "\", stale=false\r\n\r\n");
		}
	}
#endif

   state->offset = 0;
   state->length = strlen(state->buffer);
   state->state = HTTP_FINISHWRITE;
   state->nextstate = HTTP_DIE;
}

/*** BeginHeader http_sendfile */
int http_sendfile(HttpState* state);
/*** EndHeader */

/*
 * Sends the file described in state->spec
 * Returns 1 when it is finished
 */

_http_nodebug int http_sendfile(HttpState* state)
{
	auto int bytes;
   auto int retval;

   if (state->method == HTTP_METHOD_HEAD)
      return 1;

  	if ((bytes = sspec_read(state->spec, state->buffer, state->abuffer)) <= 0) {
		return 1;
   }

   // Send the data that we received
   if ((retval = sock_fastwrite(_SOCK_OF_HTTP(state), state->buffer, bytes)) < 0) {
   	// Error
   	return 1;
   }

   if (retval) {
   	state->main_timeout = set_timeout(HTTP_TIMEOUT);
   }

	// Schedule any leftover data for sending
	if (retval < bytes) {
	   state->offset = retval;
	   state->length = bytes;
	   state->nextstate = HTTP_SENDPAGE;
	   state->state = HTTP_FINISHWRITE;
   }
   return 0;
}

/*** BeginHeader http_sendbuffer */
int http_sendbuffer(HttpState* state);
/*** EndHeader */

/*
 * Sends the buffer described in state->spec, state->filelength, and state->pos
 * Returns 1 when it is finished
 */
_http_nodebug int http_sendbuffer(HttpState* state)
{
   auto int len;
   auto int retval;

  	len=(int)(state->length-state->offset);
   if(len) {
		if ((retval = sock_fastwrite(_SOCK_OF_HTTP(state),(char __far *)state->offset,len)) < 0) {
      	// Error on socket
      	return 1;
      }
      state->offset += retval;

   	/* reset timeout */
   	if(retval)
   		state->main_timeout = set_timeout(HTTP_TIMEOUT);

   	return 0;
   }
   return 1;
}

/*** BeginHeader http_expandhash */
void http_expandhash(char __far * dest, char __far * src, int len);
/*** EndHeader */

_http_nodebug void http_expandhash(char __far * dest, char __far * src, int len)
{
	auto int i;
	for (i = 0; i < len; i++) {
		sprintf(dest + i*2, "%02x", src[i]);
	}
}

/*** BeginHeader http_basicauthentication */
int http_basicauthentication(HttpState* state);
/*** EndHeader */

_http_nodebug int http_basicauthentication(HttpState* state)
{
	auto int uid;
   auto int server_mask;

	/* Basic authentication */
	if (((uid = sauth_authenticate(state->username, state->password, state->context.server)) == -1) ||
       (sspec_checkaccess(state->spec, uid) != 1))
   {
      return HTTP_AUTH_NO;
   }
   state->context.userid = uid;
	return HTTP_AUTH_OK;	// Authenticated OK
}

/*** BeginHeader http_digestauthentication */
int http_digestauthentication(HttpState* state, char __far * nonce, char __far * nc,
                              char __far * cnonce, char __far * response);
/*** EndHeader */

_http_nodebug int http_digestauthentication(HttpState* state, char __far * nonce, char __far * nc,
                                            char __far * cnonce, char __far * response)
{
	auto char __far * username;
	auto char __far * password;
	auto md5_state_t hash_state;
	auto char hash[16];
	auto char hashexp[33];
	auto char __far * method;
	auto int retval;
	auto int count;
	auto int userid;
   auto int server_mask;

	// Grab the username, password, and realm of the resource
   // Find the right user
	userid = sauth_getuserid(state->username, state->context.server);
   if (sspec_checkaccess(state->spec, userid) != 1) {
      // Authentication failed
      return HTTP_AUTH_NO;
   }
   state->context.userid = userid;
	password = sauth_getpassword(userid);
#ifdef HTTP_VERBOSE
	printf("HTTP: digest; resource=%ls realm=%s\n", state->url, state->realm ? state->realm : "<null>");
#endif
	// Calculate the hash -- See RFC 2617 for the details

	retval = http_checknonce(nonce, nc);

	// Calculate H(A1)
	md5_init(&hash_state);
	md5_append(&hash_state, state->username, strlen(state->username));
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, state->realm, state->realm ? strlen(state->realm) : 0);
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, password, strlen(password));
	md5_finish(&hash_state, hash);
	http_expandhash(hashexp, hash, 16);

	// Calculate H(A2)
	md5_init(&hash_state);
	method = http_getHTTPMethod_str(state);
	md5_append(&hash_state, method, strlen(method));
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, state->url, strlen(state->url));
	md5_finish(&hash_state, hash);

	// Put H(A1) and H(A2) together with the other stuff
	md5_init(&hash_state);
	md5_append(&hash_state, hashexp, 32);
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, nonce, strlen(nonce));
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, nc, strlen(nc));
	md5_append(&hash_state, ":", 1);
	md5_append(&hash_state, cnonce, strlen(cnonce));
	md5_append(&hash_state, ":auth:", 6);
	http_expandhash(hashexp, hash, 16);
	md5_append(&hash_state, hashexp, 32);
	md5_finish(&hash_state, hash);

	http_expandhash(hashexp, hash, 16);

	hashexp[32] = '\0';

	if (memcmp(hashexp, response, 32) != 0) {
		// Authentication failed
		return HTTP_AUTH_NO;
	}
	else {
		if (retval) {
			// Authentication succeeded with a valid nonce, as well
			return HTTP_AUTH_OK;
		}
		else {
			// Authentication succeeded, but with invalid or stale nonce
			return HTTP_AUTH_STALE;
		}
	}
}

/*** BeginHeader http_setauthentication */
int http_setauthentication(int auth);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_setauthentication          		<HTTP.LIB>

SYNTAX: int http_setauthentication(int auth);

KEYWORDS:		tcpip, http

DESCRIPTION:	Sets the type of authentication that is used globally
		by the HTTP server.  By default, this is set to the strongest
		available type of authentication available (in order of weakest
		to strongest: HTTP_NO_AUTH, HTTP_BASIC_AUTH, HTTP_DIGEST_AUTH).
		This function returns the type of authentication that was
		actually configured.  If the type of authentication that you
		ask for was not compiled in at compile time, then the type
		of authentication will not be changed.

      Note: this function only sets the "default" authentication
      method for resources who have their authentication method
      set to SERVER_AUTH_DEFAULT (or, none specified).


PARAMETER1:		Type of authentication (HTTP_NO_AUTH, HTTP_BASIC_AUTH,
					or HTTP_DIGEST_AUTH)

RETURN VALUE:	Actual resulting type of authentication (HTTP_NO_AUTH,
					HTTP_BASIC_AUTH, or HTTP_DIGEST_AUTH)

END DESCRIPTION **********************************************************/

_http_nodebug int http_setauthentication(int auth)
{
#if !USE_HTTP_BASIC_AUTHENTICATION
	auth &= ~HTTP_BASIC_AUTH;
#endif
#if !USE_HTTP_DIGEST_AUTHENTICATION
	auth &= ~HTTP_DIGEST_AUTH;
#endif
	if (!auth || auth & ~(HTTP_NO_AUTH|HTTP_BASIC_AUTH|HTTP_DIGEST_AUTH)) {
		return _http_auth_type;
	}
	_http_auth_type = auth;
	return _http_auth_type;
}

/*** BeginHeader http_process */
int http_process(HttpState* state);
/*** EndHeader */

/* Process a request */
_http_nodebug int http_process(HttpState* state)
{
   auto char *p;
   auto int (*fptr)();
   auto word type;
   auto int uid;
   auto int retval;

   if (state->spec < 0) {
   	if (state->spec == -ENOMEM) {
      	/* 503 service unavailable -- were not able to open the file because
            we were out of SSpec handles. */
#ifdef HTTP_VERBOSE
			printf("HTTP:  Unable to allocate sspec handle (SSPEC_MAX_OPEN too low).  Sending 503.\n");
#endif
         http_send_503(state);
		}
      else {
	      /* 404 not found */
	#ifdef HTTP_VERBOSE
	      printf("HTTP: URL was not found. Sending 404.\n");
	#endif
	      http_send_404(state);
   	}
      return 0;
   }

   if (state->authenticated == HTTP_AUTH_ANON) {
   	// No credentials, but not yet checked resource access.
      if (1 != sspec_checkaccess(state->spec, state->context.userid))
      	state->authenticated = HTTP_AUTH_NO;
      else
      	state->authenticated = HTTP_AUTH_OK;
	}

   if (state->authenticated != HTTP_AUTH_OK) {	// 0 if not auth, 2 if auth but stale (digest)
      http_send_401(state);
      return 0;
  	}

	/* Determine the type of resource */
	type = sspec_gettype(state->spec);

   switch (type) {
	case SSPEC_FILE:
      /* Standard file or SSI file - call the apropriate handler */
      state->type = sspec_getMIMEtype(state->url, &state->context);
#ifdef HTTP_VERBOSE
		printf("HTTP: resource type is FILE, mime type %s\n", state->type ? state->type->type : "<null>");
#endif

      if (state->type->fptr == NULL) {
         /* normal file */
         state->handler = http_sendfile;
      } else {
         /* has handler */
         state->handler = state->type->fptr;
         state->nextstate = 0; /* 0 == default state in handler */
      }

      state->pos = 0;
      state->state = HTTP_SENDPAGE;

      /* write out a header, if necessary */
      state->headerlen = 0;   /* Flag for if the header has been sent */
      if (state->version != HTTP_VER_09) {
         /* Send the http/1.x header */
      	http_genHeader(state, state->buffer, state->abuffer,
            200,	// 200 OK
            state->type ? state->type->type : "text/plain",
            2,			// Add custom headers
            "\r\n"	// End of headers (blank line)
            );
         state->headerlen = strlen(state->buffer);
         if ((state->headeroff = sock_fastwrite(_SOCK_OF_HTTP(state), state->buffer, state->headerlen)) < 0)
				// Error on socket
            state->state = HTTP_DIE;
         else if (state->headeroff >= state->headerlen) {
            state->headerlen = state->headeroff = 0;
         }
      }
      break;

   case SSPEC_FUNCTION:
   case SSPEC_FORM:
#ifdef HTTP_VERBOSE
		printf("HTTP: resource type is FUNCTION/FORM\n");
#endif
      /* enter the CGI handler */
      state->state = HTTP_OLDCGI;
      state->p = state->buffer;
	_setcgi:
		state->headerlen = state->headeroff = 0;
      if (type != SSPEC_FORM) {
			state->cgifunc = sspec_getfunction(state->spec);
      	if (!state->cgifunc)
         	state->state = HTTP_DIE;
      }
      else
      	state->cgifunc = NULL;
      break;

#ifdef USE_HTTP_UPLOAD
   case SSPEC_CGI:
#ifdef HTTP_VERBOSE
		printf("HTTP: resource type is CGI\n");
#endif
      /* enter the new style CGI handler */
      if (!state->action)
      	// Not already processing from previous CGI
      	state->state = HTTP_CGI_PROLOG;
      goto _setcgi;
#endif

   default:
      /* Unhandled type (variable, SSPEC_CGI when not USE_HTTP_UPLOAD etc.) */
#ifdef HTTP_VERBOSE
		printf("HTTP: resource type is %d (unhandled!)\n", type);
#endif
      http_send_404(state);
   }

   return 0;
}

/*** BeginHeader http_safe */
int http_safe(char __far * to, char __far * from, int tolen, int fromlen);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_safe                   		<HTTP.LIB>

SYNTAX: int http_safe(char far * to, char far * from,
							int tolen, int fromlen)

KEYWORDS:		tcpip, http

DESCRIPTION:	Convert a http-unsafe string in 'from' (length 'fromlen')
               into properly escaped string e.g. "hello&goodbye<>" would
               be changed to "hello&amp;goodbye&lt;&gt;". Returns non-zero
               if result could not fit in tolen-1 bytes.  A null is always
               added, thus tolen should take account of this.  Double
               quotes are escaped since the result may itself be quoted.

               Newline characters are turned into HTML line break "<BR>"
               markup.  Control characters (codes less than 32) are turned
               into "&#xx;" where "xx" is the hexadecimal control char
               value.  The source string can contain null character(s)
               which is why its length is passed in "fromlen".

PARAMETER1:    Destination buffer for escaped string
PARAMETER2:    Source buffer for string to convert
PARAMETER3:    Length of destination buffer (must be at least equal
               to fromlen, since string is never smaller than source
               string).
PARAMETER4:    Length of source buffer.

RETURN VALUE: 	0 on success, non-zero if resulting string (plus its
               null terminator) could not fit in the provided buffer.

SEE ALSO: 	http_handler

END DESCRIPTION **********************************************************/

_http_nodebug int http_safe(char __far * to, char __far * from, int tolen, int fromlen)
{
	auto int tc, fc;
	auto unsigned char c;
	auto char buf[8];
	auto int bl;

	tc = fc = 0;
	tolen--;
	while (fc < fromlen && tc <= tolen && (c = (unsigned char)*from)) {
		if (c == '\n')
			_f_strcpy(buf, "<br>"), bl = 4;
		else if (c < ' ' || c >= 127 || c == '"')
			sprintf(buf, "&#%02x;", (int)c), bl = 5;
		else if (c == '<')
			_f_strcpy(buf, "&lt;"), bl = 4;
		else if (c == '>')
			_f_strcpy(buf, "&gt;"), bl = 4;
		else if (c == '&' && (isalpha(from[1]) || from[1] == '#'))
			_f_strcpy(buf, "&amp;"), bl = 5;
		else
			buf[0] = c, buf[1] = 0, bl = 1;
		tc += bl;
		if (tc <= tolen) {
			_f_strcpy(to, buf);
			to += bl;
		}
		from++;
		fc++;
	}
	*to = 0;
	return tc > tolen;
}



/*** BeginHeader http_init */
int http_init(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_init                   		<HTTP.LIB>

SYNTAX: int http_init(void);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Initilize the http daemon.  This must be called after
               sock_init(), and before calling http_handler() in a loop.

               This sets the root directory to "/" and sets the
               default file name to "index.html".  You can change these
               defaults by calling http_set_path() after this function.

               You can override these defaults at compile-time by
               defining the macros

                 #define HTTP_HOMEDIR "/"
                 #define HTTP_DFLTFILE "index.html"

               to be something other than these defaults.  If you
               do this, then there is no need to invoke the
               http_set_path() function.

RETURN VALUE: 	Always returns 0

SEE ALSO: 	http_handler, http_shutdown, http_status, http_set_path

END DESCRIPTION **********************************************************/

__far int _http_init_1st_time;
#if __HTTP_USE_SSL__
#ifdef SSL_CERTIFICATE
static __far SSL_Cert_t _legacy_ssl_cert;
#endif
#endif

_http_nodebug int http_init(void)
{
   HTTP_DECL_INDEX
   #GLOBAL_INIT { _http_init_1st_time = 1; }

#ifdef FORM_ERROR_BUF
	_feblock = -1;
	_febptr = _form_error_buf;
	_feparsing = 0;
	_fcharsread = 0;
	_festrstart = _form_error_buf;
	_feequal = 0;
#endif

#if USE_RABBITWEB
#ifdef USE_LEGACY_RABBITWEB
	// This lock will prevent multiple POSTs from occuring at once
	_zhtml_lock = -1;
#endif
#endif

	_http_disabled = 0;

   HTTP_FORALL_SERVERS
      state->state=HTTP_INIT;
   	if (_http_init_1st_time) {
   		state->extbuf = NULL;
   		state->extlen = 0;
   	}
   	if (_http_init_1st_time) {
   		state->abuffer = HTTP_MAXBUFFER;
   		state->buffer = _web_malloc(state->abuffer);
   		state->aurl = HTTP_MAXURL;
   		state->url = _web_malloc(state->aurl);
   	#ifdef HTTP_SOCK_BUF_SIZE
   		// Allocate only once, to avoid memory leak
   		state->sockbuf = _web_malloc(HTTP_SOCK_BUF_SIZE);
   	#endif
   	}

#if __HTTP_USE_SSL__
   #ifndef SSL_CERTIFICATE
   	state->cert = NULL;
   #endif
		// Setup and initialize SSL sockets (if needed)
      if(HTTP_SERVNO < HTTP_SSL_SOCKETS) {
	   	state->context.server = SERVER_HTTPS;
      }
      else {
	   	state->context.server = SERVER_HTTP;
      }
      state->_n_ssl = NULL;
#else
   	state->context.server = SERVER_HTTP;
#endif
      state->context.rootdir = HTTP_HOMEDIR;
      strcpy(state->context.cwd, HTTP_HOMEDIR);
      state->context.dfltname = HTTP_DFLTFILE;
   #if USE_HTTP_SAVED_HEADERS
   	if (_http_init_1st_time) {
   		state->saved_headers = _web_malloc(HTTP_SAVED_HEADERS_SIZE);
   	}
   #endif
   HTTP_END_FORALL_SERVERS

#if USE_HTTP_DIGEST_AUTHENTICATION
	memcpy(_http_nonce_init, (char *)(&SEC_TIMER), 4);
	memcpy(_http_nonce_init+4, (char *)(&MS_TIMER), 4);
	memcpy(_http_nonce_init+8, (char *)(&TICK_TIMER), 4);
	memset(_http_nonces, 0, sizeof(_http_nonces));
#endif

#if USE_HTTP_DIGEST_AUTHENTICATION
	_http_auth_type = HTTP_DIGEST_AUTH;
#elif USE_HTTP_BASIC_AUTHENTICATION
	_http_auth_type = HTTP_BASIC_AUTH;
#else
	_http_auth_type = HTTP_NO_AUTH;
#endif

   if (_http_init_1st_time) {
#if USE_RABBITWEB
		#ifdef USE_LEGACY_RABBITWEB
	   _http_post = (long)_web_malloc(RWEB_POST_MAXBUFFER);
	   _rweb_weberror_buffer = (long)_web_malloc(RWEB_WEB_ERROR_MAXBUFFER);
		#else
		web_init();
		#endif
#endif

#if __HTTP_USE_SSL__
   #ifdef SSL_CERTIFICATE
   // Handle legacy way of specifying server certificate
   	_f_memset(&_legacy_ssl_cert, 0, sizeof(_legacy_ssl_cert));
      if (SSL_new_cert(&_legacy_ssl_cert, SSL_CERTIFICATE, SSL_CERT_XIM, 0)) {
         exit(-SSL_BAD_CERT);
      }
      https_set_cert(&_legacy_ssl_cert);
	#endif
#endif
   }

	_http_init_1st_time = 0;

   return 0;
}

/*** BeginHeader http_set_path */
int http_set_path(char * rootdir, char * dfltname);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_set_path                   		<HTTP.LIB>

SYNTAX: int http_set_path(char * rootdir, char * dfltname);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Set the default root directory and resource name for all
               HTTP server instances.  In general, this function
               should be called once only, after http_init() but before
               http_handler().

               The root directory is the base directory which is used as
               a prefix for all resource requests from clients.  For
               example, if the root directory is set to "/A/" then
               a client request for "http://<hostname>/foo.htm
               will look up the resource called "/A/foo.htm" on this
               server.

               The default resource name is used if the client's URL
               requests a directory.  For example, if dfltname is set
               to "index.htm" (and rootdir is "/A/") then a client
               request for "http://<hostname>/admin" will look up the
               resource called "/A/admin".  If that resource is actually
               a directory, then it will look up a resource called
               "/A/admin/index.htm".  If it is not a directory, then
               the default name is not used.

PARAMETER1:		Root directory name to use.  This must be a null-terminated
               string.  In addition, it MUST start and end with a
               forward slash (/) character.  If this function is not
               called, then http_init() sets it to "/".
PARAMETER2:		Default file name to use.  This is appended to the
					directory part of the URL, if the URL actually refers
               to a directory.  If this function is not called, then
               http_init() sets it to "index.html".
               If NULL: there will be no default name.  A request for
               a directory will generally return a 404 error (not
               found) to the client.
               If not NULL, must be a null-terminated string.  It must
               not start or end with a '/' character.

RETURN VALUE: 	0: OK
					-E2BIG: rootdir was too long.  It should be limited to
                       less than about 12 characters, but you can
                       increase the value of SSPEC_MAXNAME if necessary.
               -EINVAL: rootdir was NULL, or did not start and end with
                       a '/' character.

SEE ALSO: 	   http_handler, http_init

END DESCRIPTION **********************************************************/

_http_nodebug int http_set_path(char * rootdir, char * dfltname)
{
   HTTP_DECL_INDEX

   if (!rootdir)
   	return -EINVAL;
   if (strlen(rootdir) >= sizeof(state->context.cwd)-1)
   	return -E2BIG;
   if (rootdir[0] != '/' || rootdir[strlen(rootdir)-1] != '/')
   	return -EINVAL;

   HTTP_FORALL_SERVERS
      state->context.rootdir = rootdir;
      strcpy(state->context.cwd, rootdir);
      state->context.dfltname = dfltname;
   HTTP_END_FORALL_SERVERS

   return 0;
}

/*** BeginHeader http_shutdown */
int http_shutdown(int graceful);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_shutdown                   		<HTTP.LIB>

SYNTAX: int http_shutdown(int graceful);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Shut down the http daemon.  Use http_init() to restart.

PARAMETER1:    If non-zero, current connections are allowed to terminate
               normally.  Otherwise, any open connections are reset.

RETURN VALUE: 	0

SEE ALSO: 	http_handler, http_init, http_status

END DESCRIPTION **********************************************************/

_http_nodebug int http_shutdown(int graceful)
{
   HTTP_DECL_INDEX

	_http_disabled = 1;	// Tell http_handler() to refuse new connections

   if (!graceful) {
	   HTTP_FORALL_SERVERS
#if __HTTP_USE_SSL__
	      if (state->_n_ssl) {
	         // clean up and de-allocate previous instance
	         sock_unsecure(state->_n_ssl);
	         state->_n_ssl = NULL;
	      }
#endif
         if (state->state > HTTP_LISTEN) {
         	sock_abort(_SOCK_OF_HTTP(state));
	      	_http_abort(HTTP_SERVNO);
         }
	   HTTP_END_FORALL_SERVERS
   }

   return 0;
}

/*** BeginHeader http_status */
int http_status(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_status                   		<HTTP.LIB>

SYNTAX: int http_status(void)

KEYWORDS:		tcpip, http

DESCRIPTION: 	Determine whether the HTTP server is allowing conections.

RETURN VALUE: 	0 : server is currently disabled
					non-zero : server is enabled.

SEE ALSO: 	http_handler, http_init, http_shutdown

END DESCRIPTION **********************************************************/

_http_nodebug int http_status(void)
{
	return !_http_disabled;
}

/*** BeginHeader http_handler */
int http_handler(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_handler		                   <HTTP.LIB>

SYNTAX: int http_handler(void);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Tick function to run the http daemon. Must be
		called periodicly for the daemon to work.

RETURN VALUE:  	none

SEE ALSO: 	http_init

END DESCRIPTION **********************************************************/

_http_nodebug int http_handler(void)
{
   HTTP_DECL_INDEX
   auto int temp, gotlock, len;
   auto void * s;		// TCP or SSL socket
   auto int (*fptr)();
   auto HttpState * h;
   #GLOBAL_INIT { _http_uid_anon = -1; }

   tcp_tick(NULL);

   HTTP_FORALL_SERVERS
   	h = state;
      s = _SOCK_OF_HTTP(h);

      /*
       *    handle timeout's here...
       */
		if(h->state != h->laststate) {
			/* state changed; reset timeout */
#ifdef HTTP_VERBOSE
		 	printf("HTTP: state changed to %u->%u\n", h->laststate, h->state);
#endif
			h->laststate = h->state;
			h->main_timeout = set_timeout(HTTP_TIMEOUT);
		}

		if(chk_timeout(h->main_timeout)) {
      	// Note that HTTPS_LISTEN is included here. This is to avoid
         // a potential DOS attack against the Rabbit using Mozilla with
         // a "bad" certificate on the Rabbit. Mozilla stops the SSL handshake
         // and waits for user input about the certificate, keeping the
         // socket open and preventing other clients from connecting to the
         // Rabbit. By adding the HTTPS_LISTEN state, we can use the HTTP
         // timeout mechanism to close the connection if it stalls during
         // the SSL handshake. Mozilla will reconnect if the socket is closed.
			if((h->state == HTTP_LISTEN) ||
			   (h->state == HTTP_INIT)
#if __HTTP_USE_SSL__
            || (h->state == HTTPS_LISTEN && (_SSL_FIELD(s, cur_state) == SSL_STATE_HS_LISTEN))
#endif
         ) {
				/* nevermind; we are waiting for a connection */
				h->main_timeout = set_timeout(HTTP_TIMEOUT);
			} else {
				/* we timed out in one state for too long */
#ifdef HTTP_VERBOSE
				printf("HTTP: TIMEOUT!\n");
#endif
  				sock_abort(_SOCK_OF_HTTP(h));
				h->state = HTTP_WAITCLOSE;
			}
		}

      if (h->state != HTTP_INIT && !sock_alive(_SOCK_OF_HTTP(h)))
		{

#ifdef HTTP_VERBOSE
		 	printf("HTTP: socket ended in state %d\n", h->state);
#endif
         //sock_abort(h);	// Don't do this, socket already dead
			_http_abort(HTTP_SERVNO);
         h->state=HTTP_INIT;
      }

      switch (h->state) {
      case HTTP_INIT:
      	if (_http_disabled)
         	break;
         memset((char *)&h->HTTP_FIRST_FIELD_TO_ZERO, 0,
         		(char *)sizeof(*h) -
               (char *)&((HttpState *)0)->HTTP_FIRST_FIELD_TO_ZERO);
      	#ifdef HTTP_SOCK_BUF_SIZE
         http_sock_extlisten(h,HTTP_IFACE,
         	_IS_HTTPS(h) ? HTTPS_PORT : HTTP_PORT,
         	0,0,NULL,0,(long)h->sockbuf,HTTP_SOCK_BUF_SIZE);
         #else
         http_sock_extlisten(h,HTTP_IFACE,
         	_IS_HTTPS(h) ? HTTPS_PORT : HTTP_PORT,
         	0,0,NULL,0,0,0);
         #endif
         if(_IS_HTTPS(h)) {
            // HTTPS server, do HTTPS listen
            h->state=HTTPS_LISTEN;
         }
         else {
         	// Plain HTTP server, do plain HTTP listen
            h->state=HTTP_LISTEN;
         }
         break;

	   case HTTPS_LISTEN:
      case HTTP_LISTEN:
      	if (_http_disabled) {
         	sock_abort(_SOCK_OF_HTTP(h));
				h->state=HTTP_INIT;
         	break;
         }

         if (!sock_waiting(s))
			{
         	// Not waiting any more: either established or aborted.  In the latter case,
            // the above sock_alive() test will have failed so we don't need to consider it
            // here.
#ifdef HTTP_VERBOSE
				printf("HTTP: socket established\n");
#endif
            http_sock_mode(h, HTTP_MODE_ASCII);
            h->state=HTTP_GETREQ;
            h->subspec = -1;
         }
         break;

      case HTTP_GETREQ:
         if (http_getline(h)) {
            if (!http_parseget(h)) {
               sock_close(_SOCK_OF_HTTP(h));
               h->state=HTTP_WAITCLOSE;
            }
            else {
               h->state=HTTP_GETHEAD;
            }
            break;
         }
         break;

      case HTTP_GETHEAD:
         if (http_getline(h)) {
            if (h->buffer[0] == '\0') {
               /* did we receive a blank line? if so, end of head */
               state->auth_used = state->auth_meth |
                                 (_IS_HTTPS(state) ? SERVER_AUTH_PK : 0);
	            if (state->authenticated) {
	               if (state->context.userid >= 0)
	                  sauth_getusermask(state->context.userid, &state->usergroup, NULL);
	               else
	                  state->usergroup = 0;
	            }
	            else {
	            	state->usergroup = 0;
	            }
#if USE_RABBITWEB
	            if (h->method == HTTP_METHOD_POST &&
	                h->content_length > 0 &&
	                h->content_length <= RWEB_POST_MAXBUFFER &&
	                sspec_gettype(h->spec) == SSPEC_FILE
	               ) {
	               char __far * p2;
	               h->state = HTTP_HANDLEPOST;
	               h->pos = 0;
	               #ifndef USE_LEGACY_RABBITWEB
	               p2 = _sys_realloc(_http_post, h->content_length+1);
	               if (p2)
	               	_http_post = p2;
	               else
	               	h->state = HTTP_PROCESS;
	               #endif
	            }
               else {
#endif
	               h->state = HTTP_PROCESS;
#if USE_RABBITWEB
               }
#endif
            } else {
               http_parsehead(h, 0);
            }
         }
         break;

#if USE_RABBITWEB
		case HTTP_HANDLEPOST:
			// Try to acquire the lock
			#ifdef USE_LEGACY_RABBITWEB
			if (!zhtml_acquire_lock(HTTP_SERVNO))
			#else
			if (!web_acquire_lock(HTTP_SERVNO))
			#endif
			{
				// Could not get the lock--try again next time
				break;
			}
			if (!zhtml_getpost(h)) {
         	break;
         }
         // Finished getting the POST
         // Now, check the variables
         temp = zhtml_checkvars(h);
         if (!temp) {
         	// No errors found -- apply the changes and call update functions
         	// Note that this frees the transaction, since old and new values
         	// are now the same!
            zhtml_applychanges(h);
            h->parser.error = 0;
         }
         else if (temp == 1) {
         	// Errors were found--the page needs to be displayed in error mode
            h->parser.error = 1;
         }
         else if (temp == 2) {
         	// A variable update was attempted but rejected due to permissions
            http_send_403(h);
         	break;
         }
         h->state = HTTP_PROCESS;
      	break;
#endif

      case HTTP_PROCESS:
         http_process(h);
         break;

      case HTTP_FINISHWRITE:
#if USE_RABBITWEB
			#ifdef USE_LEGACY_RABBITWEB
			zhtml_release_lock(HTTP_SERVNO);
			#else
			web_release_lock(HTTP_SERVNO);
			#endif
#endif
      	if ((temp = sock_fastwrite(_SOCK_OF_HTTP(h),
              h->buffer + (int)h->offset,
              (int)h->length - (int)h->offset)) < 0) {
				// Error on socket
         	h->state = HTTP_DIE;
            break;
         }
         h->offset += temp;

         /* reset timeout */
         if(temp)
         	h->main_timeout = set_timeout(HTTP_TIMEOUT);
         if (h->offset >= h->length) {
         	// Finished writing old data.  Buffer now free.
            h->state = h->nextstate;
			}
         break;

      case HTTP_DIE:
#if __HTTP_USE_SSL__
			// For SSL, the close process requires sending a close notify alert,
			// so we have an intermediate state here in which we wait for
			// all pending data to be sent to the peer before really closing,
			// then another state to wait for the close notify to get sent,
			// and unsecure the socket ready for the transport level close.
			if (_IS_HTTPS(h)) {
				if (tls_query_unsent(_SSL_SOCK_OF_HTTP(h))) {
					break;
				}
				sock_close(_SOCK_OF_HTTP(h));
				h->state = HTTP_WAIT_CN;
	 	case HTTP_WAIT_CN:
	         if (tls_query_unsent(_SSL_SOCK_OF_HTTP(h))) {
	            break;
	         }
	         if (state->_n_ssl) {
	            // clean up and de-allocate previous instance
	            sock_unsecure(state->_n_ssl);
	            state->_n_ssl = NULL;
	            state->sock = &state->s;
	         }
			}
			h->state = HTTP_REALLY_DIE;
			// fall thru
	   case HTTP_REALLY_DIE:
#endif
         sock_close(_SOCK_OF_HTTP(h));
         h->state = HTTP_WAITCLOSE;
         // fall through
      case HTTP_WAITCLOSE:
      	// Just to be sure the socket can close...
      	// This is a slight hack, necessitated by the limitations of parsing strings
      	// byte-by-byte.  Sometimes there is a trailing CRLF in the socket which we
      	// have not read.  Must chew it up to proceed.
         if ((len = sock_readable(_SOCK_OF_HTTP(h))) > 1) {
         	--len;
#ifdef HTTP_VERBOSE
				printf("HTTP: discarded %d bytes at close\n", len);
#endif
       		sock_fastread(_SOCK_OF_HTTP(h), NULL, len);	// Discard extraneous
      	}
			_http_abort(HTTP_SERVNO);
         break;

      case HTTP_SENDPAGE:
         if (h->headeroff < h->headerlen) {
         	if ((temp = sock_fastwrite(_SOCK_OF_HTTP(h),
                h->buffer + (int)h->headeroff,
                (int)h->headerlen - (int)h->headeroff)) < 0) {
					// Error on sockets
         		h->state = HTTP_DIE;
               break;
            }
            h->headeroff += temp;

            /* reset timeout */
            if (temp)
            	h->main_timeout = set_timeout(HTTP_TIMEOUT);

            if (h->headeroff >= h->headerlen)
               h->headerlen = state->headeroff = 0;
            break;
         }

         fptr = h->handler;
         if (fptr(h)) {
         	if (h->headeroff < h->headerlen) {
	            h->offset=h->headeroff;
	            h->length=h->headerlen;
	            h->state=HTTP_FINISHWRITE;
	            h->nextstate=HTTP_DIE;
				}
            else
            	h->state = HTTP_DIE;
         }
         break;

#ifdef USE_HTTP_UPLOAD
		_callCGI:
         switch (h->cgifunc(h)) {
         	case CGI_SEND_MORE:
	            h->nextstate = h->state;
            _cgi_sendmore:
	            h->length = strlen(h->buffer);
	            h->state = HTTP_CGI_SENDMORE;
	            break;
         	case CGI_MORE:
            	h->nextstate = h->state;
            	h->state = HTTP_CGI_CONTINUE;
               break;
				case CGI_DONE:
	            h->action = 0;
	            h->state = HTTP_DIE;
               break;
				case CGI_SEND_DONE:
	            h->action = 0;
	            h->nextstate = HTTP_DIE;
               goto _callCGIsend;
				case CGI_SEND:
	            h->nextstate = h->state;
            _callCGIsend:
	            h->length = strlen(h->buffer);
	            h->state = HTTP_CGI_SENDBUF;
               break;
         }
      	break;

      case HTTP_CGI_CONTINUE:
         h->action = CGI_CONTINUE;  // CGI can write more data
         if ((temp = h->cgifunc(h)) == CGI_MORE)
            break;
         h->state = h->nextstate;
         if (temp == CGI_SEND)
         	goto _callCGIsend;
         else if (temp == CGI_SEND_MORE)
         	goto _cgi_sendmore;
			break;

      case HTTP_CGI_SENDBUF:
      	if (!http_write(h, h->buffer, (word)h->length))
         	h->state = h->nextstate;
			break;

      case HTTP_CGI_SENDMORE:
      	if (!http_write(h, h->buffer, (word)h->length))
         	h->state = HTTP_CGI_CONTINUE;
			break;

      case HTTP_CGI_PROLOG:
         switch (temp = http_getcontent(h)) {
         case 0:
         	break;
         case -1:
         	if (h->skipcgi == 1)
            	h->skipcgi = 0;
         	http_init_parthead(h);
            break;
         case -2:
         	// Should not occur (client error)
            h->state = HTTP_CGI_EPILOG;
            break;
         default:
				h->action = CGI_PROLOG;
            h->length = temp;
            if (temp < h->abuffer)
            	h->buffer[temp] = 0;
            if (!h->skipcgi)
            	goto _callCGI;
         }
			break;

      case HTTP_CGI_END:
			http_init_parthead(h);
         // fall through
      case HTTP_CGI_PARTHEAD:
         if (http_getline(h)) {
            h->length = strlen(h->buffer);
            h->content_length -= h->length + 2;
         	if (h->buffer[0]) {
            	// Got part header.  Do processing (for headers server understands)
               // then pass to CGI.
               http_parsehead(h, 1);
	            h->action = CGI_HEADER;
               if (!h->skipcgi)
	            	goto _callCGI;
            }
            else {
            	// Just read blank line.  Part content follows.
         		h->state = HTTP_CGI_PARTDATA;
               h->action = CGI_START;
               if (!h->skipcgi)
               	goto _callCGI;
            }
         }
			break;

      case HTTP_CGI_PARTDATA:
         if (h->action == CGI_START)
            h->part_content_length = 0;
         switch (temp = http_getcontent(h)) {
         case 0:
         	break;
         case -1:
            h->action = CGI_END;
         	h->state = HTTP_CGI_END;
            temp = h->skipcgi;
         	if (h->skipcgi == 1)
            	h->skipcgi = 0;
            if (!temp)
            	goto _callCGI;
            break;
         case -2:
            h->state = HTTP_CGI_EPILOG;
            h->action = CGI_END;
            temp = h->skipcgi;
         	if (h->skipcgi == 1)
            	h->skipcgi = 0;
            if (!temp)
            	goto _callCGI;
            break;
         default:
				h->action = CGI_DATA;
            h->length = temp;
            h->part_content_length += temp;
            if (!h->skipcgi)
	        		goto _callCGI;
         }
			break;


      case HTTP_CGI_EPILOG:
      	// In epilog state, read line-by-line (no boundary check).
         temp = 1;
         if (http_getline(h)) {
	         h->length = strlen(h->buffer);
	         h->content_length -= h->length + 2;
         }
         else {
         	h->length = 0;
            h->buffer[0] = 0;
            temp = 0;
         }
	      h->action = sock_readable(_SOCK_OF_HTTP(h)) && h->content_length > 0 ? CGI_EPILOG : CGI_EOF;
         if (temp && !h->skipcgi || h->action == CGI_EOF)
	      	goto _callCGI;
         break;
#endif

      case HTTP_OLDCGI:
         /* call the user function - if it returns 1, kill the socket */
#ifdef FORM_ERROR_BUF
			if (h->cgifunc) {
#endif
         	if (h->cgifunc(h))
            	h->state = HTTP_DIE;
#ifdef FORM_ERROR_BUF
         } else {
         	if (h->method == HTTP_METHOD_GET) {
         		if (!(fptr = sspec_getformfunction(h->spec)))
         			fptr = http_generateform;
         		if (fptr(h->spec, h, 0))
         			h->state = HTTP_DIE;
         	} else {
         		gotlock = 0;
					if (h->finish_form == 0) {
						// Get the lock
						if (_has_lock_feb(HTTP_SERVNO) == 1) {
							gotlock = 1;	// We have the lock already
						} else if (_lock_feb(HTTP_SERVNO) == 1) {
							gotlock = 1;	// We just got the lock
							_feparsing = 0;
						}
					}
					if ((gotlock == 1) || (h->finish_form == 1)) {
						temp = http_parseform(h->spec, h);
         			if (temp == 1) {
         				_unlock_feb(HTTP_SERVNO);
         				h->state = HTTP_DIE;
         			} else if (temp == 2) {
         				_unlock_feb(HTTP_SERVNO);
         				h->finish_form = 1;
         			}
         		}
         	}
         }
#endif

         /* reset timeout - no timeout on CGI for now */
    	 	//h->main_timeout = set_timeout(HTTP_TIMEOUT);
         break;

      default: /* doh... how did we get here??? */
               /* reset controller... */
         exit(-1);
         break;
      }
   HTTP_END_FORALL_SERVERS
}

/*** BeginHeader */
#define http_getAction(state) ((state)->action)

/* START FUNCTION DESCRIPTION ********************************************
http_getAction	                   <HTTP.LIB>

SYNTAX: char http_getAction(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current CGI action.  This should be called only
					from a CGI function registered as a SSPEC_CGI resource
               in the zserver resource table.

					Note: this is implemented as a macro.  You must define the
               macro USE_HTTP_UPLOAD if using this macro, otherwise you
               will get a compile-time error.

               http_getAction should be called at the top of the CGI
               function.  Other http_get* functions/macros may or may not
               be valid depending on the action code.  The following
               table shows which functions are applicable:

                 Action code    Valid functions/macros
                 -------------  ------------------------------------------
                 any except     http_getContext
                   CGI_ABORT    http_getURL
                                http_getState
                                http_setState
                                http_getCond
                                http_setCond
                                http_getUserState
                                http_getSocket
                                http_write
                                http_abortCGI
                                http_skipCGI
                                http_finishCGI
                                http_switchCGI
                                http_getHTTPVersion
                                http_getHTTPVersion_str
                                http_getHTTPMethod
                                http_getHTTPMethod_str
                                http_getRemainingLength

                 CGI_START      http_getField
                                http_getFileName
                                http_getContentLength
                                http_getContentType
                                http_getContentDisposition
                                http_getTransferEncoding

                 CGI_DATA       http_getField
                                http_getFileName
                                http_getContentLength
                                http_getContentType
                                http_getContentDisposition
                                http_getTransferEncoding
                                http_getData
                                http_getDataLength

                 CGI_END        http_getField
                                http_getFileName
                                http_getContentLength
                                http_getContentType
                                http_getContentDisposition
                                http_getTransferEncoding

                 CGI_HEADER,    http_getData
                   CGI_PROLOG,  http_getDataLength
                   CGI_EPILOG,
                   CGI_EOF

                 CGI_CONTINUE   depends on previous action code at time
                                of returning CGI_MORE, however
                                http_getData will NOT be valid.

                 CGI_ABORT      Should only do resource cleanup.
                                Only the following functions are
                                applicable:
                                http_getContext
                                http_getURL
                                http_getState
                                http_getCond
                                http_getUserState
                                http_getHTTPVersion
                                http_getHTTPVersion_str
                                http_getHTTPMethod
                                http_getHTTPMethod_str

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Action code.  One of the following values:
                 CGI_START  -  start of a part in a multi-part transfer.
                 CGI_DATA   -  binary data for this part
                 CGI_END    -  end of a part
                 CGI_HEADER -  header line of a part
                 CGI_PROLOG -  binary data before the first part
                 CGI_EPILOG -  line of data after the last part
                 CGI_EOF    -  normal end of all parts and epilog
                 CGI_ABORT  -  abnormal termination.  CGI should recover
                               and/or close any open resources.
                 CGI_CONTINUE -  being called from the HTTP server after
                               the CGI previously returned CGI_MORE.

SEE ALSO:		(functions mentioned above), http_defaultCGI

END DESCRIPTION **********************************************************/
/*** EndHeader */

/*** BeginHeader */
#define http_getContext(state) (&(state)->context)
#define http_getSocket(state) (&(state)->s)
#define http_getCond(state, idx) ((state)->cond[idx])
#define http_setCond(state, idx, val) ((state)->cond[idx] = (val))
#define http_getUserState(state) ((void *)(state)->userdata)
#define http_getURL(state) ((state)->url)
#define http_getField(state) ((state)->tag)
#define http_getFileName(state) ((state)->value)
#define http_getContentType(state) ((state)->content_type)
#define http_getContentLength(state) ((state)->part_content_length)
#define http_getRemainingLength(state) ((state)->content_length)
#define http_getContentDisposition(state) ((state)->disposition)
#define http_getTransferEncoding(state) ((state)->transfer_encoding)
#define http_getData(state) ((state)->buffer)
#define http_getDataLength(state) ((word)(state)->length)
#define http_getState(state) ((state)->substate)
#define http_setState(state, val) ((state)->substate = (val))
#define http_getHTTPVersion(state) ((state)->version)
#define http_getHTTPMethod(state) ((state)->method)

/* START FUNCTION DESCRIPTION ********************************************
http_getContext	                   <HTTP.LIB>

SYNTAX: ServerContext * http_getContext(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current HTTP server context.  The context
               pointer is required by many zserver resource handler
               functions.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Pointer to the HTTP server's context structure.  See
               zserver documentation.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getData	                   <HTTP.LIB>

SYNTAX: char far * http_getData(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return a pointer to the data which is available.  It is
               only valid to call this if the action code is one of
               CGI_DATA, CGI_PROLOG, CGI_EPILOG, CGI_HEADER or CGI_EOF.

               When CGI_DATA, this is the next chunk of data received as
               the content of the current part of a multi-part transfer.
               The data arrives in arbitrary amounts.  CRLF boundaries
               (if any) are not respected, and the data may contain
               NULLs and other binary values.  THE CGI MUST CONSUME ALL
               DATA PROVIDED since the data will not be presented again
               on the next call.

               When CGI_PROLOG, this is data that occurs before the
               first boundary (part) but after the main HTTP headers.
               This data (like that for CGI_DATA) is not line-oriented.

               When CGI_EPILOG, CGI_HEADER or CGI_EOF, the
               data will be a complete line of input (with the terminating
               CRLF stripped off).  The returned string will also be
               null-terminated.  When CGI_EOF, the data (if any) is
               technically part of the epilog.

               Prolog data is lines of input which were provided before
               the first "official" part of the multi-part data.  Most
               HTTP clients will not provide any prolog data.  Epilog
               data is lines of data after the last official part.
               Again, HTTP clients do not usually generate it.  It is
               always safe to ignore prolog and epilog data, since it
               is usually provided only for non-MIME compliant servers.

               Data provided when the action is CGI_HEADER is a line of
               header data provided at the start of each part of the
               multi-part data.  It is safe for the CGI to ignore header
               lines, since the HTTP server also processes the ones that
               it needs.  The CGI is given these header lines so that it
               can extract useful or customized information if desired.

               The length of the data may be obtained using
               http_getDataLength().

               The CGI is allowed to overwrite data at the returned
               area, provided that it writes no more than HTTP_MAXBUFFER
               bytes.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Pointer to first character of data.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getDataLength	                   <HTTP.LIB>

SYNTAX: word http_getDataLength(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the length of data which is available.  It is
               only valid to call this if the action code is one of
               CGI_DATA, CGI_PROLOG, CGI_EPILOG, CGI_HEADER or CGI_EOF
               i.e. when it is valid to call http_getData().

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Length of available data.  0 will only be returned for
               PROLOG and EPILOG when a blank line is read.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getContentLength	                   <HTTP.LIB>

SYNTAX: long http_getContentLength(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the length of data in the current part of a
               multi-part data stream.  The return value is interpreted
               differently, depending on the action code.

               It is only valid to call this when the action code
               is CGI_START, CGI_DATA or CGI_END.

               When CGI_START, this returns the value of the ContentLength
               header for this part (or -1 if there was no such header).

               When CGI_DATA or CGI_END, it is the total number of bytes
               that have actually been read and presented to the CGI.  This
               increases for each CGI_DATA call, until it represents the
               total content length when action is CGI_END.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Length of part data.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getRemainingLength	                   <HTTP.LIB>

SYNTAX: long http_getRemainingLength(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the remaining length of the incoming data stream.
               This length includes all parts (not just the current
               part) and also includes the boundary separators and
               epilog data.  Normally, this value will be zero when
               the action code is CGI_EOF.  If the value is negative,
               then the client might not have indicated the total data
               length, or might not have set the right value.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Length of remaining data, or negative if not known.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getContentType	                   <HTTP.LIB>

SYNTAX: char * http_getContentType(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current content type of the data which is being
               provided by the client.  This is a MIME type string e.g.
               "text/html" or "image/jpeg".

               The CGI might need to look at this to determine the
               appropriate way to process the data.  Normal form fields
               will usually contain "text/plain", however uploaded
               files may contain any type of data.

               It is only valid to call this when the action code
               is CGI_START, CGI_DATA or CGI_END.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Null terminated string containing the MIME type name.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getContentDisposition	                   <HTTP.LIB>

SYNTAX: char http_getContentDisposition(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current disposition of the data which is being
               provided by the client.  This is one of the following
               enumerated values:

                 MIME_DISP_NONE: unspecified disposition
                 MIME_DISP_INLINE: the content is to be displayed
                   "inline"
                 MIME_DISP_ATTACHMENT: the content is only to be
                   displayed if there is some action by the user
                 MIME_DISP_FORMDATA: the content is form field data
                   (or an uploaded file).

               Of these, only NONE and FORMDATA are really relevant to
               HTTP.

               It is only valid to call this when the action code
               is CGI_START, CGI_DATA or CGI_END.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Content disposition code, as documented above.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getTransferEncoding	                   <HTTP.LIB>

SYNTAX: char http_getTransferEncoding(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current encoding of the data which is being
               provided by the client.  This is one of the following
               enumerated values:

						CTE_BINARY  The default
						CTE_7BIT    7-bit safe ASCII
						CTE_8BIT    8-bit ASCII
						CTE_QP      Quoted printable
						CTE_BASE64  Base 64

               Of these, the CGI is only likely to see CTE_BINARY, since
               HTTP is an 8-bit protocol, and most clients (browsers)
               will not bother to encode the data.  Encoding is only
               an issue for internet mail, which sometimes has to cross
               interfaces which do not support full 8-bit binary
               transfers.

               If the CGI detects a transfer encoding which requires
               non-null operation (i.e. CTE_QP or CTE_BASE64) then it
               should either reject the transfer, or decode the data
               as it comes in.

               It is only valid to call this when the action code
               is CGI_START, CGI_DATA or CGI_END.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Transfer encoding code, as documented above.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getHTTPVersion	                   <HTTP.LIB>

SYNTAX: char http_getHTTPVersion(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the HTTP version number of the current request
               protocol.  The CGI might need to look at this in order
               to generate the correct response headers.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  One of the following codes:
                 HTTP_VER_09   - version 0.9
                 HTTP_VER_10   - version 1.0
                 HTTP_VER_11   - version 1.1
               Other codes may be returned in the future.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getHTTPMethod	                   <HTTP.LIB>

SYNTAX: char http_getHTTPMethod(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the HTTP request method of the current request
               protocol.  The CGI might need to look at this in order
               to generate the correct response headers.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  One of the following codes:
                 HTTP_METHOD_GET  - "GET" i.e. normal retrieval, without
                   making any permanent state update.
                 HTTP_METHOD_POST - "POST" i.e. uploading some information
                   to be stored, or making some permanent state change.
                   This is the normal method for invoking CGIs.
                 HTTP_METHOD_HEAD - "HEAD" i.e. the client only wants
                   the headers, not the actual content e.g. it might
                   be trying to determine the most recent modification
                   date.
               Other codes may be returned in the future.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getField	                   <HTTP.LIB>

SYNTAX: char * http_getField(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current form field name.  This function should
               only be called when the action code is CGI_START, CGI_DATA
               or CGI_END.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Null terminated string containing the current field name.
               The field name is the name of a form element, specified
               using e.g. <INPUT TYPE="TEXT" NAME="srv_file"> in the
               HTML, where srv_file will be the field name in this case.
               If there was no "name=" parameter in the returned form
               data, this will be an empty string (zero length, not NULL).

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getFileName	                   <HTTP.LIB>

SYNTAX: char * http_getFileName(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current "filename".  This function should
               only be called when the action code is CGI_START, CGI_DATA
               or CGI_END.  The filename is not always supplied by the
               client.  It refers to the client's idea of the file name
               which is being uploaded.  Any directory path information
               is discarded i.e. the first character stored is the
               first character after the last '/' or '\' character in
               the file name provided.  Only the first HTTP_MAXNAME-1
               characters will be stored.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Null terminated string containing the current file name.
               If there was no "filename=" parameter in the content
               disposition header, or the filename ended with '/' or
               '\', this will be an empty string (zero length, not NULL).

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getURL	                   <HTTP.LIB>

SYNTAX: char * http_getURL(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the URL of the current HTTP client request.  In a
               CGI, this will usually be something like "foo.cgi".

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Null terminated string containing the URL.  Note that
               GET-style form parameters will be stripped off e.g. a
               URL of foo.cgi?A=99&D=-45 will be returned as foo.cgi.
               The GET parameters are available using http_getCond().

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getSocket	                   <HTTP.LIB>

SYNTAX: tcp_Socket * http_getSocket(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current HTTP server socket.  The socket may be
               written/read, however this is inadvisable since it may
               interfere with the server's use of it.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Pointer to the HTTP server's TCP socket structure.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getState	                   <HTTP.LIB>

SYNTAX: int http_getState(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current primary HTTP CGI state variable.

               Use of this state variable is entirely up to the
               application, however it is initialized by the HTTP
               server to zero before calling the CGI for the first
               time.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Value of primary state variable.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_setState	                   <HTTP.LIB>

SYNTAX: int http_setState(HttpState * state, int val)

KEYWORDS:		tcpip, http

DESCRIPTION:   Set the current primary HTTP CGI state variable.

               Use of this state variable is entirely up to the
               application, however it is initialized by the HTTP
               server to zero before calling the CGI for the first
               time.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.
PARAMETER2:		New value for the primary state variable.

RETURN VALUE:  Returns the new value i.e. "val".

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getCond	                   <HTTP.LIB>

SYNTAX: int http_getCond(HttpState * state, int idx)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the current HTTP condition state variable.  There
               are HTTP_MAX_COND of these integer state variables, thus
               "idx" must be between 0 and HTTP_MAX_COND-1, inclusive.

               Use of these state variables is entirely up to the
               application, however they are initialized by the HTTP
               server under certain conditions.  By default, they are
               set to zero at the start of each request from the client.
               If the client request includes URL GET-type parameters
               of the form http://host/resource.html?A=1&B=2&C=3 etc.
               then cond state 0 is set to the value for 'A', cond state
               1 is set to the value for 'B' etc.  The values must be
               integers, which are coerced to 16 bit signed integers.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.
PARAMETER2:   	Index of cond: 0..HTTP_MAX_COND-1.  Validity is not
               checked.

RETURN VALUE:  Value of state variable "idx".

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_setCond	                   <HTTP.LIB>

SYNTAX: int http_setCond(HttpState * state, int idx, int val)

KEYWORDS:		tcpip, http

DESCRIPTION:   Set the value of an HTTP condition state variable.  There
               are HTTP_MAX_COND of these integer state variables, thus
               "idx" must be between 0 and HTTP_MAX_COND-1, inclusive.

					Note: this is implemented as a macro.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.
PARAMETER2:   	Index of cond: 0..HTTP_MAX_COND-1.  Validity is not
               checked.
PARAMETER3:   	New value

RETURN VALUE:  Returns the new value i.e. "val".

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/* START FUNCTION DESCRIPTION ********************************************
http_getUserState	                   <HTTP.LIB>

SYNTAX: void * http_getUserState(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Get the "user state" area of the HTTP server structure.
               This is an area of memory which can be used by the CGI
               to keep track of its internal state, from call to call.

               The size of this area is HTTP_USERDATA_SIZE.  If that
               macro is not defined, it defaults to zero, so use of
               the http_getUserState macro will result in a compile-time
               error.

					Note: this is implemented as a macro.

               Example:

                 typedef struct { ... } myCGIdata;
                 ...
                 #define HTTP_USERDATA_SIZE sizeof(myCGIdata)
                 #use "http.lib"
                 ...
                 int myCGI(HttpState * s) {
                   myCGIdata * d;
                   d = (myCGIdata *)http_getUserState(state);
                   ...
                 }

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  Returns the address of the first byte of the user area.
               This should be cast to the appropriate structure type.

SEE ALSO:		http_getAction

END DESCRIPTION **********************************************************/
/*** EndHeader */

/*** BeginHeader http_getHTTPVersion_str */
char *http_getHTTPVersion_str(HttpState * state);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_getHTTPVersion_str	                   <HTTP.LIB>

SYNTAX: char *http_getHTTPVersion_str(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the HTTP version number of the current request
               protocol.  The CGI might need to look at this in order
               to generate the correct response headers.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  One of the following strings:
                 "0.9"     - version 0.9
                 "1.0"     - version 1.0
                 "1.1"     - version 1.1
                 "unknown"	- unknown version

               Other strings may be returned in the future.

SEE ALSO:		http_getHTTPVersion, http_getAction

END DESCRIPTION **********************************************************/
_http_nodebug
char *http_getHTTPVersion_str(HttpState * state)
{
	switch (state->version)
	{
		case HTTP_VER_09:			return "0.9";
		case HTTP_VER_10:			return "1.0";
		case HTTP_VER_11:			return "1.1";
		default:						return "unknown";
	}
}

/*** BeginHeader http_getHTTPMethod_str */
char *http_getHTTPMethod_str(HttpState * state);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_getHTTPMethod_str	                   <HTTP.LIB>

SYNTAX: char *http_getHTTPMethod_str(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Return the HTTP request method of the current request
               protocol.  The CGI might need to look at this in order
               to generate the correct response headers.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  One of the following strings:
                 "GET"    (HTTP_METHOD_GET) i.e. normal retrieval, without
                   making any permanent state update.
                 "POST"   (HTTP_METHOD_POST) i.e. uploading some information
                   to be stored, or making some permanent state change.
                   This is the normal method for invoking CGIs.
                 "HEAD"   (HTTP_METHOD_HEAD) i.e. the client only wants
                   the headers, not the actual content e.g. it might
                   be trying to determine the most recent modification
                   date.
                 "unknown" -- returned for unrecognized method

               Other strings may be returned in the future.

SEE ALSO:		http_getHTTPMethod, http_getAction

END DESCRIPTION **********************************************************/
_http_nodebug
char *http_getHTTPMethod_str(HttpState * state)
{
	switch (state->method)
	{
		case HTTP_METHOD_GET:	return "GET";
		case HTTP_METHOD_POST:	return "POST";
		case HTTP_METHOD_HEAD:	return "HEAD";
		default:						return "unknown";
	}
}

/*** BeginHeader http_write */
int http_write(HttpState * state, char __far * data, word length);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_write	                   <HTTP.LIB>

SYNTAX: int http_write(HttpState * state, char far * data, word length)

KEYWORDS:		tcpip, http

DESCRIPTION:   Write data back to the client.

               This function either sends all of the given data, or
               none of it.  If the data cannot be sent (e.g. because the
               socket transmit buffer is already full) then a special
               return code indicates that the CGI should try again on
               the next call.

               Often, the CGI itself will not need to write anything
               to the client -- the http_switchCGI() function takes care
               of most needs.  If this function is used, then the CGI is
               responsible for generating the correct HTTP response
               (including headers) and http_switchCGI() and similar
               functions should NOT be called.

               Note: use of this function can often be avoided.
               Instead, the CGI can copy a string to the pointer
               provided by http_getData(), then return CGI_SEND.  This
               will cause the server to send out the (null terminated)
               string in the buffer, and not call the CGI until the
               string is sent to the client.  See the source to
               http_defaultCGI for example.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.
PARAMETER2:   	Pointer to first char to transmit.  It is OK to
               make this the same pointer that was returned by
               http_getData(), since that buffer can be used for
               output as well as input.  In any case, the CGI must
               ensure that it has processed any incoming data before
               writing new data to that buffer.
PARAMETER3:   	Length of data to transmit.  This should be less than or
               equal to the defined HTTP server socket buffer length.

RETURN VALUE:  0: data written (or buffered) successfully.
               CGI_MORE: data not written, try again on next call to the
                 CGI.  In general, the CGI should pass this code
                 (CGI_MORE) back to the HTTP server.  When the server
                 calls the CGI next time, it will set the action code to
                 CGI_CONTINUE which will be a cue to the CGI to try
                 retransmitting the previous data.  When CGI_CONTINUE
                 is provided, the contents in the http_getData() buffer
                 will not have been altered.

SEE ALSO:		http_getAction, http_skipCGI, http_switchCGI,
               http_finishCGI, http_abortCGI, http_defaultCGI

END DESCRIPTION **********************************************************/

_http_nodebug int http_write(HttpState * state, char __far * data, word length)
{
	auto int wr;

   if (!length)
   	return 0;
   wr = sock_writable(_SOCK_OF_HTTP(state));
   if (wr > length) {
   	sock_fastwrite(_SOCK_OF_HTTP(state), data, length);
      return 0;
   }
	return CGI_MORE;
}


/*** BeginHeader http_abortCGI */
int http_abortCGI(HttpState * state);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_abortCGI	                   <HTTP.LIB>

SYNTAX: int http_abortCGI(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Terminate this CGI request.  The client will receive an
               error message indicating the connection was closed.

               NOTE: the CGI should clean up any resources that it
               opened, since no further calls are made to this CGI for
               this request.

               The CGI should not make any further HTTP calls after
               calling this function.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  0

SEE ALSO:		http_getAction, http_skipCGI, http_switchCGI,
               http_finishCGI, http_write

END DESCRIPTION **********************************************************/

_http_nodebug int http_abortCGI(HttpState * state)
{
	state->action = 0;	// Don't re-invoke CGI out of _http_abort
   state->state = HTTP_DIE;
   sock_abort(_SOCK_OF_HTTP(state));
   return 0;
}

/*** BeginHeader http_skipCGI */
int http_skipCGI(HttpState * state);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_skipCGI	                   <HTTP.LIB>

SYNTAX: int http_skipCGI(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Indicate to the HTTP server that the CGI has finished
               processing this part of a multi-part data stream.  The
               server reads (and discards) data from the stream until
               the next part is found (or the epilog).  When the
               next part is found, the server continues calling the
               CGI function as before.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  0

SEE ALSO:		http_getAction, http_abortCGI, http_switchCGI,
               http_finishCGI, http_write

END DESCRIPTION **********************************************************/

_http_nodebug int http_skipCGI(HttpState * state)
{
	state->skipcgi = 1;
   return 0;
}

/*** BeginHeader http_finishCGI */
int http_finishCGI(HttpState * state);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_finishCGI	                   <HTTP.LIB>

SYNTAX: int http_finishCGI(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   Indicate to the HTTP server that this CGI has finished
               processing data from this multi-part data stream.  The
               server reads (and discards) data to the end of the entire
               stream (including epilog).  The next call to the CGI
               function will have an action code of CGI_EOF (or possibly
               CGI_ABORT if there was a stream error).

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.

RETURN VALUE:  0

SEE ALSO:		http_getAction, http_skipCGI, http_switchCGI,
               http_abortCGI, http_write

END DESCRIPTION **********************************************************/

_http_nodebug int http_finishCGI(HttpState * state)
{
	state->skipcgi = 2;
   return 0;
}

/*** BeginHeader http_switchCGI */
int http_switchCGI(HttpState * state, char __far * newURL);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_switchCGI	                   <HTTP.LIB>

SYNTAX: int http_switchCGI(HttpState * state, char far * newURL)

KEYWORDS:		tcpip, http

DESCRIPTION:   Tell the HTTP server to switch processing to a different
               CGI function or resource.

               Note: the CGI is responsible for generating the correct
               HTTP response header(s) using http_write() etc.  If
               this function is used to pass control to a different
               CGI, then both CGIs must co-ordinate so that only one
               header is written.  You can use the HTTP state variable
               (http_setState() and http_getState()) and/or
               http_getUserState() to achieve the necessary co-ordination.

               If newURL refers to a file or SSI resource (not a CGI),
               then the CGI function must NOT have already written the
               HTTP response header(s) -- the headers will be generated
               when the new resource is opened.

               If newURL refers to a new-style CGI (i.e. a CGI resource
               added using SSPEC_CGI, not SSPEC_FUNCTION) then that CGI
               is presented with the remaining content of the current
               request data stream.

               If newURL refers to an old-style CGI (i.e. a CGI added
               using SSPEC_FUNCTION or HTTPSPEC_FUNCTION) then the HTTP
               server abandons parsing of the request data stream, since
               old-style CGIs are expected to read the HTTP socket
               themselves.

               Rather than calling http_switchCGI(), it is often more
               convenient to call cgi_redirectto(), which tells the client
               to retrieve the next resource rather than the resource
               being provided in the current connection.  Using redirect
               is less efficient, however.

PARAMETER1:   	HTTP state pointer, as provided in the first parameter to
               the CGI function.
PARAMETER2:		The resource name to present to the client.  This may
               be another CGI, or any other type of resource that
               could be presented to the client in response to an HTTP
               GET or POST request.  The resource must exist in the
               flash- or ram-spec table, or in a filesystem.

RETURN VALUE:  0

SEE ALSO:		http_getAction, http_skipCGI, http_abortCGI,
               http_finishCGI, http_write

END DESCRIPTION **********************************************************/

_http_nodebug int http_switchCGI(HttpState * state, char __far * newURL)
{
#ifdef HTTP_VERBOSE
	printf("CGI: handing over to %ls\n", newURL);
#endif
	_f_strcpy(state->url, newURL);
   if (state->spec >= 0)
   	sspec_close(state->spec);
   state->spec = sspec_open(state->url, &state->context, O_READ, 0);
#ifdef USE_HTTP_UPLOAD
   state->action = 0;
#endif
	return http_process(state);
}


/*** BeginHeader http_defaultCGI */
int http_defaultCGI(HttpState * state);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_defaultCGI	                   <HTTP.LIB>

SYNTAX: int http_defaultCGI(HttpState * state)

KEYWORDS:		tcpip, http

DESCRIPTION:   This function should not be called directly by the
               application.  It is intended to be used as a new-style
               CGI for handling file uploads.

                 See "samples\tcpip\http\upld_fat.c" for an example
                 of using this function.

               This CGI function accepts POST requests from the
               client (browser) which may contain one or more files
               which are being uploaded.  It looks at the field name
               of the form data in the request.  If the field name
               starts with '/', it is assumed to be the name of a
               resource which is to be created (if it does not already
               exist) and overwritten with the uploaded file contents.

               There are 3 steps required to use this CGI:

               (1) Define a CGI resource in the flash- or ram-spec table.
               If using flashspec, for example, there would be an entry
               like

	               SSPEC_RESOURCETABLE_START
	                SSPEC_RESOURCE_XMEMFILE("/index.html", index_html),
                   SSPEC_RESOURCE_CGI("/upload.cgi", http_defaultCGI)
	               SSPEC_RESOURCETABLE_END

               There may be other resources, but at least 2 are normally
               required.  One resource is a web page (see below) which
               contains a form which the user can fill in with the name
               of the file to upload.  The other resource (CGI) is a
               reference to this function, giving it a URL name which
               identifies it to the browser.

               (2) Create a web page which contains a form like
               the following skeleton example:
                 <FORM ACTION="/upload.cgi" METHOD="POST"
                              enctype="multipart/form-data">
                 <INPUT TYPE="FILE" NAME="/A/incoming/new.htm">
	              <INPUT TYPE="SUBMIT" VALUE="Upload">
	              </FORM>

               in the <FORM> element, the ACTION= parameter specifies
               the URL assigned to this CGI.  In the <INPUT TYPE=
               "FILE"> element, the NAME= parameter specifies the
               resource name which will be used to contain the
               uploaded file contents.  In this example, the
               resource is called "/A/incoming/new.htm", which will
               work if you are using the FAT filesystem.

                 [Note: if uploading to a subdirectory, "incoming" in
                  the above example, the subdirectory must already
                  exist.  If not, the upload will fail.]

               (3) You will probably wish to add user authentication and
               other facilities for a real application.  When
               considering security, note that there are three possible
               things to protect:

               (a) the web page which contains the form.  Give read
               access only to those users who could conceivably upload
               the files specified therein.

               (b) the CGI itself (this function).  Protect as for (a).

               (c) the uploaded resource.  You should set up a rule
               allowing write access only to the intended user(s).

                 [Note: when defining user IDs which can use the
                  upload, don't forget to give those users overall
                  write access using e.g.
                  sauth_setwriteaccess(uid, SERVER_HTTP)].

               Be aware that "rogue clients" could easily change the
               resource name to something other than the one that was
               intended in the original form.  This is why resource
               protection is important.

               Having done these three things, the HTTP server is now
               set up to automatically place uploaded files in the
               filesystem.

               Note that this CGI is limited to placing files into
               fixed resource locations (as specified by the field
               name of the INPUT element).  If you need more
               sophisticated control, you may wish to write your own
               CGI function, using the code of this one as a starting
               point.

               This CGI also presents a default status web page back
               to the client.  This page indicates whether or not the
               upload was successful, the number of bytes uploaded,
               and a link to test out the new file (assuming it is
               something the browser will understand, such as an HTML
               document or GIF image).  You can use this function as
               a starting point for generating your own content.

PARAMETER1:   	HTTP state pointer, provided by HTTP server to all CGIs.

RETURN VALUE:  See documentation for "writing a data handler CGI"

SEE ALSO:		http_getAction, http_skipCGI, http_switchCGI,
               http_FinishCGI, http_write

END DESCRIPTION **********************************************************/

// Values for http_getState()
#define HTTP_DFLTUPLD_INIT		0	// Initial state, set by server (must be 0)
#define HTTP_DFLTUPLD_NORM		1	// Normal state (reading client data)
#define HTTP_DFLTUPLD_WRITING	2	// Writing uploaded data to the resource, but resource could not
											// "swallow" all the data on the last call.

// http_setCond() state variables
#define HTTP_DFLTUPLD_SPEC			0	// Resource handle (>=0) or error code (<0)
#define HTTP_DFLTUPLD_WROTE		1	// Amount already written in partial write to client
#define HTTP_DFLTUPLD_FILECOUNT	2	// Counter for number of files uploaded successfully.

#if HTTP_MAX_COND < 3
	#fatal "HTTP_MAX_COND must be >= 3 if using http_defaultCGI()"
#endif


_http_nodebug int http_defaultCGI(HttpState * s)
{
	auto char date[30];		// Buffer for creating the HTTP "Date:" string.
	auto char * fname;		// Pointer to field (i.e. resource to upload) name
   auto int rc, spec, len, mode, wlen;
#ifdef HTTP_VERBOSE
	static long ms;			// In verbose mode, keep track of throughput.
#endif

	if (!(mode = http_getState(s))) {
   	// Initial state (HTTP_DFLTUPLD_INIT).  Do things we want to do only
      // once at the start.
#ifdef HTTP_VERBOSE
      printf("HTTPU: init:\n");
      printf("  HTTP version=%s\n", http_getHTTPVersion_str(s));
      printf("  HTTP method=%s\n", http_getHTTPMethod_str(s));
      printf("  Userid=%d\n", http_getContext(s)->userid);
      printf("  URL=%ls\n", http_getURL(s));
#endif
   	// First time through.  Generate HTTP header
      http_setState(s, HTTP_DFLTUPLD_NORM);		// Next state is "normal"
      http_setCond(s, HTTP_DFLTUPLD_SPEC, -1);	// No open resource yet
      http_setCond(s, HTTP_DFLTUPLD_FILECOUNT, 0);	// No files as yet
      // Note: it is safe to use the getData buffer, since the first call to
      // the CGI will not have any incoming data in that buffer.
	   http_genHeader(s, http_getData(s), s->abuffer,
                  200, NULL, 0,
                  "<html><head><title>Upload status</title></head><body>");
      return CGI_SEND;	// Write string to client.
   }

   // Default return code.
   rc = 0;

   // Get the resource handle (or -1 if no resource open).
   spec = http_getCond(s, HTTP_DFLTUPLD_SPEC);

   // Main switch depending on the current CGI action code
	switch (http_getAction(s)) {

   	case CGI_CONTINUE:
      	// Continuation because we returned CGI_MORE on the last call.
#ifdef HTTP_VERBOSE
			printf("HTTPU: CONTINUE: mode=%d\n", mode);
#endif
      	if (mode == HTTP_DFLTUPLD_WRITING) {
            // We were writing buffer to resource
            http_setState(s, HTTP_DFLTUPLD_NORM);  // Set back to normal mode
            len = http_getCond(s, HTTP_DFLTUPLD_WROTE); // Get length already written
            // Write the bit we couldn't write before.
            wlen = sspec_write(spec, http_getData(s)+len, http_getDataLength(s)-len);
            if (wlen < 0)
               goto _closeError;
            len += wlen;
            if (len < http_getDataLength(s))
            	// Still not complete.
	            goto _partialwrite;
         }
         	// any other mode we ignore (should never happen)
      	break;

   	case CGI_START:
      	// Start of a new part of the multi-part data.
      	fname = http_getField(s);
#ifdef HTTP_VERBOSE
      	printf("HTTPU: START content_length=%ld\n", http_getContentLength(s));
         printf("  field name=%s\n", fname);
         printf("  disposition=%d\n", http_getContentDisposition(s));
         printf("  transfer_encoding=%d\n", http_getTransferEncoding(s));
         printf("  content_type=%s\n", http_getContentType(s));
         ms = MS_TIMER;
#endif
         if (fname[0] == '/') {
         	// Yes, it's a file to upload
				spec = sspec_open(fname, http_getContext(s), O_WRITE|O_CREAT|O_TRUNC, 0);
            http_setCond(s, HTTP_DFLTUPLD_SPEC, spec); // Save spec (or error code)
            if (spec < 0) {
      			sprintf(http_getData(s),
                 "<h1><font color=red>%s failed: could not open.</h1>" \
                 "<h2>Error code %d</h2>\r\n"
                 , fname
                 , -spec
                 );
               http_skipCGI(s);	// Skip to next part
               return CGI_SEND;		// ...after sending this buffer
      		}
            else {
            	// Try writing a string to the client.  Most browsers will be able to
               // display this straight away.  This will give some confirmation that
               // something is happening.
	            sprintf(http_getData(s),
	              "<h2>Loading %s...</h2>"
	              , fname
	              );
	            return CGI_SEND;
            }
         }
         else
         	http_skipCGI(s);	// Not a file: skip to next part.
         break;

   	case CGI_DATA:
      	// This is data to write to the resource.
         if (spec < 0)
         	// This should never happen (since we always skip data if there is an error
            // opening the resource), but it doesn't hurt to check!
         	return 0;
#ifdef HTTP_VERBOSE
      	printf("HTTPU: DATA length=%d (total %ld)\n", http_getDataLength(s), http_getContentLength(s));
#endif
      	len = sspec_write(spec, http_getData(s), http_getDataLength(s));
         if (len < 0) {
         	_closeError:
         		sspec_close(spec);
               http_setCond(s, HTTP_DFLTUPLD_SPEC, len);	// Save error code
      			sprintf(http_getData(s),
                 "<h1><font color=red>%s failed: could not write.</h1>" \
                 "<h2>Error code %d</h2>\r\n"
                 , http_getField(s)
                 , -len
                 );
               http_skipCGI(s);	// Skip to next part
               return CGI_SEND;	// ...after sending this message
         }
         else {
         	if (len < http_getDataLength(s)) {
            _partialwrite:
            	// Partial write.  Set state to HTTP_DFLTUPLD_WRITING and return CGI_MORE.  Next call
               // will have action code set to CGI_CONTINUE.
               http_setState(s, HTTP_DFLTUPLD_WRITING);
               http_setCond(s, HTTP_DFLTUPLD_WROTE, len);	// Amount already written
               rc = CGI_MORE;
            }
         }
         break;

   	case CGI_END:
      	// End of this file.  Close it.
#ifdef HTTP_VERBOSE
			ms = MS_TIMER - ms;
         if (ms < 1) ms = 1;
      	printf("HTTPU: END ----------- actual received length=%ld, %f sec, %f bytes/sec\n",
         	http_getContentLength(s), 0.001*ms, (float)http_getContentLength(s)*1000.0/ms);
#endif
     		sspec_close(spec);
         // Increment successful file count.
         http_setCond(s, HTTP_DFLTUPLD_FILECOUNT, http_getCond(s, HTTP_DFLTUPLD_FILECOUNT) + 1);
      	http_setCond(s, HTTP_DFLTUPLD_SPEC, -1);	// No open resource now
         sprintf(http_getData(s),
           "<h1><font color=#009900>%s uploaded successfully.</font>  " \
           "<a href=\"%s\">Test</a>.</h1>" \
           "<h2>Total bytes: %ld.</h1>"
           , http_getField(s)
           , http_getField(s)
           , http_getContentLength(s)
           );
         return CGI_SEND;

      case CGI_EOF:
      	// Normal end of entire set of parts.
#ifdef HTTP_VERBOSE
      	printf("HTTPU: EOF (unused content=%ld) \"%s\"\n", s->content_length, http_getData(s));
#endif
         sprintf(http_getData(s),
           "<h1>Total files uploaded successfully: %d.</h1>" \
           "<p><a href=\"/\">Home</a></p>" \
           "</body></html>\r\n"
           , http_getCond(s, HTTP_DFLTUPLD_FILECOUNT)
           );
         // Send this last message, and we are done!
         return CGI_SEND_DONE;

      case CGI_ABORT:
      	// Server had to abort the connection.
#ifdef HTTP_VERBOSE
      	printf("HTTPU: ABORT CGI\n");
#endif
			// Clean up resource if one was open.
			if (spec >= 0)
         	sspec_close(spec);
         break;
   }

   // Return one of
   //  0 : normal continuation
   //  CGI_MORE : call back with CGI_CONTINUE since we hadn't finished something
   //  CGI_DONE : terminate the connection normally.
   //  CGI_SEND : send what's in the buffer
   //  CGI_SEND_DONE : send what's in the buffer, and we're done.
   return rc;
}

/*** BeginHeader http_findname */
int http_findname(char* name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_findname	                   <HTTP.LIB>

SYNTAX: int http_findname(char* name);

KEYWORDS:		tcpip, http

DESCRIPTION: 	Finds a spec entry, searching first in RAM, then in FLASH.

					This function deprecated.  Use sspec_findname().

PARAMETER1:   	Name, in text, of the spec to find.

RETURN VALUE:  The spec entry.

SEE ALSO:		sspec_findname

END DESCRIPTION **********************************************************/

/* Returns a SPEC, given a filename (and searches in the proper order) */
_http_nodebug int http_findname(char* name)
{
   return sspec_findname(name, SERVER_HTTP | SERVER_HTTPS);
}

/*** BeginHeader http_addfile */
int http_addfile(char* name, long location);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_addfile	                   <HTTP.LIB>

SYNTAX: int http_addfile(char *name, long location);

KEYWORDS:		tcpip, http

DESCRIPTION:	Adds a file to the RAM spec table.

PARAMETER1:	Name of the file (ie: "/index.html")
PARAMETER2:	Address of the file data. (from #ximport)

RETURN VALUE:	0 on success, 1 on failure

SEE ALSO:	http_delfile

END DESCRIPTION **********************************************************/

_http_nodebug int http_addfile(char* name, long location)
{
   auto int spec;

   spec=sspec_addxmemfile(name, location, SERVER_HTTP | SERVER_HTTPS);
   if (spec == -1) {
   	return 1;
   } else {
   	return 0;
   }
}

/*** BeginHeader http_delfile */
int http_delfile(char* name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_delfile	                   <HTTP.LIB>

SYNTAX: int http_delfile(char *name);

KEYWORDS:		tcpip, http

DESCRIPTION:	Deletes a file from the RAM spec table.

PARAMETER1:	Name of the file, as passed to http_addfile.

RETURN VALUE:	0 on success, 1 on failure (not found)

SEE ALSO:	http_addfile

END DESCRIPTION **********************************************************/

_http_nodebug int http_delfile(char* name)
{
   auto int spec;

   spec=sspec_findname(name, SERVER_HTTP | SERVER_HTTPS);
   if (spec == -1) {
   	return 1;
   }

   sspec_remove(spec);
   return 0;
}

/*** BeginHeader http_getcontext */
ServerContext * http_getcontext(int servno);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_getcontext	                   <HTTP.LIB>

SYNTAX: ServerContext * http_getcontext(int servno)

KEYWORDS:		tcpip, http

DESCRIPTION:	Return the ServerContext struct for the specified HTTP
               server instance.

PARAMETER1:		Server instance number (0..HTTP_MAXSERVERS-1)

RETURN VALUE:	NULL: invalid server instance.
               Otherwise, pointer to this server's ServerContext.  This
               structure should not be modified by the application.

END DESCRIPTION **********************************************************/

_http_nodebug ServerContext * http_getcontext(int x)
{
	if (x < 0 || x >= HTTP_MAXSERVERS)
		return NULL;
   return &http_servers HTTP_X.context;
}

/*** BeginHeader http_readfromfile */
int http_readfromfile(HttpState *state, char __far *buf, int len);
/*** EndHeader */

_http_nodebug int http_readfromfile(HttpState *state, char __far *buf, int len)
{
	// This is only called by shtml handler.
	auto int bytes;

#ifdef HTTP_VERBOSE
	printf("HTTP: reading file: pos=%ld len=%d to %ld..%ld\n",
			state->pos, len, buf-state->buffer, buf-state->buffer+len);
#endif

	// Case 1:  sspec file
   if ((bytes = sspec_read(state->spec, buf, len)) <= 0)
      return -1;
   state->pos += bytes;
   return bytes;
}

/*** BeginHeader cgi_continue */
#define cgi_continue http_switchCGI

/* START FUNCTION DESCRIPTION ********************************************
cgi_continue	                   <HTTP.LIB>

SYNTAX: int cgi_continue(HttpState * state, char * localurl)

KEYWORDS:		tcpip, http, cgi

DESCRIPTION:	Called from a CGI function after processing any data
               submitted.  This function continues creating a response
               as if from a normal GET request to the specified local URL.

               NOTE: the CGI function should not have sent any data to
               the socket.

               NOTE: this function is now an alias for http_switchCGI().

PARAMETER1:	   A pointer to the HTTP server state structure.
PARAMETER2:    The URL string, which must be a URL defined in the
               server spec table (otherwise the browser will see
               a "not found" message).

RETURN VALUE:	0

END DESCRIPTION **********************************************************/
/*** EndHeader */


/*** BeginHeader http_seek */
int http_seek(HttpState __far *state, long new_pos);
/*** EndHeader */


_http_nodebug int http_seek(HttpState __far *state, long new_pos)
{
   if (sspec_seek(state->spec, new_pos, SEEK_SET) != 0)
      return -1;
   state->pos = new_pos;
   return 0;
}

/*** BeginHeader shtml_flush */
int shtml_flush(HttpState * state, int is_zhtml);
/*** EndHeader */

_http_nodebug int shtml_flush(HttpState * state, int is_zhtml)
{
	auto int sent, send;

#if USE_RABBITWEB
   if (is_zhtml && state->parser.skipping) {
   	state->headerlen = state->headeroff = 0;
      #ifdef HTTP_VERBOSE
      printf("HTTP: shtml_flush: rabbitweb skipping\n");
      #endif
   	return 1;
   }
#endif
   send = state->headerlen-state->headeroff;
   if (send <= 0) {
      #ifdef HTTP_VERBOSE
      printf("HTTP: shtml_flush: nothing to do (off=%d)\n", state->headeroff);
      #endif
   	return 1;
   }
   //if (sock_tbused(http_get_sock(state)) > state->abuffer)
   //	return 0;	// Let rest of application have a go.
	sent = sock_fastwrite(_SOCK_OF_HTTP(state), state->buffer+state->headeroff, send);
   if (send == sent) {
   	state->headerlen = state->headeroff = 0;
      #ifdef HTTP_VERBOSE
      printf("HTTP: shtml_flush: sent all (%d) from %d..%d\n",
      			sent, state->headeroff, state->headeroff+sent);
      #endif
   	return 1;
   }
   #ifdef HTTP_VERBOSE
   printf("HTTP: shtml_flush: sent %d of %d from %d..%d\n",
   				sent, send, state->headeroff, state->headeroff+sent);
   #endif
   if (sent <= 0)
   	return 0;
   state->headeroff += sent;
   return 0;
}

/*** BeginHeader shtml_handlebuffer */
int shtml_handlebuffer(HttpState* state, int is_zhtml);
/*** EndHeader */

// Returns 0 or 1 when shtml_handler or zhtml_handler need to return 0 or 1
// Returns 2 when more data is needed (shtml_handler should goto _more)
// Returns 3 when shtml_handler can proceed to the parsing section
_http_nodebug int shtml_handlebuffer(HttpState* state, int is_zhtml)
{
	auto word shift;
   auto int count;
   auto long diff;
   auto long flen;
   auto char __far *p;
   auto char __far *q;

   if (!state->ssiEnd || state->ssiEnd == state->ssiEOB) {
      if (state->ssiFlags & SSIF_SHIFT) {
         state->ssiFlags &= ~SSIF_SHIFT;
         shift = (word)(state->ssiEOB - state->p);
      #ifdef HTTP_VERBOSE
         printf("HTTP: shifting %u from %ld\n", shift, state->p-state->buffer);
      #endif
         _f_memcpy(state->buffer + HTTP_HALFBUF, state->p, shift);
      }
      else
         shift = 0;
      state->trashed = NULL;  // Nothing trashed now.
      // Nothing in buffer.  Read 2nd half.
      if ((count = http_readfromfile(state, state->buffer + HTTP_HALFBUF+shift, HTTP_HALFBUF-shift)) <= 0) {
         // Immediate EOF.
         state->headeroff = HTTP_HALFBUF;
         state->headerlen = HTTP_HALFBUF + shift;
         return 1;
      }
      state->ssiEnd = state->buffer + HTTP_HALFBUF;
      state->ssiEOB = state->buffer + HTTP_HALFBUF + shift + count;
      if (state->ssiEOB < state->buffer + HTTP_HALFBUF*2)
         *state->ssiEOB = 0;  // Null terminate to avoid invalid tag detection at EOF.
   }

   // Check if buffer contents beyond ssiEnd have been trashed.  If so, refresh from file.
   if (state->trashed && state->ssiEnd < state->trashed) {
      count = (word)(state->trashed - state->ssiEnd);
      #ifdef HTTP_VERBOSE
      printf("HTTP: %u trashed\n", count);
      #endif
      diff = state->pos;
      flen = diff - (state->ssiEOB - state->ssiEnd);
      if (http_seek(state, flen))
         return 1;   // Non-seekable file: finish now
      http_readfromfile(state, state->ssiEnd, count);
      http_seek(state, diff);
      state->pos = diff;   // Reposition back to old pos.
      state->trashed = state->ssiEnd;
   }

   // Something in buffer, need to scan for SSI tags.  SSI tag starts with either '<!--#' or '<<'
   // for compressed SSI (zssi).  We look for '<', then check next char is '!' or '<'.  If the
   // '<' is near the end of the buffer, all chars before the '<' are written then we shift
   // the '<' to start of buffer and continue.
   // ssiEnd is the first char to examine.
   p = state->ssiEnd;
   while (p <= state->ssiEOB) {
   	// if p==EOB, then we got to end of buffer without finding anything.
   	// Following result will then always be NULL.
      p = _f_memchr(p, '<', (int)(state->ssiEOB - p));

	   #ifdef HTTP_VERBOSE
   	if(p && p >= state->ssiEOB) {
      	printf("HTTP: shtml_handlebuffer: p memchr assignment past end of buffer!\n");
	   }
   	#endif

      if (!p) {
         // Nothing found, just send buffer
         state->headeroff = (int)(state->ssiEnd - state->buffer);
         state->headerlen = (int)(state->ssiEOB - state->buffer);
         state->ssiStart = state->ssiEnd = NULL;   // Signal read next chunk next time
         if (!shtml_flush(state, is_zhtml))
            return 0;
			return 2; // need more data
      }
		// Subtracting is_zhtml gets us the right number of characters
      if (p+4-is_zhtml >= state->buffer + HTTP_HALFBUF*2) {

         // Found '<', but it was too near the end so can't tell yet.  Send all but last char.
         // (We need to be able to see 5 chars to make sure it's a SSI tag, or 4
         // chars to see if it's a ZHTML tag).
      #ifdef HTTP_VERBOSE
         printf("HTTP: need shift (near end at %ld)\n", p-state->buffer);
      #endif
      _need_shift:
         state->headeroff = (int)(state->ssiEnd - state->buffer);
         state->headerlen = (int)(p - state->buffer);
         state->ssiStart = state->ssiEnd = NULL;   // Signal read next chunk next time
         state->ssiFlags |= SSIF_SHIFT;
         state->p = p;
         if (!shtml_flush(state, is_zhtml))
            return 0;
			return 2; // need more data
      }
      if ((is_zhtml && !memcmp(p+1, "?z ", 3)) ||
          (!is_zhtml && !memcmp(p+1, "!--#", 4))) {
         // Found uncompressed SSI directive or ZHTML tag (possibly).
   	#if USE_RABBITWEB
         if (is_zhtml) {
	         q = p+4;
	         q = zhtml_memstr(q, "?>", (int)(state->ssiEOB - q));
			}
         else {
      #endif
	         q = p+5;
	         q = _f_memchr(q, '>', (int)(state->ssiEOB - q));
	   #if USE_RABBITWEB
         }
      #endif
         if (!q) {
            // No end detected.  Will need to shift.
      #ifdef HTTP_VERBOSE
            printf("HTTP: need shift (end not found uncompressed at %ld)\n",
            	p-state->buffer);
      #endif
            goto _need_shift;
         }
         // Found end of SSI in buffer.  Good.  Now we have a complete SSI command.
      _found_end:
         state->headeroff = (int)(state->ssiEnd - state->buffer);
         state->headerlen = (int)(p - state->buffer);
         state->ssiStart = p;
         // Adding is_zhtml gets us the right number of characters
         state->ssiEnd = q+1+is_zhtml;
         state->endOffs = state->pos - (state->ssiEOB - state->ssiEnd);
      #ifdef HTTP_VERBOSE
      	printf("HTTP: found directive: start=%ld end=%ld %1.16ls\n",
      			state->ssiStart-state->buffer,
      			state->ssiEnd-state->buffer,
      			p);
      #endif
         if (state->headeroff < state->headerlen) {
            // first send everything from the previous ssiEnd up to the start of this
            // new directive.
            if (!shtml_flush(state, is_zhtml))
               return 0;
				return 2; // need more data
         }
         break;   // from while loop
      }
   #ifdef HTTP_ZSSI
      else if (!is_zhtml && p[1] == '<') {
         // Found compressed directive.
         q = p+2;
         while (q < state->ssiEOB) {
            q = _f_memchr(q, '>', (int)(state->ssiEOB - q));
            if (!q || q+1 >= state->buffer + HTTP_HALFBUF*2) {
               // No end detected.  Will need to shift.
      #ifdef HTTP_VERBOSE
               printf("HTTP: need shift (one '>', end not found compressed)\n");
      #endif
               goto _need_shift;
            }
            if (q[1] != '>') {
               q += 2;
               continue;
            }
            // Found end of SSI in buffer.  Good.
            q++;
            goto _found_end;
         }
      #ifdef HTTP_VERBOSE
         printf("HTTP: need shift (end not found compressed)\n");
      #endif
         goto _need_shift;
      }
   #endif
      // Otherwise was just a HTML tag or something.
      p++;

	   #ifdef HTTP_VERBOSE
   	if(p >= state->ssiEOB) {
      	printf("HTTP: shtml_handlebuffer: no directive found\n");
	   }
   	#endif

   } // while
	return 3; // Continue to parsing
}

/*** BeginHeader zhtml_handler */
int zhtml_handler(HttpState* state);
/*** EndHeader */

#if (USE_RABBITWEB == 0)
	#fatal "You must define USE_RABBITWEB to 1 to use RabbitWeb and zhtml_handler()"
#endif

/* zhtml states */

#define ZHTML_INIT      0
#define ZHTML_STEADY    1

_http_nodebug int zhtml_handler(HttpState* state)
{
   auto char c, buf[10];
   auto char __far *p;
   auto int count;
   auto int expect, comp;
   auto long flen;
   auto long diff;
   auto int (*fptr)();
   auto word type;
   auto char end;
   auto int retval;

   end = 0;

   if (state->method == HTTP_METHOD_HEAD)
      return 1;

_more:

   switch (state->nextstate) {
   case ZHTML_INIT:
#ifdef HTTP_VERBOSE
      printf("Starting ZHTML decode.\n");
#endif
      state->p = state->buffer;
      state->parser.nesting = 0;
      #ifndef USE_LEGACY_RABBITWEB
      web_cursor_start(&state->parser.context[0].with);
      #endif
      state->parser.skipping = 0;
      state->parser.state = state;
      if (!state->parser.error) {
      	// Clear out the list of changed variables, since we aren't in error
         // mode
         #ifdef USE_LEGACY_RABBITWEB
         _http_post_changed_len = 0;
         #else
			web_transaction_free(&_http_trans);
			#endif
      }
      state->nextstate = ZHTML_STEADY;
      // fall through

   case ZHTML_STEADY:
      /* steady state - move data into buffer */
      while (1) {
         // Add any pending data from ext* fields
         if (state->extlen && state->headerlen < state->abuffer / 2) {
            count = u_min(state->abuffer / 2 - state->headerlen, state->extlen);
            //printf("Sending %d from extbuf\n", count);
            _f_memcpy(state->buffer + state->headerlen, state->extp, count);
            state->headerlen += count;
            state->trashed = state->buffer + state->headerlen;
            state->extlen -= count;
            state->extp += count;
            if (!state->extlen) {
               //printf("Done sending extbuf\n");
               _web_free(state->extbuf);
               state->extbuf = NULL;
            }
         }

         if (state->headeroff < state->headerlen) {
         	// Pending data to send.  Send it then come back later.
         	//printf("`%.*ls`\n", state->headerlen-state->headeroff, state->buffer+state->headeroff);
            if (!shtml_flush(state, 1))
         		return 0;	// couldn't flush it all
         	// state->headerlen will be 0, so try sending rest of extbuf
				continue;
         }

         if (!state->ssiStart) {
				retval = shtml_handlebuffer(state, 1);
            if (retval == 2) {
            	goto _more;
            }
            else if (retval != 3) {
            	return retval;
            }
         }

         // Can only get to this point if ssiStart is not NULL.
         #ifdef HTTP_DEBUG
			if (!state->ssiStart) {
         	printf("HTTP: zhtml_handler: ssiStart is NULL!\n");
            return 1;
         }
         #endif

			state->parser.p = state->ssiStart + 3;
			state->parser.tagend = state->ssiEnd;
         state->ssiStart = NULL;
         count = 0;
         state->substate = 0;
        	state->subsubstate = 0;

         state->parser.command = ZHTML_CMD_NONE;
         state->parser.buffer = state->buffer;
			count = zhtml_parse_statement(&state->parser);
         if (count > 0) {
         	state->trashed = state->buffer + count + 1;	// Include NULL-term.
         	state->headerlen = count;
            state->headeroff = 0;
         }

         goto _more;
      } /* end of while loop */
      break;
   } /* end of switch() */
   return 0;
}

/*** BeginHeader shtml_handler */
int shtml_handler(HttpState* state);
/*** EndHeader */

/* shtml states */

#define SHTML_INIT      0
#define SHTML_INEXEC    1
#define SHTML_STARTWR   2
#define SHTML_WRITING   3
#define SHTML_STEADY    4
#define SHTML_ECHO      5
#define SHTML_EXEC      6
#define SHTML_INCL      7
#define SHTML_UNKNOWN	8
#define SHTML_MOREEXEC  9
#define SHTML_LOOP	   10

/*
 * All buffer writes here are handled by setting state->headerlen to non-zero, and
 * returning from the state. Before the function is called again, the buffer will
 * be flushed. (see the call in http_handler)
 */

const char expected_message[] = "[SSI expected ";

_http_nodebug int shtml_handler(HttpState* state)
{
   auto char c, buf[10];
   auto char __far *p;
   auto int count;
   auto int expect, comp;
   auto long flen;
   auto long diff;
   auto int (*fptr)();
   auto word type;
   auto char end;
   auto int retval;
   auto int server_mask;

   end = 0;

   server_mask = state->context.server;

   if (state->method == HTTP_METHOD_HEAD)
      return 1;

_more:

   switch (state->nextstate) {
   case SHTML_INIT:
#ifdef HTTP_VERBOSE
      printf("HTML: Starting SHTML.\n");
#endif
      state->p = state->buffer;
      state->nextstate = SHTML_STEADY;
      // fall through

   case SHTML_STEADY:
      /* steady state - move data into buffer */
      while (1) {
         if (state->headeroff < state->headerlen) {
         	// Pending data to send.  Send it then come back later.
            if (!shtml_flush(state, 0))
         		return 0;	// couldn't flush it all
         }

         if (!state->ssiStart) {
				retval = shtml_handlebuffer(state, 0);
            if (retval == 2) {
            	goto _more;
            }
            else if (retval != 3) {
            	return retval;
            }
         }

         // Can only get to this point if ssiStart is not NULL.
         #ifdef HTTP_DEBUG
			if (!state->ssiStart) {
         	printf("HTTP: shtml_handler: ssiStart is NULL!\n");
            return 1;
         }
         #endif

         // ssiStart points to start of <!--#
         // ssiEnd points after last char (i.e. after the closing '>').
         // endOffs is the file position corresponding to ssiEnd.
         // ssiEOB is the last char in the buffer, plus 1 (always >= ssiEnd).

			// There will be no pending data to transmit.

         if (state->ssiStart[1] == '!') {
         	// Uncompressed SSI construct
            p = state->ssiStart + 5;
	         if (!strncmpi(p, "echo", 4)) {
	            /* echo command */
	            state->nextstate = SHTML_ECHO;
               p += 4;

	         } else if (!strncmpi(p, "exec", 4)) {
	            /* exec command */
	            state->nextstate = SHTML_EXEC;
	            state->subspec = -1;
					p += 4;
	         } else if (!strncmpi(p, "include", 7)) {
               /* include command */
               state->nextstate = SHTML_INCL;
               state->subspec = -1;
               p += 7;
	         } else {
	            /* unknown command */
	            state->nextstate = SHTML_UNKNOWN;
	         }

	         /* Get Tag/Value, and move past end of SSI command */
	         memset(state->tag, '\0', HTTP_MAXNAME);
	         memset(state->value, '\0', HTTP_MAXNAME);
	         expect = 1;
         }
         else {
         	// Compressed SSI construct
            p = state->ssiStart + 2;
				expect = 5;
         	strcpy(state->tag, "cmd");
         	strcpy(state->value, "zssi");
            state->nextstate = SHTML_EXEC;
            state->subspec = -1;
         }

         state->ssiStart = NULL;
         count = 0;
         state->substate = 0;
        	state->subsubstate = 0;



         do {
				c = *p++;
            switch (expect) {
            case 1:  /* waiting for initial space */
               if (c == ' ') {
                  expect = 2;
               }
               break;

            case 2:  /* storing tag */
               if (c == '=') {
                  expect = 3;
               } else {
                  state->tag[count] = c;
                  count++;
                  if (count > HTTP_MAXNAME) {
                     expect = 99;   /* jump to the end */
                  }
               }
               break;
            case 3: /* got a quote? */
               if (c == '"') {
                  expect = 4;
                  count = 0;
               } else {
                  expect = 99;
               }
               break;

            case 4: /* store value */
               if (c == '"') {
                  expect = 99;
               } else {
                  state->value[count] = c;
                  count++;
                  if (count > HTTP_MAXNAME) {
                     expect = 99;
                  }
               }
               break;
#ifdef HTTP_ZSSI
            case 5: /* number for substate */
            	if (isdigit(c))
            		state->substate = state->substate * 10 + (c - '0');
            	else if (c == ',')
            		++expect;	// go to state 6 or 23
            	else if (c == '>')
            		c = 1, expect += 2;	// Go to state 7 or 24
   				else if (isalpha(c))
						state->substate = state->substate * 10 + state->cond[toupper(c)-'A'];
            	else
            		expect = 99;
            	break;

            case 6: /* number for subsubstate */
            	if (isdigit(c))
            		state->subsubstate = state->subsubstate * 10 + (c - '0');
              	else if (c == '>')
            		c = 1, ++expect; // go to state 7 or 14 or 24
   				else if (isalpha(c))
						state->subsubstate = state->subsubstate * 10 + state->cond[toupper(c)-'A'];
            	else
            		expect = 99;
            	break;

            case 7: /* Seen first '>' */
            	expect = 99;
            	break;
#endif
            case 99: /* wait for the end */
               break;
            }

         } while (c != '>');


#ifdef HTTP_VERBOSE
			if (state->nextstate != SHTML_STEADY && state->nextstate != SHTML_MOREEXEC)
         	printf("Tag = '%s', Value = '%s'\n", state->tag, state->value);
#endif

         goto _more;
      } /* end of while loop */
      break;


   case SHTML_ECHO:
      if (!strncmpi(state->tag, "var", 3)) {
         state->subspec = sspec_findname(state->value, server_mask);
         if ( (state->subspec < 0) ||
              ((type = sspec_gettype(state->subspec)) != SSPEC_VARIABLE) ) {
            sprintf(state->buffer, "%serror: '%s' not found.]",
                    expected_message, state->value);
         } else {
				sspec_readvariable(state->subspec, state->buffer);
         }
      } else {
         sprintf(state->buffer, "%s'var' tag.]", expected_message);
      }
      state->subspec = -1;
      state->headeroff = 0;
      state->headerlen = strlen(state->buffer);
      // Save point in buffer which may have been trashed.  Add 1 because of null terminator.
      p = state->buffer + state->headerlen+1;
      if (p > state->trashed)
      	state->trashed = p;
      state->nextstate = SHTML_STEADY;
      break;

   case SHTML_EXEC:
      if (!strncmpi(state->tag, "cmd", 3)) {
         if (state->subspec < 0) {
            state->subspec = sspec_findname(state->value, server_mask);
            if (state->subspec < 0 ||
                (type = sspec_gettype(state->subspec)) != SSPEC_FUNCTION) {
               sprintf(state->buffer, "%serror: '%s' not found.]",
                       expected_message, state->value);
            } else {
               return 0;
            }
         } else {
            /* have spec - exec it */
           	fptr = sspec_getfunction(state->subspec);
            state->subspec = -1;
				state->exec = fptr;
            if (fptr(state))
               state->nextstate = SHTML_STEADY;
            else
            	state->nextstate = SHTML_MOREEXEC;
	         // Save point in buffer which may have been trashed.  Add 1 because of null terminator.
	         p = state->buffer + state->headerlen+1;
	         if (p > state->trashed)
	            state->trashed = p;
            return 0;
         }
      } else {
         sprintf(state->buffer, "%s'cmd' tag.]", expected_message);
      }
      state->headeroff = 0;
      state->headerlen = strlen(state->buffer);
      state->nextstate = SHTML_STEADY;
      if (!shtml_flush(state, 0))
	   	return 0;
		goto _more;
      //break;

   case SHTML_MOREEXEC:
      if (state->exec(state))
   		state->nextstate = SHTML_STEADY;
      // Save point in buffer which may have been trashed.  Add 1 because of null terminator.
      p = state->buffer + state->headerlen+1;
      if (p > state->trashed)
      	state->trashed = p;
      if (!shtml_flush(state, 0))
	   	return 0;
		goto _more;

   case SHTML_INCL:
      if (!strncmpi(state->tag, "file", 4)) {
         if (state->subspec < 0) {
            /* find the file */
            state->subspec = sspec_open(state->value, &state->context, O_READ, 0);
            if (state->subspec < 0 ||
                (type = sspec_gettype(state->subspec)) != SSPEC_FILE) {
               sprintf(state->buffer,
                       "%serror: '%s' not found.]",
                       expected_message, state->value);
            } else {
					flen = sspec_getlength(state->subspec);
					if (flen >= 0) {
	               state->subfilelength = flen;
	               state->subpos = 0;
	               return 0;   /* have spec, wait till next tick to start output */
               }
               else {
               	sprintf(state->buffer, "[SSI error: compressed files cannot be included.]");
               }
            }
         } else {
            /* insert the file */
            if ((state->subpos) < state->subfilelength) {
               diff = L_min(state->subfilelength - state->subpos, HTTP_HALFBUF);
               diff = L_min(diff, sock_writable(_SOCK_OF_HTTP(state))-1);
               if (diff <= 0)
               	return 0;
               if ((diff = sspec_read(state->subspec, state->buffer, (int)diff)) < 0)
                  // File removed -- fail
                  return 1;
               if (diff) {
               	sock_fastwrite(_SOCK_OF_HTTP(state), state->buffer, (int)diff);
               	state->subpos += diff;
			      	state->main_timeout = set_timeout(HTTP_TIMEOUT);
					}
               return 0;
            } else {
            	sspec_close(state->subspec);
               state->subspec = -1;
               state->nextstate = SHTML_STEADY;
               return 0;
            }
         }
      } else {
         sprintf(state->buffer, "%s'file' tag.]", expected_message);
      }
      state->headeroff = 0;
      state->headerlen = strlen(state->buffer);
      state->nextstate = SHTML_STEADY;
      break;

   case SHTML_UNKNOWN:
      sprintf(state->buffer, "[Got unknown SSI command]");
      state->headeroff = 0;
      state->headerlen = strlen(state->buffer);
      state->nextstate = SHTML_STEADY;
      break;

   } /* end of switch() */
   return 0;
}

/*** BeginHeader shtml_addvariable */
int shtml_addvariable(char* name, void* variable, word type, char* format);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
shtml_addvariable 	                  <HTTP.LIB>

SYNTAX: int shtml_addvariable(char *name, void* variable,
		word type, char *format);

KEYWORDS:		tcpip, http

DESCRIPTION:	Adds a variable to the RAM spec file, for use in
		shtml documents.

PARAMETER1:	Name of the variable
PARAMETER2:	Pointer to the variable
PARAMETER3:	Type, as defined in the INT8/INT16/etc defines above
PARAMETER4:	Standard printf format string. (ie: "%d")

RETURN VALUE:	0 on success, 1 on failure (no room)

SEE ALSO:	shtml_delvariable

END DESCRIPTION **********************************************************/

_http_nodebug int shtml_addvariable(char* name, void* variable, word type, char* format)
{
   auto int spec;

   spec=sspec_addvariable(name, variable, type, format, SERVER_HTTP | SERVER_HTTPS);
   if (spec == -1) {
   	return 1;
   } else {
   	return 0;
   }
}

/*** BeginHeader shtml_delvariable */
int shtml_delvariable(char* name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
shtml_delvariable	                   <HTTP.LIB>

SYNTAX: int shtml_delvariable(char *name);

KEYWORDS:		tcpip, http

DESCRIPTION:	Deletes a variable from the RAM spec table.

PARAMETER1:	Name of the variable, as given to shtml_addvariable.

RETURN VALUE:	0 on success, 1 on failure (not found)

SEE ALSO:	shtml_addvariable

END DESCRIPTION **********************************************************/

_http_nodebug int shtml_delvariable(char* name)
{
   auto int spec;

   if ((spec=sspec_findname(name, SERVER_HTTP | SERVER_HTTPS)) < 0)
   	return 1;

   sspec_remove(spec);
   return 0;
}

/*** BeginHeader shtml_addfunction */
int shtml_addfunction(char* name, int (*fptr)());
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
shtml_addfunction                   <HTTP.LIB>

SYNTAX: int shtml_addfunction(char* name, int (*fptr(HttpState*));

KEYWORDS:		tcpip, http

DESCRIPTION:	Adds a CGI/SSI-exec function for making dynamic
		web pages to the RAM spec table.

PARAMETER1:	Name of the function (ie: "/foo.cgi")
PARAMETER2:	Function pointer to the handler, that must take
		 a HttpState* as an argument, and return an int
		 (0 while still pending, 1 when finished)

RETURN VALUE:	0 on success, 1 on failure (no room)

SEE ALSO:	shtml_delfunction

END DESCRIPTION **********************************************************/

_http_nodebug int shtml_addfunction(char* name, int (*fptr)())
{
   auto int spec;

   spec=sspec_addfunction(name, fptr, SERVER_HTTP | SERVER_HTTPS);
   if (spec == -1) {
   	return 1;
   } else {
   	return 0;
   }
}

/*** BeginHeader shtml_delfunction */
int shtml_delfunction(char* name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
shtml_delfunciton                   <HTTP.LIB>

SYNTAX: int shtml_delfunction(char *name);

KEYWORDS:		tcpip, http

DESCRIPTION:	Deletes a function from the RAM spec table.

PARAMETER1:	Name, as given to shtml_addfunction.

RETURN VALUE:	0 on success, 1 on failure (not found)

SEE ALSO:	shtml_addfunction

END DESCRIPTION **********************************************************/

_http_nodebug int shtml_delfunction(char* name)
{
   auto int spec;

   spec=sspec_findname(name, SERVER_HTTP | SERVER_HTTPS);
   if (spec == -1) {
   	return 1;
   }

   sspec_remove(spec);
   return 0;
}

/*** BeginHeader _http_abort */
void _http_abort(int x);
/*** EndHeader */

/*
 * This function does the necessary processing when the current
 * connection must be aborted.  It is OK to call more than once.
 */

_http_nodebug void _http_abort(int x)
{
   auto int  (*fptr)();
   auto HttpState * state;

   state = &(http_servers HTTP_X);

#if USE_RABBITWEB
	#ifdef USE_LEGACY_RABBITWEB
	zhtml_release_lock(HTTP_SERVNO);
	#else
	web_release_lock(HTTP_SERVNO);
	#endif
#endif

#ifdef USE_HTTP_UPLOAD
	if (state->action && state->cgifunc) {
   	// Give new-style CGI a chance to clean up.
   	state->action = CGI_ABORT;
      state->cgifunc(state);
      state->abort_notify = 0;
   }
#endif

#ifdef FORM_ERROR_BUF
	if (_has_lock_feb(HTTP_SERVNO) == 1) {
		_feparsing = 0;
		_unlock_feb(HTTP_SERVNO);
	}
#endif
	if (state->abort_notify) {
		state->cancel = 1;
		if (state->cgifunc)
			state->cgifunc(state);
#ifdef FORM_ERROR_BUF
		else {
			(fptr = sspec_getfunction(sspec_getformepilog(state->spec))) &&
			fptr(state);
		}
#endif
		state->abort_notify = 0;
	}
   if (state->subspec >= 0) {
		sspec_close(state->subspec);
      state->subspec = -1;
   }
   if (state->spec >= 0) {
		sspec_close(state->spec);
      state->spec = -1;
   }
}

/*** BeginHeader cgi_redirectto */
void cgi_redirectto(HttpState* state, char __far * url);
/*** EndHeader */

#define CGI_STATE_TXT1	0
#define CGI_STATE_URL1	1
#define CGI_STATE_TXT2	2
#define CGI_STATE_URL2	3
#define CGI_STATE_TXT3	4
#define CGI_STATE_DONE	5

#if HTTP_MAXBUFFER < 256
#fatal "http buffer not large enough for cgi_redir_handler(). MIN size is 256"
#endif

_http_nodebug int cgi_redir_handler(HttpState* state)
{
	switch(state->nextstate) {
	case CGI_STATE_TXT1:
   	http_genHeader(state, state->buffer, state->abuffer,
        302, NULL, 0, NULL);
		state->nextstate = CGI_STATE_TXT2;
		break;

	case CGI_STATE_TXT2:
		sprintf(state->buffer,
			"<HTML><HEAD><TITLE>Document has moved</TITLE></HEAD>\r\n" \
			"<BODY>Document has moved <A HREF=\"%ls\">here</A></BODY></HTML>", state->p);

		state->nextstate = CGI_STATE_DONE;
		break;

	case CGI_STATE_DONE:
		return 1;
	}

	/* queue a write */
	state->headeroff = 0;
	state->headerlen = strlen(state->buffer);
	return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
cgi_redirectto                   <HTTP.LIB>

SYNTAX: void cgi_redirectto(HttpState* state, char far * url);

KEYWORDS:		tcpip, http

DESCRIPTION:	Utility function that may be called in a CGI
		function, to redirect the user to another page.

PARAMETER1:	Current server struct, as received by the CGI func.
PARAMETER2:	Full qualified URL to redirect to.

RETURN VALUE:	none - sets the state, so the CGI must immediatly
		return with a value of 0.

SEE ALSO:	cgi_sendstring, cgi_nocontent

END DESCRIPTION **********************************************************/

_http_nodebug void cgi_redirectto(HttpState* state, char __far * url)
{
	state->p = url;
	state->handler=cgi_redir_handler;
	state->nextstate = CGI_STATE_TXT1;
	state->state=HTTP_SENDPAGE;
	state->abort_notify = 0;
}

/*** BeginHeader cgi_nocontent */
int cgi_nocontent(HttpState* state);
/*** EndHeader */
_http_nodebug
int cgi_nocontent_handler(HttpState* state)
{
	if (state->nextstate)
	{
      http_genHeader(state, state->buffer, state->abuffer,
        204, NULL, 0, NULL);
      state->nextstate = 0;
	   /* queue a write */
	   state->headeroff = 0;
	   state->headerlen = strlen(state->buffer);
	   return 0;
	}
	else
	{
		return 1;
	}
}

/* START FUNCTION DESCRIPTION ********************************************
cgi_nocontent                   <HTTP.LIB>

SYNTAX: int cgi_nocontent(HttpState* state);

KEYWORDS:		tcpip, http

DESCRIPTION:	Utility function that may be called in a CGI
		function, to send a "204 No Content" response so the
		web browser doesn't refresh the page.  Useful for initiating
		an action on the Rabbit, but not modifying the web page in
		the browser.

		Since this function sets the CGI state, any CGI function calling
		it should simply end with:

			return cgi_nocontent(state);

PARAMETER1:	Current server struct, as received by the CGI function.

RETURN VALUE:	0

SEE ALSO:	cgi_sendstring, cgi_redirectto

END DESCRIPTION **********************************************************/
_http_nodebug
int cgi_nocontent(HttpState* state)
{
	state->handler=cgi_nocontent_handler;
	state->nextstate = 1;
	state->state=HTTP_SENDPAGE;
	state->abort_notify = 0;

	return 0;
}

/*** BeginHeader cgi_sendstring */
void cgi_sendstring(HttpState* state, char __far * str);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cgi_sendstring                   <HTTP.LIB>

SYNTAX: void cgi_sendstring(HttpState* state, char far * str);

KEYWORDS:		tcpip, http

DESCRIPTION:	Sends a string to the user.

PARAMETER1:	Current server struct, as received by the CGI func.
PARAMETER2:	The string to send.

RETURN VALUE:	none - sets the state, so the CGI must immediatly
		return with a value of 0.

SEE ALSO:	cgi_redirectto, cgi_nocontent

END DESCRIPTION **********************************************************/

_http_nodebug void cgi_sendstring(HttpState* state, char __far * str)
{
	state->offset=(long)str;
	state->length=(long)str+strlen(str);
   state->handler=http_sendbuffer;
	state->state=HTTP_SENDPAGE;
}

/*** BeginHeader http_urldecode */
char __far *http_urldecode(char __far *dest, const char __far *src, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_urldecode                   <HTTP.LIB>

SYNTAX: char far *http_urldecode(char far *dest,
								const char far *src, int len);

KEYWORDS:		tcpip, http, transfer-coding

DESCRIPTION:	Converts a string with URL escaped ``tokens''
		(such as %20 (hex) for space) into actual values.  Changes "+"
		into a space.  String can be NUL byte terminated; it is also
		bounded by a specified string length.  This function is reentrant.

		It is acceptable for dest==src, since decoding never increases
		the result size.

PARAMETER1:	Buffer where decoded string is stored.
PARAMETER2:	Buffer holding original string (not changed).
PARAMETER3: maximum size of string (NUL terminated strings can be shorter).
				This may be negative, in which case the string length bound
				is the absolute value, and the destination is forced to
				all lowercase.  May also be zero, in which case the source
				length is automatically determined using strlen().

RETURN VALUE:	If all conversion are good, returns 'dest', or NULL if some
		some conversion had troubles.

SEE ALSO:	http_contentencode()

END DESCRIPTION **********************************************************/
_http_nodebug
char __far *http_urldecode(char __far *dest, const char __far *src, int len)
{
	auto int i;
	auto int j;
	auto char upper;
	auto char lower;
	auto int error;
	auto char lc;

	i = 0;
	j = 0;
	error = 0;
	if (!len)
		len = strlen(src);
	else if (len < 0) {
		len = -len;
		lc = 1;
	}
	else
		lc = 0;

	while( (i < len) && (src[i] != '\0') ) {
		if (src[i] == '+') {
			dest[j] = ' ';
		} else if (src[i] == '%') {
			/* "%" introduces a 2 digit hex number representing a char.
			 *  If not two more chars, flag error. If two digits are NOT
			 *  valid hex digits, also flag an error.
			 */
			if ((i + 2) >= len) {
				error = 1;
				break;
			}
			upper = toupper(src[++i]);
			lower = toupper(src[++i]);

			if ((upper >= '0') && (upper <= '9')) {
				upper = upper - '0';
			} else if ((upper >= 'A') && (upper <= 'F')) {
				upper = upper - 'A' + 10;
			} else {
				error = 1;
				break;
			}
			if ((lower >= '0') && (lower <= '9')) {
				lower = lower - '0';
			} else if ((lower >= 'A') && (lower <= 'F')) {
				lower = lower - 'A' + 10;
			} else {
				error = 1;
				break;
			}

			dest[j] = (upper << 4) + lower;
		} else {
			/* No conversion, so copy char verbatim. */
			dest[j] = src[i];
		}
		if (lc)
			dest[j] = tolower(dest[j]);
		i++;
		j++;
	}
	dest[j] = '\0';
	if ((i == len) && (src[i] != '\0')) {
		error = 1;
	}
	if (error == 0) {
		return dest;
	} else {
		return NULL;
	}
}

/*** BeginHeader http_contentencode */
char __far *http_contentencode(char __far *dest, /*const*/char __far *src, int max_dest_len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_contentencode                   <HTTP.LIB>

SYNTAX: char far *http_contentencode(char far *dest,
							const char far *src, int len);

KEYWORDS:		tcpip, http, transfer-coding

DESCRIPTION:	Converts a string to include HTTP transfer-coding ``tokens''
		(such as &#64; for an at-sign) where appropriate.  Changes "&" into
		"&amp;".  Source string is NUL byte terminated.  Destination buffer
		is bounded by a max string length.  This function is reentrant.

PARAMETER1:	Buffer where encoded string is stored.
PARAMETER2:	Buffer holding original string (not changed).
PARAMETER3: size of destination buffer.

RETURN VALUE:	If there was room for all conversions, returns 'dest' to caller.
		If not enough room, terminates the converted string and returns NULL.

SEE ALSO:	http_urldecode()

END DESCRIPTION **********************************************************/
_http_nodebug char __far *
http_contentencode(char __far *dest, /*const*/char __far *src, int max_dest_len)
{
   const static char  encodables[] = "<>@%#" ;		/*  Array of chars we must change */

   auto char __far * orig_dest_ptr;
	auto char __far * p;
	auto int 	more;

	orig_dest_ptr = dest;
	--max_dest_len;		/* Ensure space for terminating NUL char */
	while( max_dest_len > 0 && (*src != '\0') ) {
		/*  Encoded things are from 'encodables', or non-ASCII-7 chars. */
		p = strchr( encodables, *src );

		/*  Handle '&' specially: */
		if( '&' == *src ) {
			if( max_dest_len <= 5 ) {
				/* ERROR: Not enough space to hold transfer-coded string. */
				*dest = '\0';
				return NULL;
			} else {
				_f_strcpy( dest, "&amp;" );
				src += 1;
				dest += 5;
				max_dest_len -= 5;
			}
		} else
		if( NULL == p && (' ' <=  *src && *src < '~') ) {
			*dest++ = *src++;
			max_dest_len--;
		} else
		if( max_dest_len <= 6 ) {
			/* ERROR: Not enough space to hold transfer-coded string. Might need
			 * 	5 chars like "&#64;", or 6 chars "&#127;" .
			 */
			*dest = '\0';
			return NULL;
		} else {
			/*  There is room to perform at least one more transfer-coding. */
			more = sprintf(dest, "&#%d;", (unsigned char) *src++);
			dest += more;
			max_dest_len -= more;
		}
   }
   *dest = '\0';
   return( orig_dest_ptr );
}   /* end http_contentencode() */


/*** BeginHeader http_scanpost */
int http_scanpost(char __far * tag, char __far * buffer, char __far * dest, int maxlen);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
http_scanpost                        <HTTP.LIB>

SYNTAX: int http_scanpost(char far * tag, char far * buffer,
								char far * dest, int maxlen);

KEYWORDS:		tcpip, http, post

DESCRIPTION:	The http_scanpost function allows you to scan a buffer with
					a POST response for the key/value pairs.  Note that this
					function also does URL-decoding of the values.

					This function is reentrant.

PARAMETER1:	Buffer holding the tag name.
PARAMETER2:	Buffer to read data from.
PARAMETER3: Buffer to store value to.
PARAMETER4: size of destination buffer.

RETURN VALUE:	zero if successful, non-zero otherwise.

END DESCRIPTION **********************************************************/

_http_nodebug
int http_scanpost(char __far * tag, char __far * buffer, char __far * dest, int maxlen)
{
	auto int x, state, offset, length;

	state=offset=x=0;
	length=strlen(buffer);

	while(offset<length) {
		switch(state) {
			case 0: /* match tag */
				if(buffer[offset]=='=' && tag[x]==0) { /* do we have a match? */
					x=0;
					state=1;
					offset++;
				} else if(buffer[offset++]!=tag[x++]) { /* skip to next tag? */
					state=2;
				}
				break;

			case 1: /* copy data */
				if(x<(maxlen-1) && buffer[offset]!='&')
					dest[x++]=buffer[offset++];

				if(x==(maxlen-1) || offset==length || buffer[offset]=='&') {
					dest[x]=0;
					http_urldecode(dest,dest,maxlen-1);
					return 0;
				}
				break;

			case 2: /* scan until next & */
				if(buffer[offset]=='&') /* reached next tag? */
					state=x=0;
				offset++;
				break;
		}
	}
	return 1;
}
/*** BeginHeader http_generateform */
int http_generateform(int form, HttpState *state, int error);
/*** EndHeader */

_http_nodebug int http_generateform(int form, HttpState *state, int error)
{
	auto int num;
	auto int step;
	auto int fvspec;
	auto char* varerror;
	auto char* value;
	auto int errorbool;
	auto void (*preform)();

	if (state->length) {
		/* buffer to write out */
		if (state->offset < state->length) {
	      if ((num = sock_fastwrite(_SOCK_OF_HTTP(state), state->buffer + (int)state->offset,
				                       (int)state->length - (int)state->offset)) < 0) {
	      	// Error on socket
	         return 1;
	      }
	      state->offset += num;
	      if (num) {
	      	state->main_timeout = set_timeout(HTTP_TIMEOUT);
         }
		} else {
			state->offset = 0;
			state->length = 0;
		}
	} else {
		if (state->substate == 0) {
			// Call a user function to allow them to update variables
			if (error == 0 &&
				 (preform = sspec_getpreformfunction(form)))
				preform(form);
			_f_strcpy(state->buffer, "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n");
			state->length = strlen(state->buffer);
			state->offset = 0;
			state->substate++;
		} else if (state->substate == 1) {
			_f_strcpy(state->buffer, "<HTML>\r\n<HEAD><TITLE>");
			_f_strncat(state->buffer, sspec_getformtitle(form), state->abuffer - 22);
			state->length = strlen(state->buffer);
			state->substate++;
		} else if (state->substate == 2) {
			_f_strcpy(state->buffer, "</TITLE></HEAD>\r\n<BODY>\r\n<H1>");
			_f_strncat(state->buffer, sspec_getformtitle(form), state->abuffer - 37);
			_f_strcat(state->buffer, "</H1>\r\n");
			state->length = strlen(state->buffer);
			state->substate++;
		} else if (state->substate == 3) {
			if (error != 0) {
				_f_strcpy(state->buffer, "ERROR: Fields that are highlighted in <FONT COLOR=\"#ff0000\">red</FONT> have errors.\r\n");
			} else {
				_f_strcpy(state->buffer, "");
			}
			_f_strcat(state->buffer, "<FORM ACTION=\"");
			_f_strcat(state->buffer, sspec_getname(form));
			_f_strcat(state->buffer, "\" METHOD=\"POST\">\r\n<TABLE BORDER>\r\n");
			_f_strcat(state->buffer, "<TR>\r\n<TD>Name</TD>\r\n<TD>Value</TD>\r\n<TD>Description</TD>\r\n</TR>\r\n");
			state->length = strlen(state->buffer);
			state->substate++;
		} else if (state->substate < (sspec_getfvnum(form)*6 + 4)) {
			num = (state->substate - 4) / 6;
			step = (state->substate - 4) % 6;
			fvspec = sspec_getfvspec(form, num);
			if (step == 0) {
				state->offset = 0;
				state->subsubstate = 0;
				_f_strcpy(state->buffer, "<TR>\r\n<TD>");
				errorbool = 0;
				if ((error != 0) && ((varerror = http_finderrbuf(sspec_getname(fvspec))) != NULL)) {
					http_nextfverr(varerror, NULL, NULL, &errorbool, NULL);
					if (errorbool != 0) {
						_f_strcat(state->buffer, "<FONT COLOR=\"#ff0000\">* ");
					}
				}
				_f_strncat(state->buffer, sspec_getfvname(form, num), state->abuffer - 78);
				if (errorbool != 0) {
					_f_strcat(state->buffer, "</FONT>");
				}
				_f_strcat(state->buffer, "</TD>\r\n<TD>");
				if (sspec_getfvreadonly(form, num) == 0) {
					if (sspec_getfventrytype(form, num) == HTML_FORM_TEXT) {
						_f_strcat(state->buffer, "<INPUT TYPE=\"text\" NAME=\"");
					} else {
						_f_strcat(state->buffer, "<SELECT NAME=\"");
					}
				}
			} else if (step == 1) {
				if (sspec_getfvreadonly(form, num) == 0) {
					_f_strcpy(state->buffer, sspec_getname(fvspec));
					if (sspec_getfventrytype(form, num) == HTML_FORM_TEXT) {
						_f_strcat(state->buffer, "\" VALUE=\"");
					} else {
						_f_strcat(state->buffer, "\" SIZE=1>\r\n");
					}
				} else {
					_f_strcpy(state->buffer, "");
				}
			} else if (step == 2) {
				if ((sspec_getfventrytype(form, num) == HTML_FORM_TEXT) &&
				    (sspec_getfvreadonly(form, num) == 0)) {
					if ((error != 0) && ((varerror = http_finderrbuf(sspec_getname(fvspec))) != NULL)) {
						http_nextfverr(varerror, NULL, &value, NULL, NULL);
						_f_strncpy(state->buffer, value, sspec_getfvlen(form, num));
						if (strlen(value) >= sspec_getfvlen(form, num)) {
							state->buffer[sspec_getfvlen(form, num)] = '\0';
						}
					} else {
						sspec_readvariable(fvspec, state->buffer);
					}
				} else if (sspec_getfvreadonly(form, num) == 0) {
					_f_strcpy(state->buffer, "<OPTION");
					if ((error != 0) && ((varerror = http_finderrbuf(sspec_getname(fvspec))) != NULL)) {
						http_nextfverr(varerror, NULL, &value, NULL, NULL);
						if (strcmp(value, sspec_getfvopt(form, num, state->subsubstate)) == 0) {
							_f_strcat(state->buffer, " SELECTED>");
						} else {
							_f_strcat(state->buffer, ">");
						}
					} else {
						if (strcmp(sspec_getvaraddr(fvspec),
						           sspec_getfvopt(form, num, state->subsubstate)) == 0) {
							_f_strcat(state->buffer, " SELECTED>");
						} else {
							_f_strcat(state->buffer, ">");
						}
					}
					_f_strncat(state->buffer, sspec_getfvopt(form, num, state->subsubstate),
					        state->abuffer - 20);
					_f_strcat(state->buffer, "\r\n");
					if (state->subsubstate < (sspec_getfvoptlistlen(form, num) - 1)) {
						// Don't advance the state
						state->substate--;
						state->subsubstate++;
					}
				} else {
					sspec_readvariable(fvspec, state->buffer);
				}
			} else if (step == 3) {
				if ((sspec_getfventrytype(form, num) == HTML_FORM_TEXT) &&
				    (sspec_getfvreadonly(form, num) == 0)) {
					_f_strcpy(state->buffer, "\" SIZE=\"");
					sprintf(&state->buffer[strlen(state->buffer)], "%d", sspec_getfvlen(form, num));
					_f_strcat(state->buffer, "\"></TD>\r\n<TD>");
				} else if (sspec_getfvreadonly(form, num) == 0) {
					_f_strcpy(state->buffer, "</SELECT></TD>\r\n<TD>");
					state->subsubstate = 0;
				} else {
					_f_strcpy(state->buffer, "</TD>\r\n<TD>");
				}
			} else if (step == 4) {
				_f_strncpy(state->buffer, sspec_getfvdesc(form, num) + (int)state->subsubstate, state->abuffer - 1);
				if (strlen(sspec_getfvdesc(form, num) + (int)state->subsubstate) > state->abuffer - 1) {
					state->subsubstate += state->abuffer - 1;
					// Don't advance the state
					state->substate--;
				}
			} else if (step == 5) {
				state->subsubstate = 0;
				_f_strcpy(state->buffer, "</TD>\r\n</TR>\r\n");
			}
			state->length = strlen(state->buffer);
			state->substate++;
		} else if (state->substate == (sspec_getfvnum(form)*6 + 4)) {
			_f_strcpy(state->buffer, "</TABLE>\r\n<P>\r\n<INPUT TYPE=\"submit\" VALUE=\"Submit\">\r\n<INPUT TYPE=\"reset\" VALUE=\"Reset\">\r\n</FORM>\r\n</BODY>\r\n</HTML>\r\n");
			state->length = strlen(state->buffer);
			state->substate++;
		} else {
			state->substate = 0;
			return 1;
		}
	}
	return 0;
}

/*** BeginHeader http_finderrbuf */
/* START FUNCTION DESCRIPTION ********************************************
http_finderrbuf                        <ZSERVER.LIB>

SYNTAX: char* http_finderrbuf(char* name);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Finds the occurrence of the given variable in the HTML
					form error buffer, and returns its location

PARAMETER1: 	name of the variable

RETURN VALUE:  !NULL	location of the variable in the error buffer
               NULL	failed to find the variable

SEE ALSO:      http_nextfverr

END DESCRIPTION **********************************************************/

char* http_finderrbuf(char* name);
/*** EndHeader */

_http_nodebug char* http_finderrbuf(char* name)
{
	auto char* varname;
	auto char* nextvar;
	auto char* next;

	nextvar = _form_error_buf;
	while (nextvar != NULL) {
		http_nextfverr(nextvar, &varname, NULL, NULL, &next);
		if (strncmp(name, varname, SSPEC_MAXSPEC) == 0) {
			return nextvar;
		}
		nextvar = next;
	}

	return NULL;
}

/*** BeginHeader http_nextfverr */
/* START FUNCTION DESCRIPTION ********************************************
http_nextfverr                         <ZSERVER.LIB>

SYNTAX: void http_nextfverr(char* start, char** name, char** value,
                            int* error, char** next);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the information for the next variable in the HTML
					form error buffer.  If any of the last four parameters in
					the function call are NULL, then those parameters will
					not have a value returned.  This is useful if you are only
					interested in certain variable information.

PARAMETER1: 	pointer to the variable in the buffer for which we want to
					get information
PARAMETER2:		return location for the name of the variable
PARAMETER3:		return location for the value of the variable
PARAMETER4:		return location for whether or not the variable is in
					error (0 if it is not, 1 if it is)
PARAMETER5:		return location for a pointer to the variable after this
					one

RETURN VALUE:  none, although information is returned in the last four
					parameters

SEE ALSO:      http_finderrbuf

END DESCRIPTION **********************************************************/

void http_nextfverr(char* start, char** name, char** value, int* error, char** next);
/*** EndHeader */

_http_nodebug void http_nextfverr(char* start, char** name, char** value, int* error, char** next)
{
	auto char* ptr;

	ptr = start;
	if (name != NULL) {
		*name = ptr;
	}
	ptr += strlen(ptr) + 1;
	if (value != NULL) {
		*value = ptr;
	}
	ptr += strlen(ptr) + 1;
	if (error != NULL) {
		if (*ptr == '0') {
			*error = 0;
		} else {
			*error = 1;
		}
	}
	ptr += strlen(ptr) + 1;
	if (next != NULL) {
		if (ptr < (_form_error_buf + _febsize)) {
			*next = ptr;
		} else {
			*next = NULL;
		}
	}
}

/*** BeginHeader http_setfverror */
void http_setfverror(char* var);
/*** EndHeader */

_http_nodebug void http_setfverror(char* var)
{
	auto int i;
	auto int nullcount;

	i = 0;
	nullcount = 0;
	while(1) {
		if (nullcount == 2) {
			var[i] = '1';
			break;
		}
		if (var[i] == '\0') {
			nullcount++;
		}
		i++;
	}
}

/*** BeginHeader http_parseform */
int http_parseform(int form, HttpState *state);
/*** EndHeader */

_http_nodebug int http_parseform(int form, HttpState *state)
{
	auto int retval;
	auto char* name;
	auto char* value;
	auto int error;
	auto char* next;
	auto char* nextvar;
	auto int formerror;
	auto int i;

   // No parameter since we assign several different functions to this
   // pointer that have differing signatures
   auto int (*fptr)();

	if (_feparsing == 0) {
		_fcharsread = 0;
		_febptr = _form_error_buf;
		_festrstart = _form_error_buf;
		_feequal = 0;
		_feparsing++;
		return 0;
	} else if (_feparsing == 1) {
		// Shouldn't I check to make sure we have an '=' for every variable?
		if ((_fcharsread < state->content_length) &&
		       ((_febptr - _form_error_buf) < (FORM_ERROR_BUF - 4)) &&
	   	    sock_readable(_SOCK_OF_HTTP(state)) &&
	      	 ((retval = sock_fastread(_SOCK_OF_HTTP(state), _febptr, 1)) != -1) ) {
			if (retval > 0) {
				// Reset the timeout
				state->main_timeout = set_timeout(HTTP_TIMEOUT);
				_fcharsread++;
				if (*_febptr == '=') {
					_feequal = 1;
					*_febptr = '\0';
					http_urldecode(_festrstart, _festrstart, FORM_ERROR_BUF-1);
					_febptr = _festrstart + strlen(_festrstart) + 1;
					_festrstart = _febptr;
				} else if (*_febptr == '&') {
					_feequal = 0;
					*_febptr = '\0';
					http_urldecode(_festrstart, _festrstart, FORM_ERROR_BUF-1);
					_febptr = _festrstart + strlen(_festrstart) + 1;
					*(_febptr++) = '0';
					*(_febptr++) = '\0';
					_festrstart = _febptr;
				} else {
					_febptr++;
				}
			}
			tcp_tick(NULL);
		} else {
			if ((_fcharsread == state->content_length) &&
			    ((_febptr - _form_error_buf) < (FORM_ERROR_BUF - 4)) &&
			    (_feequal == 1)) {
				*_febptr = '\0';
				http_urldecode(_festrstart, _festrstart, FORM_ERROR_BUF-1);
				_febptr = _festrstart + strlen(_festrstart) + 1;
				*(_febptr++) = '0';
				*(_febptr++) = '\0';
				_febsize = _febptr - _form_error_buf;
				_feparsing++;
			} else {
				// ERROR!--too much form data, or didn't read all of it
				_feparsing = 199;
			}
		}
		return 0;
	} else if (_feparsing == 2) {
		// Check data for errors
		// Check for variables that are not in the form
		state->main_timeout = set_timeout(HTTP_TIMEOUT);
		nextvar = _form_error_buf;
		while (nextvar != NULL) {
			http_nextfverr(nextvar, &name, &value, &error, &next);
			if (sspec_findfv(state->spec, name) == -1) {
				// Got a variable that's not in the form
				_feparsing = 199;
				return 0;
			}
			nextvar = next;
		}
		// All of the variable names are OK, now check the values
		nextvar = _form_error_buf;
		formerror = 0;
		while (nextvar != NULL) {
			http_nextfverr(nextvar, &name, &value, &error, &next);
			retval = sspec_findfv(state->spec, name);
			if (sspec_checkfv(state->spec, retval, value) == -1) {
				formerror = 1;
				http_setfverror(nextvar);
			}
			nextvar = next;
		}
		// An error was generated
		if (formerror == 1) {
			_feparsing = 99;
			return 0;
		}
		_feparsing++;
		return 0;
	} else if (_feparsing == 3) {
		// Call the prolog function (if it exists)
		fptr = sspec_getfunction(sspec_getformprolog(state->spec));
      if (fptr) {
			if (fptr(state) != 0) {
				_feparsing++;
			}
		} else {
			_feparsing++;
		}
		return 0;
	} else if (_feparsing == 4) {
		// Change the variables
		nextvar = _form_error_buf;
		while (nextvar != NULL) {
			http_nextfverr(nextvar, &name, &value, &error, &next);
			retval = sspec_findfv(state->spec, name);
			sspec_changefv(state->spec, retval, value);
			nextvar = next;
		}
		_feparsing++;
		// Indicate that it's OK to unlock the form error buffer
		return 2;
	} else if (_feparsing == 5) {
		fptr = sspec_getfunction(sspec_getformepilog(state->spec));
      if (fptr) {
			if (fptr(state) != 0) {
				_feparsing++;
			}
		} else {
			_feparsing++;
		}
		return 0;
	} else if (_feparsing == 6) {
  		if (!(fptr = sspec_getformfunction(state->spec)))
  			fptr = http_generateform;
		retval = fptr(form, state, 0);
		if (retval == 1) {
			_feparsing++;
		}
		return 0;
	} else if (_feparsing == 99) {
  		if (!(fptr = sspec_getformfunction(state->spec)))
  			fptr = http_generateform;
		retval = fptr(form, state, 1);
		if (retval == 1) {
			_feparsing++;
		}
		return 0;
	} else if (_feparsing == 199) {
  		if (!(fptr = sspec_getformfunction(state->spec)))
  			fptr = http_generateform;
		retval = fptr(form, state, 0);
		if (retval == 1) {
			_feparsing++;
		}
		return 0;
	} else {
		_feparsing = 0;
		return 1;
	}
}

/*** BeginHeader http_idle */

/* START FUNCTION DESCRIPTION ********************************************
http_idle                     <HTTP.LIB>

SYNTAX:			int http_idle(void);

KEYWORDS:		tcpip, http

DESCRIPTION:	Query to see if any http servers are active.

RETURN VALUE:  non-zero if idle

SEE ALSO:		http_handler

END DESCRIPTION **********************************************************/

int http_idle();

/*** EndHeader */

_http_nodebug int http_idle()
{
   HTTP_DECL_INDEX

   HTTP_FORALL_SERVERS
      if(state->state > HTTP_LISTEN)
       return 0;
   HTTP_END_FORALL_SERVERS
   return 1;
}


/*** BeginHeader http_set_anonymous */
int http_set_anonymous(int uid);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
http_set_anonymous                   		<HTTP.LIB>

SYNTAX: int http_set_anonymous(int uid)

KEYWORDS:		tcpip, http

DESCRIPTION: 	Set the "anonymous" user ID.  This is the assumed user ID
               when no credentials are provided by the client (browser).
               A typical use of this function would be

|                int anon;
|
|                anon = sauth_adduser("anonymous", "",
|                                     SERVER_FTP|SERVER_HTTP);
|                sauth_setusermask(uid, WORLD_GROUP, NULL);
|                http_set_anonymous(uid);
|                ftp_set_anonymous(uid);	// if using FTP too

               which defines an "anonymous" login for the HTTP and,
               optionally, the FTP servers.  (Since FTP also
               requires an anon user, you can use the same user ID
               for both FTP and HTTP).

               When a web browser initially requests a resource, it may
               not pass any user credentials (i.e. user name and
               password).  The HTTP server will assume that the user is
               anonymous, and apply the access permissions tests on
               that basis.  If access is denied, then the browser
               will prompt the user for a real user name and password,
               and the request will be re-tried.

               You do not always need to define an anonymous user to
               HTTP, however it is required if you have some resource
               which is (say) protected for write access, but you want
               any user to be able to retrieve the resource without
               requiring a user name/password.

               Note: this function is non-reentrant.  It sets a global
               variable which is accessed by all HTTP server
               instances.  For this reason, you should call this function
               once only before starting to call http_handler().

PARAMETER1:    The userID to use as the anonymous user.  This should have
               been defined using sauth_adduser().  Pass -1 to set
               no anonymous user.  In this case, only resources which
               are completely free of any access controls will be
               accessible to users who do not provide credentials.

RETURN VALUE: 	Same as the uid parameter, except -1 if uid invalid.

SEE ALSO: 	   sauth_adduser, ftp_set_anonymous, sauth_setusermask

END DESCRIPTION **********************************************************/
_http_nodebug int http_set_anonymous(int uid)
{
	_http_uid_anon = uid;
	if (uid >= SAUTH_MAXUSERS)
		uid = -1;
	return uid;
}



/*** BeginHeader https_set_cert */
#if __HTTP_USE_SSL__
void https_set_cert(SSL_Cert_t __far *);
#endif
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
https_set_cert                   		<HTTP.LIB>

SYNTAX: void https_set_cert(SSL_Cert_t far *)

KEYWORDS:		tcpip, http

DESCRIPTION:	Register a server certificate with all HTTPS server
					instances.  Client hosts (such as web browsers) will verify
					this certificate, and may refuse to connect if there is no
					certificate, or the server certificate is not valid.

					This must be called at least once, otherwise there may be
					no default.  Alternatively, you can use the following
					line at the top of your main program:
					  #ximport "cert.dcc" SSL_CERTIFICATE
					where cert.dcc is the name (and path) of the server certificate
					file to use, which must be in .dcc format.  This usage is
					deprecated as of Dynamic C 10.54, since this function provides
					a more flexible interface.

PARAMETER1:    Pre-parsed certificate, as generated by SSL_new_cert().

SEE ALSO: 	   SSL_new_cert

END DESCRIPTION **********************************************************/

#if __HTTP_USE_SSL__
_http_nodebug
void https_set_cert(SSL_Cert_t __far * cert) {
	HTTP_DECL_INDEX

   HTTP_FORALL_SERVERS
   	// Only setup the certificate if an HTTPS server
   	if(_IS_HTTPS(state)) {
#ifdef SSL_SOCK_VERBOSE
			printf("https_set_cert: setting cert %08lX for server #%d\n",
					cert, HTTP_SERVNO);
#endif
	      state->cert = cert;
      }
   HTTP_END_FORALL_SERVERS
}
#endif


/*** BeginHeader */
#endif
/*** EndHeader */

