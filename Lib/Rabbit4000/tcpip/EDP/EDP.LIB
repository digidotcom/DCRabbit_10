/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader edp_globals, edp_init */
#ifndef EDP_LIB_Incl
#define EDP_LIB_Incl

#ifdef EDP_DEBUG
	#define _edp_debug	__debug
#else
	#define _edp_debug	__nodebug
#endif


#ifdef HAVE_RCI
	#error "EDP.LIB must be included before RCI.LIB"
#endif

#ifdef EDP_USE_TLS
	#ifndef USING_SSL
		#error "If EDP_USE_TLS defined, then SSL_SOCK.LIB must be included first"
	#endif
#endif

#define HAVE_EDP

#ifndef IDIGI_PRODUCT
	#define IDIGI_PRODUCT	"Unknown"
#endif


#ifndef EDP_VERBOSE
	#define EDP_VERBOSE 0
#endif

#ifdef DISABLE_DNS
	#error "EDP requires DNS.  Do not #define DISABLE_DNS"
#endif

#ifndef EDP_MAX_FAC
	#define EDP_MAX_FAC	3
#endif

// Interval in seconds.  Since we expect a lot of usage on cellular
// networks, it is important to minimize overall bandwidth use.  Thus,
// keepalive intervals should be selected to be as high as possible.
// It is normally OK to make the "from server" interval much higher
// than the interval at which we send keepalives, since unidirectional
// keepalives will elicit a response at the underlying (TCP) layer.
// Having keepalives in both directions is often a waste of bandwidth.
// The same considerations apply when behind ordinary firewalls etc.
// NOTE: these are initial defaults, which may be changed by the server.
// Both values must be less than 65536 since the field is a 16 bit integer.
#ifndef EDP_KEEPALIVE_INTERVAL
	#define EDP_KEEPALIVE_INTERVAL	16
#endif
#ifndef EDP_KEEPALIVE_INTERVAL_FROM_SVR
	#define EDP_KEEPALIVE_INTERVAL_FROM_SVR  65400
#endif
// Multiple of keepalive interval at which to terminate connection.  This
// applies to the "from server" direction.  Make sure that
// EDP_KEEPALIVE_WAIT * EDP_KEEPALIVE_INTERVAL_FROM_SVR is less than
// 2,140,000 (i.e. about 24 days)
#ifndef EDP_KEEPALIVE_WAIT
	#define EDP_KEEPALIVE_WAIT	5
#endif


// Basic, comm layer types.  These are specified in reversed format.
#define EDP_VERSION				0x0400
#define EDP_VERSION_OK			0x1000
#define EDP_VERSION_BAD			0x1100
#define EDP_SERVER_OVERLOAD	0x1200
#define EDP_KEEPALIVE			0x3000
#define EDP_PAYLOAD 				0x4000


// Facility codes, in byte-swapped form
#define EDP_FACILITY_PIO					0x0000
#define EDP_FACILITY_FILESYSTEM			0x4000
#define EDP_FACILITY_FIRMWARE				0x7000
#define EDP_FACILITY_RCI					0xA000
#define EDP_FACILITY_MSG					0xC000

#define EDP_FACILITY_CLIENT_LOOPBACK 	0x00FF
#define EDP_FACILITY_SERVER_LOOPBACK 	0x01FF
#define EDP_FACILITY_CONN_CONTROL	 	0xFFFF

#define EDP_MT_PORT		3197
#define EDP_MTSSL_PORT	3199

#ifndef EDP_RX_BUFFER_SIZE
	#define EDP_RX_BUFFER_SIZE 4000
#endif

#ifndef EDP_TLS_RX_BUFFER_SIZE
	#define EDP_TLS_RX_BUFFER_SIZE 16420
#endif


// This is set to half the buffer size, minus the packet overhead (8 bytes
// for the facility header and another 8 for the message start header).
// This is because entire max-sized message packets must fit in the EDP
// socket receive buffer, and we want to fit 2 such messages for efficiency.
#define EDP_MSG_MAX_WINDOW		(EDP_RX_BUFFER_SIZE/2-16)


#ifndef EDP_MSG_MAX_SVCS
	#define EDP_MSG_MAX_SVCS	3
#endif

// Opcodes for EDP_FACILITY_MSG
enum {
	EDP_MSG_OPC_CAPABILITIES =	0,
	EDP_MSG_OPC_START,
	EDP_MSG_OPC_DATA,
	EDP_MSG_OPC_ACK,
	EDP_MSG_OPC_ERROR
};

// Fixed part of msg capabilities packet
typedef struct {
	char	opcode;			// above enum, value = EDP_MSG_OPC_CAPABILITIES
   char	flags;
   #define EDP_MSG_FLAG_REQ_CAP	0x01	// Request caps from peer
   char	version;			// Facility version
   char	max_trans;		// Maximum simultaneous rx transactions (or 0 if unlimited)
   longword	window;		// Start rx window in bytes
   char	n_compr;			// Number of compression algos following
   char	compr[1];		// First of variable number of compr algos
   							// This is then followed by part2 struct below
} edp_msg_capabilities_1;

typedef struct {
	word	n_svc;			// Service count following
   word	svc_id[1];		// First of variable number of service IDs
} edp_msg_capabilities_2;

// Header of msg start packet
typedef struct {
	char	opcode;			// above enum, value = EDP_MSG_OPC_START
	char	flags;
   #define EDP_MSG_FLAG_REQUEST	0x01
   #define EDP_MSG_FLAG_LAST		0x02
   word	trans_id;		// Transaction ID
   word	svc_id;			// Service ID
   char	compr;			// Compression algorithm in use (0=none)
   			// 1st byte of payload (compressed) follows immediately
} edp_msg_start;

// Header of msg data packet: continues and/or terminates data stream.
typedef struct {
	char	opcode;			// above enum, value = EDP_MSG_OPC_DATA
	char	flags;			// Same flags as for edp_msg_start
   word	trans_id;		// Transaction ID
   			// 1st byte of payload (compressed) follows immediately
} edp_msg_data;

// Header of msg ack packet: acknowledge reception of data.
// NOTE: ack and window counts apply to the uncompressed (inflated) data stream.
typedef struct {
	char	opcode;			// above enum, value = EDP_MSG_OPC_ACK
	char	flags;			// Same flags as for edp_msg_start
   word	trans_id;		// Transaction ID
   longword	ack;			// Number of message bytes received
   longword	window;		// New rx window size in bytes
} edp_msg_ack;

// Protocol error indication packet
typedef struct {
	char	opcode;			// above enum, value = EDP_MSG_OPC_ERROR
	char	flags;			// EDP_MSG_FLAG_REQUEST or following
   #define EDP_MSG_FLAG_SENDER	0x04
   word	trans_id;		// Transaction ID
   char	code;				// Error code
} edp_msg_error;

//
// Protocol error codes
//
enum {
    MSG_ERR_NONE = 0x00,            // Success
    MSG_ERR_FATAL,                  // Unspecified error
    MSG_ERR_PROTOCOL_SEQUENCE,      // Protocol sequencing error
    MSG_ERR_MESSAGE_FORMAT,         // Message format error
    MSG_ERR_TRANSACTION,            // Transaction ID in use
    MSG_ERR_NO_TRANSACTION,         // Unknown transaction ID
    MSG_ERR_COMPRESSION_FAILURE,    // Compression failure
    MSG_ERR_DECOMPRESSION_FAILURE,  // Decompression failure
    MSG_ERR_MEMORY,                 // Memory allocation error
    MSG_ERR_SEND,                   // Message transmission error
    MSG_ERR_CANCEL,                 // Message transmission cancelled
    MSG_ERR_WOULDBLOCK,             // Flow controlled
    MSG_ERR_ACK,                    // Error waiting for acknowledgement
    MSG_ERR_TIMEOUT,                // Timeout waiting for response
    MSG_ERR_NOT_HANDLED,            // No service to process message
};

//
// Compression algorithm codes
//
enum MSG_COMP_ALG
{
    MSG_COMP_ALG_NONE = 0x00,       // No compression (default and required)
    MSG_COMP_ALG_ZLIB = 0xff        // ZLIB compressed data format
};

//
// Service IDs
//
enum {
	MSG_SVC_ECHO = 0x0000,				// Echo (loopback)
	MSG_SVC_DATA = 0x0001,				// Data service (replacement for HTTP PUT)
	MSG_SVC_FILE = 0x0002,				// Filesystem service
};


/*
	This struct encapsulates a single EDP message transaction.  A linked list
   of these is based at EDP.msgs.

   This list is consulted in the network driver handlers in order to map
   TCP/IP header fields to an active EDP transaction and its state machine.

   The "key" is the tuple (request, trans_id).

*/
typedef struct edp_trans_t
{
	struct edp_trans_t __far * next;	// Next in linked list of message transactions.
   word	timer;					// Timer (ms) for short-term events (up to 32s)
   longword ltimer;				// Timer for longer events (up to 24d)
   int	request;					// True if this is a request in the device->server
   									// direction (i.e. a response in the s->d direction)
                              // else it it a response in the d->s direction.
   word	svc_id;					// Service ID (one of MSG_SVC_* enums), however
   									// stored in network byte order.
   word	trans_id;				// Transaction ID - stored in network byte order.
                              // Note that there is a separate transaction
                              // ID space for request and !request.
   int	sent_start;				// Sent START packet to server
   int	sent_last;				// Sent LAST flag
   int	rx_start;				// Got START packet from server
   int	rx_last;					// Got LAST flag
   int	done;						// Set by app when added last data
   int	wait_win;				// Waiting for peer to open window, timer running.
   int	wait_response;			// Waiting for response data, ltimer running

   longword bytes_tx;			// Byte number of next byte to send to server
   longword bytes_rx;			// Bytes of data received from peer
   longword adv_win;				// Last rightmost window (ack+win) advertised
   longword peer_win;			// Byte number of first byte we can't send to
   									// server because of his window.
   _tbuf		tx;					// Transmit circular buffer (sized min(EDP_MSG_MAX_WINDOW,
   									//    initial server window)).
   _tbuf		rx;					// Receive circular buffer (sized EDP_MSG_MAX_WINDOW)
   const struct edp_msg_handler_t __far *
   			handler;				// Handler registered (or NULL if not known)
   void __far * context;		// Data for handler
} edp_trans_t;

/*
	This struct used to register handlers for messaging facility.  Incoming
   requests from server get routed to the appropriate handler functions.
   The list of registered handlers also gets sent in our capabilities packet.

   A handler is also specified for handling responses from the server in the
   case where the application has initiated the request.
*/
typedef struct edp_msg_handler_t
{
	word	svc_id;				// Service ID of this handler
   word	response_timeout;	// ms timeout value for server to start
   								// response after ending our request.  Max 65s.
                           // May be zero if not expecting response.
	word	allocate;			// Memory size to allocate for context.  If non-zero,
   								// edp_msg_delete_trans() will automatically
                           // free the allocated (calloc) storage.  Otherwise,
                           // no assumptions are made about context and the
                           // application is responsible.
   // Any of the following callbacks may be NULL, however at least one of
   // tick() and receive() should be coded to handle received data, and one of
   // tick(), open() or eof() would be required to send data.

	// Called regularly out of edp tick function in order to drive any
   // required timeout or regular state machine processing.
	void (*tick)(edp_trans_t __far * trans);
   // Called when new transaction - allocate resources etc.
   void (*open)(edp_trans_t __far * trans);
   // Called just before deleting transaction (cleanup) - whether or not
   // an error condition.  Free resources etc.
   void (*close)(edp_trans_t __far * trans);
   // Called when new data from server available (in rx buffer).
   void (*receive)(edp_trans_t __far * trans);
   // Called when last data received from server (in rx buffer)
   void (*eof)(edp_trans_t __far * trans);
   // Called when error received from server
   void (*error)(edp_trans_t __far * trans);
   // Called when terminated locally : -ve reason if the EDP socket is closed,
   // or +ve code (one of MSG_ERR_*) if we send an error packet to server.
   void (*cancel)(edp_trans_t __far * trans, int reason);

} edp_msg_handler_t;


/*
 * Following macros may be defined in order to specify TLS-related defaults:
 */
// Permit any iDigi server certificate.  This would normally be defined only
// during testing, or where the application has other assurances that the
// intended server is valid, or if this level of checking is not justified.
// If *not* defined, then the application must specify a trusted authority
// certificate list.
//#define IDIGI_ALLOW_ANY_SERVER_CERT

// Permit NULL encryption i.e. cleartext.  This may be permissible where the
// message contents and headers are not sensitive, and only the ability to
// detect tampering and authenticate the server are considered necessary.
//#define IDIGI_ALLOW_CLEARTEXT

// Permit server certificate common name (CN) field to mismatch the expected
// server name (e.g. sd1-na.idigi.com).  By default, the name in the certificate
// must match the expected DNS domain name.
//#define IDIGI_ALLOW_CERT_CN_MISMATCH

// Use these macros consistently for dealing with TCP and/or SSL sockets
#define _TCP_SOCK_OF_EDP(state) (state->tport)
#ifdef EDP_USE_TLS
	#define _SOCK_OF_EDP(state) (state->sock)
	#define _SSL_SOCK_OF_EDP(state) (state->_n_ssl)
#else
	#define _SOCK_OF_EDP(state) _TCP_SOCK(state->sock)
	#define _SSL_SOCK_OF_EDP(state) NULL	// should never be used
#endif



// Universals for this device.  Facility handler functions are global.
typedef struct _EDP_globals {
	word	iface;			// Current interface number for iDigi connection.
								// Only one interface can have active iDigi connection
								// at any one time.
	int   ding_network;		// Set when network reconfig required,
									// via idigi_notify_update_network(), reset
									// when rci_config_network() called.
	word	tmr;					// (short) delay timer for restart
	long	btmr;					// Timer for giving up on normal configuration
									// and trying the backup, and vice versa.
	char	mac[6];				// Interface MAC address (for convenience)
	char	device_id[16];		// Device ID
	word	num_fac;				// Number of registered facility handlers
	struct {
		word	fac_num;
		void (*func)();	// Facility handlers
	} fac[EDP_MAX_FAC];
   word	trans_id;		// Message facility new transaction ID counter
   #ifdef IDIGI_USE_FAT
   int   idigi_user;		// Zserver user ID for iDigi server access
   							// (name="idigi", password="")
	ServerContext zs_context;
	#endif
} EDP_globals;

// Connection info.
typedef struct _EDP {
	int				proto;		// 0 if unknown, 1 if MT, 2 if MTSSL
	int				secured;		// Security state. 0 = no, 1 = negotiating, 2 = secure
	void * 			sock;			// Same as _n_ssl or tport, depending on TLS use.
#ifdef EDP_USE_TLS
	ssl_Socket *	_n_ssl;
   SSL_Cert_t __far * cert; 		// Pointer to the certificate structure
	// Following fields set using edp_set_tls().  See that function for details.
	word 		tls_flags;
	SSL_Cert_t __far * my_cert;
	SSL_Cert_t __far * trusted;
	int (*policy)(ssl_Socket __far * state,
	                       int trusted,
	                       struct x509_certificate __far * cert,
	                       void __far * data);
#endif
	tcp_Socket *	tport;		// Transport layer

	int            iface;      // interface to use for socket
	int				ifx;			// interface number index for compatibility
										// with the RCI settings (_RCI_Settings.mgmtnetwork[])
	int				state;		// Current low-level state as follows...
#define EDP_STATE_CLOSED		0	// Closed, ready to open
#define EDP_STATE_RESOLVING	1	// Initial DNS resolve
#define EDP_STATE_OPENING		2	// Opening transport
#define EDP_STATE_SECURING		3	// Securing transport
#define EDP_STATE_UNSECURING	4	// Unsecuring transport (not used)
#define EDP_STATE_CLOSING		5	// Closing transport
#define EDP_STATE_REDIR_CLS	6	// Closing prior to redirect
#define EDP_STATE_REDIRECTING	7	// Closed, opening again with redirected URI
#define EDP_STATE_REBOOT		8	// Reboot requested (edp_close() called with -1)
// Following 2 states alternate when transport connection established.
#define EDP_STATE_OPEN			10	// Open, sent initial MT version message.
											// In this state, keepalives are active,
											// and facility callbacks may be invoked.
#define EDP_STATE_MSGHDR		11	// Received initial type/length field for
											// next received message at lowest layer.
#define EDP_STATE_TPORT_OPENING 12	// Opening TCP socket ready for TLS
	int				phase;		// Higher level protocol phase as foll.:
#define EDP_PHASE_INIT			0		// Received MT version OK, send inner versioning
#define EDP_PHASE_WAIT_VERS_OK 1		// Waiting for inner version OK
#define EDP_PHASE_SECURING		2		// Received inner version OK, securing
#define EDP_PHASE_DISCOVERY	8
#define EDP_PHASE_FACILITY		10

	// Following is set to the various parts of the server URL.
	char __far *		uri;			// Original URI
	char __far *		red_uri;		// Redirected URI (or NULL for first try)
	url_parsed_t 	parsed;		// Points to application-owned data
	char __far *		hostname;	// Host name
	longword			ip;			// ipv4 address of server
	word 				port;			// Host port (usually 80)
	int				dns;			// Handle for nameserver resolve

	long				rx_ka;		// RX keepalive timer - use this to send KAs to
											// server if no messages sent in the interval.
	long				tx_ka;		// TX keepalive timer.  This is set to
											// WAIT * TX in the initial negotiation.
											// If no KAs received from server in this
											// interval, can the connection.
	word				msg_type;	// Received message type (network order)
	word				msg_len;		// Received message length (size of rxdata)
	word				msg_read;	// Amount of above message which has been read
	char __far *		rxdata;		// Buffer (malloc'd) to read in current message.
	long				epoch;		// Session start time (MS_TIMER)

   /*****************************************************************
   Following fields really belong in RCI library, but put them here
   so we can more easily manage cleanup of the malloc'd rci_rxdata
   in case of errors.  Also, there's some RCI-related initialization
   which must be done when session established.
   ******************************************************************/
	int				rci_state;	// State for RCI facility handler
#define RCI_STATE_READY		0		// Initial state, ready to get server data
#define RCI_STATE_RX			1		// Reading server data
#define RCI_STATE_RXDONE	2		// Server sent disconnect mesage
#define RCI_STATE_ERROR		10		// Encountered error
	longword			rci_rxlen;	// Total data to expect
	longword			rci_read;	// Total read so far
	char __far *		rci_rxdata;	// Buffer (malloc'd) to read into, or NULL.

   /*****************************************************************
   Following fields for firmware access.
   ******************************************************************/
   int				fw_state;	// State for firmware access:
#define FW_STATE_READY		0		// Initial state
#define FW_STATE_START		1		// Ready to receive 1st bock
#define FW_STATE_RX1			2		// Receiving first 1024 bytes
#define FW_STATE_RX2			3		// Receiving past the first 1k
#define FW_STATE_COMPLETE	4		// Read complete, temp closed.
#define FW_STATE_VERIFYING	5		// tmp open, verifying
#define FW_STATE_DONE		6		// tmp closed, installation attempted
   longword			new_vers;	// New firmware version (as set by server)
   longword			new_size;	// Image size (0 if not downloading)
   longword			next_offs;	// Next expected image offset

   /*****************************************************************
   Following fields for message facility.
   ******************************************************************/
   edp_trans_t __far *	msgs;	// Linked list of active transactions
   edp_trans_t __far *	robin;// Next transaction to tick in round-robin
   const edp_msg_handler_t __far *
   		handlers[EDP_MSG_MAX_SVCS];	// Array of handlers
   									// for incoming requests from the server.
   // Following fields point to malloc'd copy of peer's capabilities
   // packet.  Freeing peer_caps_1 frees both pointers since 2 points into 1.
   // This is re-allocated when new caps come in from peer, since in theory
   // they can change during a connection.  Both pointers NULL until
   // caps available.
	edp_msg_capabilities_1 __far * peer_caps_1;
	edp_msg_capabilities_2 __far * peer_caps_2;

} EDP;





extern EDP_globals edp_globals;
void edp_init(EDP __far * s, tcp_Socket *t, int iface);

/*** EndHeader  */

EDP_globals edp_globals;

#ifdef EDP_USE_TLS
#ximport "include/ximport/Certs/digi2048ca.crt"  _digi_ca_pem
#endif

const far edp_msg_handler_t _edp_handlers_echo_svc = {
	MSG_SVC_ECHO, 60000u, 0,
	_edp_msg_echo_tick
};

const far edp_msg_handler_t _edp_handlers_data_svc = {
	MSG_SVC_DATA, 60000u, sizeof(edp_msg_data_svc_t),
	_edp_msg_data_tick
};

#ifdef IDIGI_USE_FAT
const far edp_msg_handler_t _edp_handlers_file_svc = {
	MSG_SVC_FILE, 60000u, sizeof(edp_msg_file_svc_t),
	_edp_msg_file_tick,
   _edp_msg_file_open,
   _edp_msg_file_close
};
#endif



_edp_debug
void edp_init(EDP __far * s, tcp_Socket *t, int iface)
{
	static int first_time = 1;
#ifdef EDP_USE_TLS
	static SSL_Cert_t trusted;
   static int rc;
#endif
	word m;
	#GLOBAL_INIT { _f_memset(&edp_globals, 0, sizeof(edp_globals)); }

	_f_memset(s, 0, sizeof(*s));
	s->sock = t;
	s->tport = t;
	s->iface = iface;

   s->handlers[0] = &_edp_handlers_echo_svc;
   s->handlers[1] = &_edp_handlers_data_svc;
#ifdef IDIGI_USE_FAT
   s->handlers[2] = &_edp_handlers_file_svc;
#endif
/*
From the description for edp_set_tls():
   It is automatically called by edp_init() with the following
   flags:
      SSL_F_REQUIRE_CERT
   my_cert: NULL
   trusted: Digi 2048-bit RSA CA certificate (include/ximport/Certs/digi2048ca.crt)
   policy: default policy is to accept all certificates signed by
           the above trusted CA.
   These defaults are not secure since there is no certificate
   chain verification.
*/
	if (first_time) {
   	first_time = 0;
#ifdef IDIGI_USE_FAT
		edp_globals.idigi_user = sauth_adduser("idigi", "", SERVER_IDIGI);
      sauth_setusermask(edp_globals.idigi_user, idigi_get_group(), NULL);
      sauth_setwriteaccess(edp_globals.idigi_user, SERVER_IDIGI);
      // Create a context (i.e. Zserver user under which iDigi operates)
	   edp_globals.zs_context.userid = edp_globals.idigi_user;
	   edp_globals.zs_context.server = SERVER_IDIGI;// All servers
	   edp_globals.zs_context.rootdir = "/";     // Access from root
	   _f_strcpy(edp_globals.zs_context.cwd, "/");
	   edp_globals.zs_context.dfltname = NULL;   // No default filename
#endif

#ifdef EDP_USE_TLS
	   memset(&trusted, 0, sizeof(trusted));
	   rc = SSL_new_cert(&trusted, _digi_ca_pem, SSL_DCERT_XIM, 0);
	   #if EDP_VERBOSE
      printf("EDP: Parsed CA certificate, rc=%d\n", rc);
	   #endif
#endif
   }
#ifdef EDP_USE_TLS
	edp_set_tls(s,
		SSL_F_REQUIRE_CERT,
		NULL,
		rc ? NULL : &trusted,
		_edp_dflt_policy
		);

#endif
}


/*** BeginHeader edp_facility_index */
int edp_facility_index(word fac_num);
/*** EndHeader  */
_edp_debug
int edp_facility_index(word fac_num)
{
	word i;
	for (i = 0; i < edp_globals.num_fac; ++i) {
		if (edp_globals.fac[i].fac_num == fac_num)
			return i;
	}
	return -1;
}



/*** BeginHeader edp_register_facility */
int edp_register_facility(word fac_num, void (*func)());
/*** EndHeader  */
_edp_debug
int edp_register_facility(word fac_num, void (*func)())
{
	int idx;

	idx = edp_facility_index(fac_num);
	if (idx >= 0)
		edp_globals.fac[idx].func = func;
	else if (edp_globals.num_fac >= EDP_MAX_FAC)
		return -1;
	else {
		idx = edp_globals.num_fac++;
		edp_globals.fac[idx].func = func;
	}
	return 0;
}

/*** BeginHeader _edp_dflt_policy */
#ifdef EDP_USE_TLS
int _edp_dflt_policy(ssl_Socket __far * state, int trusted,
	                       struct x509_certificate __far * cert,
	                       void __far * data);
#endif
/*** EndHeader  */

_edp_debug
int _edp_dflt_policy(ssl_Socket __far * state, int trusted,
	                       struct x509_certificate __far * cert,
	                       void __far * data)
{
	EDP __far * s = (EDP __far *)data;
#if EDP_VERBOSE
	printf("EDP: cert CN=%ls;\n  hostname=%ls\n  trusted=%s\n",
		cert->subject.cn, s->hostname, trusted ? "yes" : "no");
#endif
	// Always accept if trusted - we assume any cert signed by the CA is OK, since the
   // CA is Digi.
	return trusted == 0;
}




/*** BeginHeader edp_tick */
/* Pass non-NULL URI to start, NULL uri to continue, until returns other
   than -EAGAIN.  Returns 0 if no URI in state CLOSED (meaning state is
   ready to re-open with new URI).

	This routine may rely on some data in the _RCI_Settings variable.

	Caller is expected to call tcp_tick().
*/
int edp_tick(EDP __far * s, char __far * uri);
/*** EndHeader  */


_edp_debug
int edp_tick(EDP __far * s, char __far * uri)
{
	auto char hnbuf[128];
	auto longword ipaddr;
	int rc;
	word len;
	int cmi;	// Management network index to use (0=ppp,1=eth,2=wifi)
	int cm;	// Connect method (0=auto, 1=none, 2=MT, 3=MTSSL)
	word iface;
#ifdef EDP_USE_TLS
	ssl_Socket * ssl;
#endif

	switch (s->state) {
	case EDP_STATE_REDIRECTING:
#if EDP_VERBOSE
      printf("EDP: Redirecting to %ls\n", s->red_uri);
#endif
		uri = s->red_uri;
		s->phase = EDP_PHASE_INIT;
		goto _reso;
	case EDP_STATE_REBOOT:
		return -NETERR_ABORT;
	case EDP_STATE_CLOSED:
		if (!uri)
			return 0;
		if (s->rci_rxdata) {
			_sys_free(s->rci_rxdata);
			s->rci_rxdata = NULL;
		}
		edp_free_buf(s);
		s->epoch = MS_TIMER;
		s->uri = uri;
		s->red_uri = NULL;
	_reso:
		rc = url_parse(&s->parsed, uri);
		if (rc) return rc;
		s->port = 0;
		s->proto = 0;
		s->secured = 0;
		if (*s->parsed.scheme) {
#ifdef EDP_USE_TLS
			s->proto = !strcmp(s->parsed.scheme, "ens") ? 2 : 1;
#endif
			if (s->proto != 2 && strcmp(s->parsed.scheme, "en"))
				return -EINVAL;	// If given, scheme must be 'en' (or 'ens' if SSL).
		}	// else proto remains 0 and is resolved according to RCI variables.

		if (!s->parsed.port && s->proto) {
			s->port = s->proto == 1 ? EDP_MT_PORT : EDP_MTSSL_PORT;	// Default EDP port number
		}

		s->hostname = s->parsed.hostname;
#if EDP_VERBOSE
      printf("EDP: Resolving %ls\n", s->hostname);
#endif
      //DEVIDEA: make DNS far ptrs
      _f_strcpy(hnbuf, s->hostname);
      s->dns = resolve_name_start(hnbuf);
      if (s->dns < 0)
      {
      _edp_dnserror:
#if EDP_VERBOSE
         printf("EDP: Error resolving server (%x).\n", s->dns);
#endif
         return s->dns;
      }
      s->state=EDP_STATE_RESOLVING;
		// fall thru
	case EDP_STATE_RESOLVING:
      if ((rc = resolve_name_check(s->dns, &ipaddr)) == RESOLVE_SUCCESS) {
      	s->ip = ipaddr;
      	if (s->iface == IF_ANY) {
      		// Resolve specific (best) interface
      		router_for_iface(ipaddr, NULL, &iface, IF_ANY);
      		s->iface = iface;
      	}
      	// Based on the interface, select the appropriate management network index.
      	// (This is an RCI thing).
      	cmi = 0;	// default PPP (mobile)
	#if WIFI_ONBOARD
			if (s->iface == IF_WIFI0)
				cmi = 2;
	#endif
	#if ETHERNET_ONBOARD
			if (s->iface == IF_ETH0)
				cmi = 1;
	#endif
			s->ifx = cmi;
			cm = _RCI_Settings.mgmtnetwork[cmi].connectMethod;
	#if EDP_VERBOSE
	      printf("EDP: iface=0x%x, using management network %d, cm = %d\n", s->iface, cmi, cm);
	#endif
      	if (!s->proto) {
      		if (cm == 1) // none
      			return -ENOENT;
				s->proto = cm == 3 ? 2 : 1;
      	}
			if (!s->port)
      		if (cm == 1) // none
      			return -ENOENT;
				s->port = cm == 3 ? EDP_MTSSL_PORT : EDP_MT_PORT;
	#ifndef EDP_USE_TLS
			if (s->proto == 2) {
	#if EDP_VERBOSE
	      	printf("EDP: TLS required but not available\n");
	#endif
				return -EINVAL;
			}
	#endif

	      // tcp_extopen has non-standard return -- 0 is failure, !0 is success
	#if EDP_VERBOSE
	      printf("EDP: Opening IP=%08lX port=%u proto=%s\n", s->ip, s->port,
	      	s->proto == 2 ? "mtssl" : "mt");
	#endif
	#ifdef EDP_USE_TLS
	      rc = tcp_extopen(s->sock, s->iface, 0, s->ip, s->port, NULL, 0,
	   				s->proto == 2 ? -EDP_TLS_RX_BUFFER_SIZE :
	   								-EDP_RX_BUFFER_SIZE);
	#else
	      rc = tcp_extopen(s->sock, s->iface, 0, s->ip, s->port, NULL, 0,
	   								-EDP_RX_BUFFER_SIZE);
	#endif
	      if (!rc)
	         return -NETERR_NOHOST_ARP;
	#ifdef EDP_USE_TLS
	      s->state = s->proto == 2 ? EDP_STATE_TPORT_OPENING : EDP_STATE_OPENING;
	#else
	      s->state = EDP_STATE_OPENING;
	#endif
	      break;
      }
      if (rc != RESOLVE_AGAIN) {
      	s->dns = rc;
         goto _edp_dnserror;
      }
      break;

#ifdef EDP_USE_TLS
	case EDP_STATE_TPORT_OPENING:
		if (sock_established(s->sock)) {
#if EDP_VERBOSE
			printf("EDP: Socket connected (plaintext)\n");
#endif
         // OK, secure this socket and re-jig pointers so that server struct
         // points to secure socket rather than direct transport.
         // App data buffers are sized to be the same as the transport (TCP socket)
         // buffer sizes, and dynamically allocated.
         rc = sock_secure(_TCP_SOCK_OF_EDP(s), &ssl,
                      TCP_BUF_SIZE>>2, NULL, // Read buffer (1/4)
                      TCP_BUF_SIZE*3>>2, NULL, // Write buffer (3/4)
                      1,   // Is a client
                      s->tls_flags,
                      0, 0, 0, 0,
                      s->my_cert,
                      s->trusted,
                      NULL          // No session to resume
                      );
         if (!rc) {
         	s->_n_ssl = ssl;
            s->sock = s->_n_ssl;
            s->_n_ssl->policy_data = s;
            if (s->policy)
               s->_n_ssl->policy = s->policy;
            else
               s->_n_ssl->policy = _edp_dflt_policy;
            s->secured = 1;
         }
         else {
				_edp_handle_error(s, 11);
				return rc;
			}
         s->state = EDP_STATE_OPENING;
		}
		break;
#endif

   case EDP_STATE_OPENING:
		if (!sock_alive(s->sock)) {
			_edp_handle_error(s, 12);
			return -NETERR_REMOTE_RESET;
		}

		if (sock_established(s->sock)) {
#if EDP_VERBOSE
			printf("EDP: Socket connected!\n");
#endif
			if (s->secured == 1)
				s->secured = 2;
			s->epoch = MS_TIMER;
			s->state = EDP_STATE_OPEN;
	      // Set up device ID based on MAC address.
	      // Create an EUI-64 identifier
	      // Always use the SystemID block MAC address, since want the
	      // "canonical" address on those boards with multiple interfaces.
	      _f_memcpy(edp_globals.mac, SysIDBlock.macAddr, 6);
	      _f_memset(edp_globals.device_id, 0, 8);
	      _f_memcpy(edp_globals.device_id + 8, SysIDBlock.macAddr, 3);
	      edp_globals.device_id[11] = 0xFF;
	      edp_globals.device_id[12] = 0xFF;
	      _f_memcpy(edp_globals.device_id + 13, SysIDBlock.macAddr+3, 3);
#if EDP_VERBOSE
			printf("EDP: My device ID is:\n");
			mem_dump(edp_globals.device_id, 16);
#endif

	      // Write the version mesage (Version 2 of MT),
	      // RX interval (16 sec), TX interval (16 sec) and Wait (3).
	      // This won't block, since have empty tx buffer.
	      // Also can't fail.
			memcpy(hnbuf, "\x00\x04\x00\x04\x00\x00\x00\x02" \
	      	"\x00\x20\x00\x02\x00\x00" \
	      	"\x00\x21\x00\x02\x00\x00" \
	      	"\x00\x22\x00\x02\x00\x00"
	      	, 8+6+6+6);
	      *(word *)(hnbuf+12) = htons(_RCI_Settings.mgmtnetwork[s->ifx].mtRxKeepAlive);
	      *(word *)(hnbuf+18) = htons(_RCI_Settings.mgmtnetwork[s->ifx].mtTxKeepAlive);
	      *(word *)(hnbuf+24) = htons(_RCI_Settings.mgmtnetwork[s->ifx].mtWaitCount);
	      sock_fastwrite(s->sock, hnbuf, 8+6+6+6);

	      s->rx_ka = _SET_TIMEOUT(_RCI_Settings.mgmtnetwork[s->ifx].mtRxKeepAlive * 1000ul);
	      s->tx_ka = _SET_TIMEOUT(_RCI_Settings.mgmtnetwork[s->ifx].mtTxKeepAlive * 1000ul *
	      					_RCI_Settings.mgmtnetwork[s->ifx].mtWaitCount);
		}
		break;

	case EDP_STATE_MSGHDR:
	case EDP_STATE_OPEN:
		if (_CHK_TIMEOUT(s->tx_ka)) {
			// Server died
			_edp_handle_error(s, 1);
			return -NETERR_INACTIVE_TIMEOUT;
		}
		if (_CHK_TIMEOUT(s->rx_ka)) {
			// Send keepalive msg
			rc = edp_send_msg(s, EDP_KEEPALIVE, NULL, 0);
			if (rc)
				return rc;
		}

      // Drive message facility transactions
		edp_msg_tick(s);

		// Check if complete message ready and, if so, send it to
		// next protocol layer.
		if (s->state == EDP_STATE_OPEN) {
			rc = sock_readable(s->sock);
			if (!rc) {
				_edp_handle_error(s, 2);
				return -EIO;
			}
			--rc;
			if (rc >= 4) {
				// OK, got header (type+length)
				rc = sock_fastread(s->sock, hnbuf, 4);
				s->msg_type = *(word *)hnbuf;
				s->msg_len = ntohs(*(word *)(hnbuf + 2));
				s->state = EDP_STATE_MSGHDR;
				s->msg_read = 0;
				// Get at least 512 bytes, so can be used as reply area
				s->rxdata = (char __far *)_sys_malloc(u_max(s->msg_len, 512));
				if (!s->rxdata) {
					_edp_handle_error(s, 14);
					return -ENOMEM;
				}
			}
			else
				break;
		}
		// OK, must be in state EDP_STATE_MSGHDR.  Get complete message
		rc = sock_readable(s->sock);
      if (!rc) {
         _edp_handle_error(s, 3);
         return -EIO;
      }
      len = rc - 1;
      len = u_min(len, s->msg_len - s->msg_read);
      sock_fastread(s->sock, s->rxdata + s->msg_read, len);
      s->msg_read += len;
      if (s->msg_read == s->msg_len) {
         edp_handle_message(s, s->rxdata, s->msg_len);
         edp_free_buf(s);
         if (s->state == EDP_STATE_MSGHDR)
            s->state = EDP_STATE_OPEN; // Done with this msg, continue
         // Otherwise, may have closed for redirect etc.
      }
		break;

	case EDP_STATE_REDIR_CLS:
		if (!sock_alive(s->sock))
			s->state = EDP_STATE_REDIRECTING;
		break;

	case EDP_STATE_CLOSING:
   	// Empty transport if any remaining
   	if (sock_readable(s->sock) > 1) {
      	sock_fastread(s->sock, NULL, sock_readable(s->sock)-1);
      }
		if (!sock_alive(s->sock)) {
			s->state = EDP_STATE_CLOSED;
#ifdef EDP_USE_TLS
	      if (s->secured) {
	         sock_unsecure(s->_n_ssl);
	         s->secured = 0;
	         s->_n_ssl = NULL;
         }
#endif
			return 0;
		}
		break;

	default:
		// Bad state to be calling this
		return -EINVAL;

	}
	return -EAGAIN;
}


/*** BeginHeader _edp_handle_error */
void _edp_handle_error(EDP __far *s, int p);
/*** EndHeader  */
_edp_debug
void _edp_handle_error(EDP __far *s, int p)
{
	edp_trans_t __far * trans;

#if EDP_VERBOSE
	printf("%s - EDP: unexpected error, p=%d, aborting connection\n",
		_edp_getElapsed(s), p);
#endif
	edp_close(s, 0);

   // Now cancel any outstanding message facility transactions
	for (trans = s->msgs; trans; trans = trans->next)
   	edp_msg_delete_trans(s, trans, -EIO);
}


/*** BeginHeader edp_send_msg */
// 'type' must be supplied byte-reversed from what's natural to Rabbit.
int edp_send_msg(EDP __far * s, word type, void __far * msg, word len);
/*** EndHeader  */
_edp_debug
int edp_send_msg(EDP __far * s, word type, void __far * msg, word len)
{
	int wr;
	word rlen;

	tcp_tick(NULL);
	wr = sock_writable(s->sock);
	if (!wr) {
		_edp_handle_error(s, 4);
		return -EIO;
	}
	--wr;
	if ((word)wr < len+4)
		return -EAGAIN;
#if EDP_VERBOSE > 2
	#if EDP_VERBOSE == 3
	if (type != EDP_KEEPALIVE) {
	#endif
	printf("\n%s --> EDP: sending message type=0x%04X totlen=%u\n",
			_edp_getElapsed(s), ntohs(type), len);
	mem_dump(msg, len);
	printf("\n");
	#if EDP_VERBOSE == 3
	}
	#endif
#endif
	rlen = htons(len);
	sock_noflush(s->sock);
	sock_fastwrite(s->sock, (char __far *)&type, 2);
	sock_fastwrite(s->sock, (char __far *)&rlen, 2);
	if (len)
		sock_fastwrite(s->sock, msg, len);
	sock_flush(s->sock);
	s->rx_ka = _SET_TIMEOUT(_RCI_Settings.mgmtnetwork[s->ifx].mtRxKeepAlive * 1000ul);
	return 0;
}


/*** BeginHeader edp_can_send_fac */
int edp_can_send_fac(EDP __far * s, word len);
/*** EndHeader  */
_edp_debug
int edp_can_send_fac(EDP __far * s, word len)
{
	return sock_writable(s->sock) >= len+9;
}

/*** BeginHeader edp_send_fac */
int edp_send_fac(EDP __far * s, word fac, void __far * msg, word len);
/*** EndHeader  */
_edp_debug
int edp_send_fac(EDP __far * s, word fac, void __far * msg, word len)
{
	// This is like edp_send_msg, except it assumes EDP_PAYLOAD and
	// 0x0000 for the security layer flags (i.e. no encryption and
	// normal payload data).  fac is the facility code (in reversed order
	// i.e. use the EDP_FACILITY_* macro values).
	int wr;
	word rlen;
	word type;

	wr = sock_writable(s->sock);
	if (!wr) {
		_edp_handle_error(s, 5);
		return -EIO;
	}
	--wr;
	if ((word)wr < len+8)
		return -EAGAIN;
#if EDP_VERBOSE > 2
	printf("\n%s ----> EDP: sending facility message fac=0x%04X len=%u\n",
			_edp_getElapsed(s), ntohs(fac), len);
	mem_dump(msg, len);
	printf("\n");
#endif
	rlen = htons(len+4);
	type = EDP_PAYLOAD;
	sock_noflush(s->sock);
	sock_fastwrite(s->sock, (char *)&type, 2);
	sock_fastwrite(s->sock, (char *)&rlen, 2);
	type = 0;
	sock_fastwrite(s->sock, (char *)&type, 2);
	sock_fastwrite(s->sock, (char *)&fac, 2);
	if (len)
		sock_fastwrite(s->sock, (char __far *)msg, len);
	sock_flush(s->sock);
	s->rx_ka = _SET_TIMEOUT(_RCI_Settings.mgmtnetwork[s->ifx].mtRxKeepAlive * 1000ul);
	return 0;
}


/*** BeginHeader edp_send_fac_g */
int edp_send_fac_g(EDP __far * s, word fac, ll_Gather __far * g);
/*** EndHeader  */
_edp_debug
int edp_send_fac_g(EDP __far * s, word fac, ll_Gather __far * g)
{
	// This is like edp_send_fac(), except that an ll_Gather is used instead
   // of data+length parameters.
	int wr;
	word rlen;
	word type;
   word len;

	//tcp_tick(NULL);
	wr = sock_writable(s->sock);
	if (!wr) {
		_edp_handle_error(s, 5);
		return -EIO;
	}
	--wr;
   len = g->len1 + g->len2 + g->len3;
	if ((word)wr < len+8)
		return -EAGAIN;
#if EDP_VERBOSE > 2
	printf("\n%s ----> EDP: gathering facility message fac=0x%04X len=%u\n",
			_edp_getElapsed(s), ntohs(fac), len);
   if (g->len1)
		mem_dump(g->data1, g->len1);
   if (g->len2)
		mem_dump(g->data2, g->len2);
   if (g->len3)
		mem_dump(g->data3, g->len3);
	printf("\n");
#endif
	rlen = htons(len+4);
	type = EDP_PAYLOAD;
	sock_noflush(s->sock);
	sock_fastwrite(s->sock, (char *)&type, 2);
	sock_fastwrite(s->sock, (char *)&rlen, 2);
	type = 0;
	sock_fastwrite(s->sock, (char *)&type, 2);
	sock_fastwrite(s->sock, (char *)&fac, 2);
	if (g->len1)
		sock_fastwrite(s->sock, g->data1, g->len1);
	if (g->len2)
		sock_fastwrite(s->sock, g->data2, g->len2);
	if (g->len3)
		sock_fastwrite(s->sock, g->data3, g->len3);
	sock_flush(s->sock);
	s->rx_ka = _SET_TIMEOUT(_RCI_Settings.mgmtnetwork[s->ifx].mtRxKeepAlive * 1000ul);
	return 0;
}


/*** BeginHeader edp_handle_message */
int edp_handle_message(EDP __far * s, char __far * msg, word len);
/*** EndHeader  */
_edp_debug
int edp_handle_message(EDP __far * s, char __far * msg, word len)
{
	// s->msg_type is current message type,
	// msg contains the message, in malloc storage.  It can be re-used as
	//  temp storage to create a new message, since it is freed by the
	//  caller when this returns.  (Also, this can free it by calling
	//  edp_free_buf(s) - could be wise if need the memory!).
	// len is length of this message.
	word iface;
	word fac;
	word urllen;
	int fac_idx;

	// Since we got message, reset server KA timer
	s->tx_ka = _SET_TIMEOUT(_RCI_Settings.mgmtnetwork[s->ifx].mtTxKeepAlive * 1000ul *
	      					_RCI_Settings.mgmtnetwork[s->ifx].mtWaitCount);

#if EDP_VERBOSE > 2
	#if EDP_VERBOSE == 3
	if (s->msg_type != EDP_KEEPALIVE) {
	#endif
	printf("\n%s <-- EDP: got message type=0x%04X totlen=%u offs=%u len=%u\n",
			_edp_getElapsed(s), ntohs(s->msg_type), s->msg_len, s->msg_read, len);
	mem_dump(msg, len);
	printf("\n");
	#if EDP_VERBOSE == 3
	}
	#endif
#endif

	switch (s->msg_type) {
	default:
		// Ignore anything unknown.  (This also handles keepalives)
#if EDP_VERBOSE
		if (s->msg_type != EDP_KEEPALIVE)
			printf("EDP: unexpected message type 0x%04X\n", s->msg_type);
#endif
		break;
	case EDP_PAYLOAD:
		switch (s->phase) {
		case EDP_PHASE_WAIT_VERS_OK:
			if (len != 1 || msg[0]) {
#if EDP_VERBOSE
				printf("EDP: code %u (msg len %u) waiting for inner vers OK\n", msg[0], len);
#endif
				_edp_handle_error(s, 6);
			}
			else {
				// Success, proceed to security
				s->phase = EDP_PHASE_SECURING;

				// We're using simple identification here...
				edp_send_msg(s, EDP_PAYLOAD, "\x80\x00", 2);		// Simple form
				msg[0] = 0x81;	// Device ID
				_f_memcpy(msg+1, edp_globals.device_id, 16);
				edp_send_msg(s, EDP_PAYLOAD, msg, 17);				// Device ID
				msg[0] = 0x86;	// Connection URI
				_f_strcpy(msg+3, s->red_uri ? s->red_uri : s->uri);
				len = strlen(msg+3);
				*(word __far *)(msg+1) = htons(len);
				edp_send_msg(s, EDP_PAYLOAD, msg, 3+len); // Conn. URI

				// Simple form does not require waiting for any response,
				// so proceed to discovery...
				s->phase = EDP_PHASE_DISCOVERY;
				msg[0] = 0x00;	// Security layer payload
				msg[1] = 0x04;	// Device type discovery message
				sprintf(msg+4, IDIGI_PRODUCT);
				len = strlen(msg+4);
				*(word __far *)(msg+2) = htons(len);
				edp_send_msg(s, EDP_PAYLOAD, msg, 4+len); // Device Type

				// Initialization: send a few odd messages
				if (s->red_uri) {
					_f_memcpy(msg, "\x04\x01\x0DRedirected OK\x00\x00", 18);	// Redirected OK
					urllen = strlen(s->uri);
					*(word __far *)(msg + 16) = htons(urllen);
					_f_memcpy(msg+18, s->uri, urllen);
					edp_send_fac(s, EDP_FACILITY_CONN_CONTROL, msg, 18+urllen);
				}
				else {
					_f_memcpy(msg, "\x04\x00\x00\x00\x00", 5);	// Not redirected
					edp_send_fac(s, EDP_FACILITY_CONN_CONTROL, msg, 5);
				}
				// Connection report
				_f_memcpy(msg, "\x05\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF" \
				               "\x00\x00\x00\x00\x01", 19);
			   arpcache_iface(s->tport->sath, &iface);
				*(longword __far *)(msg + 14) = htonl(_if_tab[iface].ipaddr);
				_f_memcpy(msg+19, edp_globals.mac, 6);
				edp_send_fac(s, EDP_FACILITY_CONN_CONTROL, msg, 25);

				// Firmware access target list.  In the case that we don't have
				// _FIRMWARE_VERSION_ defined, set it to 0x0101.  If a firmware
				// update is attempted, then an error will be returned.
				// It is necessary to have a version number, since the server
				// needs to look at it to determine whether to query the RCI
				// descriptors.
				msg[0] = 0;	// target list opcode
				msg[1] = 0;	// target (0=firmware containing this EDP client)
				// We only have 16 bit firmware code, but EDP expects 32 bits.
#ifdef _FIRMWARE_VERSION_
				*(longword __far *)(msg+2) = htonl(_FIRMWARE_VERSION_);
#else
				*(longword __far *)(msg+2) = 0x01010000uL;
#endif
				edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, 6);

				// Announce RCI compression.
				//edp_send_fac(s, EDP_FACILITY_RCI, "\xB0\x01\x01\xFF", 4);	// ZLIB, reply
				edp_send_fac(s, EDP_FACILITY_RCI, "\xB0\x00\x00", 3); // None, no reply

	         edp_msg_send_capabilities(s);

				// Init RCI fields
				s->rci_state = RCI_STATE_READY;

				// Done init
				edp_send_msg(s, EDP_PAYLOAD, "\x00\x05", 2);
				s->phase = EDP_PHASE_FACILITY;

			}
			break;
		case EDP_PHASE_SECURING:
			break;
		case EDP_PHASE_DISCOVERY:
			break;
		case EDP_PHASE_FACILITY:
			if (len < 5) {
#if EDP_VERBOSE
	 			printf("EDP: bad message length %u\n", len);
#endif
				_edp_handle_error(s, 7);
			}
			switch (fac = *(word __far *)(msg+2)) {
			case EDP_FACILITY_CLIENT_LOOPBACK:
				edp_send_msg(s, EDP_PAYLOAD, msg, len);
				break;
			case EDP_FACILITY_CONN_CONTROL:
				switch (msg[4]) {	// opcode
				case 0x00:	// disconnect (server has nothing to send)
#if EDP_VERBOSE
					printf("EDP: got disconnect request\n");
#endif
					edp_close(s, _RCI_Reboot ? -1 : 1);
					break;
				case 0x03:	// redirect
#if EDP_VERBOSE
					printf("EDP: got redirect request\n");
#endif
					// Ignore the URL count.  Just use the 1st URL, since
					// we have a nameserver.
					urllen = ntohs(*(word __far *)(msg + 6));
					if (len < 13 || msg[5] < 1 || urllen+8 > len) {
#if EDP_VERBOSE
						printf("EDP: Redirect no URL provided, or bad URL length\n");
#endif
						_edp_handle_error(s, 8);
					}
					else {
						s->red_uri = _sys_malloc(urllen + 1);
	               if (!s->red_uri) {
	                  _edp_handle_error(s, 15);
	                  return -ENOMEM;
	               }
						_f_memcpy(s->red_uri, msg+8, urllen);
						s->red_uri[urllen] = 0;
						edp_close(s, 2);	// Close and redirect
					}
					break;
				}
				break;
			case EDP_FACILITY_FIRMWARE:
				edp_fw_handler(s, msg+4, len-4);
				break;
#ifdef HAVE_RCI
			case EDP_FACILITY_RCI:
				rci_handler(s, msg+4, len-4);
				break;
#endif
			case EDP_FACILITY_MSG:
				edp_msg_handler(s, msg+4, len-4);
				break;
			default:
				fac_idx = edp_facility_index(fac);
				if (fac_idx >= 0)
					// Invoke the registered handler
					edp_globals.fac[fac_idx].func(s, msg+4, len-4);
#if EDP_VERBOSE
				else
					printf("EDP: got unhandled facility code 0x%04X\n", ntohs(fac));
#endif
				break;
			}
			break;
		default:
			break;
		}
		break;
	case EDP_VERSION_OK:
		if (s->phase == EDP_PHASE_INIT) {
			// Send inner versioning info
			edp_send_msg(s, EDP_PAYLOAD, "\x00\x00\x01\x20", 4);
			s->phase = EDP_PHASE_WAIT_VERS_OK;
		}
		break;
	case EDP_VERSION_BAD:
#if EDP_VERBOSE
		printf("EDP: server says bad version\n");
#endif
		_edp_handle_error(s, 9);
		break;
	case EDP_SERVER_OVERLOAD:
#if EDP_VERBOSE
		printf("EDP: server says it's overloaded\n");
#endif
		_edp_handle_error(s, 10);
		break;
	}
	return 0;
}

/*** BeginHeader edp_close */
void edp_close(EDP __far * s, int nicely);
/*** EndHeader  */
_edp_debug
void edp_close(EDP __far * s, int nicely)
{
   if (s->rci_rxdata) {
      _sys_free(s->rci_rxdata);
      s->rci_rxdata = NULL;
   }
   if (s->red_uri) {
      _sys_free(s->red_uri);
      s->red_uri = NULL;
   }
	edp_free_buf(s);
	switch (s->state) {
	case EDP_STATE_OPEN:
	case EDP_STATE_MSGHDR:
		if (nicely > 0) {
			sock_close(s->sock);
			if (nicely == 2)
				s->state = EDP_STATE_REDIR_CLS;
			else
				s->state = EDP_STATE_CLOSING;
			break;
		}
		// fall thru
	case EDP_STATE_OPENING:
		sock_abort(s->sock);
		// fall thru
	default:
		if (nicely < 0)
			s->state = EDP_STATE_REBOOT;
		else
			s->state = EDP_STATE_CLOSED;
		break;

	}
}


/*** BeginHeader _edp_getElapsed */
char * _edp_getElapsed(EDP __far * s);
/*** EndHeader  */
_edp_debug
char * _edp_getElapsed(EDP __far * s)
{
	static char stamp[20];
	long ms = MS_TIMER - s->epoch;
	sprintf(stamp, "%06lu.%02u", ms / 1000, (word)(ms % 1000 / 10));
	return stamp;
}



/*** BeginHeader edp_free_buf */
void edp_free_buf(EDP __far * s);
/*** EndHeader  */
_edp_debug
void edp_free_buf(EDP __far * s)
{
   if (s->rxdata) {
      _sys_free(s->rxdata);
      s->rxdata = NULL;
   }
}



/*** BeginHeader edp_fw_handler */
void edp_fw_handler(EDP __far * s, char __far * msg, word len);
/*** EndHeader  */

// Server->client messages
#define EDP_FW_INFO_REQ				0x01
#define EDP_FW_DOWNLOAD_REQ 		0x03
#define EDP_FW_CODE_BLOCK	 		0x05
#define EDP_FW_DOWNLOAD_ABORT		0x07	// both dirs
#define EDP_FW_DOWNLOAD_COMPLETE	0x08
#define EDP_FW_REQ_TARGET_RESET	0x0A

// Client->server messages.  We don't use the EDP_FW_DOWNLOAD_STATUS message,
// since we curently have no targets other than *this* firmware, and we don't
// have a way of telling if we are running a "newly loaded" firmware or not.
#define EDP_FW_TARGET_LIST			0x00
#define EDP_FW_INFO_RESP			0x02
#define EDP_FW_DOWNLOAD_RESP		0x04
#define EDP_FW_CODE_ACK				0x06
#define EDP_FW_DL_COMPLETE_RESP	0x09
#define EDP_FW_DOWNLOAD_STATUS	0x0B
#define EDP_FW_ERROR					0x0C


_edp_debug
void edp_fw_handler(EDP __far * s, char __far * msg, word len)
{
	char fname[128];
	char * name;
	word opc, tgt, ltc;
	firmware_info_t fi;
	char __far * p;
	char error_code, resp, ack_req;
	longword offs;
	int rc;

	if (len < 2)
		goto _malformed;

	opc = msg[0];
	tgt = msg[1];
	if (tgt) {
		error_code = 0x00;	// invalid target
		goto _bad;
	}
	switch (opc) {
	case EDP_FW_INFO_REQ:
		msg[0] = EDP_FW_INFO_RESP;
		_f_memset(msg+2, 0, 8);	// Default version and size to 0.
		len = 10;
		switch (tgt) {
		case 0:
			*(longword __far *)(msg+2) = htonl(_FIRMWARE_VERSION_);
			*(longword __far *)(msg+6) = htonl(fiProgramSize());
			// The suffix string is a regular expression specifying the
			// host file names which are acceptable as firmware images.
			// In this case, we use the Dynamic C naming convention of
			// case insensitive ".bin" for binary images.
			_f_strcpy(msg+10, IDIGI_PRODUCT "\n.*\\.[bB][iI][nN]");
			len += strlen(msg+10);
			break;
		}
		edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, len);
		break;
	case EDP_FW_DOWNLOAD_REQ:
		if (len < 10)
			goto _malformed;
#if !EDP_USE_RPU
		// Not actually using RPU.  Cancel any request to update firmware.
		error_code = 0x01;	// user cancelled
		goto _abort;
#else
		if (s->fw_state != FW_STATE_READY) {
			// There's not really a good code for when a download is requested
			// when one's already running.  Just use the "user cancelled" code.
			error_code = 0x01;
			goto _abort;
		}
		// NOTE: server sends string identifier and version, but how does
		// it obtain them?  For us, they're really embedded in the firmware image.
		// However, the identifier (string following new_size) is in 3 fields,
		// separated by '\n'.  Fields are
		//  1. firmware ID string (label)
		//  2. filename spec (regular expression)
		//  3. filename being uploaded (as known by server)
		// Normally, 1 and 2 will be empty strings.  If not empty, replace the
		// relevant items returned by the firmware target request query.
		//DEVIDEA: updating the strings is not yet implemented.
		s->new_vers = ntohl(*(longword __far *)(msg+2));
		s->new_size = ntohl(*(longword __far *)(msg+6));
		ltc = u_min(sizeof(fname)-1, len-10);
		_f_memcpy(fname, msg+10, ltc);
		fname[ltc] = 0;
		name = strchr(fname, '\n');
		if (name)
			name = strchr(name+1, '\n');
		if (name)
			++name;	// Now points to 3rd field (if any).
	#if EDP_VERBOSE
		printf("EDP_FW: got dnld req: vers=0x%08lX, size=%lu, name=%s\n",
				s->new_vers, s->new_size, name ? name : "<none>");
	#endif
		s->next_offs = 0;
		if (s->new_size > 0x100000) {
			resp = 0x02;	// Image too large (>1M)
			s->new_size = 0;	// Prevent any download
		}
		else
			resp = 0x00;	// OK, go ahead
		msg[0] = EDP_FW_DOWNLOAD_RESP;
		msg[2] = resp;
		edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, 3);
		s->fw_state = FW_STATE_START;
		break;
#endif
	case EDP_FW_CODE_BLOCK:
		if (len < 8)	// expect at least one byte of data (+7 header)
			goto _malformed;
#if !EDP_USE_RPU
		// Not actually using RPU.
		error_code = 0x03;
		goto _abort;
#else
		if (s->fw_state < FW_STATE_START) {
			error_code = 0x03;	// Unexpected binary block message
			goto _abort;
		}
		ack_req = msg[2];
		offs = ntohl(*(longword __far *)(msg+3));
		p = msg + 7;
		len -= 7;
	#if EDP_VERBOSE > 1
		printf("EDP_FW: code block: offs=%lu, len=%u\n", offs, len);
	#endif
		if (offs != s->next_offs || offs + len > s->new_size) {
			error_code = 0x02;	// bad offset
			goto _abort;
		}
		if (!offs) {
			// First block.  Open temp staging area
			if ((rc = buTempCreate()) < 0) {
	#if EDP_VERBOSE
				printf("EDP_FW: buTempCreate rc=%d\n", rc);
	#endif
				error_code = 0x01;	// unexpected error
				goto _abort;
			}
			s->fw_state = FW_STATE_RX1;
		}
		s->next_offs += len;
		while (len) {
			do
				rc = buTempWrite(p, len);
			while (rc == -EBUSY);
			if (rc < 0) {
	#if EDP_VERBOSE
				printf("EDP_FW: buTempWrite rc=%d\n", rc);
	#endif
				error_code = 0x01;	// unspec error
				goto _abort;
			}
			p += rc;
			len -= rc;
		}
		if (s->fw_state == FW_STATE_RX1 &&
		    s->next_offs >= 1024) {
			// We got 1st 1k, so can look for fw info, to see if looks like
			// well-formed .bin file.

			s->fw_state = FW_STATE_RX2;
		}
		if (ack_req) {
			msg[0] = EDP_FW_CODE_ACK;
			*(longword __far *)(msg+2) = htonl(offs);
			msg[6] = 0x00;	// OK
			edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, 7);
		}
		break;
#endif
	case EDP_FW_DOWNLOAD_ABORT:
#if EDP_VERBOSE
	 	printf("EDP_FW: got download abort code=%02X!\n", msg[2]);
#endif
		goto _cleanup;
	case EDP_FW_DOWNLOAD_COMPLETE:
		if (len < 10)
			goto _malformed;
#if !EDP_USE_RPU
		// Not actually using RPU.
		error_code = 0x03;
		goto _abort;
#else
		msg[0] = EDP_FW_DL_COMPLETE_RESP;
		while (-EBUSY == buTempClose());
		s->fw_state = FW_STATE_COMPLETE;
		if (s->fw_state < FW_STATE_RX1 ||
			 s->next_offs != s->new_size ||
			 (rc = buOpenFirmwareTemp(BU_FLAG_NONE)) < 0) {
	#if EDP_VERBOSE
	 		printf("EDP_FW: got download complete; error: state=%d remain=%lu rc=%d\n",
	 				s->fw_state,
	 				s->new_size-s->next_offs,
	 				rc);
	#endif
			// Incomplete according to initial proposed length
			msg[10] = 0x02;	// Did not complete
		_senddlresp:
			_f_memset(msg+2, 0, 8);	// Zero version and checksum
   		edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, 11);
   		goto _cleanup;
		}
		s->fw_state = FW_STATE_VERIFYING;
		// Think we're finished.  Verify download image.  This is done
		// independently of the EDP CRC check, since .bin files have their
		// own CRC.  If this passes, then assume EDP CRC passes also.
		rc = buVerifyFirmwareBlocking();
		if (rc) {
			// Signal CRC mismatch
	#if EDP_VERBOSE
	 		printf("EDP_FW: buVerifyFirmwareBlocking() rc=%d\n", rc);
	#endif
			// Use code 02, since that indicates specific format not valid.
			// Code 01 (CRC mismatch) is not appropriate if the server is
			// not using CRCs.
			msg[10] = 0x02;
			goto _senddlresp;
		}
		buGetInfo(&fi);
		*(longword __far *)(msg+2) = htonl(fi.version);
		// checksum field untouched from incoming message
		rc = buInstallFirmware();
		s->fw_state = FW_STATE_DONE;
		if (rc) {
	#if EDP_VERBOSE
	 		printf("EDP_FW: buInstallFirmware() rc=%d\n", rc);
	#endif
			error_code = 0x04;	// permanent error
			goto _abort;
		}
		msg[10] = 0x00;	// All OK!
   	edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, 11);
	#if EDP_VERBOSE
	 	printf("EDP_FW: firmware update successful\n");
	#endif
		goto _cleanup;
#endif
	case EDP_FW_REQ_TARGET_RESET:
#if EDP_VERBOSE
		printf("EDP_FW: got target reset request\n");
#endif
		// This causes main loop to reboot (as per RCI boot command)
		_RCI_Reboot = 1;
		break;
	default:
		error_code = 0x01;	// unknown opcode
		goto _bad;
	}
	return;
_malformed:
	error_code = 0x02;
_bad:
   msg[0] = EDP_FW_ERROR;
	goto _senderr;
_abort:
   msg[0] = EDP_FW_DOWNLOAD_ABORT;
_senderr:
   msg[2] = error_code; // malformed message
#if EDP_VERBOSE
	printf("EDP_FW: sending %s response tgt=%02X code=%02X\n",
			msg[0] == EDP_FW_ERROR ? "error" : "abort", msg[1], msg[2]);
#endif
   edp_send_fac(s, EDP_FACILITY_FIRMWARE, msg, 3);
_cleanup:
	// Since we've put the kybosh on the process, clean up and reset state
#if EDP_USE_RPU
	if (s->fw_state == FW_STATE_RX1 ||
	    s->fw_state == FW_STATE_RX2)
		while (-EBUSY == buTempClose());
	else if (s->fw_state == FW_STATE_VERIFYING)
		while (-EBUSY == buCloseFirmware());
#endif
	s->fw_state = FW_STATE_READY;
}

/*** BeginHeader edp_find_trans */
edp_trans_t __far * edp_find_trans(EDP __far * s, int request, word trans_id);
/*** EndHeader  */
_edp_debug
edp_trans_t __far * edp_find_trans(EDP __far * s, int request, word trans_id)
{
	edp_trans_t __far * t;

   for (t = s->msgs; t; t = t->next) {
   	if (t->request == request && t->trans_id == trans_id)
      	return t;
   }
   return NULL;
}

/*** BeginHeader edp_msg_find_handler */
const edp_msg_handler_t __far * edp_msg_find_handler(EDP __far * s, word svc_id);
/*** EndHeader  */
_edp_debug
const edp_msg_handler_t __far * edp_msg_find_handler(EDP __far * s, word svc_id)
{
	word i;

   for (i = 0; i < sizeof(s->handlers)/sizeof(s->handlers[0]); ++i)
   	if (s->handlers[i] && s->handlers[i]->svc_id == svc_id)
      	return s->handlers[i];
   return NULL;
}

/*** BeginHeader edp_create_trans */
edp_trans_t __far * edp_create_trans(EDP __far * s, int request,
							word svc_id, word trans_id);
/*** EndHeader  */
_edp_debug
edp_trans_t __far * edp_create_trans(EDP __far * s, int request,
							word svc_id, word trans_id)
{
	edp_trans_t __far * t;

	t = _sys_calloc(sizeof(*t));
   if (!t)
   	return NULL;
   t->next = s->msgs;
   s->msgs = t;
   t->request = request;
   t->svc_id = svc_id;
   t->trans_id = trans_id;
   if (s->peer_caps_1)
   	t->peer_win = ntohl(s->peer_caps_1->window);
   else
   	// Shouldn't happen unless server errs.
   	t->peer_win = 256;
   t->adv_win = EDP_MSG_MAX_WINDOW;	// According to protocol spec, this
   											// is the effective start window i.e.
                                    // what we send in capabilities.
   t->tx.maxlen = EDP_MSG_MAX_WINDOW;
   t->rx.maxlen = EDP_MSG_MAX_WINDOW; // must be >= t->adv_win
   t->tx.buf = _sys_malloc(t->tx.maxlen);
   t->rx.buf = _sys_malloc(t->rx.maxlen);
   _tbuf_reset(&t->tx);
   _tbuf_reset(&t->rx);
   if (!t->tx.buf || !t->rx.buf) {
   _freeup:
   	_sys_free(t->tx.buf);
      _sys_free(t->rx.buf);
      _sys_free(t);
      return NULL;
   }

   t->handler = edp_msg_find_handler(s, ntohs(svc_id));
   if (t->handler && t->handler->allocate) {
   	t->context = _sys_calloc(t->handler->allocate);
      if (!t->context)
      	goto _freeup;
   }

#if EDP_VERBOSE
	printf("EDP MSG: created %s transaction svc=%u trans=%u\n",
   	request ? "request" : "reply",
   	ntohs(svc_id),
      ntohs(trans_id));
#endif
   return t;
}


/*** BeginHeader edp_msg_delete_trans */
void edp_msg_delete_trans(EDP __far * s, edp_trans_t __far * trans, int reason);
/*** EndHeader  */
_edp_debug
void edp_msg_delete_trans(EDP __far * s, edp_trans_t __far * trans, int reason)
{
	edp_trans_t __far * __far * tp;

   for (tp = &s->msgs; *tp; tp = &(*tp)->next) {
   	if (*tp == trans) {
      	*tp = trans->next;
         if (s->robin == trans)
         	s->robin = trans->next;
         if (reason && trans->handler && trans->handler->cancel)
				trans->handler->cancel(trans, reason);
         if (trans->handler && trans->handler->close)
				trans->handler->close(trans);
#if EDP_VERBOSE
	      printf("EDP MSG: deleted %s transaction svc=%u trans=%u tx=%lu rx=%lu\n",
	         trans->request ? "request" : "reply",
	         ntohs(trans->svc_id),
	         ntohs(trans->trans_id),
	         trans->bytes_tx,
            trans->bytes_rx);
#endif
			if (trans->handler && trans->handler->allocate)
         	_sys_free(trans->context);
         _sys_free(trans->tx.buf);
         _sys_free(trans->rx.buf);
         _sys_free(trans);
         break;
      }
   }
}



/*** BeginHeader edp_msg_send_ack */
void edp_msg_send_ack(EDP __far * s, edp_trans_t __far * trans);
/*** EndHeader  */
_edp_debug
void edp_msg_send_ack(EDP __far * s, edp_trans_t __far * trans)
{
   edp_msg_ack a;
   word w;

   if (trans->rx_last)
   	// Once we have received last packet, do not need to ACK.
   	return;
   w = _tbuf_remain(&trans->rx);
#if EDP_VERBOSE
   printf("EDP MSG: sending ACK %s trans=%u svc=%u rx=%lu adv_win=%lu\n",
   	trans->request ? "request" : "reply",
      ntohs(trans->trans_id),
      ntohs(trans->svc_id),
      trans->bytes_rx,
      w);
#endif
   if (!edp_can_send_fac(s, sizeof(a))) {
   	// We consider inability to send an ack to the server to be an error
      // worth ignoring.
#if EDP_VERBOSE
   	printf("EDP MSG: ...can't send just now\n");
#endif
   	return;
   }
   a.opcode = EDP_MSG_OPC_ACK;
   a.flags = (trans->request ? 0 : EDP_MSG_FLAG_REQUEST);
   a.trans_id = trans->trans_id;
   a.ack = htonl(trans->bytes_rx);
   a.window = htonl(w);
   edp_send_fac(s, EDP_FACILITY_MSG, &a, sizeof(a));
   trans->adv_win = trans->bytes_rx + w;
}


/*** BeginHeader edp_msg_send_error */
int edp_msg_send_error(EDP __far * s, edp_trans_t __far * trans, word code);
/*** EndHeader  */
_edp_debug
int edp_msg_send_error(EDP __far * s, edp_trans_t __far * trans, word code)
{
	edp_msg_error m;

#if EDP_VERBOSE
	printf("EDP MSG: sending error code %u for %s trans_id=%u\n",
   	code,
	   trans->request ? "request" : "reply",
      ntohs(trans->trans_id));
#endif
   if (!edp_can_send_fac(s, sizeof(m))) {
#if EDP_VERBOSE
   	printf("EDP MSG: ...can't send just now\n");
#endif
   	return -EBUSY;
   }
	m.opcode = EDP_MSG_OPC_ERROR;
	m.flags = EDP_MSG_FLAG_SENDER; //EDP_MSG_FLAG_REQUEST;  ???
   m.trans_id = trans->trans_id;
   m.code = code;
	edp_send_fac(s, EDP_FACILITY_MSG, &m, sizeof(m));
   edp_msg_delete_trans(s, trans, code);
   return 0;
}


/*** BeginHeader edp_msg_send_error_notrans */
void edp_msg_send_error_notrans(EDP __far * s, word trans_id, word code);
/*** EndHeader  */
_edp_debug
void edp_msg_send_error_notrans(EDP __far * s, word trans_id, word code)
{
	edp_msg_error m;

#if EDP_VERBOSE
	printf("EDP MSG: sending generic error code %u for trans_id=%u\n",
      code, ntohs(trans_id));
#endif
	m.opcode = EDP_MSG_OPC_ERROR;
	m.flags = 0;
   m.trans_id = trans_id;
   m.code = code;
	edp_send_fac(s, EDP_FACILITY_MSG, &m, sizeof(m));
}


/*** BeginHeader _edp_msg_echo_tick */
void _edp_msg_echo_tick(edp_trans_t __far * t);
/*** EndHeader  */
_edp_debug
void _edp_msg_echo_tick(edp_trans_t __far * t)
{
	char buf[128];
	word w, x;

   w = u_min(edp_msg_readable(t), edp_msg_writable(t));
   if (!w)
   	edp_msg_close(t);
   else {
   	--w;
	   while (w) {
      	x = u_min(w, sizeof(buf));
	      edp_msg_read(t, buf, x);
	      edp_msg_write(t, buf, x);
         w -= x;
	   }
   }
}


/*** BeginHeader _edp_msg_data_tick */
void _edp_msg_data_tick(edp_trans_t __far * t);

typedef struct edp_msg_data_svc_t
{
	// Context struct for EDP message data service
   enum {
   	_EMDS_INIT = 0,
      _EMDS_TARGET,
      _EMDS_PARMS,
      _EMDS_PARM,
      _EMDS_PAYLOAD,
      _EMDS_DONE,
   } state;
   char opcode;
   char tlen;
   char parmc;
   char parmid;
   char parmlen;
   char target[256];
} edp_msg_data_svc_t;

/*** EndHeader  */
_edp_debug
void _edp_msg_data_tick(edp_trans_t __far * t)
{
	char buf[80];
   word r;
	edp_msg_data_svc_t __far * emds = t->context;

   switch (emds->state) {
   case _EMDS_INIT:
   	// Read opcode and target length
   	if (edp_msg_readable(t) > 2) {
      	edp_msg_read(t, &emds->opcode, 1);
      	edp_msg_read(t, &emds->tlen, 1);
         if (emds->opcode == 2) {
	      #if EDP_VERBOSE
	         printf("EDP DATA: got Device Request\n");
	      #endif
         	emds->state = _EMDS_TARGET;
         }
         else {
	      #if EDP_VERBOSE
	         printf("EDP DATA: opcode 0x%02X not recognized\n", emds->opcode);
	      #endif
         	edp_msg_abort(t);
         }
      }
   	break;
   case _EMDS_TARGET:
   	if (edp_msg_readable(t) > emds->tlen+1) {
      	edp_msg_read(t, emds->target, emds->tlen);
      	edp_msg_read(t, &emds->parmc, 1);
         emds->target[emds->tlen] = 0;
      #if EDP_VERBOSE
         printf("EDP DATA: got target `%ls`\n", emds->target);
      #endif
      	emds->state = emds->parmc ? _EMDS_PARMS : _EMDS_PAYLOAD;
      }
   	break;
   case _EMDS_PARMS:
   	if (edp_msg_readable(t) > 2) {
      	edp_msg_read(t, &emds->parmid, 1);
      	edp_msg_read(t, &emds->parmlen, 1);
         emds->state = _EMDS_PARM;
      }
   	break;
   case _EMDS_PARM:
   	if (edp_msg_readable(t) > emds->parmlen) {
      	edp_msg_read(t, NULL, emds->parmlen);
         --emds->parmc;
      	emds->state = emds->parmc ? _EMDS_PARMS : _EMDS_PAYLOAD;
      }
   	break;
   case _EMDS_PAYLOAD:
   	if (!edp_msg_readable(t)) {
      	// Finished getting data, respond.
         edp_msg_write(t, "\x03\x00Jolly good show!\r\n", 20);
         edp_msg_close(t);
         emds->state = _EMDS_DONE;

      }
      else {
   		r = u_min(sizeof(buf), edp_msg_readable(t)-1);
         if (r) {
      		edp_msg_read(t, buf, r);
         	printf("DS: '%.*s'\n", r, buf);
         }
      }
   	break;
   case _EMDS_DONE:
   	break;
   }
}


/*** BeginHeader _edp_msg_file_tick, _edp_msg_file_open, _edp_msg_file_close */
#ifdef IDIGI_USE_FAT
void _edp_msg_file_tick(edp_trans_t __far * t);
void _edp_msg_file_open(edp_trans_t __far * t);
void _edp_msg_file_close(edp_trans_t __far * t);

typedef struct edp_msg_file_svc_t
{
	// Context struct for EDP message data service
   enum {
   	_EMFS_INIT = 0,
      _EMFS_PATH,
      _EMFS_GET_OFFS_LEN,
      _EMFS_GET,
      _EMFS_GET_FLAGS_OFFS,
      _EMFS_PUT,
      _EMFS_GET_HASH_ALGO,
      _EMFS_LS,
      _EMFS_RM,
      _EMFS_DONE,
      _EMFS_SEND_ERROR,
   } state;				// Processing state for tick function
   word timer;			// 15 second timeout if no progress
   char opcode;		// Request opcode
   char reply_opcode;// Reply opcode (=request+1 currently, or 200 for error)
   int f;				// Zserver resource handle (-1 if invalid)
   char	flags;		// Flags for PUT request, hash algorithm for LS
   #define _EMFS_FLAG_PUT_TRUNCATE	0x01
   #define _EMFS_HASH_ALGO_NONE		0
   #define _EMFS_HASH_ALGO_BEST		1
   #define _EMFS_HASH_ALGO_CRC32		2
   #define _EMFS_HASH_ALGO_MD5		3
   longword offs;		// File offset
   longword len;		// Length to retrieve
   word pathlen;		// Length of file path
   char pathok;		// Set true of path parsed OK
   char path[256];	// Path - must immediately preceed following sub-struct
   struct {
   	char flags;		// 0x01 if directory
      #define _EMFS_LS_FLAGS_DIRECTORY	0x01
      long last_mod;	// Last modification time (sec since 1970)
      long size;		// File size (0 for directories)
   } ls;
   struct {
   	char opcode;	// Fields for error message: opcode=200
	   char code;		// Server-specific error code
	   char hint_length;	// Hint for device side
	   char hint[256];	// See _edp_msg_file_error() for message format
   } err;
} edp_msg_file_svc_t;

// Protocol-specified opcodes
enum {
	_EMFS_OPC_GET = 1,
	_EMFS_OPC_GET_REPLY,
	_EMFS_OPC_PUT,
	_EMFS_OPC_PUT_REPLY,
	_EMFS_OPC_LS,
	_EMFS_OPC_LS_REPLY,
	_EMFS_OPC_RM,
	_EMFS_OPC_RM_REPLY,
	_EMFS_OPC_ERROR = 200
};

// Protocol-specified server-specific errors
enum {
	_EMFS_ERROR_UNSPECIFIED = 0,
	_EMFS_ERROR_NOENT,
	_EMFS_ERROR_NOSPC,
	_EMFS_ERROR_FORMAT,
	_EMFS_ERROR_INVAL,
	_EMFS_ERROR_NOMEM,
	_EMFS_ERROR_PERM,
};
#endif
/*** EndHeader  */
#ifndef IDIGI_USE_FAT
	#error "Cannot use _edp_msg_file_tick if not IDIGI_USE_FAT"
#endif

_edp_debug
void _edp_msg_file_error(edp_trans_t __far * t,
      int rc,
      const char * hint_context)
{
	edp_msg_file_svc_t __far * emfs = t->context;
   word ecode;

   ecode = _EMFS_ERROR_UNSPECIFIED;
   switch (rc) {
   case -EINVAL:
   case -EEOF:   ecode = _EMFS_ERROR_INVAL; break;
   case -ENOENT:
   case -EPATHSTR:
   case -E2BIG:  ecode = _EMFS_ERROR_NOENT; break;
   case -ENOMEM: ecode = _EMFS_ERROR_NOMEM; break;
   case -EACCES: ecode = _EMFS_ERROR_PERM; break;
   case -EPROTO: ecode = _EMFS_ERROR_FORMAT; break;
   case -ENOSPC: ecode = _EMFS_ERROR_NOSPC; break;
   }

   emfs->err.opcode = _EMFS_OPC_ERROR;
   emfs->err.code = ecode;
  	sprintf(emfs->err.hint, "%s: device specific errno=%d", hint_context, rc);
   emfs->err.hint_length = strlen(emfs->err.hint);
   emfs->state = _EMFS_SEND_ERROR;
#if EDP_VERBOSE
   printf("EDP FILE: sending error code %u for rc %d, when %s\n",
   			ecode, rc, hint_context);
#endif
}

_edp_debug
void _edp_msg_file_done(edp_trans_t __far * t)
{
	edp_msg_file_svc_t __far * emfs = t->context;

   emfs->state = _EMFS_DONE;
   edp_msg_close(t);
}

_edp_debug
void _edp_msg_file_tick(edp_trans_t __far * t)
{
	union {
	   char buf[128];
	   sspec_ls_t ls;
   } u;
   word r, ecode;
   int rc;
   char __far * str;
   long flen;
   FATfile * fat;
	edp_msg_file_svc_t __far * emfs = t->context;

   if (_CHK_SHORT_TIMEOUT(emfs->timer)) {
   #if EDP_VERBOSE
      printf("EDP FILE: timed out\n");
   #endif
   	edp_msg_abort(t);
      return;
   }

   switch (emfs->state) {
   case _EMFS_INIT:
   	if (edp_msg_readable(t) > 1) {
      	edp_msg_read(t, &emfs->opcode, 1);
         switch (emfs->opcode) {
         case _EMFS_OPC_GET:
         case _EMFS_OPC_PUT:
         case _EMFS_OPC_LS:
         case _EMFS_OPC_RM:
         	emfs->state = _EMFS_PATH;
            break;
         default:
	      #if EDP_VERBOSE
	         printf("EDP FILE: opcode 0x%02X not recognized\n", emfs->opcode);
	      #endif
        		_edp_msg_file_error(t, -EPROTO, "opcode");
				return;
         }
      }
      else
   		break;
      // Fall through if valid opcode.  All are followed by path...
   case _EMFS_PATH:
   	// Read null-terminated path name
      while (emfs->pathlen < sizeof(emfs->path) &&
				 edp_msg_readable(t) > 1) {
      	edp_msg_read(t, emfs->path + emfs->pathlen, 1);
         if (!emfs->path[emfs->pathlen]) {
         	emfs->pathok = 1;
         	break;
         }
         ++emfs->pathlen;
      }
      if (emfs->pathok) {
	      #if EDP_VERBOSE
	      printf("EDP FILE: %3.3s path = `%ls`\n",
				"getputls rm" + emfs->opcode/2*3,
         	emfs->path);
	      #endif
         emfs->reply_opcode = emfs->opcode + 1;
      	switch (emfs->opcode) {
         case _EMFS_OPC_GET:
      		emfs->state = _EMFS_GET_OFFS_LEN;
            break;
         case _EMFS_OPC_PUT:
      		emfs->state = _EMFS_GET_FLAGS_OFFS;
            break;
         case _EMFS_OPC_LS:
      		emfs->state = _EMFS_GET_HASH_ALGO;
            break;
         case _EMFS_OPC_RM:
      		emfs->state = _EMFS_RM;
            break;
         }
      }
      else if (emfs->pathlen == sizeof(emfs->path)) {
	      #if EDP_VERBOSE
	         printf("EDP FILE: path length too long (opcode 0x%02X)\n", emfs->opcode);
	      #endif
         	edp_msg_abort(t);
      }
   	break;
   case _EMFS_GET_OFFS_LEN:
   	if (edp_msg_readable(t) > 8) {
      	edp_msg_read(t, &emfs->offs, 4);
      	edp_msg_read(t, &emfs->len, 4);
         emfs->offs = ntohl(emfs->offs);
         emfs->len = ntohl(emfs->len);
         emfs->state = _EMFS_GET;
         // Open file and seek to offset
         emfs->f = sspec_open(emfs->path, &edp_globals.zs_context, O_READ, 0);
			if (emfs->f < 0) {
        		_edp_msg_file_error(t, emfs->f, "get open");
         }
         else {
         	// Opened OK
            if (emfs->offs) {
					flen = sspec_getlength(emfs->f);
               if (flen >= 0) {
               	if ((longword)flen < emfs->offs) {
	               	_edp_msg_file_error(t, -EINVAL, "get offs");
                  	break;
                  }
	            	rc = sspec_seek(emfs->f, emfs->offs, SEEK_SET);
               }
               else
               	rc = -EPERM;
	            if (rc) {
	               _edp_msg_file_error(t, rc, "get seek");
                  break;
               }
            }
            edp_msg_write(t, &emfs->reply_opcode, 1);
         }
		}
   	break;
   case _EMFS_GET_FLAGS_OFFS:
   	if (edp_msg_readable(t) > 5) {
      	edp_msg_read(t, &emfs->flags, 1);
      	edp_msg_read(t, &emfs->offs, 4);
         emfs->offs = ntohl(emfs->offs);
         emfs->state = _EMFS_PUT;
         emfs->f = sspec_open(emfs->path, &edp_globals.zs_context,
         								O_WRITE|O_CREAT, 1);
			if (emfs->f < 0) {
        		_edp_msg_file_error(t, emfs->f, "put open");
         }
         else {
         	// Opened OK
            rc = 0;
            if (emfs->offs) {
	            rc = sspec_seek(emfs->f, emfs->offs, SEEK_SET);
	            if (rc)
	               _edp_msg_file_error(t, rc, "put seek");
            }
         }
		}
   	break;
   case _EMFS_GET_HASH_ALGO:
   	if (edp_msg_readable(t) > 1) {
      	edp_msg_read(t, &emfs->flags, 1);	// hash algo (ignored)
         emfs->state = _EMFS_LS;
			rc = sspec_cd(emfs->path, &edp_globals.zs_context, 1);
			if (rc) {
     			_edp_msg_file_error(t, rc, "ls cd");
         }
         else {
            emfs->f = sspec_dirlist(0, (char __far *)&u.ls, 0,
                    		&edp_globals.zs_context, SSPEC_LIST_BIN);
				if (emfs->f >= 0 || emfs->f == -EEOF) {
	            edp_msg_write(t, &emfs->reply_opcode, 1);
	            edp_msg_write(t, "\0\0", 2);  // Hash not supported
            	goto _send_ls_result;
            }
            else {
	            _edp_msg_file_error(t, emfs->f, "ls");
            }
         }
		}
   	break;
   case _EMFS_GET:
		while (emfs->len &&							// Got less than requested
             edp_msg_writable(t) > sizeof(u.buf)) {
         if (emfs->len > sizeof(u.buf))
            r = sizeof(u.buf);
         else
            r = (word)emfs->len;
         rc = sspec_read(emfs->f, u.buf, r);
         if (rc > 0) {
            edp_msg_write(t, u.buf, rc);
				emfs->timer = _SET_SHORT_TIMEOUT(15000);
            emfs->len -= rc;
         }
         else {
         	// If EOF, finish transaction.  Other errors need to cancel
            // at the messaging service level, since we have already started
            // the reply.
            if (!rc)
            	emfs->len = 0;
            else
            	edp_msg_abort(t);
            break;
         }
      }
      if (!emfs->len || !sspec_read(emfs->f, NULL, 0))
			_edp_msg_file_done(t);
   	break;
   case _EMFS_PUT:
   	while ((r = edp_msg_readable(t)) > 1) {
			r = u_min(sizeof(u.buf), r-1);
         edp_msg_read(t, u.buf, r);
			emfs->timer = _SET_SHORT_TIMEOUT(15000);
         rc = sspec_write(emfs->f, u.buf, r);
         if (rc < (int)r) {
         	// sspec_write() can write less than requested, however this
            // should not happen for FAT.  Treat all cases as errors.
            _edp_msg_file_error(t, rc, "put write");
            break;
         }
      }
      if (!edp_msg_readable(t)) {
      	// put OK
         if (emfs->flags & _EMFS_FLAG_PUT_TRUNCATE) {
         	fat = _sspec_fatfile(emfs->f);
            if (!fat) {
            	_edp_msg_file_error(t, -EPERM, "put trunc");
               break;
            }
            rc = fat_Truncate(fat, FAT_BRK_POS);
            if (rc < 0) {
            	_edp_msg_file_error(t, rc, "put trunc");
               break;
            }
         }
         edp_msg_write(t, &emfs->reply_opcode, 1);
			_edp_msg_file_done(t);
      }
   	break;
   case _EMFS_LS:
   	while (edp_msg_writable(t) > sizeof(emfs->ls)+sizeof(emfs->path)) {
         emfs->f = sspec_dirlist(emfs->f, (char __far *)&u.ls, 0,
                     &edp_globals.zs_context, SSPEC_LIST_BIN);
     _send_ls_result:
         if (emfs->f < 0) {
				_edp_msg_file_done(t);
            break;
         }
         else {
         	emfs->ls.flags = u.ls.isdir ? _EMFS_LS_FLAGS_DIRECTORY : 0;
            // Strange constant below is number of seconds between 1970 and 1980
            // Server wants a 1970 (Posix) epoch.
				emfs->ls.last_mod = htonl(u.ls.mod_date + 0x12CEA600L);
            emfs->ls.size = htonl(u.ls.length);
            // Tuck null-terminated path just before ls substruct so it
            // is contiguous with same
            r = strlen(u.ls.path);
            r = u_min(r, sizeof(emfs->path)-1);
            str = (char __far *)&emfs->ls - (r+1);
            _f_strcpy(str, u.ls.path);
				edp_msg_write(t, str, r+(1+sizeof(emfs->ls))-(u.ls.isdir?4:0));
				emfs->timer = _SET_SHORT_TIMEOUT(15000);
         }
		}
   	break;
   case _EMFS_RM:
   	rc = sspec_delete(emfs->path, &edp_globals.zs_context);
      if (rc) {
         _edp_msg_file_error(t, rc, "rm");
      }
      else {
      	edp_msg_write(t, &emfs->reply_opcode, 1);
			_edp_msg_file_done(t);
		}
   	break;
   case _EMFS_DONE:
   	// Discard any trailing readable
      if ((r=edp_msg_readable(t)) > 1)
      	edp_msg_read(t, NULL, r-1);
   	break;
   case _EMFS_SEND_ERROR:
   	if (edp_msg_writable(t) > 3 + emfs->err.hint_length) {
      	edp_msg_write(t, &emfs->err.opcode, 3 + emfs->err.hint_length);
			_edp_msg_file_done(t);
      }
      if (!edp_msg_writable(t))
      	emfs->state = _EMFS_DONE;
   	break;
   }
}

_edp_debug
void _edp_msg_file_open(edp_trans_t __far * t)
{
	edp_msg_file_svc_t __far * emfs = t->context;
	emfs->timer = _SET_SHORT_TIMEOUT(15000);	// 15 sec timeout
   emfs->f = -1;	// no open Zserver resource
}

_edp_debug
void _edp_msg_file_close(edp_trans_t __far * t)
{
	edp_msg_file_svc_t __far * emfs = t->context;

   if (emfs->f >= 0) {
   	if (emfs->opcode == _EMFS_OPC_LS)
      	sspec_dirlist(emfs->f, emfs->path, sizeof(emfs->path),
         	&edp_globals.zs_context, SSPEC_LIST_END);
      else
	      sspec_close(emfs->f);
   }
}


/*** BeginHeader edp_msg_tick */
void edp_msg_tick(EDP __far * s);
/*** EndHeader  */
_edp_debug
void edp_msg_tick(EDP __far * s)
{
	edp_msg_start m;
   ll_Gather g;
	edp_trans_t __far * t;
   word	w;
   longword win;

   if (!s->msgs)
   	return;
	if (!s->robin)
   	s->robin = s->msgs;	// Start round-robin over
   t = s->robin;

   // Tick this transaction: send any data which we can.
   if (!t->sent_last) {
	   win = t->peer_win - t->bytes_tx; // How much can send
      if (win > 65535)
      	win = 65535;
      w = (word)win;
	   w = u_min(w, TCP_BUF_SIZE/2);
	   w = u_min(w, t->tx.len);
      if (!win && t->tx.len) {
			// No available window, but have data to tx.  If timer not
         // already running, start it (60 sec fixed).
         if (!t->wait_win) {
         	t->timer = _SET_SHORT_TIMEOUT(60000u);
            t->wait_win = 1;
         }
         else if (_CHK_SHORT_TIMEOUT(t->timer)) {
      		edp_msg_send_error(s, t, MSG_ERR_TIMEOUT);
         }
      }
	   else if ((w || t->done) &&
      			edp_can_send_fac(s, w + sizeof(edp_msg_start))) {
	      m.opcode = EDP_MSG_OPC_DATA;
	      m.flags = t->request ? EDP_MSG_FLAG_REQUEST : 0;
	      m.trans_id = t->trans_id;
	      g.len1 = sizeof(edp_msg_data);
	      if (!t->sent_start) {
	         m.opcode = EDP_MSG_OPC_START;
	         m.svc_id = t->svc_id;
	         m.compr = 0;
	         g.len1 = sizeof(edp_msg_start);
	      }
	      if (t->done) {
	         m.flags |= EDP_MSG_FLAG_LAST;
	         t->sent_last = 1;
            if (t->request && t->handler->response_timeout) {
            	t->wait_response = 1;
            	t->ltimer = _SET_TIMEOUT(t->handler->response_timeout);
            }
	      }
	      t->sent_start = 1;
	      g.data1 = (char __far *)&m;
	      _tbuf_ref(&t->tx, &g, 0, w);
	      edp_send_fac_g(s, EDP_FACILITY_MSG, &g);
	      _tbuf_delete(&t->tx, w);
	   }
   }
   else if (t->sent_last && t->rx_last && !t->rx.len) {
   	// Transaction completed normally, and all data read out.
      edp_msg_delete_trans(s, t, 0);
   }
   else if (t->wait_response) {
   	// This is a request which expects a response,
      // so wait for response (or timeout).
      if (_CHK_TIMEOUT(t->ltimer)) {
      	edp_msg_send_error(s, t, MSG_ERR_TIMEOUT);
      }
   }

   // If current trans was deleted (e.g. an error above) then robin will
   // no longer equal it.
   if (s->robin == t) {
   	if (t->handler->tick)
   		t->handler->tick(t);

   	// Finally, point to next one to process
   	s->robin = t->next;
   }
}


/*** BeginHeader edp_msg_open */
edp_trans_t __far * edp_msg_open(const edp_msg_handler_t __far * handler);
/*** EndHeader  */
_edp_debug
edp_trans_t __far * edp_msg_open(const edp_msg_handler_t __far * handler)
{
	edp_trans_t __far * t;
	t = edp_create_trans(&_edp_inst, 1,
   			htons(handler->svc_id), htons(edp_globals.trans_id++));
   if (!t)
   	return NULL;
  	t->handler = handler;
	return t;
}

/*** BeginHeader edp_msg_close */
void edp_msg_close(edp_trans_t __far * t);
/*** EndHeader  */
_edp_debug
void edp_msg_close(edp_trans_t __far * t)
{
	t->done = 1;
}

/*** BeginHeader edp_msg_abort */
void edp_msg_abort(edp_trans_t __far * t);
/*** EndHeader  */
_edp_debug
void edp_msg_abort(edp_trans_t __far * t)
{
	edp_msg_send_error(&_edp_inst, t, MSG_ERR_CANCEL);
}

/*** BeginHeader edp_msg_writable */
word edp_msg_writable(edp_trans_t __far * t);
/*** EndHeader  */
_edp_debug
word edp_msg_writable(edp_trans_t __far * t)
{
	if (t->done)
   	return 0;
   return 1 + _tbuf_remain(&t->tx);
}

/*** BeginHeader edp_msg_readable */
word edp_msg_readable(edp_trans_t __far * t);
/*** EndHeader  */
_edp_debug
word edp_msg_readable(edp_trans_t __far * t)
{
	if (t->rx.len)
   	return 1 + t->rx.len;
   return !t->rx_last;
}

/*** BeginHeader edp_msg_read */
word edp_msg_read(edp_trans_t __far * t, void __far * buf, word len);
/*** EndHeader  */
_edp_debug
word edp_msg_read(edp_trans_t __far * t, void __far * buf, word len)
{
	word r = edp_msg_readable(t);
   if (!r)
   	return 0;
   r = u_min(r-1, len);
   if (buf)
		_tbuf_extract(buf, &t->rx, r);
   else
   	_tbuf_delete(&t->rx, r);
   return r;
}

/*** BeginHeader edp_msg_write */
word edp_msg_write(edp_trans_t __far * t, const void __far * buf, word len);
/*** EndHeader  */
_edp_debug
word edp_msg_write(edp_trans_t __far * t, const void __far * buf, word len)
{
	word w = edp_msg_writable(t);
   if (!w)
   	return 0;
   w = u_min(w-1, len);
   //DEVIDEA: need to update tbuf.lib for const correctness
   _tbuf_append(&t->tx, (void __far *)buf, w);
   return w;
}




/*** BeginHeader edp_msg_handle_server_data */
void edp_msg_handle_server_data(
							EDP __far * s,
                     int mode,
							edp_msg_start __far * m,
                     char __far * data,
                     word len);
// Values for mode parameter
enum {
	EDPMSG_START,	// Received start data from server
   EDPMSG_DATA,	// Received subsequent data from server
   EDPMSG_ERROR,	// Received error from server
   // Following must be last; used to automatically ACK local socket
   // when data is sent to the server.
   EDPMSG_LOCAL,	// Locally generated ACK for socket
   EDPMSG_LOCAL_SYNACK	// Locally generated ACK, with SYN flag
};
/*** EndHeader  */
_edp_debug
void edp_msg_handle_server_data(
							EDP __far * s,
                     int mode,
							edp_msg_start __far * m,
                     char __far * data,
                     word len)
{
   longword w;
   int request;
   int new;
   int error = mode == EDPMSG_ERROR;
   edp_trans_t __far * trans;

   request = m->flags & EDP_MSG_FLAG_REQUEST;

   // The logic inversion is because 'request' field in the transaction
   // struct applies to *our* send direction.
   trans = edp_find_trans(s, error ? request : !request, m->trans_id);
   new = 0;
   if (error) {
   	if (!trans) {
#if EDP_VERBOSE
			printf("EDP MSG: no such erring transaction in progress\n");
#endif
      	return;	// No relevant transaction was active, ignore error.
      }
      if (trans->handler->error)
         trans->handler->error(trans);
   }
   else if (mode == EDPMSG_START) {
   	if (trans && trans->rx_start) {
      	// Already received start for this transaction ID
      	edp_msg_send_error_notrans(s, m->trans_id, MSG_ERR_TRANSACTION);
         return;
      }
      if (!trans) {
      	if (!request) {
         	// Response from server, but no request in progress.  Maybe we
            // cancelled when this packet was already in transit.
      		edp_msg_send_error_notrans(s, m->trans_id, MSG_ERR_NO_TRANSACTION);
				return;
         }
      	trans = edp_create_trans(s, !request, m->svc_id, m->trans_id);
         if (!trans) {
      		edp_msg_send_error_notrans(s, m->trans_id, MSG_ERR_MEMORY);
            return;
         }
         else if (!trans->handler) {
      		edp_msg_send_error(s, trans, MSG_ERR_NOT_HANDLED);
            // trans is deleted
            return;
         }
         new = 1;
      }
      trans->rx_start = 1;
      if (trans->handler->open)
         trans->handler->open(trans);
   }
   else {
   	if (!trans) {
      	edp_msg_send_error_notrans(s, m->trans_id, MSG_ERR_NO_TRANSACTION);
         return;
      }
   }

#if EDP_VERBOSE
   printf("EDP MSG: received %s trans_id=%u svc_id=%u len=%u (+%lu) %s%s\n",
	      !trans->request ? "request" : "reply",
	      ntohs(trans->trans_id),
	      ntohs(trans->svc_id),
         len,
         trans->bytes_rx,
	      error ? "ERROR" : mode == EDPMSG_START ? " START" : "",
	      m->flags & EDP_MSG_FLAG_LAST ? " LAST" : "");

#endif

   if (!error) {
		// Move received data to buffer
      if (len) {
      	if (len > _tbuf_remain(&trans->rx)) {
	         edp_msg_send_error(s, trans, MSG_ERR_WOULDBLOCK);
	         return;
         }
         _tbuf_append(&trans->rx, data, len);
         trans->bytes_rx += len;
         if (trans->handler->receive)
         	trans->handler->receive(trans);
      }
	   if (m->flags & EDP_MSG_FLAG_LAST) {
	      if (trans->rx_last) {
	         // Already got last, protocol error
	         edp_msg_send_error(s, trans, MSG_ERR_PROTOCOL_SEQUENCE);
	         return;
	      }
	      else {
	         trans->rx_last = 1;
	         if (trans->handler->eof)
	            trans->handler->eof(trans);
	      }
	   }
      w = trans->bytes_rx + _tbuf_remain(&trans->rx);
      if (w > trans->adv_win)
			edp_msg_send_ack(s, trans);
	}
	else
	   // Clean up transaction if received error packet
   	edp_msg_delete_trans(s, trans, 0);


	return;
}

/*** BeginHeader edp_msg_handler */
void edp_msg_handler(EDP __far * s, char __far * msg, word len);
/*** EndHeader  */
_edp_debug
void edp_msg_handler(EDP __far * s, char __far * msg, word len)
{
	edp_msg_start __far * m;
	edp_msg_ack __far * a;
	edp_msg_error __far * e;
   edp_msg_capabilities_1 __far * c1;
   edp_msg_capabilities_2 __far * c2;
	char opc;
   word clen;
   int request;
   edp_trans_t __far * trans;
   word svc_id;
   int svc_avail;
   int svc_possible;

	if (len < 1)
		return;

	opc = msg[0];
	switch (opc) {
	case EDP_MSG_OPC_CAPABILITIES:
#if EDP_VERBOSE
	   printf("EDP MSG: got capabilities\n");
#endif
   	// Minimum caps length (if no compression or services)
   	clen =	sizeof(edp_msg_capabilities_1) +
               sizeof(edp_msg_capabilities_2) - 3;
   	if (len < clen)
      	goto _len_error;
      c1 = (edp_msg_capabilities_1 __far *)msg;
      if (len < clen + c1->n_compr)
      	goto _len_error;
      c2 = (edp_msg_capabilities_2 __far *)(c1->compr + c1->n_compr);
      if (len < clen + c1->n_compr + ntohs(c2->n_svc)*sizeof(word))
      	goto _len_error;

   	// Keep a malloc'd copy of peer capabilities, since we have
      // at least verified the packet length is correct.
      if (s->peer_caps_1)
      	s->peer_caps_1 = _sys_realloc(s->peer_caps_1, len);
      else
      	s->peer_caps_1 = _sys_malloc(len);
      if (s->peer_caps_1) {
      	_f_memcpy(s->peer_caps_1, msg, len);
      	s->peer_caps_2 = (edp_msg_capabilities_2 __far *)
         		(s->peer_caps_1->compr + s->peer_caps_1->n_compr);
			if (s->peer_caps_1->flags & EDP_MSG_FLAG_REQ_CAP) {
         	edp_msg_send_capabilities(s);
         }
      }
   	break;
   case EDP_MSG_OPC_START:
   	if (len < sizeof(edp_msg_start))
      	goto _len_error;
   	m = (edp_msg_start __far *)msg;
      // Check if service handler socket is available
      svc_id = ntohs(m->svc_id);
      if (!edp_msg_find_handler(s, svc_id)) {
     		edp_msg_send_error_notrans(s, a->trans_id, MSG_ERR_NOT_HANDLED);
        	edp_msg_send_capabilities(s);
      }
		else
			edp_msg_handle_server_data(s, EDPMSG_START, m, (char __far *)(m+1),
      					len - sizeof(*m));
      break;
   case EDP_MSG_OPC_DATA:
   	if (len < sizeof(edp_msg_data))
      	goto _len_error;
   	m = (edp_msg_start __far *)msg;
		edp_msg_handle_server_data(s, EDPMSG_DATA, m,
      					(char __far *)m + sizeof(edp_msg_data),
      					len - sizeof(edp_msg_data));
   	break;
   case EDP_MSG_OPC_ACK:
   	if (len < sizeof(edp_msg_ack))
      	goto _len_error;
   	a = (edp_msg_ack __far *)msg;
      request = a->flags & EDP_MSG_FLAG_REQUEST;
		trans = edp_find_trans(s, request, a->trans_id);
      if (!trans) {
      	edp_msg_send_error_notrans(s, a->trans_id, MSG_ERR_NO_TRANSACTION);
      }
      else {
			trans->peer_win = ntohl(a->ack) + ntohl(a->window);
#if EDP_VERBOSE
	   	printf("EDP MSG: got ack, bytes=%lu win=%lu\n",
         	ntohl(a->ack), ntohl(a->window));
#endif
      }

   	break;
   case EDP_MSG_OPC_ERROR:
   	if (len < sizeof(edp_msg_error))
      	goto _len_error;
   	e = (edp_msg_error __far *)msg;
      request = e->flags & EDP_MSG_FLAG_REQUEST;
#if EDP_VERBOSE
      printf("EDP MSG: got error, %s %s trans_id=%u code=%d\n",
	   	request ? "request" : "reply",
         e->flags & EDP_MSG_FLAG_SENDER ? "SENDER" : "",
         ntohs(e->trans_id), e->code);
#endif
		m = (edp_msg_start __far *)e;
      // Send a RST to socket
		edp_msg_handle_server_data(s, EDPMSG_ERROR, m, NULL, 0);
		break;
	}
   return;

_len_error:
	// Can't really send an error message, since if the length is wrong
   // then we can't fill in the transaction ID field in the error packet.
   // So, for now, just ignore the packet.
#if EDP_VERBOSE
	printf("EDP MSG: packet length error from server\n");
#endif
	return;
}


/*** BeginHeader edp_msg_send_capabilities */
void edp_msg_send_capabilities(EDP __far * s);
/*** EndHeader  */
_edp_debug
void edp_msg_send_capabilities(EDP __far * s)
{
	char buf[sizeof(edp_msg_capabilities_1) +
            sizeof(edp_msg_capabilities_2) +
            0 + 	// No compression algos currently
            EDP_MSG_MAX_SVCS * sizeof(word)];
   word svc_id;
   word len;
   edp_msg_capabilities_1 * c1;
   edp_msg_capabilities_2 * c2;

	c1 = (edp_msg_capabilities_1 *)buf;
   c2 = (edp_msg_capabilities_2 *)(buf + offsetof(edp_msg_capabilities_1, compr) + 0);

   c1->opcode = EDP_MSG_OPC_CAPABILITIES;
   c1->flags = s->peer_caps_1 ? 0 : EDP_MSG_FLAG_REQ_CAP;
   c1->version = 1;
   c1->max_trans = 0;
   c1->window = htonl(EDP_MSG_MAX_WINDOW);
   c1->n_compr = 0;
   c2->n_svc = 0;
   for (svc_id = 0; svc_id < EDP_MSG_MAX_SVCS; ++svc_id)
	   if (edp_msg_find_handler(s, svc_id))
         *(c2->svc_id + c2->n_svc++) = htons(svc_id);

   len = (char *)(c2->svc_id + c2->n_svc) - buf;

   c2->n_svc = htons(c2->n_svc);
#if EDP_VERBOSE
	printf("EDP MSG: sending capabilities: n_svc=%u%s\n",
   	ntohs(c2->n_svc),
      c1->flags & EDP_MSG_FLAG_REQ_CAP ? ", requesting his" : ""
      );
#endif
   edp_send_fac(s, EDP_FACILITY_MSG, buf, len);

}

/*** BeginHeader rci_handler */
void rci_handler(EDP __far * s, char __far * msg, word len);
/*** EndHeader  */
_edp_debug
void rci_handler(EDP __far * s, char __far * msg, word len)
{
	// RCI protocol handler
	char opc;

	if (len < 1 || s->rci_state == RCI_STATE_ERROR)
		return;

	opc = msg[0];
	--len;
	++msg;
	switch (opc) {
	case RCI_COMMAND_REQ_START:
		if (s->rci_state != RCI_STATE_READY)
			rci_send_error(s, RCI_ERROR_SEQUENCE);
		else if (len < 5 || msg[0])	// can't handle compression
			rci_send_error(s, RCI_ERROR_FATAL);
		else {
			s->rci_rxlen = ntohl(*(longword __far *)(msg+1));
			if (s->rci_rxlen) {
	         if (s->rci_rxdata) {
	            _sys_free(s->rci_rxdata);
	            s->rci_rxdata = NULL;
	         }
				s->rci_rxdata = (char __far *)_sys_malloc(s->rci_rxlen);
				if (!s->rci_rxdata) {
					rci_send_error(s, RCI_ERROR_FATAL);
					break;	// Have to skip this message if no memory
				}
				len -= 5;
				len = (word)ulong_min(len, s->rci_rxlen);
				_f_memcpy(s->rci_rxdata, msg+5, len);
				edp_free_buf(s);	// Free caller's buffer, since may need the
										// space when generating a reply.
				s->rci_read = len;
				if (s->rci_read == s->rci_rxlen) {
					rci_process_request(s, s->rci_rxdata, s->rci_read);
				}
				else
					s->rci_state = RCI_STATE_RX;
			}
		}
		break;
	case RCI_COMMAND_REQ_DATA:
	case RCI_COMMAND_REQ_END:
		if (s->rci_state != RCI_STATE_RX) {
			// Forgive zero length stuff.  He might have provided everything
			// in a REQ_DATA (which we processed) and then sent an empty END.
			if (!len)
				break;
			rci_send_error(s, RCI_ERROR_SEQUENCE);
		}
		else {
			len = (word)ulong_min(len, s->rci_rxlen - s->rci_read);
         _f_memcpy(s->rci_rxdata + s->rci_read, msg, len);
			edp_free_buf(s);	// Free caller's buffer, since may need the
									// space when generating a reply.
         s->rci_read += len;
         // Try to be forgiving of slightly bad server
         if (s->rci_read == s->rci_rxlen || opc == RCI_COMMAND_REQ_END) {
            rci_process_request(s, s->rci_rxdata, s->rci_read);
            s->rci_state = RCI_STATE_READY;
         }
		}
		break;
	case RCI_ERROR_DETECTED:
#if RCI_VERBOSE
		printf("RCI: got error code 0x%02X\n", msg[1]);
#endif
		s->rci_state = RCI_STATE_ERROR;
		edp_close(s, 0);
		break;
	default:
		// Ignore anything else (for upward compat) - could be
		// server ACKs, announce compression etc.
		break;
	}
}


/*** BeginHeader rci_send_error */
void rci_send_error(EDP __far * s, word code);
/*** EndHeader  */
_edp_debug
void rci_send_error(EDP __far * s, word code)
{
	char buf[2];

	buf[0] = RCI_ERROR_DETECTED;
	buf[1] = (char)code;
	edp_send_fac(s, EDP_FACILITY_RCI, buf, 2);
	s->rci_state = RCI_STATE_ERROR;
}


/*** BeginHeader edp_is_secure */
int edp_is_secure(EDP __far * s);
/*** EndHeader  */
_edp_debug
int edp_is_secure(EDP __far * s)
{
	return s->secured == 2;
}


/*** BeginHeader edp_set_tls */

/* START _FUNCTION DESCRIPTION ********************************************
edp_set_tls          		<EDP.LIB>

SYNTAX: int edp_set_tls(
					EDP far * s,
					word flags,
					SSL_Cert_t far * my_cert,
	 				SSL_Cert_t far * trusted,
	 				int (*policy)() );

DESCRIPTION:	Set various options for iDigi over TLS.

					NOTE: this is an internal function; do not call from
               application.  Contact technical support.

               This function is only available if you first #use "ssl_sock.lib"
               before #use this library.

               It is automatically called by edp_init() with the following
               flags:
						SSL_F_REQUIRE_CERT
						my_cert: NULL
						trusted: the certificate in
                  				include/ximport/Certs/digi2048ca.crt
						policy: default policy is to accept all certificates
                          signed by the above CA.

               Because of the above default setting, your application must
               call this function after edp_init() in order to set the
               desired options.

               The options provided here are basically passed to sock_secure()
               when the iDigi connection to the secure iDigi port is made.

               NOTE: this function only copies the pointers, not the objects
               to which they refer.  Thus, the application should be careful
               not to modify or delete the relevant objects.  The application
               is responsible for all certificate management.

PARAMETER 1: EDP state variable
PARAMETER 2: flags:
				 A bitwise combination of the following flags:
               SSL_F_REQUIRE_CERT  Require certificate from peer.
               SSL_F_PEER_CERT_OK  Pretend all certs are valid.  This is mainly
                         for debugging.
               SSL_F_NO_RESUME     Set to not attempt session resumption.
               SSL_S_ALLOW_NULL    Permit NULL bulk encryption suites.  This
											  allows eavesdropping, but still requires
											  strong authentication and message integrity.
					SSL_S_FORBID_MD5    Do not permit MD5-based hash (force SHA-1)
PARAMETER 3:my_cert:
				 If not NULL, is a parsed certificate including private key
				 information.  This certificate will be presented to the server
				 if requested.  This is not normally required, since most publicly
				 accessible iDigi servers will use account details provided by
				 the RCI rather than a client certificate provided by this
				 function.
PARAMETER 4:trusted:
				 Pre-parsed certificate chain representing the list of trusted
				 authorities.  This is required if server authentication is
				 required by the application.  If the application is intended to
				 work with a single iDigi server, then it is sufficient to provide
				 the server's certificate only.  Otherwise, it may be necessary
				 to provide a relatively long list of CA certificates, or allow
				 CA certificates to be provided at run-time.  Note that a default
             Digi CA certificate is provided in Certs/digi2048ac.crt, which
             is used if this function is not called by the application.
PARAMETER 5:policy
				 Callback function which is called by this library when a server
				 certificate is provided.  Prototype of such a callback must be:
					int edp_server_policy(
									ssl_Socket far * state,
	                       	int trusted,
	                       	struct x509_certificate far * cert,
	                       	void far * data
										);
				 Pass NULL to remove this callback.  If not NULL, this callback
				 is called if and only if the SSL_F_REQUIRE_CERT flag is set,
				 after a valid certificate is available.  If trusted is false, then
				 no trusted CA list was specified. If there is a trusted CA list,
				 but the certificate could not be validated, then this function
				 will not be called since this always causes an error.
             Function should return 0 to proceed (allow) or non-zero to
             disallow. In the latter case, an access_denied alert will be sent
             to the peer.
             cert parameter is the peer certificate.  This has several fields
             (see X509.lib) which indicate the subject and issuer etc.  Most
             useful field is cert->subject which points to a struct containing
             ascii representations of the various certificate subject name
             fields.  Function may call x509_name_string() to get a formatted
             subject name e.g. for messages.
             data parameter is set to the EDP state structure.

RETURN VALUE: 	0

END DESCRIPTION **********************************************************/

#ifdef EDP_USE_TLS
int edp_set_tls(EDP __far * s,
					word flags,
					SSL_Cert_t __far * my_cert,
	 				SSL_Cert_t __far * trusted,
	 				int (*policy)( /* ssl_Socket far * state,
	                       int trusted,
	                       struct x509_certificate far * cert,
	                       void far * data */ )
					);
#endif
/*** EndHeader */

_edp_debug
int edp_set_tls(EDP __far * s,
					word flags,
					SSL_Cert_t __far * my_cert,
	 				SSL_Cert_t __far * trusted,
	 				int (*policy)( /* ssl_Socket far * state,
	                       int trusted,
	                       struct x509_certificate far * cert,
	                       void far * data */ )
					)
{
	s->tls_flags = flags;
	s->my_cert = my_cert;
	s->trusted = trusted;
	s->policy = policy;
	return 0;
}




/*** BeginHeader */
#endif
/*** EndHeader  */


