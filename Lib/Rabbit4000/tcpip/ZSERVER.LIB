/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader  ********************************************/
#ifndef __ZSERVER_LIB
#define __ZSERVER_LIB
/*** EndHeader ***********************************************/

/* START LIBRARY DESCRIPTION *********************************************
ZSERVER.LIB

DESCRIPTION:

	Common server resource and user management functions.

   This library provides a common point of interface for TCP/IP servers,
   such as HTTP and FTP, so that various resources (files, variables
   and functions) are accessible to external clients in a uniform way.

   Many of the functions in this library are mainly intended for
   developers of new servers, and need not be considered if your application
   makes use of the servers provided with Dynamic C.  The functions which
   are commonly called by the application (mainly during the initialization
   phase) are grouped together for convenience.

   Starting with Dynamic C 8.10, this library has been upgraded to support
   the FAT filesystem, along with the existing FS2 filesystem.  These
   filesystems are supported in a more powerful, consistent and
   user-friendly manner.  In addition, there is better support for
   access control.

   The new library is fully backward-compatible with previous releases.
   Existing code should not need to be modified, or very small modifications
   may be made if it is desired to support the new FAT filesystem or
   enhance access control.  In spite of this backward compatibility, it
   is recommended that you review existing code and upgrade it to take
   advantage of the new facilities.  This will ease the process of
   upgrading to future releases.  For example, the old style of defining
   "static" resources was to initialize a constant structure called
   http_flashspec[].  Since this is rather restrictive, a new set of
   macros has been defined to make the table easier to define.  Using
   the macros also hides internal details, which gives Rabbit Semiconductor greater
   ability to make improvements.

   Virtual Filesystem Hierarchy
   ----------------------------

   Zserver supports the concept of a "virtual filesystem".  This is
   modelled on the Unix directory structure.  There is a "root
   directory" called "/".  Under this directory there are a number
   of "mount points" (which are entry points for the various
   filesystems) plus individual entries for each resource added
   statically (flash) or dynamically (RAM).

   A naming convention has been established for the sub-directories.
   The FS2 filesystem is accessed via the "/fs2" mount point.
   DOS FAT partitions are accessed from "/A", "/B", "/C" etc.
   (This was chosen to be reminiscent of DOS drive letters).

   Note that the mount point will only exist if the corresponding
   filesystem has been included prior to #use zserver.lib.  For example,
   if you #use fs2.lib, then the /fs2 mount point will be created.

   Note that resource names added using sspec_addrootfile(),
   sspec_addvariable() etc. may conflict with mount-point names.
   This is undesirable, so your application should avoid calling
   such resources by names starting with /fs2/, /A/ etc.  In
   addition, you should not use /dev or /etc either, since these
   may be used by future versions of the library.

   For backward compatibility, a resource called "/" may be created.
   When accessed by a server as a resource file, this entry will
   be returned.  Otherwise (e.g. for directory listing) the "/"
   entry will refer to the root directory.

   FS2:

   If you #use fs2.lib, then all FS2 files automatically become
   available as resource files.  Under the /fs2 mount point,
   each FS2 file is called "file1", "file2" etc.  The numeric
   suffic indicates the FS2 file number (1..255), and the
   "file" prefix is constant.  These entries will exist for
   each file which exists in FS2, whatever the FS2 extent that is
   exists in.

   In addition, under /fs2 there will be a series of subdirectories.
   These indicate the available FS2 extents.  Each extent will be
   called "/fs2/ext1", "/fs2/ext2" etc.  Alias entries also exist
   such as /fs2/ram for the first RAM extent, /fs2/flash for the
   first data flash extent, and /fs2/pflash for the program flash
   extent.

   Under each of these extent directories will be a list of all the
   files which exist on that extent.  For example, if FS2 file
   number 88 exists on the data flash, then the following three
   entries will appear to exist:

     /fs2/file88
     /fs2/flash/file88
     /fs2/ext2/file88

   All three files refer to the same actual file.  The main distinction
   applies when creating new files.  If a resource /fs2/ram/file99
   is created, then that file will be created on the RAM extent.
   If, on the other hand, /fs2/file99 is created, then that file
   will be created on an unspecified extent.  Thus, it is best to
   include the extent subdirectory when creating new resources.

   FAT:

   If you #use fat16.lib, then zserver will have access to FAT partitions.
   FAT partitions live on "devices", and each device can have up to
   4 partitions recognized by the FAT library.  Since the FAT
   filesystem has its own native file naming and directory navigation
   facility, zserver defers to this for resource names.

   The first partition will be accessible under the /A mount point.
   For example, if the first partition contains a file called
   /htdocs/admin/index.htm then the full resource name will be
   /A/htdocs/admin/index.htm.

   NOTE: FAT files are customarily accessed using backslashes in
   the path name.  Zserver requires use of forward slashes, so you
   must define the symbol FAT_USE_FORWARDSLASH before #use fat16.lib.
   Do not worry about interoperability with PCs etc., since the
   slash delimiters are not stored on the actual medium.  If you
   unmount a removable medium then mount it in a DOS or Windows
   PC, then backslashes are used in the path names, as usual.

   Note that zserver requires each FAT partition to be registered,
   otherwise its mount point will not be visible.  You can assign
   any mount point to any partition, however each mount point must
   refer to a different partition.  See the sspec_fatregister()
   function for more details.

   You can use the sspec_automount() function to simplify the
   initialization of the FAT (and/or FS2) libraries.  Otherwise,
   you need to properly initialize the library in your application
   before calling zserver functions.  See the documentation for the
   FS2 and FAT libraries for more details.

   Static and RAM resources:

   These resources live directly in the root directory.  Each
   resource may be assigned a name that may contain slashes and other
   arbitrary characters (except NULL).  If you use slashes, this does
   NOT mean that there is an implied directory hierarchy.  For example,
   if you have two resources called
     /food/bread.html  and
     /food/cheese.html
   then you cannot use sspec_cd() to "change directory" to "/food".
   There is no such directory; the resource name just happens to look
   like a file in a directory.

   Not only files, but also variables, functions, forms and other types
   of resources can be defined in the static or RAM tables.  The names of
   these resources appear in a directory listing of the root directory,
   however they are not openable using sspec_open() or other functions
   which expect file-type resources.

   Resource Access Control
   -----------------------

	Resources may be assigned various access controls, called "permissions".
   The permissions control access by servers (in general) as well as
   specific user groups.

   It is assumed that most servers will identify and authenticate a
   set of "users" i.e. external entities which want to access resources.
   Zserver.lib supports the concept of "user groups", and access control
   is specified for user groups, not individual users.

   The sauth_*() series of functions allow users to be defined and
   managed.  Each unique user ID added via sauth_adduser() has the
   following set of attributes:

   	username - a character string of up to SAUTH_MAXNAME characters.
      password - another character string up to SAUTH_MAXNAME.
      mask - a 16-bit bitmask.  Each bit which is set indicates a
             user group of which this user is a member.  This implies
             that there is a maximum of 16 user groups which can
             be defined; typically 2 or 3 would be used in a typical
             application e.g. one for ordinary users, one for an
             "administrator" and maybe one with unlimited access.
      writeaccess - another 16-bit mask.  Each bit in this mask
             indicates a server for which this user has write
             access to one or more resources.  If the bit is not
             set, then the user does not have write access from
             this server in spite of any other permission which
             may allow write access.
		servermask - this defines the set of servers for which this
      		user has any access at all.  If the bit for a server
            is not set, then this user is effectively "hidden" as
            far as that server is concerned.
      data - this is an arbitrary pointer which may be used to
      		associate additional data with this user.

   Zserver provides a basic authentication service (sauth_authenticate())
   however some servers may need to perform more sophisticated
   authentication when the user logs in.  This is left up to the
   server, since the methods are quite variable.

   Note: only the sauth_* functions are concerned with individual
   user IDs.  The sspec_* functions are only concerned with user
   groups i.e. the mask field in the userid entry.

   The mask can contain one or more bits set to '1' i.e. a user
   can be a member of one or more groups.  Typically, if a "super
   user" was defined, then that user would be a member of all
   groups.  When access tests are performed, access is granted if
   any of the user's group bits allow the specified access
   (read or write).

   By default, when you call sauth_adduser() to define a new
   userid, the mask is set to a single bit which is a '1'
   shifted left by the user's entry number in the userid table.
   If 16 or fewer users are defined in this manner, each user
   will be assigned a new, unique, group.  This is compatible
   with older versions of the library which did not have the
   concept of user groups.  In this case, users and user groups
   are considered equivalent.  You can override this behavior
   by calling the sauth_setusermask() function for any users
   where this is undesirable (e.g. to make the super user a
   member of all groups, not just its own unique group).

   Each server should have a unique bit assigned to identify that
   server.  Up to 12 servers may be defined; 4 bits in the 16-bit
   bitmask are reserved for special flags.  Some of these server
   identifiers are predefined for use by existing server libraries.
   These are:
		SERVER_HTTP			0x0001	// Web
		SERVER_FTP			0x0002	// File transfer
		SERVER_SMTP			0x0004	// Mail
		SERVER_HTTPS		0x0008	// Secure web server
		SERVER_SNMP			0x0010	// SNMP agent
		SERVER_SSL			0x0020	// SSL/TLS
		SERVER_CLOUD		0x0040	// Device Cloud
   Other bits are reserved for servers developed by customers:
		SERVER_USER			0x0800
		SERVER_USER2 		0x0400
   Note that the user-defined server should "grow down" to allow
   room for future Rabbit Semiconductor-supplied servers (which "grow up").

   There is also a symbol, SERVER_ANY, which can be used in place
   of a server mask when any (or all) servers are applicable.
   Otherwise, you can usually specify multiple servers by ORing
   the SERVER_* symbols together.

   Many of the new sspec_* functions require a "ServerContext"
   structure to be passed.  This is explained in greater detail
   below, however the important thing to note is that this
   structure has fields which identify the current server and
   userid.  The "server" field in ServerContext identifies the
   server, and this is one of the few cases where only a single
   server bit should be set, identifying the server.

   Having specified a set of user groups and servers, the various
   methods for setting permissions for each resource is described
   below.

   There are three basic methods for setting the permissions for
   a resource.  If the resource is defined in the flash resource
   table (e.g. using the SSPEC_RESOURCE_* macros), then the
   permissions must be set using the SSPEC_RESOURCE_P_* series
   of macros.  Such permissions cannot be changed at runtime since
   they are stored in flash.

   If the resource is defined in the RAM table, then you can use
   the sspec_setpermissions() function (and some others) to
   dynamically specify the reource permissions.

   If the resource is in the virtual filesystem hierarchy, then
   you can use the sspec_addrule() function to associate permissions
   with a resource (or set of resources with the same path name
   prefix).

   Whichever method is used, the permissions data structure is the
   same.  The fields in this structure are:

   	realm - this is an arbitrary character string which is
          associated with the resource.  The name "realm" originates
          with the HTTP server, however this string can be used
          for any purpose as required by the server.  If the realm
          string is NULL in a flash- or ram-table entry, then the
          rule table (sspec_addrule()) is consulted to obtain the
          permissions.  If the rule table has no entry for this
          resource name, then it reverts back to the flash- or ram-
          table permissions (with NULL realm).
      readgroups - this 16-bit bitmask indicates the user group(s)
      	 which are granted read access to this resource.
      writegroups - as for readgroups, except for write access.
      servermask - a bitmask of the servers which are allowed to
      	 access this resource.  For historical reasons, if this
          is set to zero, then all servers are allowed.  If at
          least one bit is set, but the server bit does not match,
          then the resource is effectively hidden from that server
          regardless of the other permissions (user groups).
      method - this is a single character bitfield which
          is set to indicate the acceptable method(s) of
          authentication required.  Currently, the following values
          are defined, however zserver does not actually make use
          of them:
            SERVER_AUTH_DEFAULT		0x00
            		// Use backward-compatible authentication (see below)
				SERVER_AUTH_NONE			0x01
            		// No authentication method specified
				SERVER_AUTH_BASIC			0x02
            		// May use plaintext userid/password matching
				SERVER_AUTH_DIGEST	  	0x04
            		// May use challenge-response type protocol
                  // (such as HTTP digest).  Note that this is only
                  // useful if USE_HTTP_DIGEST_AUTHENTICATION is
                  // also defined.
				SERVER_AUTH_PK				0x08
            		// May use public key authentication (such as SSL/TLS)
            		// This is not yet implemented; reserved for future use.
          "SERVER_AUTH_DEFAULT" (0) has the following semantics,
          which are retained from previous releases of the HTTP
          library: If sspec_needsauthentication() returns FALSE,
          then no authentication is
          required.  Otherwise, the authentication method set using
          the http_setauthentication() function is used.
		mimetype - this is a pointer to a MIMETypeMap struct.  This
          information is not strictly related to access control,
          but it is grouped with the permissions for convenience.
          If NULL, then the default table of MIME types will be
          consulted.  MIME types are explained below.

   The rule-based permissions are described in detail with the
   documentation for the sspec_addrule() function.


   Naming Conventions
   ------------------

   For mainly historical reasons, most of the function names start with
   "sspec_".  The functions associated with user and group management
   start with "sauth_".

   Most of the macros start with "SSPEC_" however, for backward compatibility,
   there are a few inconsistencies.  In particular, the HTTP server was
   treated specially by the library (HTTP pre-dated ZSERVER).  Now, HTTP
   is treated the same as any other server, but some of the names reflect
   this heritage.


DATA STRUCTURES:

	MIME Type Table
   ---------------

	Mapping for MIME (Multimedia Internet Mail Extensions) types based on
   resource name extensions.  The purpose of this structure (one or more
   of which are collected into a table called "http_types") is to associate
   resource content types with a file-type resource.  Common examples are
   "text/html" and "image/jpeg".  Typically, the association is done by
   looking at the resource name's "extension" e.g. index.html is mapped
   to "text/html" by setting the extension field to ".html" and the
   type field to "text/html".  You can also make an explicit association
   using the rule table or directly in the static definitions.

	   typedef struct {
	      char extension[10];
	      char type[SSPEC_MAXNAME];
	      int  (*fptr)(void* server_data); // This is used for server-specific processing e.g. SSI.
	   } MIMETypeMap;

   Note that this structure was historically called "HttpType", and this
   typedef is still available if you #use http.lib.

   A MIMETypeMap table is only required if you are using HTTP or another server
   which uses MIME types.

   Rather than explicitly declaring and initializing the MIME table using
   normal C initializers, it is recommended that new applications use the
   set of macros

		SSPEC_MIMETABLE_START
		SSPEC_MIME(extension, type)
		SSPEC_MIME_FUNC(extension, type, function)
		SSPEC_MIMETABLE_END

   For example, with a typical web server application, you would place the
   following code in your main C program:

      SSPEC_MIMETABLE_START
      SSPEC_MIME(".html", "text/html"),
      SSPEC_MIME_FUNC(".shtml", "text/html", shtml_handler),
      SSPEC_MIME(".jpg", "image/jpeg"),
      SSPEC_MIME(".gif", "image/gif"),
      SSPEC_MIME_FUNC(".cgi", "text/html", my_cgi_handler)
      SSPEC_MIMETABLE_END

   The SSPEC_MIME_FUNC variation allows a C function to be associated with
   that MIME table entry.  This is used for SSI (.shtml) and CGI (Common
   Gateway Interface) facilities in the web server.

   Status Return
   -------------

   A new zserver function, sspec_stat(), returns information about a
   file-type resource, similar to the Unix stat(2) function.  See the
   documentation with sspec_stat() for more details.

	   typedef struct
	   {
	      word     flags;
	   #define SSPEC_ATTR_MDTM    0x0001      // Have modification date/time
	   #define SSPEC_ATTR_LENGTH  0x0002      // Have current length
	   #define SSPEC_ATTR_WRITE   0x0004      // File is writable
	   #define SSPEC_ATTR_EXEC    0x0008      // File is "executable"
	   #define SSPEC_ATTR_HIDDEN  0x0010      // "Hidden" attribute bit
	   #define SSPEC_ATTR_SYSTEM  0x0020      // "System" attribute bit
	   #define SSPEC_ATTR_ARCHIVE 0x0040      // "Archive" attribute bit
	   #define SSPEC_ATTR_DIR     0x0080      // This is directory name
	   #define SSPEC_ATTR_COMPRESSED 0x0100   // File stored in compressed format
	   #define SSPEC_ATTR_MAXLENGTH  0x0200   // Have maximum length
	   #define SSPEC_ATTR_SEEKABLE   0x0400   // Resource is randomly accessible
	   #define SSPEC_ATTR_EXTENSIBLE 0x0800   // File may be expanded at end

	      long     mdtm;          // Modification date/time (SEC_TIMER format)
	      long     length;        // Current file size
	      long     maxlength;     // Maximum allowable file size
	      ServerPermissions *
	               perm;          // Access (groups and server)
	   } SSpecStat;

   In general, you should look at the flag bits to see if a particular
   field is filled in.  Some of the data is not available for certain
   filesystems, so don't assume it is always available.

   The ServerPermissions struct pointer is always filled in.  This information
   is maintained by zserver, not the filesystem.


   Server Contextual Information
   -----------------------------

   Zserver now requires each server to maintain some context information.
   In particular, zserver now implements the concept of a "current
   working directory".  Zserver itself does not remember the CWD, but it
   does provide functions to support it.  The ServerContext structure
   must be provided by the server to zserver when required.

   Since zserver now supports more powerful access control, the
   ServerContext structure also contains the "current userid".
   It also identifies the server which is calling the zserver function,
   via the "server" field.

	   typedef struct
	   {
	      int      userid;           // Current user ID (-1 if none)
	      word     server;           // Mask bit of this server e.g.
         										// SERVER_HTTP.
	      char *   rootdir;          // "Root directory", or NULL for default
                                    //  root.
	      char     cwd[SSPEC_MAXNAME+1];   // Current working directory.  This
         									// must include the root directory, if any,
                                    // as a prefix.  Null terminated.
	      char *   dfltname;         // Default file name to append if attempt
         									// to open a directory. e.g. this would be
                                    // "index.html" for web server.
	      SSpecFileHandle * dirlist; // File handle for directory listing.
         									// This is used by zserver internally
	                                 // for remembering state during a directory
                                    // list sequence.  Should not be touched by
                                    // server during such a sequence.
	   } ServerContext;


CONTROL MACROS:

	There are several configuration macros that may be set up by the
   application to control the memory usage and behavior of zserver.
   These should be defined before #use zserver.lib, unless otherwise noted.

	   ZSERVER_DEBUG

      	Define to enable Dynamic C single-stepping in the zserver library.

      ZSERVER_VERBOSE

      	Define to enable some printf()'s of common error situations.  For
         debugging only.

	   HTTP_MAXRAMSPEC

      	This macro is deprecated.  Use SSPEC_MAXSPEC instead.

	   SSPEC_MAXSPEC

      	Define to the number of dynamic (RAM) resource table entries to
         allocate.  Each entry takes SSPEC_MAXNAME + 23 bytes of root
         memory (or SSPEC_MAXNAME + 33 if FORM_ERROR_BUF is defined).

         Defaults to 10 entries (approx 530 bytes).  Do not set higher
         than 511.

	   SSPEC_MAXNAME

      	Define the maximum name length of each dynamic or static resource.
         Defaults to 20.  You can minimize memory usage by choosing short
         names for all resources, and reducing the value of this macro.

	   SERVER_PASSWORD_ONLY

			This is set to a bitmask of the server mask bits for each server
         which supports the concept of a "password-only" user i.e. no
         user name.  Defaults to zero, since currently no servers are
         implemented which use this facility.

	   SSPEC_MAXRULES

      	Define the maximum number of dynamically added "rules".  Defaults
         to 10, but you can explicitly define it to zero if all the rule
         table entries are static (see SSPEC_RULETABLE_* macros).  Each
         rule takes up 13 bytes of root storage.

	   SAUTH_MAXNAME

			Define the maximum length of a user name or password.  Defaults
         to 20 characters.

	   SAUTH_MAXUSERS

      	Define the maximum number of unique users.  Defaults to 4.  This
         determines the size of the userid table.  Each table entry takes
         up 2*SAUTH_MAXNAME + 8 bytes of root storage.

      SSPEC_ALLOW_ANONYMOUS_WRITE

      	If defined, allow "anonymous" user write access to resources.
         By default, this is denied.  The "anonymous" user is defined
         as a user which is not listed in the userid list (i.e. the
         sauth handle is -1).

	   SSPEC_XMEMVARLEN

			This determines the maximum length of xmem "variables".  Defaults
         to 20.  The size of this only determines the amount of stack space
         used by the sspec_readvariable() function.

	   SSPEC_MAX_FATDEVS

      	Determine the maximum number of independent FAT filesystem "devices".
         Defaults to 1.  Each device takes 8 bytes of root storage (plus
         whatever is required by the filesystem itself).  Each device can
         have up to 4 partitions.  This is only relevant if you use the
         FAT library.

	   SSPEC_MAX_OPEN

      	Determine the maximum number of simultaneously open resources.
         Defaults to 4.  Choose this number carefully, since each entry
         can take up a fairly large amount of root storage, depending
         on the mix of filesystems in use.  For example, with the FAT
         filesystem each open resource needs over 600 bytes.  Unless you
         are anticipating a very busy server, 4 should be enough.

	   SSPEC_DEFAULT_READGROUPS
	   SSPEC_DEFAULT_WRITEGROUPS
	   SSPEC_DEFAULT_SERVERMASK
	   SSPEC_DEFAULT_REALM
	   SSPEC_DEFAULT_METHOD

      	This group of macros establishes global default permissions
         for resources which do not have a rule associated.  For
         readgroups, the default is '0xFFFF' which means "all
         users".  For writegroups, this is '0' meaning "no
         users".  servermask defaults to SERVER_ANY (all servers
         can access).  realm defaults to "" i.e. an empty string,
         or no realm.  method defaults to no authentication method
         required.

	   FORM_ERROR_BUF

      	This macro must be defined to use automatic HTTP server
         forms generation.  Use of this macro slightly increases the
         size of each resource table entry (static or dynamic).


MACROS FOR CONTROL DATA INITIALIZATION:

	Static Rule Table
   -----------------

	   SSPEC_FLASHRULES

			Define this if your application is using static rules.  You
         must define this if you want to use the following macro.  If
         you do this, and you do not need dynamic rules, then you can
         define the macro SSPEC_MAXRULES to zero to recover the
         root memory that would be otherwise wasted.

	   SSPEC_RULETABLE_START
	   SSPEC_RULE(prefix, realm, rg, wg, sm)
	   SSPEC_MM_RULE(prefix, realm, rg, wg, sm, method, mimetype)
	   SSPEC_RULETABLE_END

      	This sequence of macros is used to define static rules.
         See the documentation with the sspec_addrule() function
         for more information.  You must define SSPEC_FLASHRULES
         to use these macros.


	Static MIME Type Table
   ----------------------

		SSPEC_MIMETABLE_START
		SSPEC_MIME(extension, type)
		SSPEC_MIME_FUNC(extension, type, function)
		SSPEC_MIMETABLE_END

      	This sequence sets up the MIME type mapping table.  You
         only need such a table if using a server which requires
         MIME types.  Currently, only the HTTP server needs this.

         Only a static MIME table is supported.  Currently, you
         cannot dynamically add new MIME types to this table,
         however it is possible to allocate new MIMETypeMap
         structures in RAM and assign them to specific resources
         using sspec_addrule() or sspec_setpermissions().  Such
         entries will not be accessed using the default resource
         name extension method.


	Static Resource Table
   ---------------------

		SSPEC_NO_STATIC
	   HTTP_NO_FLASHSPEC

      	Define if there is to be NO static resource table i.e. all resources
         are in the dynamic (RAM) table or in the filesystem(s).  If you
         define this, then there is no point in using the SSPEC_RESOURCE_*
         series of macros below.  Note that both of these are equivalent
         (HTTP_NO_FLASHSPEC is provided for backwards compatibility).

		SSPEC_RESOURCETABLE_START
		SSPEC_RESOURCE_ROOTFILE(name, addr, len)
		SSPEC_RESOURCE_XMEMFILE(name, addr)
      SSPEC_RESOURCE_ZMEMFILE(name, addr)
      SSPEC_RESOURCE_FSFILE(name, fnum)
      SSPEC_RESOURCE_ROOTVAR(name, addr, type, format)
      SSPEC_RESOURCE_XMEMVAR(name, addr, type, format)
      SSPEC_RESOURCE_FUNCTION(name, addr)
      SSPEC_RESOURCE_CGI(name, addr)
      SSPEC_RESOURCE_P_ROOTFILE(name, addr, len, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_XMEMFILE(name, addr, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_ZMEMFILE(name, addr, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_FSFILE(name, fnum, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_ROOTVAR(name, addr, type, format, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_XMEMVAR(name, addr, type, format, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_FUNCTION(name, addr, realm, rg, wg, sm, meth)
      SSPEC_RESOURCE_P_CGI(name, addr, realm, rg, wg, sm, meth)
      SSPEC_RESOURCETABLE_END

      	These macros are used to initialize the static resource table (which
         used to be performed by explicitly using C language initialization
         of a table declared as "const HttpSpec http_spec[]".  These macros
         perform the same function, however it is recommended to use them
         instead of static initializers for forward compatibility.

         The macros with _P_ in the name are the same as the others, except
         that they explicitly allow all the server permissions information
         to be initialized as well (see sspec_addrule()) except for the
         MIME type mapping.

         The "name" parameter to all these macros is the resource name.
         This usually starts with a "/" for files, but not for variables.
         The string length should be less than or equal to SSPEC_MAXNAME.

         The other parameters depend on the resource type being created:
				ROOTFILE: addr = root memory address of 1st byte of file,
                      len = length of file (0..32767).
            XMEMFILE: addr = longword (physical address) of the length
                             word of the file.  The length word (4 bytes)
                             is followed by the 1st byte of data.
         	ZMEMFILE: as for XMEMFILE, except the file is compressed and
                      imported using #zimport instead of #ximport.
            FSFILE:   fnum = FS2 file number of file (1..255)
            ROOTVAR:  addr = root memory address of data
                      type = type of data, as documented with
                             sspec_addvariable().
                      format = char * format, as used by printf() e.g.
                             "%d" for a decimal number.
            XMEMVAR:	 as for ROOTVAR except the address is a longword
                      physical address.
            FUNCTION: addr = address of C function.

         Note that a maximum of 511 static resource table entries can
         be defined.


API FUNCTIONS:

   Deprecated Functions
   --------------------

   The following functions are either no longer supported, or are
   replaced with more efficient or more capable functions.

   int sspec_save(void);
   int sspec_setsavedata(char* data, unsigned long len, void* fptr);
   int sspec_restore(void);
		- Not supported.

   int sspec_openfilehandle(SSpecFileHandle *handle, int sspec);
   int sspec_readfilehandle(SSpecFileHandle *handle, char *buffer,
                                 int len);
   int sspec_seekfilehandle(SSpecFileHandle *handle, long new_pos);
   int sspec_closefilehandle(SSpecFileHandle *handle);
   	- Replaced with sspec_open(), sspec_read(), sspec_seek(),
        and sspec_close() respectively.  Note that SSpecFileHandle's
        are now managed internally.

   int sspec_setuser(int sspec, int userid);
   int sspec_adduser(int sspec, int userid);
   int sspec_removeuser(int sspec, int userid);
   	- Replaced with more general sspec_setpermissions() function.

   int sspec_readfile(int sspec, char* buffer, long offset, int len);
		- This may be inefficient, and does not support all filesystems.
        It has the advantage of being "stateless", but the price
        to pay is in great loss of efficiency (especially when
        sequential access is all that is required.)

   int sspec_needsauthentication(int sspec);
   	- This is replaced by sspec_checkpermissions().  This function
        assumes that a non-NULL "realm" string indicates the
        resource needs authentication.

   int sspec_checkaccess(int sspec, int userid);
   	- This is replaced by sspec_checkpermissions().  This function
        only checks read access.

   char* sspec_getusername(int sspec);
   int sspec_getuserid(int sspec, int index);
   	- Because of the change to group-based access control,
        these functions do not work as may be expected.

	FAT/FS2 Filesystem Specifics
   ----------------------------

   int sspec_fatregister(int partno, fat_part * pt);
   fat_part * sspec_fatregistered(int partno);
   int sspec_automount(word which, void ** fatstuff,
                            void ** fs2stuff, void ** reserved);

       Register/test for registration of FAT partition.
       Automatically initialize and mount FAT and/or FS2 filesystems.

   Dynamic Rule Table
   ------------------

   int sspec_addrule(char * pfx, word readgroups, word writegroups,
                          word servermask, char * realm, word method,
                          MIMETypeMap * mimetype);
   int sspec_removerule(char * pfx);


   MIME Types
   ----------

   MIMETypeMap * sspec_getMIMEtype(char* name,
							 						 ServerContext * context);


	Dynamic (RAM) Resource Table
   ----------------------------

   int sspec_addrootfile(char* name, char* fileloc, int len,
                              word servermask);
   int sspec_addxmemfile(char* name, long fileloc, word servermask);
   int sspec_addfsfile(char* name, byte filenum, word servermask);
   int sspec_addvariable(char* name, void* variable, word type,
										char* format, word servermask);
   int sspec_addxmemvar(char* name, long variable, word type,
									  char* format, word servermask);
   int sspec_addfunction(char* name, void (*fptr)(), word servermask);
   int sspec_addform(char* name, FormVar* form, int formsize,
                          word servermask);
   int sspec_aliasspec(int sspec, char* name);
   int sspec_resizerootfile( int spec_index, int new_size );
   int sspec_remove(int sspec);

   HTTP Form generation
   --------------------

   int sspec_addfv(int form, int var);
   int sspec_findfv(int form, char* varname);
   int sspec_setfvcheck(int form, int var, int (*varcheck)());
   int sspec_setfvname(int form, int var, char* name);
   int sspec_setfvdesc(int form, int var, char* desc);
   char* sspec_getfvdesc(int form, int var);
   int sspec_setfventrytype(int form, int var, int entrytype);
   int sspec_getfventrytype(int form, int var);
   int sspec_setfvlen(int form, int var, int len);
   int sspec_getfvlen(int form, int var);
   int sspec_setfvoptlist(int form, int var, const char* list[], int listlen);
   int sspec_setfvrange(int form, int var, long low, long high);
   int sspec_setfvfloatrange(int form, int var, float low, float high);
   int sspec_setfvreadonly(int form, int var, int readonly);
   int sspec_getfvreadonly(int form, int var);
   int sspec_setformtitle(int form, char* title);
   char* sspec_getformtitle(int form);
   int sspec_setformfunction(int form, void (*fptr)());
   int sspec_setpreformfunction(int form, void (*fptr)());
   void* sspec_getpreformfunction(int form);
   void* sspec_getformfunction(int form);
   int sspec_setformepilog(int form, int function);
   int sspec_getformepilog(int form);
   int sspec_setformprolog(int form, int function);
   int sspec_getformprolog(int form);
   int sspec_getfvnum(int form);
   int sspec_getfvspec(int form, int var);
   char* sspec_getfvname(int form, int var);
   const char* sspec_getfvopt(int form, int var, int option);
   int sspec_getfvoptlistlen(int form, int var);


   Resource Location and Information Retrieval
   -------------------------------------------

   int sspec_findname(char* name, word servermask);
   int sspec_findfsname(word filenum, word servermask);
   int sspec_findnextfile(int start, word servermask);
   long sspec_getfileloc(int sspec);
   word sspec_getfiletype(int sspec);
   long sspec_getlength(int sspec);
   void* sspec_getvaraddr(int sspec);
   word sspec_getvarkind(int sspec);
   word sspec_getvartype(int sspec);
   int sspec_getservermask(int sspec, word *servermask);
   long sspec_getxvaraddr(int sspec);
   void* sspec_getfunction(int sspec);
   word sspec_gettype(int sspec);
   char* sspec_getname(int sspec);


   Resource Retrieval and Update
   -----------------------------

   int sspec_open(char * name, const ServerContext * context, word mode, word alloc);
   int sspec_stat(char * name, ServerContext * context,
								SSpecStat * s);
   int sspec_close(int sspec);
   int sspec_read(int sspec, char far * buf, int len);
   int sspec_write(int sspec, char far * buf, int len);
   int sspec_seek(int sspec, long offset, int whence);
   long sspec_tell(int sspec);
   int sspec_delete(char * name, ServerContext * context);
   int sspec_mkdir(char * name, ServerContext * context);
   int sspec_rmdir(char * name, ServerContext * context);

   int sspec_readvariable(int sspec, char far * buffer);

   Directory Navigation
   --------------------

   int sspec_cd(char * path, ServerContext * context, int check);
   char * sspec_pwd(ServerContext * context, char * buf);
   int sspec_dirlist(int item, char *line, int linelen,
                 	ServerContext * context, word options);

   Resource Access Control
   -----------------------

   int sspec_setpermissions(int sspec,
                                 char * realm,
                                 word readgroups,
                                 word writegroups,
                                 word servermask,
                                 word method,
                                 MIMETypeMap * mimetype);
   int sspec_getpermissions(int sspec,
                                 char ** realm,
                                 word * readgroups,
                                 word * writegroups,
                                 word * servermask,
                                 word * method,
                                 MIMETypeMap ** mimetype);
   int sspec_checkpermissions(int sspec, ServerContext * context);
   int sspec_access(char * name, ServerContext * context);
   int sspec_setrealm(int sspec, char* realm);
   char* sspec_getrealm(int sspec);

   User Identification and Authentication
   --------------------------------------

   int sauth_adduser(char* username, char* password, word servermask);
   int sauth_setwriteaccess(int sauth, int writeaccessmask);
   int sauth_getwriteaccess(int sauth);
   int sauth_setserver(int sauth, int server);
   int sauth_getserver(int sauth);
   int sauth_setserver(int sauth, int server);
   int sauth_getserver(int sauth);
   int sauth_authenticate(char* username, char* password, word server);
   char* sauth_getusername(int userid);
   int sauth_getuserid(char* username, word server);
   int sauth_setpassword(int userid, char* password);
   char* sauth_getpassword(int userid);
   int sauth_removeuser(int userid);
   int sauth_setusermask(int userid, word groupbits, void * authdata);
   int sauth_getusermask(int userid, word * groupbits,
									void ** authdata);



END DESCRIPTION **********************************************************/


/*** BeginHeader _sspec_generic, _sspec_rvt, _sspec_xvt, _sspec_zvt,
                 _sspec_fatvt, _sspec_fatparts */

#ifdef ZSERVER_DEBUG
	#define _zserver_nodebug	__debug
#else
	#define _zserver_nodebug	__nodebug
#endif

#use "pool.lib"		// include memory pool allocation (fixed block size)

// Backward compatibility with old "flashspec" struct (used for HTTP server only).
// Now, flash and ram tables have been changed to use the same structure
// definition.
#ifdef HTTP_NO_FLASHSPEC
	#ifndef SSPEC_NO_STATIC
		#define SSPEC_NO_STATIC
	#endif
#endif

#ifndef SSPEC_NO_STATIC
	#define HTTP_MAXFLASHSPEC		(sizeof(http_flashspec)/sizeof(HttpSpec))
#else
	#define HTTP_MAXFLASHSPEC		0
#endif

// Backward compatibility for MIME type table
#define HTTP_MAXTYPE          (sizeof(http_types)/sizeof(HttpType))



//
// ServerSpec structure
//

// The following are constants for the type member of the ServerSpec structure
#define SSPEC_UNUSED			0	// Marks a ServerSpec unused (this must be zero)
#define SSPEC_XMEMFILE		1	// The data resides in xmem
#define SSPEC_ZMEMFILE		2	// The data resides in xmem and is compressed
#define SSPEC_ROOTFILE		3	// The data resides in root memory
#define SSPEC_FSFILE			4	// The data resides in an FS2 file.
#define SSPEC_FATFILE		5	// The data resides in a DOS FAT file.
#define SSPEC_DEVFILE		6	// The data resides in a /dev device. This symbol
										//  is not usable in flash or ramspec tables, it
                              //  is only for device types registered using
                              //  sspec_devregister().  It is ORed with the
                              //  specific device table entry number in the
                              //  high byte.
#define SSPEC_FILE         9  // The data resides in a file - generic type
										//  returned by sspec_gettype()

#define SSPEC_ROOTVAR		10 // The data is a variable in root mem (for HTTP)
#define SSPEC_XMEMVAR		11 // The data is a variable in xmem (for HTTP)
#define SSPEC_VARIABLE		19	// The data is a variable (for HTTP) - generic
										//  type returned by sspec_gettype()

#define SSPEC_FUNCTION		20	// The data is a function (for HTTP)
#define SSPEC_FORM         21	// A set of modifiable variables
#define SSPEC_CGI				22	// The data is a CGI function (for HTTP) - new
										//  style CGIs with better interface.

#define SSPEC_LINK         30 // Symbolic link (alias) to another resource name
#define SSPEC_HARDLINK     31 // Symbolic link (alias) to anothe sever_spec or
										//  http_flashspec entry.

#define SSPEC_ERROR       999 // Indicates an error condition

// Flags for sspec_automount()
#define SSPEC_MOUNT_FS		0x0001		// Mount FS2
#define SSPEC_MOUNT_FAT		0x0002		// Mount FAT partition(s)
#define SSPEC_MOUNT_DEV		0x0004		// Mount /dev filesystem (reserved)
#define SSPEC_MOUNT_ANY		0xFFFFu		// Mount all known filesystem(s)

// Maximum length of the name of the data
#ifndef SSPEC_MAXNAME
	#define SSPEC_MAXNAME	20
#endif

// Constants for the vartype member of the ServerSpec structure
#define INT8					 1
#define INT16					 2
#define PTR16					 3
#define INT32					 4
#define FLOAT32				 5

// Bitmasks for the servermask member of the ServerSpec and ServerAuth
// structures--these determine which servers are allowed to use a particular
// resource.  Up to 12 different servers may be defined, with the limit being
// the number of available bits in a single word.  4 bits (the MSBs) are
// reserved for error indications and special flags (mainly for backward compat).
#define SERVER_HTTP			0x0001	// Web
#define SERVER_FTP			0x0002	// File transfer
#define SERVER_SMTP			0x0004	// Mail
#define SERVER_HTTPS			0x0008	// Secure web server
#define SERVER_SNMP			0x0010	// SNMP agent
#define SERVER_SSL			0x0020	// SSL/TLS
#define SERVER_CLOUD			0x0040	// Device Cloud (we run as client)
// (reserved bits for future Rabbit Semiconductor server implementations)
#define SERVER_USER			0x0800	// Placeholder for 1st user-defined server
#define SERVER_USER2			0x0400	// Placeholder for second user-defined
												//  server (etc.) - grow down.

#define SERVER_ANY			0x0FFF	// "Any server" mask. May be passed in most
												//  cases when any server will do.
#define SERVER_COMPRESSED	0x2000	// Reserved bit for backward compatibility
#define SERVER_WRITABLE		0x4000	// Reserved bit for backward compatibility
#define SERVER_ERROR			0x8000	// Reserved bit for error flagging.

// Define a default mask of servers which accept "password-only" authentication
//  (e.g. SNMP would set this).
#ifndef SERVER_PASSWORD_ONLY
	#define SERVER_PASSWORD_ONLY	SERVER_SNMP
#endif

// Definitions of authentication methods supported.  (8 bit field).  These
//  should be arranged so that higher numbered bits indicate a "stronger"
//  (and thus preferred) authentication.
#define SERVER_AUTH_DEFAULT	0x00	// Use "sspec_needsauthentication()" to
												//  determine.
#define SERVER_AUTH_NONE		0x01	// No authentication method specified
#define SERVER_AUTH_BASIC		0x02	// Use plaintext userid/password matching
#define SERVER_AUTH_DIGEST	  	0x04
            		// May use challenge-response type protocol
                  // (such as HTTP digest).  Note that this is only
                  // useful if USE_HTTP_DIGEST_AUTHENTICATION is
                  // also defined.
#define SERVER_AUTH_PK			0x08	// Use public key authentication
												//  (such as SSL/TLS)
            		// This is not yet implemented; reserved for future use.


// Mapping for MIME types based on resource name extensions
typedef struct {
   char extension[10];
   char type[SSPEC_MAXNAME];
   // Don't prototype parameter list, since it needs to be varyadic
   int  (*fptr)(/* void* server_data*/ );	// This is used for server-specific
   													//  processing e.g. SSI.
} MIMETypeMap;

#define SSPEC_MIMETABLE_START const MIMETypeMap http_types[] = {
#define SSPEC_MIME(extension, type)	{ extension, type, NULL }
#define SSPEC_MIME_FUNC(extension, type, function)	{extension, type, function}
#define SSPEC_MIMETABLE_END };

/* START FUNCTION DESCRIPTION ********************************************
MIME                      									<ZSERVER.LIB>

KEYWORDS:		tcpip, server

DESCRIPTION:
	This is a list of available MIME type macros.  They can be used in the
	MIMETABLE definition, for example, as follows:

		SSPEC_MIMETABLE_START
			SSPEC_MIME_FUNC(".zhtml", MIMETYPE_HTML, zhtml_handler),
			SSPEC_MIME(".html", MIMETYPE_HTML),
			SSPEC_MIME(".cgi", MIMETYPE_HTML),
			SSPEC_MIME(".gif", MIMETYPE_GIF)
		SSPEC_MIMETABLE_END

	The available macros (and their values) are:

	MIMETYPE_CSS			"text/css"
	MIMETYPE_HTML			"text/html"
	MIMETYPE_HTM			"text/html"
	MIMETYPE_PLAINTEXT	"text/plain"
	MIMETYPE_XML			"text/xml"

	MIMETYPE_GIF			"image/gif"
	MIMETYPE_ICO			"image/vnd.microsoft.icon"
	MIMETYPE_JPEG			"image/jpeg"
	MIMETYPE_JPG			"image/jpeg"
	MIMETYPE_PNG			"image/png"
	MIMETYPE_SVG			"image/svg+xml"

	MIMETYPE_MP3			"audio/mpeg"

	MIMETYPE_JS				"application/javascript"
	MIMETYPE_JAVASCRIPT	"application/javascript"
	MIMETYPE_JSON			"application/json"
	MIMETYPE_XHTML			"application/xhtml+xml"
	MIMETYPE_SWF			"application/x-shockwave-flash"
	MIMETYPE_BINARY		"application/octet-stream"


END DESCRIPTION **********************************************************/
#define MIMETYPE_CSS				"text/css"
#define MIMETYPE_HTML			"text/html"
#define MIMETYPE_HTM				MIMETYPE_HTML
#define MIMETYPE_PLAINTEXT		"text/plain"
#define MIMETYPE_XML				"text/xml"

#define MIMETYPE_GIF				"image/gif"
#define MIMETYPE_ICO				"image/vnd.microsoft.icon"
#define MIMETYPE_JPEG			"image/jpeg"
#define MIMETYPE_JPG				MIMETYPE_JPEG
#define MIMETYPE_PNG				"image/png"
#define MIMETYPE_SVG				"image/svg+xml"

#define MIMETYPE_MP3				"audio/mpeg"

#define MIMETYPE_JS				"application/javascript"
#define MIMETYPE_JAVASCRIPT	MIMETYPE_JS
#define MIMETYPE_JSON			"application/json"
#define MIMETYPE_XHTML			"application/xhtml+xml"
#define MIMETYPE_SWF				"application/x-shockwave-flash"
#define MIMETYPE_BINARY			"application/octet-stream"



// Access permissions for a resource or group of resources
typedef struct {
   char * realm;				// Realm string of the resource (only used by HTTP
   								//  server, but can be used for other purposes).
   word readgroups;			// Read permission granted if current ServerAuth.mask
   								//  matches in at least one bit position.
   word writegroups;			// Similar, for write access.  In addition,
   								//  ServerAuth.writeaccess must also be set.
   word servermask;			// Bit set for each server which can access this
   								//  resource.  NB: for backwards compat, if this is
                           //  set to zero then all servers are allowed.
   char	method;				// Authentication method(s) allowed: combination of
   								//  SERVER_AUTH_* bits.  Note that zserver.lib does
                           //  not directly support anything other than "basic",
                           //  however the required information is stored here
                           //  so that servers can access it as needed in a
                           //  consistent manner.
   MIMETypeMap * mimetype;	// MIME type for this resource, or NULL.  If NULL,
   								//  the MIME type will be derived from the file name
                           //  using the MIMETypeMap table called 'http_types'.
                           //  If not found in that table, the first entry in
                           //  that table will be used (for backward compat.)
} ServerPermissions;

// Rule table entry.  Associates resource names (or prefix thereof) with a set
//  of permissions
typedef struct {
	char * prefix;				// Resource name prefix string (null terminated).
   								//  Should include leading '/'. NULL if this entry
                        	//  is not in use.
	ServerPermissions perm;	// Associated permissions
} RuleEntry;

// Define max number of dynamically added rules.  Set 0 if flash only
#ifndef SSPEC_MAXRULES
	#define SSPEC_MAXRULES	10
#endif

#if SSPEC_MAXRULES
RuleEntry _rule_table[SSPEC_MAXRULES];	// Dynamic rule table.  A static const
													// (flash) table can also be defined if
                                       // the program #define's SSPEC_FLASHRULES
                                       // and defines a const f_rule_table[]
                                       // with initialized values.
#endif

// Define 'SSPEC_FLASHRULES' if application wants flash and/or dynamic rules.
//  If there are no permission rules, then programmer should define defaults.
#ifdef SSPEC_FLASHRULES
	#define HAVE_RULES
   // Macros for programmer to construct static rule table
	#define SSPEC_RULETABLE_START const RuleEntry f_rule_table[] = {
   #define SSPEC_RULE(pfx, realm, rg, wg, sm) \
   	{ pfx, { realm, rg, wg, sm, 0, NULL } }
   #define SSPEC_MM_RULE(pfx, realm, rg, wg, sm, meth, mime) \
   	{ pfx, { realm, rg, wg, sm, meth, mime } }
   #define SSPEC_RULETABLE_END };

#else
	#if SSPEC_MAXRULES
   	#define HAVE_RULES
   #endif
#endif

// Define default permissions for resources which do not match any rule.  These are also
// used, obviously, when HAVE_RULES is not defined.
#ifndef SSPEC_DEFAULT_READGROUPS
	#define SSPEC_DEFAULT_READGROUPS		0xFFFFu		// Any user can read
#endif
#ifndef SSPEC_DEFAULT_WRITEGROUPS
	#define SSPEC_DEFAULT_WRITEGROUPS	0x0000u		// No user can write
#endif
#ifndef SSPEC_DEFAULT_SERVERMASK
	#define SSPEC_DEFAULT_SERVERMASK		SERVER_ANY	// Any server can access
#endif
#ifndef SSPEC_DEFAULT_REALM
	#define SSPEC_DEFAULT_REALM			""				// No particular realm
#endif
#ifndef SSPEC_DEFAULT_METHOD
	#define SSPEC_DEFAULT_METHOD			SERVER_AUTH_NONE	// No authentication method required
#endif

// The ServerSpec structure
typedef struct
{
   word type;						// Entry type (SSPEC_* defines)
   char name[SSPEC_MAXNAME];	// Resource name
	long data;						// Location of data (when "*FILE" is the type of
	                        	// data), or maximum number of variables in a form
	                        	// (when "SSPEC_FORM" is the type of data)
	void* addr;						// Address of function or variable (when
										// "SSPEC_FUNCTION", "SSPEC_CGI" or "SSPEC_VARIABLE" is
										// the type of data).  Address of form struct for SSPEC_FORM.
	word vartype;					// Type of variable (when "SSPEC_VARIABLE" is the
										// type of data), or length of data (when "*FILE"
										// is the type of data and the length is needed--
										// e.g., a root file).  For SSPEC_HARDLINK, contains the sspec index
                              // number of a http_flashspec or server_spec entry.
   char* format;					// sprintf() format for a variable, or form title for a form,
   									// or base address for SSPEC_ROOTFILE.  For SSPEC_LINK, points to a
                              // string containing the linked-to resource name.
   ServerPermissions perm;		// Permissions associated with this resource.  If NULL, then the
   									// permissions table is consulted as for filesystem resources.
                              // Note: this field used to be char* for the realm string.  Programs
                              // which used this feature will need to be modified.

#ifdef FORM_ERROR_BUF
	int highvar;					// Next index into FormVar array to allocate
										// (when "SSPEC_FORM" is the type of data)
	void* formfunc;				// Form generation function (when "SSPEC_FORM" is
										// the type of data)
	void* preformfunc;			// Function to call just before a form is generated
										// (when "SSPEC_FORM" is the type of data)
	int formepilog;				// Form epilog function (when "SSPEC_FORM" is
										// the type of data) - index in table.
	int formprolog;				// Form prolog function (when "SSPEC_FORM" is
										// the type of data) - index in table.
#endif
} ServerSpec;

// Set the number of entries in the ServerSpec table.
// For compatibility's sake, make HTTP_MAXRAMSPEC override SSPEC_MAXSPEC.
// If a user attempts to use both HTTP_MAXRAMSPEC and SSPEC_MAXSPEC, she may
// not get the desired results.  Hence, use of HTTP_MAXRAMSPEC should probably
// be deprecated.
#ifdef HTTP_MAXRAMSPEC
	#define SSPEC_MAXSPEC HTTP_MAXRAMSPEC
#endif
#ifndef SSPEC_MAXSPEC
	#define SSPEC_MAXSPEC	10
#endif

// The global ServerSpec structure
ServerSpec server_spec[SSPEC_MAXSPEC];

#define SSPEC_RESOURCETABLE_START const ServerSpec http_flashspec[] = {
#define SSPEC_RESOURCE_ROOTFILE(name, addr, len) { SSPEC_ROOTFILE, name, 0L, NULL, len, (char *)addr }
#define SSPEC_RESOURCE_XMEMFILE(name, addr) { SSPEC_XMEMFILE, name, (long)addr }
#define SSPEC_RESOURCE_ZMEMFILE(name, addr) { SSPEC_ZMEMFILE, name, (long)addr }
#define SSPEC_RESOURCE_FSFILE(name, fnum) { SSPEC_FSFILE, name, (long)fnum }
#define SSPEC_RESOURCE_ROOTVAR(name, addr, type, format) { SSPEC_ROOTVAR, name, 0L, addr, type, format }
#define SSPEC_RESOURCE_XMEMVAR(name, addr, type, format) { SSPEC_XMEMVAR, name, addr, NULL, type, format }
#define SSPEC_RESOURCE_FUNCTION(name, addr) { SSPEC_FUNCTION, name, 0L, addr }
#define SSPEC_RESOURCE_CGI(name, addr) { SSPEC_CGI, name, 0L, addr }
#define SSPEC_RESOURCE_P_ROOTFILE(name, addr, len, realm, rg, wg, sm, meth) \
	 { SSPEC_ROOTFILE, name, 0L, NULL, len, (char *)addr, {realm, rg, wg, sm, meth} }
#define SSPEC_RESOURCE_P_XMEMFILE(name, addr, realm, rg, wg, sm, meth) \
	{ SSPEC_XMEMFILE, name, (long)addr, NULL, 0, NULL, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCE_P_ZMEMFILE(name, addr, realm, rg, wg, sm, meth) \
	{ SSPEC_ZMEMFILE, name, (long)addr, NULL, 0, NULL, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCE_P_FSFILE(name, fnum, realm, rg, wg, sm, meth) \
	{ SSPEC_FSFILE, name, (long)fnum, NULL, 0, NULL, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCE_P_ROOTVAR(name, addr, type, format, realm, rg, wg, sm, meth) \
	{ SSPEC_ROOTVAR, name, 0L, addr, type, format, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCE_P_XMEMVAR(name, addr, type, format, realm, rg, wg, sm, meth) \
	{ SSPEC_XMEMVAR, name, addr, NULL, type, format, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCE_P_FUNCTION(name, addr, realm, rg, wg, sm, meth) \
	{ SSPEC_FUNCTION, name, 0L, addr, 0, NULL, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCE_P_CGI(name, addr, realm, rg, wg, sm, meth) \
	{ SSPEC_CGI, name, 0L, addr, 0, NULL, {realm, rg, wg, sm, meth}  }
#define SSPEC_RESOURCETABLE_END };




// Macros for dealing with sspec index numbers
#ifndef SSPEC_NO_STATIC
	#define SSPEC_END_OF_FLASH  (sizeof(http_flashspec)/sizeof(http_flashspec[0]))
	#define SSPEC_IS_FLASH(s) ((word)(s) < SSPEC_END_OF_FLASH)
	#define SSPEC_END_OF_RAM  (512+SSPEC_MAXSPEC)
	#define SSPEC_IS_RAM(s)   ((word)(s) >= 512 && (word)(s) < SSPEC_END_OF_RAM)
	#define SSPEC_RAM_INDEX(s)   ((s) - 512)
	#define SSPEC_RAM_HANDLE(idx)   ((idx) + 512)
	#define SSPEC_FLASH_INDEX(s) (s)
	#define SSPEC_FLASH_HANDLE(idx) (idx)
#else
	#define SSPEC_END_OF_FLASH  (-1)
	#define SSPEC_IS_FLASH(s) 0
	#define SSPEC_END_OF_RAM  SSPEC_MAXSPEC
	#define SSPEC_IS_RAM(s)   ((word)(s) < SSPEC_END_OF_RAM)
	#define SSPEC_RAM_INDEX(s)   (s)
	#define SSPEC_RAM_HANDLE(idx)   (idx)
	#define SSPEC_FLASH_INDEX(s) (-1)
	#define SSPEC_FLASH_HANDLE(idx) (-1)
#endif
#define SSPEC_IS_VIRT(s)  ((word)(s) >= 1024)

#define SSPEC_VIRTUAL	32767		// This is a special handle which means that the resource is
											// in the virtual filesystem, but no specific handle has been
                                 // allocated.  Returned by some functions which can return any
                                 // type of handle, but the function does not actually allocate
                                 // the necessary persistent state information.  It is generally
                                 // an error to pass this handle to another function.


//
// ServerAuth structure.  One entry for every individual user.
//

// Maximum length of strings in ServerAuth structure
#ifndef SAUTH_MAXNAME
	#define SAUTH_MAXNAME	20
#endif

typedef struct
{
	char username[SAUTH_MAXNAME];		// Name of user, or ""
	char password[SAUTH_MAXNAME];		// Password for user, or ""
   word mask;								// Mask bits.  Identifies which group(s) this user belongs
   											// to - corresponding bits in ServerPermissions readgroups/
                                    // writegroups must match at least one bit.
	word writeaccess;						// Defines if user has write access in general for the corresponding
   											// server bit(s).
	word servermask;						// A bitmask that determines which servers
												// a ServerAuth is used for--servers are
												// disabled by default
   void * data;				  			// Other authentication data (e.g. for SSL).
} ServerAuth;

// Maximum number of users.  This is limited only by memory constraints; however there
// are a maximum of 16 distinct "groups" with which permissions for each resource are
// associated.  Each user may be a member of zero or more groups.
#ifndef SAUTH_MAXUSERS
	#define SAUTH_MAXUSERS	4
#endif

// The global server_auth structure i.e. table of user IDs.
ServerAuth server_auth[SAUTH_MAXUSERS];

#ifndef SSPEC_XMEMVARLEN
	#define SSPEC_XMEMVARLEN 20
#endif

// The FormVar structure, which holds a list of variables to be used in a form
#define HTML_FORM_TEXT 		1
#define HTML_FORM_PULLDOWN	2
typedef struct
{
	int varspec;		// server_spec index that represents the variable
	long int high;		// Highest value (long int) allowed
	long int low;		// Lowest value (long int) allowed
	float fhigh;		// Highest value (float) allowed
	float flow;			// Lowest value (float) allowed
	byte rangeset;		// Is the range set?
	int varlen;			// Length of string (when a string is represented), or
							// length of string representation (to limit form text
							// field size)
	const char **values;		// Pointer to list of values a string variable can take
	int valueslen;		// Length of values array
	int (*varcheck)();	// Function pointer to variable integrity check function
	char *name;			// Name to display for the variable in the form (if not
							// set, defaults to the name for the server_spec entry
							// for the variable)
	char *desc;			// Description of form variable
	int entrytype;		// Type of HTML form element for this variable (defaults
							// to HTML_FORM_TEXT)
	byte readonly;		// Indicates if the variable is read-only
} FormVar;


// Also define seek whence parm values
#ifndef SEEK_SET
	#define SEEK_SET     0
	#define SEEK_CUR     1
	#define SEEK_END     2
#endif

#include <errno.h>

#ifdef __FAT16_LIB
	#define SSPEC_USEFAT
   #ifndef FAT_BLOCK
   	#error "ZSERVER.LIB does not currently support non-blocking FAT."
      #fatal "Please #define FAT_BLOCK at the top of your application."
   #endif

   // This struct is passed to the sspec_automount() function in order to return FAT
   // information to the caller.
	typedef struct {
	   mbr_drvr * driver;
	   mbr_dev * dev;
	   fat_part * part[4];
	} sspec_fatinfo;
#else
	// Dummy version of the above if not using FAT.
	typedef struct {
	   void * dummy[6];
	} sspec_fatinfo;
#endif

// Application defines this to enable /dev filesystem.  This is not yet officially supported but
// some code is in place if you want to use it at your own risk.  Note: the /dev filesystem allows
// arbitrary "devices" to be accessed as zserver resources.  All such devices live under the /dev
// mount point.  Each different device needs to be registered using sspec_devregister().  The registration
// function associates a name with a particular device (as specified by a list of function pointers).
// For example, /dev/mem may refer to a device which allows reading the processor address space.
// /dev/mem.5.24 refers to the same device, but (when opening) allows up to 2 byte parameters
// to be specified.  The meaning of the parameters is up to the device driver.
//#define SSPEC_USEDEV

// Write number for the saved server_spec file
unsigned long sspec_writenum;
unsigned long sspec_version;
char* _sspec_data_ptr;
unsigned long _sspec_data_len;
void (*_sspec_data_fptr)();


// V1: original
// V2: enhanced
#define SSPEC_VERSION 2

// Pools for allocation of large structures (such as FAT file access)
#ifndef SSPEC_MAX_OPEN
	#define SSPEC_MAX_OPEN 4	// Max resources open simultaneously - used for File structs etc.
#endif

#ifndef SSPEC_MAXDEVDATA
	#define SSPEC_MAXDEVDATA	1
#endif

typedef union
{
		int dummy;
#ifdef __ZIMPORT_LIB
		ZFILE zfile;			// File handle for a compressed file
#endif
#ifdef SSPEC_USEFAT
		FATfile  fatfile;	// File for DOS FAT file
#endif
#ifdef SSPEC_USEDEV
		struct {
			SSpecDevEntry * sde;	// Device info
         char	state[SSPEC_MAXDEVDATA];	// Device state/data
      } devdata;
#endif
} SSpecFileUnion;

typedef struct SSpecFileHandle_t
{
	int sspec;			// Sspec handle of the open file
	long offset;		// Number of characters into the read process, also state variable for dir listings.
   const struct SSpecVTable_t * vt;	// Function pointers to access methods
	SSpecFileUnion * u;	// Pointer to appropriate file accessor struct.  These come out of a
   							// dynamic pool.
	ServerSpec * realspec;	// This is non-NULL if the handle refers to a flash or RAM spec entry.
   								// If NULL, it is a virtual entry in one of the filesystems.
                           // It MUST be non-NULL for ram or xmem files.
	const ServerPermissions * perm;	// Permissions etc.
	void * data;		// Data private to application/interpreter.
} SSpecFileHandle;

struct SSpecStat_t;

#define SSPEC_OPEN_PARMS \
  SSpecFileHandle * sfh, const char __far * path, word partition, word mode
#define SSPEC_CLOSE_PARMS \
  SSpecFileHandle * sfh
#define SSPEC_CREATE_PARMS \
  const char __far * path, word partition, long alloc
#define SSPEC_EXISTS_PARMS \
  const char __far * path, word partition
#define SSPEC_DELETE_PARMS \
  const char __far * path, word partition
#define SSPEC_LENGTH_PARMS \
  const char __far * path, word partition
#define SSPEC_MAXLEN_PARMS \
  const char __far * path, word partition
#define SSPEC_SEEK_PARMS \
  SSpecFileHandle * sfh, long offset, int whence
#define SSPEC_TELL_PARMS \
  SSpecFileHandle * sfh
#define SSPEC_READ_PARMS \
  SSpecFileHandle * sfh, char __far * buf, int len
#define SSPEC_READREF_PARMS \
  SSpecFileHandle * sfh, long * xptr, long * lenptr
#define SSPEC_WRITE_PARMS \
  SSpecFileHandle * sfh, char __far * buf, int len
#define SSPEC_EXTENSIBLE_PARMS \
  const char __far * path, word partition
#define SSPEC_STAT_PARMS \
  const char __far * path, word partition, struct SSpecStat_t * stat
#define SSPEC_DEXISTS_PARMS \
  const char __far * path, word partition
#define SSPEC_OPENDIR_PARMS \
  SSpecFileHandle * sfh, const char __far * path, word partition
#define SSPEC_NEXTDIR_PARMS \
  SSpecFileHandle * sfh, struct SSpecStat_t * stat, char __far * buf
#define SSPEC_CLOSEDIR_PARMS \
  SSpecFileHandle * sfh
#define SSPEC_MKDIR_PARMS \
  const char __far * path, word partition
#define SSPEC_RMDIR_PARMS \
  const char __far * path, word partition

// This struct contains pointers to functions which are implemented by the
// particular filesystem/device.  We use this to avoid having a ton of switch
// statements (and conditional compilation) in the zserver code.  Most of the
// function pointers are optional.  They should be set to NULL if the operation
// is not implemented or required for the particular filesystem.
// Return value conventions:
// .  If the return value is an 'int', then the function should return 0 for
//    success, or otherwise return the negative of one of the error codes in
//    ERRNO.H.
// .  If the return value is long, the returned value is the desired result
//    of the method.
// Parameter conventions:
// .  See the SSPEC_**_DECL macros below.
// .  The methods are divided into two categories: those which take a
//    path/partition, and those which take a pointer to a SSpecFileHandle.
//    The former act on absolute path names in the given partition (for
//    multi-partition filesystems), and the latter act only on files which have
//    been opened via sspec_open().
// Note: these methods should only be called by the zserver library.  The
// server ("application") does not call them directly, but rather via the
// sspec_* functions.
typedef struct SSpecVTable_t
{
	int  (*open)(SSPEC_OPEN_PARMS);		// Open a resource if necessary.  NULL if access can
   							//   be performed in stateless manner.
	int  (*close)(SSPEC_CLOSE_PARMS);		// Close if necessary.  If 'open' is not null, this
                        //   should not be null
	int  (*create)(SSPEC_CREATE_PARMS); 	// Create resource by name if possible.  NULL if
                        //   cannot create new files.
	int  (*exists)(SSPEC_EXISTS_PARMS); 	// Test if resource name exists.  If 'create' or
   							//   'delete' are not NULL, then this must not be NULL.
   int  (*delete)(SSPEC_DELETE_PARMS); 	// Delete resource by name. NULL if can't delete files.
	long (*length)(SSPEC_LENGTH_PARMS); 	// Return current length. NULL if can't be determined.
	long (*maxlen)(SSPEC_MAXLEN_PARMS); 	// Return max permissible length.  NULL if unlimited.
	int  (*seek)(SSPEC_SEEK_PARMS);		// Seek to new offset.  NULL if not seekable
	long (*tell)(SSPEC_TELL_PARMS);		// Return current offset.  NULL if not tellable --
   							//   zserver keeps track of the current offset in all
                        //   cases except where a seek(..,SEEK_END) is
                        //   performed and there is no 'length' method.  In
                        //   such cases, tell must not be NULL or the current
                        //   offset will become undefined.
	int  (*read)(SSPEC_READ_PARMS);		// Read next into far buffer.  Must not be NULL.
	int  (*readref)(SSPEC_READREF_PARMS);	// Read next, returning reference to xmem area managed
   							//  by filesystem. If NULL, then read-by-reference not
                        //  available.  This is not yet implemented, but is
                        //  reserved for future efficiency enhancements.
	int  (*write)(SSPEC_WRITE_PARMS);		// Write next from root buffer. NULL if this filesystem
   							//   is read-only.
	int  (*extensible)(SSPEC_EXTENSIBLE_PARMS); // Return whether resource may be appended to.  If
   							 //  NULL, assumed to be non-extensible.
	int  (*stat)(SSPEC_STAT_PARMS);		// Return modification date/time stamp, ownership and
   							//   attribute bits. This must not be NULL.
	int  (*dexists)(SSPEC_DEXISTS_PARMS);	// Test if resource directory exists.  NULL if
   							//   filesystem does not support subdirectories.
	int  (*opendir)(SSPEC_OPENDIR_PARMS);	// Open directory for listing, NULL if no inherent
   							//   directory support.
	int  (*nextdir)(SSPEC_NEXTDIR_PARMS);	// Return next directory entry. Must not be NULL if
   							//   opendir is not NULL.
	int  (*closedir)(SSPEC_CLOSEDIR_PARMS);	// Close directory listing resource. NULL if stateless
   							//   listing.
	int  (*mkdir)(SSPEC_MKDIR_PARMS);		// Create new directory. NULL if cannot do for this FS.
	int  (*rmdir)(SSPEC_RMDIR_PARMS);		// Delete directory. NULL if cannot do for this FS.
} SSpecVTable;

#define SSPEC_OPEN_DECL(name) \
  int name(SSPEC_OPEN_PARMS)
#define SSPEC_CLOSE_DECL(name) \
  int name(SSPEC_CLOSE_PARMS)
#define SSPEC_CREATE_DECL(name) \
  int name(SSPEC_CREATE_PARMS)
#define SSPEC_EXISTS_DECL(name) \
  int name(SSPEC_EXISTS_PARMS)
#define SSPEC_DELETE_DECL(name) \
  int name(SSPEC_DELETE_PARMS)
#define SSPEC_LENGTH_DECL(name) \
  long name(SSPEC_LENGTH_PARMS)
#define SSPEC_MAXLEN_DECL(name) \
  long name(SSPEC_MAXLEN_PARMS)
#define SSPEC_SEEK_DECL(name) \
  int name(SSPEC_SEEK_PARMS)
#define SSPEC_TELL_DECL(name) \
  long name(SSPEC_TELL_PARMS)
#define SSPEC_READ_DECL(name) \
  int name(SSPEC_READ_PARMS)
#define SSPEC_READREF_DECL(name) \
  int name(SSPEC_READREF_PARMS)
#define SSPEC_WRITE_DECL(name) \
  int name(SSPEC_WRITE_PARMS)
#define SSPEC_EXTENSIBLE_DECL(name) \
  int name(SSPEC_EXTENSIBLE_PARMS)
#define SSPEC_STAT_DECL(name) \
  int name(SSPEC_STAT_PARMS)
#define SSPEC_DEXISTS_DECL(name) \
  int name(SSPEC_DEXISTS_PARMS)
#define SSPEC_OPENDIR_DECL(name) \
  int name(SSPEC_OPENDIR_PARMS)
#define SSPEC_NEXTDIR_DECL(name) \
  int name(SSPEC_NEXTDIR_PARMS)
#define SSPEC_CLOSEDIR_DECL(name) \
  int name(SSPEC_CLOSEDIR_PARMS)
#define SSPEC_MKDIR_DECL(name) \
  int name(SSPEC_MKDIR_PARMS)
#define SSPEC_RMDIR_DECL(name) \
  int name(SSPEC_RMDIR_PARMS)


#define SSPEC_OPEN_DEF(name) _zserver_nodebug SSPEC_OPEN_DECL(name)
#define SSPEC_CLOSE_DEF(name) _zserver_nodebug SSPEC_CLOSE_DECL(name)
#define SSPEC_CREATE_DEF(name) _zserver_nodebug SSPEC_CREATE_DECL(name)
#define SSPEC_EXISTS_DEF(name) _zserver_nodebug SSPEC_EXISTS_DECL(name)
#define SSPEC_DELETE_DEF(name) _zserver_nodebug SSPEC_DELETE_DECL(name)
#define SSPEC_LENGTH_DEF(name) _zserver_nodebug SSPEC_LENGTH_DECL(name)
#define SSPEC_MAXLEN_DEF(name) _zserver_nodebug SSPEC_MAXLEN_DECL(name)
#define SSPEC_SEEK_DEF(name) _zserver_nodebug SSPEC_SEEK_DECL(name)
#define SSPEC_TELL_DEF(name) _zserver_nodebug SSPEC_TELL_DECL(name)
#define SSPEC_READ_DEF(name) _zserver_nodebug SSPEC_READ_DECL(name)
#define SSPEC_READREF_DEF(name) _zserver_nodebug SSPEC_READREF_DECL(name)
#define SSPEC_WRITE_DEF(name) _zserver_nodebug SSPEC_WRITE_DECL(name)
#define SSPEC_EXTENSIBLE_DEF(name) _zserver_nodebug SSPEC_EXTENSIBLE_DECL(name)
#define SSPEC_STAT_DEF(name) _zserver_nodebug SSPEC_STAT_DECL(name)
#define SSPEC_DEXISTS_DEF(name) _zserver_nodebug SSPEC_DEXISTS_DECL(name)
#define SSPEC_OPENDIR_DEF(name) _zserver_nodebug SSPEC_OPENDIR_DECL(name)
#define SSPEC_NEXTDIR_DEF(name) _zserver_nodebug SSPEC_NEXTDIR_DECL(name)
#define SSPEC_CLOSEDIR_DEF(name) _zserver_nodebug SSPEC_CLOSEDIR_DECL(name)
#define SSPEC_MKDIR_DEF(name) _zserver_nodebug SSPEC_MKDIR_DECL(name)
#define SSPEC_RMDIR_DEF(name) _zserver_nodebug SSPEC_RMDIR_DECL(name)

// Opening modes
#define O_READ		0x0001	// Always valid.
#define O_WRITE	0x0002	// Valid if resource has a 'write' method
	// the following only used by sspec_open, not interpreted by access methods.
#define O_CREAT	0x0004	// Valid if resource has all of 'write', 'delete', 'exists' and 'create'.
#define O_CREATE	O_CREAT	// Alias for the typographically challenged
#define O_TRUNC	0x0008	// Valid under same conditions as O_CREAT
#define O_APPEND	0x0010	// Valid if resource has 'write' and 'seek'.

#ifdef SSPEC_USEDEV
typedef struct {
	char * name;				// 11 chars or less, null terminated.  Base name in /dev/
   const SSpecVTable * vt;				// Device implementation
   const ServerPermissions * perm;	// Access permissions
	void * data;				// Application data.
} SSpecDevEntry;
#endif

extern const SSpecVTable _sspec_generic;
extern const SSpecVTable _sspec_rvt;
extern const SSpecVTable _sspec_xvt;
#ifdef __ZIMPORT_LIB
extern const SSpecVTable _sspec_zvt;
#endif
#ifdef SSPEC_USEFAT
	#ifndef SSPEC_MAX_FATDEVS
	   #define SSPEC_MAX_FATDEVS   1
	#endif
	#define SSPEC_MAX_PARTITIONS (SSPEC_MAX_FATDEVS*4)
	extern const SSpecVTable _sspec_fatvt;
	extern fat_part * _sspec_fatparts[SSPEC_MAX_PARTITIONS];
#endif
#ifdef SSPEC_USEDEV
	#ifndef SSPEC_MAXDEV
   	#define SSPEC_MAXDEV		2
   #endif
	extern SSpecDevEntry _sspec_devtable[SSPEC_MAXDEV];
   extern word _sspec_numdev;
#endif


SSpecFileUnion _sfustore[SSPEC_MAX_OPEN];	// Allocation pool root storage
Pool_t _sfup;										// Pool to allocate the above
SSpecFileHandle _sfhstore[SSPEC_MAX_OPEN];	// Allocation pool root storage
Pool_t _sfhp;										// Pool to allocate the above
int _sspec_nexthandle;							// Counter for virtual handle uniqueness



// Structure filled in by "stat" call.  This struct is documented with the sspec_stat() function.
typedef struct SSpecStat_t
{
	word		flags;
#define SSPEC_ATTR_MDTM		0x0001		// Have modification date/time
#define SSPEC_ATTR_LENGTH	0x0002		// Have current length
#define SSPEC_ATTR_WRITE	0x0004		// File is writable
#define SSPEC_ATTR_EXEC		0x0008		// File is "executable"
#define SSPEC_ATTR_HIDDEN	0x0010		// "Hidden" attribute bit
#define SSPEC_ATTR_SYSTEM	0x0020		// "System" attribute bit
#define SSPEC_ATTR_ARCHIVE	0x0040		// "Archive" attribute bit
#define SSPEC_ATTR_DIR		0x0080		// This is directory name
#define SSPEC_ATTR_COMPRESSED	0x0100	// File stored in compressed format
#define SSPEC_ATTR_MAXLENGTH	0x0200	// Have maximum length
#define SSPEC_ATTR_SEEKABLE	0x0400	// Resource is randomly accessible
#define SSPEC_ATTR_EXTENSIBLE	0x0800	// File may be expanded at end

	long		mdtm;				// Modification date/time (SEC_TIMER format)
	long		length;			// Current file size
	long		maxlength;		// Maximum allowable file size
	const ServerPermissions *
   			perm;				// Access (groups and server)
} SSpecStat;


// Struct passed by servers to new API functions.  Typically, servers extend this struct
// by including it as the first field of their own struct, then adding other fields
// as required.  The resulting struct is cast back to ServerContext for use by zserver APIs.
typedef struct ServerContext_t
{
	// Public fields for use by servers and zserver
	int		userid;				// Current user ID (-1 if none)
   word		server;				// Mask bit of this server
   char *	rootdir;				// "Root directory", or NULL for default root.
   char		cwd[SSPEC_MAXNAME+1];	// Current working directory.  This must include the
   											// root directory, if any, as a prefix.  Null terminated.
	char *	dfltname;			// Default file name to append if attempt to open a directory.
   									// e.g. this would be "index.html" for web server.
	struct SSpecFileHandle_t * dirlist;
	                           // File handle for directory listing.  This is used by zserver internally
   									// for remembering state during a directory list sequence.  Should not be
                              // touched by application during such a sequence.
	// Private fields for zserver only. (None as yet)
} ServerContext;


/*** EndHeader */

const SSpecVTable _sspec_generic = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	sspec_gendexists,
	sspec_genopendir,
	sspec_gennextdir,
	NULL,
	NULL,
	NULL
};
#ifndef ENABLE_DLM_TCP_SUPPORT
const SSpecVTable _sspec_rvt = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	sspec_rlength,
	sspec_rlength,
	sspec_rseek,
	NULL,
	sspec_rread,
	sspec_rreadref,
	NULL,
	sspec_rextensible,
	sspec_rstat,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};
const SSpecVTable _sspec_xvt = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	sspec_xlength,
	sspec_xlength,
	sspec_xseek,
   NULL,
	sspec_xread,
	sspec_xreadref,
	NULL,
	sspec_xextensible,
	sspec_xstat,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};
#else	// ENABLE_DLM_TCP_SUPPORT
const SSpecVTable _sspec_rvt = {
	NULL,
	NULL,
	sspec_rcreate,
	NULL,
	sspec_rdelete,
	sspec_rlength,
	sspec_rlength,
	sspec_rseek,
	NULL,
	sspec_rread,
	sspec_rreadref,
	sspec_rwrite,
	sspec_rextensible,
	sspec_rstat,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};
const SSpecVTable _sspec_xvt = {
	NULL,
	NULL,
	sspec_xcreate,
	NULL,
	sspec_xdelete,
	sspec_xlength,
	sspec_xlength,
	sspec_xseek,
   NULL,
	sspec_xread,
	sspec_xreadref,
	sspec_xwrite,
	sspec_xextensible,
	sspec_xstat,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};
#endif	// ENABLE_DLM_TCP_SUPPORT
#ifdef __ZIMPORT_LIB
const SSpecVTable _sspec_zvt = {
	sspec_zopen,
	sspec_zclose,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	sspec_zread,
	NULL,
	NULL,
	sspec_zextensible,
	sspec_zstat,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};
#endif
#ifdef SSPEC_USEFAT
const SSpecVTable _sspec_fatvt = {
	sspec_fatopen,
	sspec_fatclose,
	#ifdef FAT_WRITEACCESS
	sspec_fatcreate,
   #else
   NULL,
   #endif
	sspec_fatexists,
	#ifdef FAT_WRITEACCESS
	sspec_fatdelete,
   #else
   NULL,
   #endif
	sspec_fatlength,
	NULL,
	sspec_fatseek,
	sspec_fattell,
	sspec_fatread,
	NULL,
	#ifdef FAT_WRITEACCESS
	sspec_fatwrite,
   #else
   NULL,
   #endif
	sspec_fatextensible,
	sspec_fatstat,
	sspec_fatdexists,
	sspec_fatopendir,
	sspec_fatnextdir,
	sspec_fatclosedir,
#ifdef FAT_WRITEACCESS
   sspec_fatmkdir,
   sspec_fatrmdir
#else
	NULL,
   NULL
#endif
};

// Also, for FAT need to cache the partition pointers
fat_part * _sspec_fatparts[SSPEC_MAX_PARTITIONS];	// Pointer will be NULL if no accessible partition.
#endif

#ifdef SSPEC_USEDEV
SSpecDevEntry _sspec_devtable[SSPEC_MAXDEV];
word _sspec_numdev;
#endif

/*** BeginHeader sspec_gendexists */
SSPEC_DEXISTS_DECL(sspec_gendexists);
SSPEC_OPENDIR_DECL(sspec_genopendir);
SSPEC_NEXTDIR_DECL(sspec_gennextdir);
/*** EndHeader */
SSPEC_DEXISTS_DEF(sspec_gendexists) {
	return !strcmp(path, "/");	// Only root dir exists as far as generic system concerned.
}


#ifdef SSPEC_USEFAT
_zserver_nodebug void sspec_fatnextpart(SSpecFileHandle * sfh, int i)
{
   while (++i < SSPEC_MAX_PARTITIONS && !_sspec_fatparts[i]);
   if (i < SSPEC_MAX_PARTITIONS)
      sfh->offset = 2049 + i;
   else
   #ifdef SSPEC_USEDEV
      sfh->offset = 4097;
   #else
      sfh->offset = -1;
   #endif
}
#endif

SSPEC_OPENDIR_DEF(sspec_genopendir) {
	auto int sspec;

   sspec = sspec_nexthandle(-1);	// Get first ram or flash spec entry
   if (sspec < 0) {
   	// None of either - start with mount points
      #ifdef SSPEC_USEFAT
      sspec_fatnextpart(sfh, -1);   // Start FAT dir list
      #else
         #ifdef SSPEC_USEDEV
      sfh->offset = 4097;
         #else
      sfh->offset = -1;    // End
         #endif
      #endif
   }
   else {
   	sfh->realspec = sspec_nvhandle(sspec);
		sfh->offset = sspec + 1;
   }
   if (sfh->offset >= 0)
   	return 0;
   else
   	return -EEOF;
}

SSPEC_NEXTDIR_DEF(sspec_gennextdir) {
	auto int i, sspec;
   auto ServerSpec * ssp;

   i = (int)sfh->offset - 1;
   if (i < 0)
   	return -EEOF;
   stat->flags = SSPEC_ATTR_DIR;
   ++sfh->offset;
   // List ram, flash, fs2, fat and dev entries in that order
   ssp = NULL;
   if (i < 1024) {
		ssp = sspec_nvhandle(sspec = i);
      sfh->realspec = ssp;
      i = sspec_nexthandle(i);
      sfh->offset = i+1;
      if (i < 0) {
      	#ifdef SSPEC_USEFAT
			sspec_fatnextpart(sfh, -1);
         #else
         	#ifdef SSPEC_USEDEV
         sfh->offset = 4097;
         	#else
         sfh->offset = -1;		// End
         	#endif
         #endif
      }
		// ssp points to flash or ram spec entry.  This is a 'file' even though
      // the file name may contain slashes.
      _f_strncpy(buf, ssp->name, sizeof(ssp->name));
      buf[sizeof(ssp->name)] = 0;
      stat->flags = 0;
      stat->length = sspec_getlength(sspec);
      if (stat->length > 0)
      	stat->flags |= SSPEC_ATTR_LENGTH;
      if (ssp->type == SSPEC_ZMEMFILE)
      	stat->flags |= SSPEC_ATTR_COMPRESSED;
   }
#ifdef SSPEC_USEFAT
   else if (i >= 2048 && i < 2048 + SSPEC_MAX_PARTITIONS) {
		i -= 2048;
     	buf[0] = 'A' + i;
      buf[1] = 0;
		sspec_fatnextpart(sfh, i);
   }
#endif
#ifdef SSPEC_USEDEV
	else if (i == 4096) {
   	strcpy(buf, "dev");
		sfh->offset = -1;
   }
#endif
	else
   	sfh->offset = -1;
   return 0;
}


/*** BeginHeader sspec_rlength */
#ifdef ENABLE_DLM_TCP_SUPPORT
SSPEC_CREATE_DECL(sspec_rcreate);
SSPEC_DELETE_DECL(sspec_rdelete);
SSPEC_WRITE_DECL(sspec_rwrite);
#endif
SSPEC_LENGTH_DECL(sspec_rlength);
SSPEC_SEEK_DECL(sspec_rseek);
SSPEC_READ_DECL(sspec_rread);
SSPEC_READREF_DECL(sspec_rreadref);
SSPEC_EXTENSIBLE_DECL(sspec_rextensible);
SSPEC_STAT_DECL(sspec_rstat);
/*** EndHeader */

#ifdef ENABLE_DLM_TCP_SUPPORT
SSPEC_CREATE_DEF(sspec_rcreate) {
	return 0;
}

SSPEC_DELETE_DEF(sspec_rdelete) {
	return 0;
}

SSPEC_WRITE_DEF(sspec_rwrite) {
	return len;
}
#endif

SSPEC_LENGTH_DEF(sspec_rlength) {
	return partition;
}

SSPEC_SEEK_DEF(sspec_rseek) {
	auto int len;

   len = sfh->realspec->vartype;
	switch (whence) {
   case SEEK_SET:
		sfh->offset = offset;
   	break;
   case SEEK_CUR:
   	sfh->offset += offset;
      break;
   case SEEK_END:
   	sfh->offset = len + offset;
      break;
   }
   if (sfh->offset < 0)
   	sfh->offset = 0;
   else if (sfh->offset > len)
   	sfh->offset = len;
	return 0;
}

SSPEC_READ_DEF(sspec_rread) {
	auto int sz, rem;
   auto char * base;

   sz = sfh->realspec->vartype;
   base = sfh->realspec->format;
   if (!len)
   	return sfh->offset < sz;
	if (len > (rem = (int)(sz - sfh->offset)))
   	len = rem;
   if (buf)
   	_f_memcpy(buf, base + (int)sfh->offset, len);
	return len;
}

SSPEC_READREF_DEF(sspec_rreadref) {
   *xptr = paddr(sfh->realspec->format + (int)sfh->offset);
	*lenptr = sfh->realspec->vartype - sfh->offset;
	return 0;
}

SSPEC_EXTENSIBLE_DEF(sspec_rextensible) {
	return 0;
}

SSPEC_STAT_DEF(sspec_rstat) {
	stat->flags = SSPEC_ATTR_LENGTH | SSPEC_ATTR_SEEKABLE;
   stat->length = partition;
	return 0;
}

/*** BeginHeader sspec_xlength */
#ifdef ENABLE_DLM_TCP_SUPPORT
SSPEC_CREATE_DECL(sspec_xcreate);
SSPEC_DELETE_DECL(sspec_xdelete);
SSPEC_WRITE_DECL(sspec_xwrite);
#endif
SSPEC_LENGTH_DECL(sspec_xlength);
SSPEC_SEEK_DECL(sspec_xseek);
SSPEC_READ_DECL(sspec_xread);
SSPEC_READREF_DECL(sspec_xreadref);
SSPEC_EXTENSIBLE_DECL(sspec_xextensible);
SSPEC_STAT_DECL(sspec_xstat);
/*** EndHeader */

#ifdef ENABLE_DLM_TCP_SUPPORT
SSPEC_CREATE_DEF(sspec_xcreate) {
	return 0;
}

SSPEC_DELETE_DEF(sspec_xdelete) {
	return 0;
}

SSPEC_WRITE_DEF(sspec_xwrite) {
	return len;
}
#endif

SSPEC_LENGTH_DEF(sspec_xlength) {
#ifdef __ZIMPORT_LIB
	return xgetlong(*(long __far *)path) & ZIMPORT_MASK;
#else
	return xgetlong(*(long __far *)path);
#endif
}

SSPEC_SEEK_DEF(sspec_xseek) {
	auto long len;

#ifdef __ZIMPORT_LIB
   len = xgetlong(sfh->realspec->data) & ZIMPORT_MASK;
#else
   len = xgetlong(sfh->realspec->data);
#endif
	switch (whence) {
   case SEEK_SET:
		sfh->offset = offset;
   	break;
   case SEEK_CUR:
   	sfh->offset += offset;
      break;
   case SEEK_END:
   	sfh->offset = len + offset;
      break;
   }
   if (sfh->offset < 0)
   	sfh->offset = 0;
   else if (sfh->offset > len)
   	sfh->offset = len;
	return 0;
}

SSPEC_READ_DEF(sspec_xread) {
	auto long sz, rem;
   auto long base;

   base = sfh->realspec->data;
#ifdef __ZIMPORT_LIB
   sz = xgetlong(base) & ZIMPORT_MASK;
#else
   sz = xgetlong(base);
#endif
   if (!len)
   	return sfh->offset < sz;
	if ((long)len > (rem = sz - sfh->offset))
   	len = (int)rem;
   if (buf)
   	_f_memcpy(buf, (char __far *)base + sfh->offset + 4, len);
	return len;
}

SSPEC_READREF_DEF(sspec_xreadref) {
	auto long sz;
   auto long base;

   base = sfh->realspec->data;
#ifdef __ZIMPORT_LIB
   sz = xgetlong(base) & ZIMPORT_MASK;
#else
   sz = xgetlong(base);
#endif
   *xptr = sfh->realspec->data + sfh->offset + 4;
	*lenptr = sz - sfh->offset;
	return 0;
}

SSPEC_EXTENSIBLE_DEF(sspec_xextensible) {
	return 0;
}

SSPEC_STAT_DEF(sspec_xstat) {
	stat->flags = SSPEC_ATTR_LENGTH | SSPEC_ATTR_SEEKABLE;
#ifdef __ZIMPORT_LIB
   stat->length = xgetlong(*(long __far *)path) & ZIMPORT_MASK;
#else
   stat->length = xgetlong(*(long __far *)path);
#endif
	return 0;
}

/*** BeginHeader sspec_zopen */
SSPEC_OPEN_DECL(sspec_zopen);
SSPEC_CLOSE_DECL(sspec_zclose);
SSPEC_READ_DECL(sspec_zread);
SSPEC_EXTENSIBLE_DECL(sspec_zextensible);
SSPEC_STAT_DECL(sspec_zstat);
/*** EndHeader */
SSPEC_OPEN_DEF(sspec_zopen) {
	if (OpenInputCompressedFile(&sfh->u->zfile, *(long __far *)path))
		return 0;
   return -EIO;
}

SSPEC_CLOSE_DEF(sspec_zclose) {
	CloseInputCompressedFile(&sfh->u->zfile);
	return 0;
}

SSPEC_READ_DEF(sspec_zread) {
	auto int rc;

   if (!len)
   	return sfh->u->zfile.state != LZ_RDSTATE_EOF;
   rc = ReadCompressedFile(&sfh->u->zfile, buf, len);
	return rc;
}

SSPEC_EXTENSIBLE_DEF(sspec_zextensible) {
	return 0;
}

SSPEC_STAT_DEF(sspec_zstat) {
	stat->flags = SSPEC_ATTR_COMPRESSED;
	return 0;
}




/*** BeginHeader sspec_fatregister, sspec_fatregistered, sspec_fatopen */
#ifdef SSPEC_USEFAT
int sspec_fatregister(int partno, fat_part * pt);
fat_part * sspec_fatregistered(int partno);
SSPEC_OPEN_DECL(sspec_fatopen);
SSPEC_CLOSE_DECL(sspec_fatclose);
	#ifdef FAT_WRITEACCESS
SSPEC_CREATE_DECL(sspec_fatcreate);
SSPEC_DELETE_DECL(sspec_fatdelete);
SSPEC_WRITE_DECL(sspec_fatwrite);
	#endif
SSPEC_EXISTS_DECL(sspec_fatexists);
SSPEC_LENGTH_DECL(sspec_fatlength);
SSPEC_SEEK_DECL(sspec_fatseek);
SSPEC_TELL_DECL(sspec_fattell);
SSPEC_READ_DECL(sspec_fatread);
SSPEC_EXTENSIBLE_DECL(sspec_fatextensible);
SSPEC_STAT_DECL(sspec_fatstat);
SSPEC_DEXISTS_DECL(sspec_fatdexists);
SSPEC_OPENDIR_DECL(sspec_fatopendir);
SSPEC_NEXTDIR_DECL(sspec_fatnextdir);
SSPEC_CLOSEDIR_DECL(sspec_fatclosedir);
#ifdef FAT_WRITEACCESS
SSPEC_MKDIR_DECL(sspec_fatmkdir);
SSPEC_RMDIR_DECL(sspec_fatrmdir);
#endif
#endif
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_fatregister                             <ZSERVER.LIB>

SYNTAX: int sspec_fatregister(int partno, fat_part * pt);

KEYWORDS:		tcpip, server

DESCRIPTION:   This function must be used to register all FAT partitions
               which will be accessible to zserver.lib.  Partitions are
               numbered consecutively from 0, and they correspond to
               mount points /A, /B, /C etc.

               It is assumed that, by the time this function is called,
               the required devices and partitions have been mounted.
               For example, call fat_EnumDevice() followed by as many
               fat_MountPartition() calls as required.  The fat_part
               pointer returned by fat_MountPartition() should be
               passed to this function.  Up to SSPEC_MAX_PARTITIONS
               can be registered.  This number can be changed indirectly
               by defining SSPEC_MAX_FATDEVS before #use zserver.lib.
               This defaults to one device, and the number of partitions
               is set to 4 times this number (hence the default allows
               up to four partitions).

               NOTE: it is NOT necessary to call this function if you
               called sspec_automount(SSPEC_MOUNT_FAT,...) since that
               function does all necessary initializations for a
               single "device".

PARAMETER1:		Partition number to register.  This starts at 0, corres-
               ponding to the '/A' mount point; 1 for '/B' etc.
PARAMETER2:    Pointer to fat_part data structure returned by
               fat_MountPartition etc.  To unregister a partition, pass
               NULL for this parameter.  Note: attempted access to an
               unregistered partition generally results in an error
               code of -ENXIO.

RETURN VALUE:  >=0 	OK
               -ENXIO	error: the specified partno is outside the allowable
                     range of 0..SSPEC_MAX_PARTITIONS-1.

SEE ALSO:      fat_EnumDevice, fat_EnumPartition, fat_MountPartition,
					sspec_automount, sspec_fatregistered

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_fatregister(int partno, fat_part * pt)
{
	if (partno >= 0 && partno < SSPEC_MAX_PARTITIONS)
   	_sspec_fatparts[partno] = pt;
   else
   	return -ENXIO;
   return 0;
}


/* START FUNCTION DESCRIPTION ********************************************
sspec_fatregistered                             <ZSERVER.LIB>

SYNTAX: fat_part * sspec_fatregistered(int partno);

KEYWORDS:		tcpip, server

DESCRIPTION:   Test whether a FAT partition has been registered with
               zserver.

PARAMETER1:		Partition number to test.  This starts at 0, corres-
               ponding to the '/A' mount point; 1 for '/B' etc.

RETURN VALUE:  NULL:  	   Not registered.
               Otherwise:	Registered, and this is the fat_part pointer.

SEE ALSO:      fat_EnumDevice, fat_EnumPartition, fat_MountPartition,
					sspec_automount, sspec_fatregister

END DESCRIPTION **********************************************************/

_zserver_nodebug fat_part * sspec_fatregistered(int partno)
{
	if (partno >= 0 && partno < SSPEC_MAX_PARTITIONS)
   	return _sspec_fatparts[partno];
   return NULL;
}

#ifdef FAT_BLOCK
	#define _SSPEC_BLOCK(x) return x
	#define _SSPEC_BLOCK_NORET(x) rc = x
#else
	#ifdef TCPCONFIG
		#define _SSPEC_BLOCK(x) for (rc=-EBUSY;rc==-EBUSY;tcp_tick(NULL)) rc = x; return rc
		#define _SSPEC_BLOCK_NORET(x) for (rc=-EBUSY;rc==-EBUSY;tcp_tick(NULL)) rc = x
   #else
		#define _SSPEC_BLOCK(x) for (rc=-EBUSY;rc==-EBUSY;) rc = x; return rc
		#define _SSPEC_BLOCK_NORET(x) for (rc=-EBUSY;rc==-EBUSY;) rc = x
	#endif
#endif

SSPEC_OPEN_DEF(sspec_fatopen) {
	auto char _path[256];
	auto fat_part * pt;
   auto int rc;
   //FIXME: FAT support far
   _f_strcpy(_path, path);

   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
#ifndef FAT_BLOCK
	memset(&sfh->u->fatfile, 0, sizeof(sfh->u->fatfile));
#endif
	_SSPEC_BLOCK(fat_Open(pt, _path, FAT_FILE, 0, &sfh->u->fatfile, NULL));
   //for (rc=-EBUSY;rc==-EBUSY;tcp_tick(NULL))
   //	rc = fat_Open(pt, path, FAT_FILE, 0, &sfh->u->fatfile, NULL);
   //return rc
}

SSPEC_CLOSE_DEF(sspec_fatclose) {
	auto int rc;

	//fat_SyncFile(&sfh->u->fatfile);	// Update directory length, ignore R/C.
	_SSPEC_BLOCK(fat_Close(&sfh->u->fatfile));
}

#ifdef FAT_WRITEACCESS
SSPEC_CREATE_DEF(sspec_fatcreate) {
	auto char _path[256];
	auto fat_part * pt;
	auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
	_SSPEC_BLOCK(fat_CreateFile(pt, _path, alloc, NULL));
}
#endif

SSPEC_EXISTS_DEF(sspec_fatexists) {
	auto char _path[256];
	auto fat_dirent dent;
	auto fat_part * pt;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return 0;	// No exist if unregistered partition
   _SSPEC_BLOCK_NORET(fat_Status(pt, _path, &dent));
   if (rc)
   	return 0;
   if (dent.attr & FATATTR_DIRECTORY)
   	return 0;
   return 1;
}

#ifdef FAT_WRITEACCESS
SSPEC_DELETE_DEF(sspec_fatdelete) {
	auto char _path[256];
	auto fat_part * pt;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
	_SSPEC_BLOCK(fat_Delete(pt, FAT_FILE, _path));
}
#endif

SSPEC_LENGTH_DEF(sspec_fatlength) {
	auto char _path[256];
	auto fat_dirent dent;
	auto fat_part * pt;
   auto int rc;
   auto long L;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
   _SSPEC_BLOCK_NORET(fat_Status(pt, _path, &dent));
   if (rc)
   	return rc;
   if (dent.attr & FATATTR_DIRECTORY)
   	return -EISDIR;

	return (long)dent.fileSize;
}

SSPEC_SEEK_DEF(sspec_fatseek) {
	auto int rc;
	_SSPEC_BLOCK_NORET(fat_Seek(&sfh->u->fatfile, offset, whence));
   if (rc)
   	return rc;
   return fat_Tell(&sfh->u->fatfile, (unsigned long *)&sfh->offset);
}

SSPEC_TELL_DEF(sspec_fattell) {
	auto unsigned long t;
	fat_Tell(&sfh->u->fatfile, &t);
   return t;
}

SSPEC_READ_DEF(sspec_fatread) {
	auto char _buf[256];
	auto int rc;
	//FIXME: FAT should be fixed to support far
	len = i_min(len, sizeof(_buf));
	if (!len) {
		// This is an EOF test
		return fat_Read(&sfh->u->fatfile, NULL, 0);
	}
   while (!(rc = fat_Read(&sfh->u->fatfile, _buf, len)));
   if (rc == -EEOF)
   	return 0;
   if (rc > 0)
   	_f_memcpy(buf, _buf, rc);
	return rc;
}

#ifdef FAT_WRITEACCESS
SSPEC_WRITE_DEF(sspec_fatwrite) {
	//FIXME: make FAT far
	auto char _buf[256];
	auto int rc;

	len = i_min(len, sizeof(_buf));
	_f_memcpy(_buf, buf, len);
	rc = fat_Write(&sfh->u->fatfile, _buf, len);
   if (rc == -EBUSY)
   	// For our purposes, EBUSY is the same as 0.
   	rc = 0;
   return rc;
}
#endif

SSPEC_EXTENSIBLE_DEF(sspec_fatextensible) {
#ifdef FAT_WRITEACCESS
	return 1;
#else
	return 0;
#endif
}

_zserver_nodebug void sspec_de2stat(fat_dirent * de, SSpecStat * stat)
{
	auto struct tm t;

   stat->length = de->fileSize;
	stat->flags = SSPEC_ATTR_LENGTH | SSPEC_ATTR_SEEKABLE | SSPEC_ATTR_MDTM;

   fat_LastWrite(de, &t);
   stat->mdtm = mktime(&t);
   if (de->attr & FATATTR_DIRECTORY)
   	stat->flags |= SSPEC_ATTR_DIR;
#ifdef FAT_WRITEACCESS
	if (!(de->attr & FATATTR_READ_ONLY))
   	stat->flags |= SSPEC_ATTR_WRITE | SSPEC_ATTR_EXTENSIBLE;
#endif
	if (de->attr & FATATTR_HIDDEN)
   	stat->flags |= SSPEC_ATTR_HIDDEN;
	if (de->attr & FATATTR_SYSTEM)
   	stat->flags |= SSPEC_ATTR_SYSTEM;
	if (de->attr & FATATTR_ARCHIVE)
   	stat->flags |= SSPEC_ATTR_ARCHIVE;
}

SSPEC_STAT_DEF(sspec_fatstat) {
	auto char _path[256];
	auto fat_dirent de;
	auto fat_part * pt;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
	_SSPEC_BLOCK_NORET(fat_Status(pt, _path, &de));
	if (rc < 0)
		return rc;
	sspec_de2stat(&de, stat);
	return 0;
}

SSPEC_DEXISTS_DEF(sspec_fatdexists) {
	auto char _path[256];
	auto fat_part * pt;
   auto fat_dirent dent;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return 0;	// No exist if unregistered partition
	_SSPEC_BLOCK_NORET(fat_Status(pt, _path, &dent));
   return !(rc || !(dent.attr & FATATTR_DIRECTORY));
}

SSPEC_OPENDIR_DEF(sspec_fatopendir) {
	auto char _path[256];
	auto fat_part * pt;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
   sfh->offset = 1;	// Init entry counter for sspec_readdir() return value.
	_SSPEC_BLOCK(fat_OpenDir(pt, _path, &sfh->u->fatfile));
}

SSPEC_NEXTDIR_DEF(sspec_fatnextdir) {
	auto char _buf[256];
	auto fat_dirent dent;
	auto int rc;

   //FIXME: FAT support far
   _SSPEC_BLOCK_NORET(fat_ReadDir(&sfh->u->fatfile, &dent, 0));
   if (!rc) {
   	sspec_de2stat(&dent, stat);
      fat_GetName(&dent, _buf, FAT_LOWERCASE);
      _f_strcpy(buf, _buf);
      ++sfh->offset;
   }
   else
   	sfh->offset = -1;
	return rc;
}

SSPEC_CLOSEDIR_DEF(sspec_fatclosedir) {
	auto int rc;

	_SSPEC_BLOCK_NORET(fat_Close(&sfh->u->fatfile));
   return 0;
}

#ifdef FAT_WRITEACCESS
SSPEC_MKDIR_DEF(sspec_fatmkdir) {
	auto char _path[256];
	auto fat_part * pt;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
	_SSPEC_BLOCK(fat_CreateDir(pt, _path));
}

SSPEC_RMDIR_DEF(sspec_fatrmdir) {
	auto char _path[256];
	auto fat_part * pt;
   auto int rc;

   //FIXME: FAT support far
   _f_strcpy(_path, path);
   pt = _sspec_fatparts[partition];
   if (!pt)
   	return -ENXIO;	// No such device
	_SSPEC_BLOCK(fat_Delete(pt, FAT_DIR, _path));
}
#endif

/*** BeginHeader sspec_devregister */
int sspec_devregister(char * name, const SSpecVTable * vt,
											const ServerPermissions * perm, void * data);
/*** EndHeader */
#warnt "SSPEC_USEDEV (/dev filesystem) is not officially supported."
_zserver_nodebug
int sspec_devregister(char * name, const SSpecVTable * vt,
											const ServerPermissions * perm, void * data)
{
	if (_sspec_numdev >= SSPEC_MAXDEV)
   	return -ENOMEM;
	_sspec_devtable[_sspec_numdev].name = name;
	_sspec_devtable[_sspec_numdev].vt = vt;
	_sspec_devtable[_sspec_numdev].perm = perm;
	_sspec_devtable[_sspec_numdev].data = data;
   return _sspec_numdev++;
}


/*** BeginHeader sspec_init */
void sspec_init(void);
/*** EndHeader */
__nodebug void sspec_init(void)
{
	auto int i, j, rc;
#ifdef SSPEC_USEFAT
   auto int pn;
	auto fat_part * pt;
#endif

	sspec_writenum = 0;
	sspec_version = SSPEC_VERSION;
	_sspec_data_ptr = NULL;
	_sspec_data_len = 0;
	_sspec_data_fptr = NULL;
   memset(server_spec, 0, sizeof(server_spec));
	memset(server_auth, 0, sizeof(server_auth));
#ifdef SSPEC_MAXRULES
	memset(_rule_table, 0, sizeof(_rule_table));
#endif
	pool_init(&_sfup, &_sfustore, SSPEC_MAX_OPEN, sizeof(_sfustore[0]));
	pool_init(&_sfhp, &_sfhstore, SSPEC_MAX_OPEN, sizeof(_sfhstore[0]));
   _sspec_nexthandle = 1024;	// increments by 256 for each virt. handle

#ifdef SSPEC_USEFAT
   memset(_sspec_fatparts, 0, sizeof(_sspec_fatparts));
#endif
#ifdef SSPEC_USEDEV
	_sspec_numdev = 0;
#endif
}
/*** BeginHeader */
#funcchain _GLOBAL_INIT sspec_init
/*** EndHeader */

/*** BeginHeader sspec_automount */
int sspec_automount(word which, sspec_fatinfo * fatstuff, void ** fs2stuff, void ** reserved);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_automount                             <ZSERVER.LIB>

SYNTAX: int sspec_automount(word which, sspec_fatinfo * fatstuff,
                            void ** fs2stuff, void ** reserved);

KEYWORDS:		tcpip, server

DESCRIPTION:   This function automatically initializes and 'mounts' the
               specified filesystem(s) for use by zserver.

               You must #use the appropriate filesystem library (e.g.
               FS2.LIB) otherwise the filesystem will not be mountable.

               If using the FAT library, this function will mount all
               devices and partitions using the fat_AutoMount() function.
               Note that zserver.lib assigns 'drive letters' to each
               mounted FAT partition.  Unlike PC operating systems (and
               BIOSes), the drive letters are fixed: mount point '/A'
               always refers to the first partition on the first drive;
               '/D' is always the 4th partition etc.  Basically, this
               means that the drive letters do not move around depending
               on which partitions happen to be mounted at any particular
               time.

               For FS2, all logical extents will be initialized via the
               fs_init() function.


PARAMETER1:		Which filesystem(s) to mount.  This is a bitwise OR of the
               following constants:
                 SSPEC_MOUNT_FS   - FS or FS2 flash filesystem
                 SSPEC_MOUNT_FAT  - FAT filesystem.
               You can also pass SSPEC_MOUNT_ANY to mount all known
               filesystems.
PARAMETER2:		This parameter is used to return FAT partition information.
               If partition info required, pass a valid pointer.
               Otherwise, pass a NULL pointer.
PARAMETER3:		This parameter is currently reserved for returning FS2
               information.  For now, pass as NULL.
PARAMETER4:		Reserved for other filesystems.  For now, pass as NULL.

RETURN VALUE:  0 	OK
               Otherwise: if a filesystem fails to mount, then the return
               code will be the bitwise OR of the SSPEC_MOUNT_* constants
               of those filesystem(s) which failed to initialize.

SEE ALSO:      sspec_fatregister, sspec_fatregistered, fat_Init,
               fs_init

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_automount(word which, sspec_fatinfo * fatstuff, void ** fs2stuff, void ** reserved)
{
	auto int rc, err;
#ifdef SSPEC_USEFAT
   auto int pn;
   auto int numpart;
   static mbr_drvr _sspec_driver;	// Static driver struct
	static fat_part _sspec_pt;			// Static partition instance
	static mbr_dev _sspec_fatdev;		// Static device instance
   auto mbr_drvr * driver;
   auto mbr_drvr * root_driver;
   auto mbr_dev * dev;
   auto fat_part * part, * opart;
#endif

	err = 0;
#ifdef SSPEC_USEFAT
   // User wants automatic mounting of FAT partition(s).
   if (which & SSPEC_MOUNT_FAT) {
   	rc = fat_AutoMount(FDDF_USE_DEFAULT);
		if (rc < 0) {
	      #ifdef ZSERVER_VERBOSE
	      printf("Could not initialize FAT filesystem, rc=%d\n", rc);
	      #endif
         err |= SSPEC_MOUNT_FAT;
      }
      else {
      	for (pn = 0; pn < num_fat_devices * FAT_MAX_PARTITIONS; ++pn) {
         	if (fat_part_mounted[pn]) {
         		sspec_fatregister(pn, fat_part_mounted[pn]);
               if (fatstuff) {
                 fatstuff->driver = fat_part_mounted[pn]->dev->driver;
                 fatstuff->dev = fat_part_mounted[pn]->dev;
                 fatstuff->part[pn % 4] = fat_part_mounted[pn];
               }
            }
         }
      }
   }
#endif	// SSPEC_USEFAT

	return err;
}

/*** BeginHeader sspec_findunused_ram */
int sspec_findunused_ram(char *name);
/*** EndHeader */
_zserver_nodebug int sspec_findunused_ram(char *name)
{
	// Find unused entry in ramspec table.  Name must not conflict with any
   // existing name.  Returns index (not handle).
   // Note that an entry of the same name is allowed to exist in the static table
   // in which case the dynamic table entry will override it.
	auto int i;

	if ((i = sspec_findname(name, SERVER_ERROR|SERVER_ANY)) >= 0 && !SSPEC_IS_FLASH(i)) {
		return -1;
	}
	for (i = 0; i < SSPEC_MAXSPEC; i++) {
		if (server_spec[i].type == SSPEC_UNUSED)
			return i;
	}
	return -1;
}

/*** BeginHeader sspec_initent */
ServerSpec * sspec_initent(ServerSpec * ssp, word type, char* name, word servermask);
/*** EndHeader */
_zserver_nodebug ServerSpec * sspec_initent(ServerSpec * ssp, word type, char* name, word servermask)
{
	memset(ssp, 0, sizeof(*ssp));
   ssp->type = type;
   strncpy(ssp->name, name, sizeof(ssp->name));
   ssp->perm.servermask = servermask;
   ssp->perm.readgroups = 0xFFFFu;		// Default to all read, none write
   return ssp;
}

/*** BeginHeader sspec_actualtype */
word sspec_actualtype(ServerSpec * ssp);
/*** EndHeader */
_zserver_nodebug word sspec_actualtype(ServerSpec * ssp)
{
	auto long s;
	// Convert a generic type (SSPEC_FILE or SSPEC_VARIABLE) to its actual specific storage type.
	switch (ssp->type) {
   	case SSPEC_FILE:
      	if (ssp->format)
         	return SSPEC_ROOTFILE;
         #ifdef __ZIMPORT_LIB
         s = xgetlong(ssp->data);
         if (s & ~ZIMPORT_MASK)
            return SSPEC_ZMEMFILE;
         #endif
         return SSPEC_XMEMFILE;
      case SSPEC_VARIABLE:
      	if (ssp->addr)
      		return SSPEC_ROOTVAR;
         return SSPEC_XMEMVAR;
   }
   return ssp->type;	// others untranslated.
}

/*** BeginHeader sspec_nvhandle */
ServerSpec * sspec_nvhandle(int sspec);
/*** EndHeader */
_zserver_nodebug ServerSpec * sspec_nvhandle(int sspec)
{
	// Convert sspec (handle) to flash or ram spec.
	// returns NULL if sspec is a virtual handle or not valid.
   if (SSPEC_IS_RAM(sspec))
   	return server_spec + SSPEC_RAM_INDEX(sspec);
#ifndef SSPEC_NO_STATIC
	else if (SSPEC_IS_FLASH(sspec))
   	return (ServerSpec *)(http_flashspec + SSPEC_FLASH_INDEX(sspec));
   // DEVNOTE: Temporarily cast away const -- need to update most ServerSpec *
   //				in this library to be const.
#endif
	return NULL;
}

/*** BeginHeader sspec_ramhandle */
ServerSpec * sspec_ramhandle(int sspec);
/*** EndHeader */
_zserver_nodebug ServerSpec * sspec_ramhandle(int sspec)
{
	// Convert sspec (handle) to ram spec only.  returns NULL if sspec is a virtual or flash handle or not valid.
   if (SSPEC_IS_RAM(sspec))
   	return server_spec + SSPEC_RAM_INDEX(sspec);
	return NULL;
}


/*** BeginHeader sspec_fh */
SSpecFileHandle * sspec_fh(int sspec);
/*** EndHeader */
_zserver_nodebug SSpecFileHandle * sspec_fh(int sspec)
{
	auto word idx;
   auto SSpecFileHandle * sfh;

	if (!SSPEC_IS_VIRT(sspec))
   	return NULL;
	idx = sspec & 0xFF;
   if (idx >= SSPEC_MAX_OPEN)
   	return NULL;
	sfh = _sfhstore + idx;
   if (sfh->sspec != sspec)
   	return NULL;
   return sfh;
}

/*** BeginHeader sspec_is_directory */
int sspec_is_directory(const char __far * path);
/*** EndHeader */
_zserver_nodebug int sspec_is_directory(const char __far * path)
{
	// Return true iff path is a directory name.  path includes leading and trailing '/' chars.
   auto word partition, fsystem;
	auto const SSpecVTable * vt;
   auto int isdir;

   if (!strcmp(path, "/"))
   	return 1;	// Special case: root directory.
   path = sspec_name_virtual(path, &partition, &fsystem, 1, &isdir);
   if (!path)
   	return 0;	// Not virtual.
   if (isdir)
   	return 1;	// Was a mount point.
	vt = sspec_vt(fsystem);
   if (!vt)
   	return 0;
   if (vt->dexists && vt->dexists(path, partition))
		return 1;
   return 0;
}

/*** BeginHeader sspec_vt */
const SSpecVTable * sspec_vt(word fsystem);
/*** EndHeader */
_zserver_nodebug
const SSpecVTable * sspec_vt(word fsystem)
{
	switch (fsystem & 0x00FFu) {
   	case SSPEC_FILE:
      	// This does not normally happen except for directory listings of the root directory.
      	return &_sspec_generic;
   	case SSPEC_ROOTFILE:
      	return &_sspec_rvt;
   	case SSPEC_XMEMFILE:
      	return &_sspec_xvt;
#ifdef __ZIMPORT_LIB
		case SSPEC_ZMEMFILE:
      	return &_sspec_zvt;
#endif
#ifdef SSPEC_USEFAT
		case SSPEC_FATFILE:
      	return &_sspec_fatvt;
#endif
#ifdef SSPEC_USEDEV
		case SSPEC_DEVFILE:
      	return _sspec_devtable[fsystem>>8].vt;	// High byte of filesystem type indexes table.
#endif
   }
   return NULL;
}

/*** BeginHeader sspec_perm */
const ServerPermissions * sspec_perm(int sspec);
/*** EndHeader */
_zserver_nodebug
const ServerPermissions * sspec_perm(int sspec)
{
	auto ServerSpec * ssp;
	auto SSpecFileHandle * ssfhp;

	if (SSPEC_IS_VIRT(sspec))
	{
		if ( (ssfhp = sspec_fh(sspec)) )
		{
	   	return ssfhp->perm;
	   }
	}
   else if (ssp = sspec_nvhandle(sspec))
   {
   	return &ssp->perm;
   }
   return NULL;
}

/*** BeginHeader sspec_name_virtual */
const char __far * sspec_name_virtual(const char __far * path, word * partition,
											word * fsystem, int lfd, int * isdir);
/*** EndHeader */
_zserver_nodebug
const char __far * sspec_name_virtual(const char __far * path, word * partition,
											word * fsystem, int lfd, int * isdir)
{
	auto int fnum;
   auto char fname[12];
#ifdef SSPEC_USEDEV
   auto const char __far * dn;
   auto word dnum;
   auto word dnlen;
#endif

	// Return non-NULL iff given absolute pathname is in the virtual filesystem hierarchy.
   // If so, *partition to the partition (and possibly file) number of the appropriate extent.
   // The return value points to the character in 'path' which is the first character of
   // the part of the pathname which is local to the returned partition.  e.g. if
   // /fs2/file8 is passed, then the return value will point to "/file8".  The leading slash
   // is included unless the given file referred to the mount point e.g. just "/fs2".

   // *isdir is set to TRUE iff the resulting name is a directory name (but only if partition
   // was not null).
   *isdir = 0;

   // Flash/ramspec entries override virtual FS.  Typically, this occurs for "/" which
   // is historically added to the flashspec table as an alias for "index.html".
   // This is only done if not "look for directory".
	if (!lfd && sspec_findname(path, SERVER_ERROR|SERVER_ANY) >= 0)
   	return NULL;

   if (path[0] == '/')
   	++path;
   if (fsystem)
   	*fsystem = SSPEC_FILE;	// No filesystem yet determined: set to generic.
   if (!*path)
   	return *isdir = 1, (char __far *) path;		// Is just the root directory "/".

#ifdef SSPEC_USEFAT
	// FAT files start with '/A', '/B' etc.
   if (path[0] >= 'A' && path[0] < 'A'+sizeof(_sspec_fatparts)/sizeof(_sspec_fatparts[0]) &&
       (!path[1] || path[1] == '/')) {
      if (fsystem)
         *fsystem = SSPEC_FATFILE;
      fnum = path[0] - 'A';
      if (!_sspec_fatparts[fnum])
      	return NULL;
      ++path;
      if (!path[0] || !strcmp(path, "/"))
      	*isdir = 1;
      if (partition)
	      *partition = fnum;
      return path;
   }
#endif
#ifdef SSPEC_USEDEV
	// Dev files start with '/dev/'.  Then follows a name registered using sspec_devregister(), then
   // optionally a "partition" number specified as either .x or .x.y where x,y are ascii numbers
   // 0..255.  If not specified, the number is assumed to be zero.  x goes in the MSB, y in the LSB.
   // If only x is specified, it may range from 0..65535.  Note that strtol() is used to parse the
   // numbers, so they may be given in base 16 or 8 (0x or leading 0 respectively).
   // Note that fsystem is set to SSPEC_DEVFILE ORed with the registered device table entry in the
   // high byte (thus the caller does not have to re-parse the file name).
   if (!strncmp(path, "dev", 3)) {
   	if (!path[3] || path[3] == '/') {
         path += 3;
         if (fsystem)
         	*fsystem = SSPEC_DEVFILE;
      	if (!partition)
      		return path;
         *partition = 0;	// Default, i.e. not determined.
			if (!*path || !strcmp(path, "/"))
         	return *isdir = 1, path;
         dn = ++path;
         while (*dn && *dn != '.' && *dn != '/') ++dn;
			dnlen = dn - path;
         if (dnlen > 11)
         	return NULL;
         if (*dn == '/')
         	return NULL;	// No subdirectories in /dev.
         _f_memcpy(fname, path, dnlen);
         fname[dnlen] = 0;
         for (dnum = 0; dnum < _sspec_numdev; ++dnum)
         	if (!strcmp(_sspec_devtable[dnum].name, fname))
            	break;
         if (dnum == _sspec_numdev)
				return NULL;	// Not registered dev name (even though started with '/dev/').
         if (fsystem)
         	*fsystem |= dnum << 8;
         if (*dn) {
         	// cast away const for _f_strtol()
         	// Parse the "partition" number(s).  dn points to first ".".
            *partition = (word)_f_strtol(dn+1, (char **)&dn, 0);
            if (*dn == '.') {
            	*partition <<= 8;
               *partition |= (word)_f_strtol(dn+1, (char **)&dn, 0) & 0x00FF;
            }
            if (*dn)
            	return NULL;
         }
         return path-1;	// back up to the '/'.
      }
   }
#endif
	return NULL;
}

/*** BeginHeader sspec_name_parse */
const char __far * sspec_name_parse(char __far * name, char __far * path, word * partition,
								const ServerPermissions ** sppp, const SSpecVTable ** vtp,
                        ServerSpec ** sspp, const ServerContext * context, int lfd,
                        word * fsystemp);
/*** EndHeader */
_zserver_nodebug
const char __far * sspec_name_parse(char __far * name, char __far * path, word * partition,
								const ServerPermissions ** sppp, const SSpecVTable ** vtp,
                        ServerSpec ** sspp, const ServerContext * context, int lfd,
                        word * fsystemp)
{
	auto const char __far * p;
	auto char __far * abs;
   auto const ServerPermissions * spp;
   auto int sspec;
   auto ServerSpec * ssp;
   auto const SSpecVTable * vt;
   auto word fsystem;
   auto int isdir;

	if (context) {
   	if (sspec_simplify(name, path, context, 0))
   		return NULL;
   }
   else if (name != path)
   	_f_strcpy(path, name);
  	abs = path;

   if (!lfd && (sspec = sspec_findname(abs, SERVER_ERROR|SERVER_ANY)) >= 0) {
		ssp = sspec_nvhandle(sspec);
     	spp = &ssp->perm;		// Overriding permissions.
      if (!spp->realm) {
      	// No realm string, try rule-based.
      	spp = sspec_findrule(abs, ssp);
         if (!spp)
         	// No rule, revert to static.
         	spp = &ssp->perm;
      }
     	fsystem = sspec_actualtype(ssp);
      switch (fsystem) {
#ifdef __ZIMPORT_LIB
      	case SSPEC_ZMEMFILE:
#endif
			case SSPEC_XMEMFILE:
            p = (char *)&ssp->data;
         	goto _getvt;
			case SSPEC_ROOTFILE:
         	*partition = ssp->vartype;
            p = ssp->format;
            goto _getvt;
      }
      // If none of the above, is an error
      return NULL;
   }
  	if (!lfd && context && context->dfltname &&
   		strlen(abs)+1+strlen(context->dfltname) < SSPEC_MAXNAME &&
         sspec_is_directory(abs)) {
   	// If looking for file, and have default file name, and abs is a directory (virtual only) and
      // there is enough space in 'abs' to take the name concatenation, then recurse to operate
      // on the default file instead of the directory.
      if (abs[strlen(abs)-1] != '/')
   		_f_strcat(abs, "/");
      _f_strcat(abs, context->dfltname);
      return sspec_name_parse(abs, abs, partition, sppp, vtp, sspp, NULL, 0, fsystemp);
   }
  	spp = NULL;
   ssp = NULL;
	p = sspec_name_virtual(abs, partition, &fsystem, lfd, &isdir);
   if (!lfd && isdir)
   	return NULL;
   if (p) {
#ifdef SSPEC_USEDEV
		if (!((fsystem & 0x00FF) == SSPEC_DEVFILE && (spp = _sspec_devtable[fsystem>>8].perm)))
#endif
  		spp = sspec_findrule(abs, NULL);
   _getvt:
   	if (!(vt = sspec_vt(fsystem)))
      	return NULL;
   }
   if (sspp)
   	*sspp = ssp;
   if (sppp)
   	*sppp = spp;
   if (vtp)
   	*vtp = vt;
   if (fsystemp)
   	*fsystemp = fsystem;
	return p;
}

/*** BeginHeader sspec_nexthandle */
int sspec_nexthandle(int sspec);
/*** EndHeader */
_zserver_nodebug int sspec_nexthandle(int sspec)
{
	// Iterate thru RAM entries followed by flash entries.  -1 if end.
   if (sspec == -1)
   	// First entry.
      sspec = SSPEC_RAM_HANDLE(-1);
   while (++sspec, SSPEC_IS_RAM(sspec))
      if (server_spec[SSPEC_RAM_INDEX(sspec)].type)
      	return sspec;
#ifndef SSPEC_NO_STATIC
	if (sspec == SSPEC_END_OF_RAM)
   	sspec = SSPEC_FLASH_HANDLE(0);
   if (SSPEC_IS_FLASH(sspec))
      return sspec;
#endif
   return -1;
}

/*** BeginHeader sspec_simplify */
int sspec_simplify(const char __far * path, char __far * abs,
													const ServerContext * context, int lfd);
/*** EndHeader */
_zserver_nodebug
int sspec_simplify(const char __far * path, char __far * abs,
													const ServerContext * context, int lfd)
{
	// Simplify the given 'path' (which may be relative to the CWD or absolute, or may contain
   // '.' or '..' components) and return the simplified full absolute path in abs.  If lfd
   // is true, append a trailing slash.  Returns 0 if OK, else error code.
   // context contains the root directory, and current working directory.
	auto char comp[SSPEC_MAXNAME+2];	// Temp store for component
   auto char __far * cp;
   auto char __far * ep;
   auto char __far * ap;

	if (*path == '/') {
   	_f_strcpy(abs, context->rootdir);
      ++path;
   }
   else
   	_f_strcpy(abs, context->cwd);
   ep = comp + SSPEC_MAXNAME;
   while (*path) {
   	cp = comp;
   	while (*path && *path != '/' && cp != ep)
      	*cp++ = *path++;
      if (*path && *path != '/')
      	return -E2BIG;			// Directory component too long
      *cp++ = '/';
      *cp = 0;
      if (*path) ++path;	// Skip slash
      if (!strcmp(comp, "./"))
      	continue;
      if (!strcmp(comp, "../")) {
      	// Up one level
         if (!strcmp(abs, context->rootdir))
         	return -EACCES;			// Trying to go above root directory
			ap = abs + (strlen(abs) - 2);
         while (*ap != '/') --ap;
         *++ap = 0;
         continue;
      }
      // Otherwise, is component to append.
		if (strlen(abs) + strlen(comp) > SSPEC_MAXNAME)
      	return -E2BIG;
      _f_strcat(abs, comp);
   }
   if (!lfd && strlen(abs) > 1)
   	// Take off final slash unless root directory
      abs[strlen(abs)-1] = 0;
   return 0;
}

/*** BeginHeader sauth_pointer */
ServerAuth * sauth_pointer(int userid);
/*** EndHeader */
_zserver_nodebug ServerAuth * sauth_pointer(int userid)
{
	if (userid < 0 || userid >= SAUTH_MAXUSERS)
   	return NULL;
   if (*server_auth[userid].username)
   	return server_auth + userid;
   return NULL;
}

/*** BeginHeader sspec_addrule */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addrule                             <ZSERVER.LIB>

SYNTAX: int sspec_addrule(char * pfx,
                          char * realm,
                          word readgroups,
                          word writegroups,
                          word servermask,
                          word method,
                          MIMETypeMap * mimetype);

KEYWORDS:		tcpip, server

DESCRIPTION:   Add a rule to the dynamic resource rule table.  Resource
					rules are used to associate access information with
               resource names matching the specified prefix string.
               Note that the most specific i.e. longest matching string
               is used.

               Normally, the rule table is consulted only for resource
               names which belong in a file system (FS2 or FAT).  You
               can also cause the rule table to be consulted for flash-
               or RAM-table entries if you leave the "realm" field as
               NULL in the entry.  If the realm field is not NULL, then
               the rule table is NOT consulted for that entry.  If the
               realm field was NULL, and there was no applicable entry
               in the rule table, then the resource table permissions
               are used (with NULL realm).

               Note: you should not attempt to use a very large number
               of rule table entries, since the table must be searched
               exhaustively for each initial resource access.  There
               should be no need for a large number of entries provided
               that the resource name hierarchy is organized in a
               reasonably efficient manner.  For example, keep the
               resources for a particular user or realm in one
               directory, and just add an entry for that directory
               instead of an entry for each resource.  This works
               because the full path name is always used for matching,
               and the directory will always be a prefix string of the
               files which reside in that directory.

               As an alternative to this function, you can also statically
               initialize a rule table using the following macros:

                 #define SSPEC_FLASHRULES		// required.
                 #use "zserver.lib"  // this lib

                 SSPEC_RULETABLE_START
                    SSPEC_RULE("prefix", realm, rg, wg, sm)
                   ,SSPEC_RULE("prefix", realm, rg, wg, sm)
                    SSPEC_MM_RULE("prefix", realm, rg, wg, sm, meth, mime)
                   ,SSPEC_MM_RULE("prefix", realm, rg, wg, sm, meth, mime)
                    ...
                 SSPEC_RULETABLE_END

               where the SSPEC_MM_RULE macro parameters are basically
               the same parameters as would be passed to this function.
               These macros define and initialize a constant rule
               table named f_rule_table.  SSPEC_RULE just omits the
               (rarely used) method and mimetype fields.

               If using a static rule table, the dynamically added
               entries will be searched before the static ones.

PARAMETER1:		prefix of resource name.  This must include the initial
					'/' character, since all matching is done using absolute
               path names.  If this prefix string exactly matches an
               existing entry in the table, that entry is replaced.
               Otherwise, a new entry is created (if possible).  This
               string is not copied, only the pointer is stored.  Thus,
               the parm must point to static storage i.e. string
               constant or a global variable.
               Initial characters other than '/' are reserved for
               future use.
PARAMETER2:		If not NULL, is an arbitrary null-terminated string
					which may be used by the server.  For HTTP, this is used
               as the "realm" of the resource.  This string is not
               copied, only the pointer is stored.  Thus, the parm must
               point to static storage.
PARAMETER3:		A word with a bit set for each group which can access
					this resource for reading.  A maximum of 16 different
               user groups can exist.
PARAMETER4:		A word with a bit set for each group which can access
					this resource for writing.  The user must also be given
               permission to write resources in the userid table entry,
               for the appropriate server(s).
PARAMETER5:		The server(s) which are allowed to access this resource.
					Servers have predefined bits.  This parm should be a
               combination of
                 SERVER_HTTP : web server
                 SERVER_FTP : file transfer protocol server
                 SERVER_SMTP : email
                 SERVER_HTTPS : secure web server
                 SERVER_SNMP : SNMP agent
                 SERVER_CLOUD : Device Cloud server
                 SERVER_USER : user-defined server.
               or could be SERVER_ANY for all servers.
PARAMETER6:		Allowable authentication method(s) to be used when
					accessing this resource.  This is a bitwise combination
               of
                 SERVER_AUTH_BASIC : plaintext userid/password
                 SERVER_AUTH_DIGEST : challenge-response protocol (only
                   useful if USE_HTTP_DIGEST_AUTHENTICATION is defined
                   before inclusion of the HTTP library).
                 SERVER_AUTH_PK: public key (such as SSL/TLS)
            	    This is not yet implemented; reserved for future use.
               If zero, then the resource has no particular authentication
               method requirements.
PARAMETER7:		An appropriate MIME type to use.  If NULL, then the default
               table (called http_types) will be consulted.

RETURN VALUE:  >=0 	OK
               -1		error e.g. out of space in rule table.  In this
                     case, the macro SSPEC_MAXRULES should be increased.

SEE ALSO:      sspec_removerule, sspec_getMIMEtype

END DESCRIPTION **********************************************************/

int sspec_addrule(char * pfx, char * realm, word readgroups, word writegroups,
                          word servermask, word method,
                          MIMETypeMap * mimetype);
/*** EndHeader */

_zserver_nodebug int sspec_addrule(char * pfx, char * realm, word readgroups, word writegroups,
                          word servermask, word method,
                          MIMETypeMap * mimetype)
{
#if SSPEC_MAXRULES
	auto word i;
   auto RuleEntry * re;

   for (i = 0; i < SSPEC_MAXRULES; ++i)
   	if (_rule_table[i].prefix && !strcmp(_rule_table[i].prefix, pfx))
      	break;
   if (i == SSPEC_MAXRULES)
	   for (i = 0; i < SSPEC_MAXRULES; ++i)
	      if (!_rule_table[i].prefix)
	         break;
   if (i < SSPEC_MAXRULES) {
		re = _rule_table + i;
      re->prefix = pfx;
      re->perm.readgroups = readgroups;
      re->perm.writegroups = writegroups;
      re->perm.servermask = servermask;
      re->perm.realm = realm;
      re->perm.method = method;
      re->perm.mimetype = mimetype;
   	return 0;
   }
#endif
	return -1;
}

/*** BeginHeader sspec_removerule */

/* START FUNCTION DESCRIPTION ********************************************
sspec_removerule                             <ZSERVER.LIB>

SYNTAX: int sspec_removerule(char * pfx);

KEYWORDS:		tcpip, server

DESCRIPTION:   Remove a rule from the dynamic resource rule table.

PARAMETER1:		Prefix of resource name.  This must be an exact match to
					one of the rules previously added using sspec_addrule().

RETURN VALUE:  >=0 	OK
               -1		error e.g. rule not found, or maybe rule was in
                  flash table (f_rule_table).

SEE ALSO:      sspec_addrule

END DESCRIPTION **********************************************************/

int sspec_removerule(char * pfx);
/*** EndHeader */

_zserver_nodebug int sspec_removerule(char * pfx)
{
#if SSPEC_MAXRULES
	auto word i;
   auto RuleEntry * re;

   for (i = 0; i < SSPEC_MAXRULES; ++i)
   	if (_rule_table[i].prefix && !strcmp(_rule_table[i].prefix, pfx))
      	break;
   if (i < SSPEC_MAXRULES) {
		_rule_table[i].prefix = NULL;
   	return 0;
   }
#endif
	return -1;
}

/*** BeginHeader sspec_findrule */
const ServerPermissions * sspec_findrule(const char __far * name, ServerSpec * ssp);
/*** EndHeader */

const ServerPermissions _sspec_default_perms =
{
	SSPEC_DEFAULT_REALM,
	SSPEC_DEFAULT_READGROUPS,
	SSPEC_DEFAULT_WRITEGROUPS,
	SSPEC_DEFAULT_SERVERMASK,
	SSPEC_DEFAULT_METHOD,
   NULL
};

_zserver_nodebug
const ServerPermissions * sspec_findrule(const char __far * name, ServerSpec * ssp)
{
	// Find the most specific rule for a given resource name.  Both the dynamic table
   // and the static table (if any) are searched.  A pointer to the table entry is
   // returned if found in either of these tables.  Otherwise, a const struct is
   // returned, filled with default values.
   // If ssp is not NULL, then &ssp->perm will be returned rather than falling back to the
   // default rule.  This is the case when ssp is a known (static or dynamic table) resource,
   // since these can have individual permissions.
#ifdef HAVE_RULES
	auto word i;
	auto word mlen;	// Largest matching prefix length
   auto word plen;	// Length of prefix being matched
   auto word rlen;	// Length of resource name
   auto const ServerPermissions * p;	// NULL, or largest match
   auto const RuleEntry * re;

   rlen = strlen(name);
   mlen = 0;	// Nothing matches yet
   p = NULL;

	#if SSPEC_MAXRULES
   for (i = 0; i < SSPEC_MAXRULES; ++i) {
   	re = _rule_table + i;
      if (!re->prefix)
      	continue;
		plen = strlen(re->prefix);
		if (plen > rlen || plen <= mlen)
      	continue;
      if (!memcmp(re->prefix, name, plen)) {
      	mlen = plen;
         p = &re->perm;
      }
   }
	#endif
   #ifdef SSPEC_FLASHRULES
   for (i = 0; i < sizeof(f_rule_table)/sizeof(f_rule_table[0]); ++i) {
   	re = f_rule_table + i;
		plen = strlen(re->prefix);
		if (plen > rlen || plen <= mlen)
      	continue;
      if (!memcmp(re->prefix, name, plen)) {
      	mlen = plen;
         p = &re->perm;
      }
   }
   #endif
   if (p)
   	return p;
#endif
	if (ssp)
   	return &ssp->perm;
	return &_sspec_default_perms;
}



/*** BeginHeader sspec_getMIMEtype */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getMIMEtype                      <ZSERVER.LIB>

SYNTAX: const MIMETypeMap * sspec_getMIMEtype(const char far * name,
							 						         const ServerContext * context);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Return the MIME type information for a specified resource
               name, in the given server context.

               Note that the available MIME types are set up by defining
               a global variable (or constant) table using the
               definition (for example)

                 const MIMETypeMap http_types[] =
                 {
	               { ".html", "text/html", NULL},
	               { ".gif", "image/gif", NULL}
             	  };

               The name 'http_types' is required for backward compatibility
               even though servers other than HTTP can make use of MIME
               types.

               When searching for the appropriate type, the rule table
               is consulted first.  Only if this results in a NULL mime
               type pointer is the http_types table consulted.

               See sspec_open() for more detailed description of the
               parameters.

PARAMETER1: 	Name of the resource.
PARAMETER2: 	Current server context.

RETURN VALUE:  Pointer to the appropriate table entry.  MIMETypeMap is
               defined as
	               typedef struct {
	                  char extension[10];	// File extension or suffix.
	                  char type[SSPEC_MAXNAME]; // MIME type e.g. "text/html"
	                  int  (*fptr)();   // This is used for server-specific
                                       // processing e.g. SSI.
	               } MIMETypeMap;
               A valid pointer is always returned.  If the appropriate
               table entry cannot be located by the resource's extension
               (or using a rule (see sspec_addrule)) then the first
               table entry is returned.

SEE ALSO:      sspec_addrule
END DESCRIPTION **********************************************************/

const MIMETypeMap * sspec_getMIMEtype(const char __far * name,
							 						 const ServerContext * context);
/*** EndHeader */
_zserver_nodebug
const MIMETypeMap * sspec_getMIMEtype(const char __far * name,
							 						 			const ServerContext * context)
{
	auto char path[SSPEC_MAXNAME+1];
   auto int i, k;
   auto const char __far *p;
   auto const char __far *end;
   auto const char __far *ex;
	auto const ServerPermissions * spp;

	if (!context || sspec_simplify(name, path, context, 0))
   	return http_types;
   // First check rules
	spp = sspec_findrule(path, NULL);
   if (spp && spp->mimetype)
   	return spp->mimetype;

   // Then check old-fashioned table
   end = name + strlen(name);
   for (i=0; i<sizeof(http_types)/sizeof(http_types[0]); i++) {
      p = end - (k = strlen(ex = http_types[i].extension));

      if (!memcmp(p, ex, k))
         return http_types + i;
   }

   // Didn't find type.  Return 1st entry (should be text/html for backward compat).
   return http_types;
}



/*** BeginHeader sspec_addrootfile */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addrootfile                      <ZSERVER.LIB>

SYNTAX: int sspec_addrootfile(char* name, char* fileloc, int len,
                              word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a file located in root memory to the RAM resource
					list.  Make sure that SSPEC_MAXSPEC is large enough to
					hold this new entry.

PARAMETER1: 	name of the new file.  This must be unique, but this
               function does not check.  The name should not conflict
               with the virtual filesystem hierarchy i.e. it should
               not start with "/fs2/", "/A/", "/B/" etc.
PARAMETER2: 	pointer to the beginning of the file
PARAMETER3: 	length of the file
PARAMETER4:		bitmask representing valid servers

RETURN VALUE:  >= 0	successfully added file index
               -1		failed to add file

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addfunction,
					sspec_addvariable, sspec_addxmemvar, sspec_addxmemfile,
					sspec_aliasspec, sspec_resizerootfile

END DESCRIPTION **********************************************************/

int sspec_addrootfile(char* name, char* fileloc, int len, word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_addrootfile(char* name, char* fileloc, int len, word servermask)
{
	auto int i;

	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_ROOTFILE, name, servermask)->format = fileloc;
		server_spec[i].vartype = (word)len;
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}

/*** BeginHeader sspec_addxmemfile */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addxmemfile                      <ZSERVER.LIB>

SYNTAX: int sspec_addxmemfile(char* name, long fileloc, word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a file located in extended memory to the RAM resource
					list.  Make sure that SSPEC_MAXSPEC is large enough to hold
					this new entry.

PARAMETER1: 	name of the new file.  See sspec_addrootfile() for naming
               requirements.
PARAMETER2: 	location of the file (with the first 4 bytes being the size of
					the file--#ximport does this by default)
PARAMETER3:		bitmask representing valid servers

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add file

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addfunction,
					sspec_addrootfile, sspec_addvariable, sspec_addxmemvar,
					sspec_aliasspec

END DESCRIPTION **********************************************************/

int sspec_addxmemfile(char* name, long fileloc, word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_addxmemfile(char* name, long fileloc, word servermask)
{
	auto int i;


	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_XMEMFILE, name, servermask)->data = fileloc;
#ifdef __ZIMPORT_LIB
      if (xgetlong(fileloc) & ~ZIMPORT_MASK)
      	// Compressed file
			server_spec[i].type = SSPEC_ZMEMFILE;
#endif
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}


/*** BeginHeader sspec_addvariable */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addvariable                      <ZSERVER.LIB>

SYNTAX: int sspec_addvariable(char* name, void* variable, word type,
										char* format, word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a variable to the RAM resource list.  This function is
					currently only useful for the HTTP server.  Make sure that
					SSPEC_MAXSPEC is large enough to hold this new entry.

PARAMETER1: 	name of the new variable.  This should not conflict with an
               existing name (see sspec_addrootfile).  Variables appear in
               a directory listing of the root directory "/" however they
               cannot be opened using sspec_open().
PARAMETER2: 	address of the variable's storage
PARAMETER3:		type of the variable: one of
					INT8 - single character
      			INT16 - 2-byte integer
               PTR16	- string in root memory
               INT32	- 4-byte (long) integer
               FLOAT32 - floating point variable
PARAMETER4:		output format of the variable as a printf() specifier e.g.
               "%d".
PARAMETER5:		bitmask representing valid servers (currently only useful with
					SERVER_HTTP)

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add variable

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addfunction,
					sspec_addxmemvar, sspec_addrootfile, sspec_addxmemfile,
					sspec_aliasspec

END DESCRIPTION **********************************************************/

int sspec_addvariable(char* name, void* variable, word type, char* format,
                      word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_addvariable(char* name, void* variable, word type, char* format,
                              word servermask)
{
	auto int i;

	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_ROOTVAR, name, servermask)->addr = variable;
		server_spec[i].vartype = type;
		server_spec[i].format = format;
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}

/*** BeginHeader sspec_addxmemvar */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addxmemvar                       <ZSERVER.LIB>

SYNTAX: int sspec_addxmemvar(char* name, long variable, word type,
									  char* format, word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a variable located in xmem to the RAM resource list.
					This function is currently only useful for the HTTP server.
					Make sure that SSPEC_MAXSPEC is large enough to hold this
					new entry.

               See sspec_addvariable() for more details on parameters.

PARAMETER1: 	name of the new variable
PARAMETER2: 	address of the variable storage in xmem
PARAMETER3:		type of the variable
PARAMETER4:		output format of the variable
PARAMETER5:		bitmask representing valid servers (currently only useful with
					SERVER_HTTP)

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add variable

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addfunction,
					sspec_addrootfile, sspec_addxmemfile, sspec_aliasspec

END DESCRIPTION **********************************************************/

int sspec_addxmemvar(char* name, long variable, word type, char* format,
                     word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_addxmemvar(char* name, long variable, word type, char* format,
                             word servermask)
{
	auto int i;

	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_XMEMVAR, name, servermask)->data = variable;
		server_spec[i].vartype = type;
		server_spec[i].format = format;
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}

/*** BeginHeader sspec_addfunction */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addfunction                      <ZSERVER.LIB>

SYNTAX: int sspec_addfunction(char* name, int (*fptr)(), word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a function to the RAM resource list.  This function is
					currently only useful for the HTTP server, in which case
               the function is registered as a CGI or #exec.  Make sure
               that SSPEC_MAXSPEC is large enough to hold this new entry.

               Note: if using HTTP upload facility and/or new CGI
               interface, use sspec_addCGI() instead.

PARAMETER1: 	name of the new function
PARAMETER2: 	pointer to the function
PARAMETER3:		bitmask representing valid servers (currently only useful with
					SERVER_HTTP)

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add function

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addrootfile,
					sspec_addvariable, sspec_addxmemvar, sspec_addxmemfile,
					sspec_aliasspec, sspec_addCGI

END DESCRIPTION **********************************************************/

int sspec_addfunction(char* name, int (*fptr)(), word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_addfunction(char* name, int (*fptr)(), word servermask)
{
	auto int i;

	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_FUNCTION, name, servermask)->addr = fptr;
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}

/*** BeginHeader sspec_addCGI */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addCGI                      <ZSERVER.LIB>

SYNTAX: int sspec_addCGI(char* name, void (*fptr)(), word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a CGI function to the RAM resource list.  This function
               is currently only useful for the HTTP server, in which case
               the function is registered as a CGI processor.  Make sure
               that SSPEC_MAXSPEC is large enough to hold this new entry.

PARAMETER1: 	URL name of the new function e.g. "myCGI.cgi"
PARAMETER2: 	Pointer to the function.  The prototype for this function is
                 int (*fptr)(HttpState * state);
               There is a specific documented interface that must be used
               when specifying this type of CGI handler function.  See the
               manual for details.
PARAMETER3:		Bitmask representing valid servers (currently only useful with
					SERVER_HTTP)

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add function

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addrootfile,
					sspec_addvariable, sspec_addxmemvar, sspec_addxmemfile,
					sspec_aliasspec, sspec_addfunction

END DESCRIPTION **********************************************************/

int sspec_addCGI(char* name, void (*fptr)(), word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_addCGI(char* name, void (*fptr)(), word servermask)
{
	auto int i;

	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_CGI, name, servermask)->addr = fptr;
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}

/*** BeginHeader sspec_addform */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addform                          <ZSERVER.LIB>

SYNTAX: int sspec_addform(char* name, FormVar* form, int formsize,
                          word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a form (set of modifiable variables) to the RAM
					resource list.  This function is currently only useful for
					the HTTP server.  Make sure that SSPEC_MAXSPEC is large
					enough to hold this new entry.

PARAMETER1: 	name of the new form
PARAMETER2: 	pointer to the form array
PARAMETER3:		size of the form array
PARAMETER4:		bitmask representing valid servers (currently only useful with
					SERVER_HTTP)

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add form

SEE ALSO:      sspec_addfsfile, sspec_addfunction, sspec_addrootfile,
					sspec_addvariable, sspec_addxmemvar, sspec_addxmemfile,
					sspec_aliasspec, sspec_addfv

END DESCRIPTION **********************************************************/

int sspec_addform(char* name, FormVar* form, int formsize, word servermask);
/*** EndHeader */

#ifndef FORM_ERROR_BUF
	#fatal "FORM_ERROR_BUF must be defined to use forms"
#endif
_zserver_nodebug int sspec_addform(char* name, FormVar* form, int formsize, word servermask)
{
	auto int i;

	i = sspec_findunused_ram(name);
	if (i != -1) {
   	sspec_initent(server_spec + i, SSPEC_FORM, name, servermask)->addr = form;
		server_spec[i].data = formsize;
		server_spec[i].formepilog = -1;
		server_spec[i].formprolog = -1;
		server_spec[i].format = "";
      return SSPEC_RAM_HANDLE(i);
	}
	return -1;
}

/*** BeginHeader sspec_aliasspec */

/* START FUNCTION DESCRIPTION ********************************************
sspec_aliasspec                        <ZSERVER.LIB>

SYNTAX: int sspec_aliasspec(int sspec, char* name);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Creates an alias to an existing spec structure.  Note that
					this is NOT a deep copy.  That is, any file, variable, or
					form that the new spec entry references will be the same
					copy of the file, variable, or form as in the old spec
					entry.  This should be called only when the original spec
					entry has been completely set up.  Make sure that
					SSPEC_MAXSPEC is large enough to hold this new entry.

               NOTE: do not attempt to alias a sspec handle which was
               returned by sspec_open(), because the handle may be
               dynamically allocated.  In such a case, the alias will
               not work once the original handle is closed.  You can
               test whether such a "virtual" handle has been returned
               using the macro SSPEC_IS_VIRT(sspec).

PARAMETER1: 	spec index that this function will alias
PARAMETER2: 	Alias name.

RETURN VALUE:  >= 0	successfully added spec index
               -1		failed to add alias e.g. handle was virtual.

SEE ALSO:      sspec_addform, sspec_addfsfile, sspec_addfunction,
					sspec_addrootfile, sspec_addvariable, sspec_addxmemfile

END DESCRIPTION **********************************************************/

int sspec_aliasspec(int sspec, char* name);
/*** EndHeader */

_zserver_nodebug int sspec_aliasspec(int sspec, char* name)
{
	auto int i;
	auto ServerSpec * ssp;

	if (ssp = sspec_nvhandle(sspec)) {
		i = sspec_findunused_ram(name);
		if (i != -1) {
      	memcpy(server_spec + i, server_spec + sspec, sizeof(ServerSpec));
			strncpy(server_spec[i].name, name, SSPEC_MAXNAME);
      	return SSPEC_RAM_HANDLE(i);
		}
	}
	return -1;
}

/*** BeginHeader sspec_resizerootfile */

/* START FUNCTION DESCRIPTION ********************************************
sspec_resizerootfile                            <ZSERVER.LIB>

SYNTAX: int sspec_resizerootfile( int spec_index, int new_size );

KEYWORDS:		tcpip, server

DESCRIPTION: 	Change the byte size of a SSPEC item stored in root memory.
					Item must be a ROOTFILE, thus the item must have been created
					with sspec_addrootfile().

PARAMETER1: 	spec index of the item
PARAMETER2: 	new size to assign to item

RETURN VALUE:  spec_index:	successfully adjusted size of item.
               -1:		failed to adjust size

SEE ALSO:      sspec_addrootfile

END DESCRIPTION **********************************************************/

int sspec_resizerootfile( int spec_index, int new_size );
/*** EndHeader */

_zserver_nodebug int sspec_resizerootfile( int spec_index, int new_size )
{
	auto ServerSpec * ssp;
	if ((ssp = sspec_ramhandle(spec_index)) &&
		 ssp->type == SSPEC_ROOTFILE) {
			/*  If index legal and item ROOTFILE, then OK to adjust size. */
			ssp->vartype = (word)new_size;
			return spec_index;
	}
	return -1;
}

/*** BeginHeader sspec_addfv */

/* START FUNCTION DESCRIPTION ********************************************
sspec_addfv                            <ZSERVER.LIB>

SYNTAX: int sspec_addfv(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a variable to a form.

PARAMETER1: 	spec index of the form (previously returned by
               sspec_addform()).
PARAMETER2: 	spec index of the variable to add (which must have
               been previously created using sspec_addvariable() etc.)

RETURN VALUE:  >= 0	successfully added variable index
               -1		failed to add variable

SEE ALSO:      sspec_addform

END DESCRIPTION **********************************************************/

int sspec_addfv(int form, int var);
/*** EndHeader */

_zserver_nodebug int sspec_addfv(int form, int var)
{
	auto FormVar* fv;
   auto ServerSpec * ssp;
	if ((ssp = sspec_ramhandle(form)) &&
	    (ssp->type == SSPEC_FORM) &&
	    (ssp->highvar < ssp->data) &&
	    sspec_nvhandle(var)) {
		fv = ((FormVar *)ssp->addr) + ssp->highvar;
		fv->varspec = var;
		fv->varlen = 10;
		fv->entrytype = HTML_FORM_TEXT;
		fv->rangeset = 0;
		fv->valueslen = 0;
		fv->readonly = 0;
		fv->varcheck = NULL;
		fv->desc = "";
		return (ssp->highvar++);
	}
	return -1;
}

/*** BeginHeader sspec_setuser */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setuser                          <ZSERVER.LIB>

SYNTAX: int sspec_setuser(int sspec, int userid);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set the read permission mask of a spec entry (usually a file).
               The permissions for this resource are set to readable only
               by the group(s) which this user is a member of.  Write
               access is set to "none".

PARAMETER1: 	spec index.  This must refer to a RAM resource.
PARAMETER2: 	user index

RETURN VALUE:   0		success
               -1		failure: either sspec or userid was not valid.

SEE ALSO:      sauth_adduser, sspec_getusername, sspec_getuserid,
					sspec_removeuser

END DESCRIPTION **********************************************************/

int sspec_setuser(int sspec, int userid);
/*** EndHeader */

_zserver_nodebug int sspec_setuser(int sspec, int userid)
{
   auto ServerSpec * ssp;
   auto ServerAuth * sap;

	if ((ssp = sspec_ramhandle(sspec)) &&
       (sap = sauth_pointer(userid)) &&
	    sap->username[0]) {
		ssp->perm.readgroups = sap->mask;
		ssp->perm.writegroups = 0;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_adduser */

/* START FUNCTION DESCRIPTION ********************************************
sspec_adduser                          <ZSERVER.LIB>

SYNTAX: int sspec_adduser(int sspec, int userid);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add to the read permission mask for the given resource.
               The group(s) which 'userid' is a member of are ORed in
               to the existing permission mask for the resource.  The
               write permissions are not modified.

               Note: this is not used to create new userids.  For that,
               see sauth_adduser().

PARAMETER1: 	spec index
PARAMETER2: 	user index

RETURN VALUE:  >= 0	success
               -1		failure

SEE ALSO:      sspec_setuser, sspec_getusername, sspec_getuserid,
               sspec_removeuser

END DESCRIPTION **********************************************************/

int sspec_adduser(int sspec, int userid);
/*** EndHeader */

_zserver_nodebug int sspec_adduser(int sspec, int userid)
{
   auto ServerSpec * ssp;
   auto ServerAuth * sap;

	if ((ssp = sspec_ramhandle(sspec)) &&
       (sap = sauth_pointer(userid)) &&
	    sap->username[0]) {
   	ssp->perm.readgroups |= sap->mask;
      return 0;
	}
	return -1;
}

/*** BeginHeader sspec_removeuser */

/* START FUNCTION DESCRIPTION ********************************************
sspec_removeuser                       <ZSERVER.LIB>

SYNTAX: int sspec_removeuser(int sspec, int userid);

KEYWORDS:		tcpip, server

DESCRIPTION:	Removes the group(s) which userid belong to from the
               read and write access masks for the specified resource.

               Note: this will deny access to other users who have
               the same group(s) as the current user.

PARAMETER1: 	spec index
PARAMETER2: 	user index

RETURN VALUE:   0		success, user was removed
               -1		failure, no such userid found

SEE ALSO:      sspec_setuser, sspec_adduser, sspec_getusername,
					sspec_getuserid

END DESCRIPTION **********************************************************/

int sspec_removeuser(int sspec, int userid);
/*** EndHeader */

_zserver_nodebug int sspec_removeuser(int sspec, int userid)
{
   auto ServerSpec * ssp;
   auto ServerAuth * sap;

	if ((ssp = sspec_ramhandle(sspec)) &&
       (sap = sauth_pointer(userid)) &&
	    sap->username[0]) {
   	ssp->perm.readgroups &= ~sap->mask;
   	ssp->perm.writegroups &= ~sap->mask;
      return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setrealm */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setrealm                         <ZSERVER.LIB>

SYNTAX: int sspec_setrealm(int sspec, char* realm);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set the realm of a spec entry (usu. for HTTP authentication
					purposes).  Setting this enables authentication for the
					given spec entry.  Authentication can be turned off again
					by passing "" or NULL as the realm parameter to this function.

               Note: "realm" must NOT point to an auto variable, since only
               the pointer is stored.  The string is NOT copied.

PARAMETER1: 	spec index.  This must refer to the RAM table.
PARAMETER2: 	name of realm

RETURN VALUE:   0	success
               -1	failure

SEE ALSO:      sspec_getrealm

END DESCRIPTION **********************************************************/

int sspec_setrealm(int sspec, char* realm);
/*** EndHeader */

_zserver_nodebug int sspec_setrealm(int sspec, char* realm)
{
	auto ServerSpec * ssp;
	if (ssp = sspec_ramhandle(sspec)) {
		ssp->perm.realm = realm;
      if (!*realm)
			ssp->perm.realm = NULL;	// "" and NULL considered equivalent.  Store NULL.
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_findname */

/* START FUNCTION DESCRIPTION ********************************************
sspec_findname                         <ZSERVER.LIB>

SYNTAX: int sspec_findname(const char far * name, word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Find the spec entry with a name field that matches the given
					name and is allowed with the specified server(s).  Note
               that a leading slash in 'name' and/or in the resource name
               is ignored for backwards compatibility.

PARAMETER1: 	name to search for
PARAMETER2: 	the server making the request (e.g., SERVER_HTTP).

RETURN VALUE:  >= 0	spec index.  The special value SSPEC_VIRTUAL is
                     returned if the name refers to part of the
                     virtual filesystem hierarchy.  In this case,
                     the server mask is not consulted.  SSPEC_VIRTUAL
                     is _not_ a valid handle for other functions.
               -1		failure

SEE ALSO:		sspec_findnextfile

END DESCRIPTION **********************************************************/

int sspec_findname(const char __far * name, word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_findname(const char __far * name, word servermask)
{
	auto int i, isdir;
   auto const ServerSpec * ssp;
   auto const char __far * rn;

   if (!(servermask & SERVER_ERROR) && sspec_name_virtual(name, NULL, NULL, 0, &isdir))
   	return SSPEC_VIRTUAL;
   if (*name == '/') ++name;

	for (i = 0; i < SSPEC_MAXSPEC; i++) {
   	ssp = server_spec + i;
      rn = ssp->name;
      if (*rn == '/') ++rn;
		if (ssp->type != SSPEC_UNUSED &&
      	 !strncmp(rn, name, SSPEC_MAXNAME) &&
		    (!ssp->perm.servermask || ssp->perm.servermask & servermask))
	   	return SSPEC_RAM_HANDLE(i);
	}
#ifndef SSPEC_NO_STATIC
	for (i = 0; i < sizeof(http_flashspec)/sizeof(http_flashspec[0]); i++) {
   	ssp = http_flashspec + i;
      rn = ssp->name;
      if (*rn == '/') ++rn;
		if (!strncmp(rn, name, SSPEC_MAXNAME) &&
		    (!ssp->perm.servermask || ssp->perm.servermask & servermask)) {
		    return SSPEC_FLASH_HANDLE(i);
		}
   }
#endif

	return -1;
}



/*** BeginHeader sspec_findnextfile */

/* START FUNCTION DESCRIPTION ********************************************
sspec_findnextfile                     <ZSERVER.LIB>

SYNTAX: int sspec_findnextfile(int start, word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Find the first spec file entry at or following the start
					spec that is accessible by the given server.  When the
               end of the RAM entries is reached, the flash entries are
               searched.  Virtual filesystem entries are not considered.
               Only entries for which sspec_gettype() would return
               SSPEC_FILE are considered.

               If you are using this function to iterate through the
               available resources, then the caller is responsible for
               incrementing the starting point.  To do this, you can
               call the function sspec_nexthandle() which will return
               the next valid handle after the given one (or -1 if
               no more handles).

PARAMETER1: 	spec entry at which to begin the search.  -1 starts
               searching the RAM entries.
PARAMETER2: 	the server(s) making the request (e.g., SERVER_HTTP)

RETURN VALUE:  >= 0	spec index
               -1		no more

SEE ALSO:		sspec_findname, sspec_gettype

END DESCRIPTION **********************************************************/

int sspec_findnextfile(int start, word servermask);
/*** EndHeader */

_zserver_nodebug int sspec_findnextfile(int start, word servermask)
{
	auto int sspec;
   auto ServerSpec * ssp;

	if (start < 0)
		sspec = sspec_nexthandle(-1);
	else
		sspec = start;
	while ((ssp = sspec_nvhandle(sspec)) &&
   		 (!(!ssp->perm.servermask || ssp->perm.servermask & servermask)))
		sspec = sspec_nexthandle(sspec);
	return ssp ? sspec : -1;
}

/*** BeginHeader sspec_getfileloc */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfileloc                       <ZSERVER.LIB>

SYNTAX: long sspec_getfileloc(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Get the location of the file represented by the given spec
					index.  Note that the location of the file is returned as
					a long, even if the file location should be represented by
					a char* (for a root file) or a FileNum (for the file
					system).  The return value should be cast to the
					appropriate type by the caller.  See sspec_getfiletype()
					for getting the type of file.

PARAMETER1: 	spec index of the file

RETURN VALUE:  >= 0	location of file
               -1		failure

SEE ALSO:		sspec_getfiletype, sspec_getlength

END DESCRIPTION **********************************************************/

long sspec_getfileloc(int sspec);
/*** EndHeader */

_zserver_nodebug long sspec_getfileloc(int sspec)
{
   auto ServerSpec * ssp;

   ssp = sspec_nvhandle(sspec);
	if (ssp) switch (sspec_actualtype(ssp)) {
   	case SSPEC_ROOTFILE: return (long)ssp->format;
      case SSPEC_ZMEMFILE:
      case SSPEC_FSFILE:
      case SSPEC_XMEMFILE: return ssp->data;
   }
	return -1L;
}

/*** BeginHeader sspec_getfiletype */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfiletype                      <ZSERVER.LIB>

SYNTAX: word sspec_getfiletype(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION:	Get the type of file represented by the given spec handle.

PARAMETER1: 	spec index of the file

RETURN VALUE:  SSPEC_ROOTFILE	root memory data
               SSPEC_XMEMFILE xmem data
               SSPEC_ZMEMFILE compressed xmem data
               SSPEC_FSFILE   FS2 file
               SSPEC_ERROR		failure - not a file, or invalid handle

SEE ALSO:		sspec_getfileloc, sspec_gettype

END DESCRIPTION **********************************************************/

word sspec_getfiletype(int sspec);
/*** EndHeader */

_zserver_nodebug word sspec_getfiletype(int sspec)
{
	auto ServerSpec * ssp;
	if (!(ssp = sspec_nvhandle(sspec)) || sspec_gettype(sspec) != SSPEC_FILE)
		return SSPEC_ERROR;
	return sspec_actualtype(ssp);
}

/*** BeginHeader sspec_findfv */

/* START FUNCTION DESCRIPTION ********************************************
sspec_findfv                           <ZSERVER.LIB>

SYNTAX: int sspec_findfv(int form, char* varname);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Find the index of a form variable in the given form.

PARAMETER1: 	spec index of form in which to search
PARAMETER2: 	name of the variable

RETURN VALUE:  >= 0	form variable index
               -1		failure

SEE ALSO:		sspec_addfv

END DESCRIPTION **********************************************************/

int sspec_findfv(int form, char* varname);
/*** EndHeader */

_zserver_nodebug int sspec_findfv(int form, char* varname)
{
	auto int i;
	auto FormVar* fv;
   auto ServerSpec * ssp, * vssp;

	if (!(ssp = sspec_nvhandle(form)) || ssp->type != SSPEC_FORM)
   	return -1;

   for (i = 0; i < ssp->highvar; i++) {
      fv = ((FormVar *)ssp->addr) + i;
      vssp = sspec_nvhandle(fv->varspec);
      if (vssp && !strncmp(vssp->name, varname, SSPEC_MAXNAME))
         return fv->readonly ? -1 : i;
   }
   return -1;
}

/*** BeginHeader sspec_checkfv */
int sspec_checkfv(int form, int var, char* value);
/*** EndHeader */

_zserver_nodebug int sspec_checkfv(int form, int var, char* value)
{
	auto FormVar* fv;
	auto int i;
	auto long testlong;
	auto float testfloat;
	auto char* end;

	fv = ((FormVar *)sspec_nvhandle(form)->addr) + var;
	switch (sspec_nvhandle(fv->varspec)->vartype) {
	case INT8:
		testlong = _n_strtol(value, &end, 10);
		for (; *end != '\0'; end++) {
			if (*end != ' ') {
				return -1;
			}
		}
		if (fv->rangeset == 1) {
			if ((testlong > fv->high) || (testlong < fv->low)) {
				return -1;
			}
		} else {
			if ((testlong > CHAR_MAX) || (testlong < CHAR_MIN)) {
				return -1;
			}
		}
		if (fv->varcheck != NULL) {
			if (fv->varcheck((int)testlong) != 0) {
				return -1;
			}
		}
		return 0;

	case INT16:
		testlong = _n_strtol(value, &end, 10);
		for (; *end != '\0'; end++) {
			if (*end != ' ') {
				return -1;
			}
		}
		if (fv->rangeset == 1) {
			if ((testlong > fv->high) || (testlong < fv->low)) {
				return -1;
			}
		} else {
			if ((testlong > INT_MAX) || (testlong < INT_MIN)) {
				return -1;
			}
		}
		if (fv->varcheck != NULL) {
			if (fv->varcheck((int)testlong) != 0) {
				return -1;
			}
		}
		return 0;

	case INT32:
		testlong = _n_strtol(value, &end, 10);
		for (; *end != '\0'; end++) {
			if (*end != ' ') {
				return -1;
			}
		}
		if ((testlong == LONG_MAX) || (testlong == LONG_MIN)) {
			return -1;
		}
		if (fv->rangeset == 1) {
			if ((testlong > fv->high) || (testlong < fv->low)) {
				return -1;
			}
		}
		if (fv->varcheck != NULL) {
			if (fv->varcheck(testlong) != 0) {
				return -1;
			}
		}
		return 0;

	case FLOAT32:
		testfloat = _n_strtod(value, &end);
		for (; *end != '\0'; end++) {
			if (*end != ' ') {
				return -1;
			}
		}
		if (fv->rangeset == 1) {
			if ((testfloat > fv->fhigh) || (testfloat < fv->flow)) {
				return -1;
			}
		}
		if (fv->varcheck != NULL) {
			if (fv->varcheck(testfloat) != 0) {
				return -1;
			}
		}
		return 0;

	case PTR16:
		if (strlen(value) > fv->varlen) {
			return -1;
		}
		if (fv->valueslen > 0) {
			for (i = 0; i < fv->valueslen; i++) {
				if (strncmp(value, fv->values[i], fv->varlen) == 0) {
					break;
				}
			}
			if (i >= fv->valueslen) {
				return -1;
			}
		}
		if (fv->varcheck != NULL) {
			if (fv->varcheck(value) != 0) {
				return -1;
			}
		}
		return 0;

	default:
		return -1;
	}
}

/*** BeginHeader sspec_changefv */
int sspec_changefv(int form, int var, char* value);
/*** EndHeader */

_zserver_nodebug int sspec_changefv(int form, int var, char* value)
{
	auto FormVar* fv;
   auto ServerSpec * vssp;

	fv = ((FormVar *)sspec_nvhandle(form)->addr) + var;
	switch ((vssp = sspec_nvhandle(fv->varspec))->vartype) {
	case INT8:
		*((char *)vssp->addr) = (char)_n_strtol(value, NULL, 10);
		break;

	case INT16:
		*((int *)vssp->addr) = (int)_n_strtol(value, NULL, 10);
		break;

	case INT32:
		*((long *)vssp->addr) = _n_strtol(value, NULL, 10);
		break;

	case FLOAT32:
		*((float *)vssp->addr) = _n_strtod(value, NULL);
		break;

	case PTR16:
		strncpy((char *)vssp->addr, value, fv->varlen);
		// Ensure NUL-termination
		((char *)vssp->addr)[fv->varlen] = '\0';
		break;

	default:
		return -1;
	}
	return 0;
}

/*** BeginHeader sspec_getlength */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getlength                            <ZSERVER.LIB>

SYNTAX: long sspec_getlength(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Get the length of the file specified by the sspec index.
               Note that compressed files (#zimport) return -1 because
               their expanded length is not known until they are
               processed.

PARAMETER1: 	spec index

RETURN VALUE:  >= 0	length of file
               -1		failure (compressed file, or other type whose
                     effective length is not known)

SEE ALSO:		sspec_readfile, sspec_getfileloc

END DESCRIPTION **********************************************************/

long sspec_getlength(int sspec);
/*** EndHeader */

_zserver_nodebug long sspec_getlength(int sspec)
{
	auto ServerSpec * ssp;
   auto SSpecFileHandle * sfh;
	auto long length, offs;

   if (SSPEC_IS_VIRT(sspec) && (sfh = sspec_fh(sspec))) {
   	if (sfh->vt->seek) {
      	// Get the current length of an open file by seek/tell.
      	offs = sfh->vt->tell ? sfh->vt->tell(sfh) : sfh->offset;
         sfh->vt->seek(sfh, 0L, SEEK_END);
         length = sfh->vt->tell ? sfh->vt->tell(sfh) : sfh->offset;
         sfh->vt->seek(sfh, offs, SEEK_SET);
			return length;
      }
   }
	else if (ssp = sspec_nvhandle(sspec)) {
		switch (sspec_actualtype(ssp)) {
		case SSPEC_ROOTFILE:
			return (long)ssp->vartype;
		case SSPEC_XMEMFILE:
			return xgetlong(ssp->data);
		}
	}
	return -1;
}

/*** BeginHeader sspec_readfile */

/* START FUNCTION DESCRIPTION ********************************************
sspec_readfile                             <ZSERVER.LIB>

SYNTAX: int sspec_readfile(int sspec, char* buffer, long offset, int len);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Read a file represented by the sspec index into a given
					buffer, starting at a given offset, and only copying a
					given length. For xmem files, this function automatically
					skips the first 4 bytes.  Hence, an offset of 0 marks the
					beginning of the file contents, not the file length.

               This function is intended for file types which do not
               require explicit 'open' or 'close' calls i.e. root or
               xmem files.  It can also be called for FS2 files, but this
               is not recommended since each call requires the file to
               be opened, seeked, read then closed.  Instead, use the
               sspec_readfilehandle() call which is more efficient, or
               use sspec_open(), sspec_read() and sspec_close() calls
               which are the most efficient.

               This function will NOT work for compressed xmem files
               or DOS FAT files.

PARAMETER1: 	spec index
PARAMETER2:		buffer in which to put the file contents
PARAMETER3:		offset in the file at which copying should begin
PARAMETER4:		number of bytes to copy

RETURN VALUE:  >= 0	number of bytes copied
               -1		failure

SEE ALSO:		sspec_getlength, sspec_getfileloc, sspec_readfilehandle,
					sspec_open, sspec_seek, sspec_read, sspec_close

END DESCRIPTION **********************************************************/

int sspec_readfile(int sspec, char* buffer, long offset, int len);
/*** EndHeader */

_zserver_nodebug int sspec_readfile(int sspec, char* buffer, long offset, int len)
{
	auto ServerSpec * ssp;
	auto long readin;
	auto int status;

	if (ssp = sspec_nvhandle(sspec)) switch (sspec_actualtype(ssp)) {
	   case SSPEC_ROOTFILE:
	      readin = (long)ssp->vartype;
	      if (offset >= readin)
	         return 0;
	      readin = (offset + len <= readin)?len:(readin - offset);
	      memcpy(buffer, (void*)(ssp->format+(unsigned int)offset), (size_t)readin);
	      return (int)readin;
	   case SSPEC_XMEMFILE:
	      readin = xgetlong(ssp->data);
	      if (offset >= readin)
	         return 0;
	      readin = (offset + len <= readin)?len:(readin - offset);
	      xmem2root(buffer, ssp->data+offset+4, (unsigned)readin);
	      return (int)readin;
	   default:
	      break;
	}
   return -1;
}

/*** BeginHeader sspec_openfilehandle */
int sspec_openfilehandle(SSpecFileHandle *handle, int sspec);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_openfilehandle                       <ZSERVER.LIB>

SYNTAX: int sspec_openfilehandle(SSpecFileHandle *handle, int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION:	This file opens a file handle to the given file.  This
					file handle can then be subsequently read using
               sspec_readfilehandle().  This interface provides a way
               to linearly read files.

					The SSpecFileHandle structure must be declared by the
               user, and its address must be passed in to this
               function.

               Note that any opened file handle MUST be closed with
               sspec_closefilehandle()--otherwise, it is a coding
               error.

               This function only works for flash and ram table
               entries.  See sspec_open() for a more general function.

PARAMETER1:		address of file handle structure
PARAMETER2:		spec index of file

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_readfilehandle, sspec_closefilehandle, sspec_readfile,
					sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_openfilehandle(SSpecFileHandle *handle, int sspec)
{
	auto ServerSpec * ssp;
   auto const SSpecVTable * vt;
   auto char * path;
   auto word partition;

   if (!handle)
   	return -1;
   handle->sspec = -1;
   handle->realspec = NULL;
   handle->offset = 0;
   handle->u = NULL;

	if (!(ssp = sspec_nvhandle(sspec)))
		return -1;
   handle->realspec = ssp;

   switch (sspec_actualtype(ssp)) {
   	// These don't need a SSpecFileUnion to be allocated.
   case SSPEC_ROOTFILE:
      handle->vt = &_sspec_rvt;
   	break;
   case SSPEC_XMEMFILE:
      handle->vt = &_sspec_xvt;
   	break;
#ifdef __ZIMPORT_LIB
	case SSPEC_ZMEMFILE:
   	// Compressed file
      vt = &_sspec_zvt;
		path = (char *)&ssp->data;
      partition = 0;
#endif
	_common:
		if (!(handle->u = (SSpecFileUnion *)pcalloc(&_sfup)))
      	return -1;	// Too many open files
		handle->vt = vt;
      if (vt->open(handle, path, partition, O_READ)) {
      	// Failed to open at lower level
         pfree(&_sfup, handle->u);
         handle->u = NULL;
			return -1;
      }
      break;
	default:
   	return -1;
   }
   handle->sspec = sspec;
   return 0;
}

/*** BeginHeader sspec_open */
int sspec_open(char __far * name, const ServerContext * context, word mode, word alloc);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_open                       <ZSERVER.LIB>

SYNTAX: int sspec_open(char far * name, const ServerContext * context,
                       word mode, word alloc);

KEYWORDS:		tcpip, server

DESCRIPTION:	Open a resource by name.  The name may refer
               to a flash- or ram-spec entry, or may be the name of a
               file in a filesystem.

               The resource namespace is specified as a directory
               hierarchy, similar to a Unix-like filesystem.  The root
               directory, '/', is the base for all named resources.

               If "fs2.lib" is included, then files stored in the FS2
               filesystem are accessible under a "mount point" called
               "/fs2".  FS2 files do not have native names.  Instead,
               each file is numbered from 1 to 255.  Zserver assigns
               names to FS2 files by appending the file number (in
               decimal) to the string "file".  For example, FS2 file
               number 99 has a complete resource name of "/fs2/file99".

               If "fatxx.lib" is included, then all DOS FAT files are
               mounted under a drive letter.  The first partition of the
               first DOS FAT filesystem is called "/A", the second
               partition (if any) is called "/B" etc.  For example,
               if the FAT filesystem has a file called
               "/system/admin.htm" then the complete resource name
               will be "/A/system/admin.htm".  [Note: forward
               slashes are required.  Do not use backslashes as is
               customary with DOS filesystems.]

               If the resource name does not begin with "/fs2" or
               "/A" etc., then the resource is located in the static
               resource table ("flashspec" i.e. the http_flashspec
               global table) or in the dynamic (RAM) table.

               The return value from this function must be passed to
               other functions, such as sspec_read(), in order to
               access the resource.  A few functions do not work with
               resources opened with this function.  These cases are
               documented with the function.

               NOTE!
               When the application has finished acessing the resource,
               it must be explicitly closed using sspec_close().  This
               must be done, since there is a limited amount of storage
               for maintaining the necessary file handles.

PARAMETER1:		Resource name, as a null terminated string.  This name
					is assumed to be relative to context->cwd if it does not
               begin with a '/' character.  Otherwise, the name is
               assumed to be relative to context->rootdir.  Note that the
               name string can contain "." and ".." directory components.
               These will be interpreted as 'same directory' and 'one
               level up' as is customary.  If '..' components are
               included, the resulting name cannot be above or outside
               the root directory specified in context->rootdir.
PARAMETER2:		Additional context information.  The ServerContext struct
					should be set up by the caller.  It contains the
               following fields:

                 typedef struct {
                 		int	userid;	// User ID of the current user, or
                     					// -1 if not applicable.
                     word	server;	// Server identifier (e.g. SERVER_HTTP)
                     char * rootdir;// Root directory.  This is usually
                     		 			// "/" if the whole namespace is to
                                    // be accessible.  Otherwise, it may
                                    // be e.g. "/A" to restrict access
                                    // to just the first DOS FAT partition.
                                    // -- first and last char must be '/'!
                     char cwd[];		// Current working directory.  This
                     					// would normally include rootdir as
                                    // a prefix.  First and last char
                                    // must be '/'.
                     char * dfltname;// A file name to be used as a
                     					// resource name suffix in the case
                                    // that the first parameter refers
                                    // to a directory name.
                 } ServerContext;
PARAMETER3:		Resource opening mode.  Bitwise OR of the following
					macros:
                 O_READ: open for reading
                 O_WRITE: open for writing (implies reading as well)
                 O_CREAT: with O_WRITE, if file does not exist then
                   create it with zero length and allocation.
                 O_TRUNC: with O_WRITE, if file already exists,
                   truncate it to zero length.
                 O_APPEND: with O_WRITE, if file already exists,
                   position at end of file so as to append new data.
                   You can later seek to the existing portion of the
                   file.
PARAMETER4:		Initial allocation mode (only if creating new resource).
               The value specifies the number of 1k blocks to pre-
               allocate.  This is ignored if the underlying file
               system does not support pre-allocation.  Note that
               passing a value which is too big will needlessly waste
               space in the filesystem.  Passing the correct value
               (or at least a good guess) can improve following
               write performance.

RETURN VALUE:   >=0		success.  The returned value should be passed to
						other function which require a general handle, such
                  as sspec_read(), sspec_seek(), sspec_write(),
                  sspec_tell(), and sspec_close().
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -ENOENT		The resource was not found when it was
                  expected to exist.
               -EACCES     The context->userid field was not -1, and
                  the specified user is not allowed to access the
                  resource using the specified mode.
               -EINVAL     The resource name was malformed (e.g. too long),
                  or context was NULL, or the resource was not a file type,
                  or O_CREAT,O_TRUNC or O_APPEND were specified without
                  O_WRITE.
               -ENOMEM		Insufficient storage for handle or buffers.
                  Increase definition of SSPEC_MAX_OPEN.
               -EPERM		Operation not permitted, e.g. opening an
                  xmem file for writing.

SEE ALSO:		sspec_read, sspec_write, sspec_seek, sspec_tell,
					sspec_close

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_open(char __far * name, const ServerContext * context, word mode, word alloc)
{
	auto char path[SSPEC_MAXNAME+1];
   auto const char __far * p;
   auto word partition;
   auto word fsystem;
   auto int sspec;
   auto int rc;
   auto int exists;
   auto const SSpecVTable * vt;
   auto SSpecFileHandle * sfh;
   auto SSpecFileUnion * sfu;
   auto ServerSpec * ssp;
   auto const ServerPermissions * spp;
   auto ServerAuth * sap;

#ifdef ZSERVER_VERBOSE
	printf("ZSRV: opening '%ls', mode %04X, alloc %u\n", name, mode, alloc);
#endif

	if (!context ||
   		!(mode & O_WRITE) && mode & (O_CREAT|O_TRUNC|O_APPEND))
   	return -EINVAL;
  	sap = sauth_pointer(context->userid);	// May be NULL.
#ifndef SSPEC_ALLOW_ANONYMOUS_WRITE
   if (!sap && mode & O_WRITE) {
	#ifdef ZSERVER_VERBOSE
      printf("ZSRV: anonymous user denied write\n");
	#endif
      return -EACCES;   // Anon user denied
   }
#endif
   if (p = sspec_name_parse(name, path, &partition, &spp, &vt, &ssp, context, 0, &fsystem)) {
#ifdef ZSERVER_VERBOSE
		printf("ZSRV: path '%s' partition=%04X fsystem=%04X\n", path, partition, fsystem);
#endif
   	// Test accessibility (R/W)
     	if (spp && !(!spp->servermask || context->server & spp->servermask)) {
#ifdef ZSERVER_VERBOSE
			printf("ZSRV: server %04X denied\n", context->server);
#endif
      	return -EACCES;	// Server denied in general
      }
      if (spp && sap) {
      	if (mode & O_WRITE && !(sap->mask & spp->writegroups && sap->writeaccess & context->server) ||
             mode & O_READ && !(sap->mask & spp->readgroups)) {
#ifdef ZSERVER_VERBOSE
				printf("ZSRV: server %04X, user %d denied\n", context->server, context->userid);
#endif
         	return -EACCES;
			}
      }
      // Make sure the necessary methods are available for the mode.
      if (mode & O_WRITE && !vt->write)
      	return -EPERM;
      if (mode & O_CREAT && !vt->create)
      	return -EPERM;
      if (mode & O_TRUNC && (!vt->delete || !vt->create))
      	return -EPERM;
      if (mode & O_APPEND && (!vt->extensible || !vt->extensible(p, partition) || !vt->seek ||
      						!vt->tell && !vt->length))
      	return -EPERM;
      // Now action the mode flags
      exists = vt->exists ? vt->exists(p, partition) : 1;
#ifdef ZSERVER_VERBOSE
		printf("ZSRV: mode OK, %s\n", exists ? "exists" : "create");
#endif
      if (mode & O_CREAT && !exists) {
      	rc = vt->create(p, partition, 1024L * alloc);
         if (rc < 0)
         	return rc;
         mode &= ~O_TRUNC;
         exists = 1;
      }
      if (mode & O_TRUNC && exists) {
			// truncation is implemented as delete/create
         rc = vt->delete(p, partition);
         if (rc < 0)
         	return rc;
			rc = vt->create(p, partition, 0L);
         if (rc < 0)
         	return rc;
      }
      // Allocate SSpecFileHandle from pool, and a virtual sspec handle.
		sfh = (SSpecFileHandle *)palloc(&_sfhp);
      if (!sfh)
      	return -ENOMEM;
		sfu = (SSpecFileUnion *)palloc(&_sfup);
      if (!sfu) {
      	pfree(&_sfhp, sfh);
      	return -ENOMEM;
      }
      memset(sfh, 0, sizeof *sfh);
      memset(sfu, 0, sizeof *sfu);
      sfh->perm = spp;
		sfh->u = sfu;
      // If the entry is from the flash or RAM table, store pointer to it.  (Else it will be null).
     	sfh->realspec = ssp;
     	// Index of entry allocated (0..SSPEC_MAX_OPEN-1) in lo byte,
		// uniquifier in high byte...
      sspec = sfh->sspec = (sfh - _sfhstore) | _sspec_nexthandle;
#ifdef ZSERVER_VERBOSE
		printf("ZSRV: allocated, sspec=%04X\n", sspec);
#endif
		_sspec_nexthandle += 256;
      if (_sspec_nexthandle < 0)
      	_sspec_nexthandle = 1024;
      sfh->offset = 0;
      sfh->vt = vt;
   #ifdef SSPEC_USEDEV
      if ((fsystem & 0x00FF) == SSPEC_DEVFILE)
			sfu->devdata.sde = _sspec_devtable + (fsystem>>8);
   #endif
      if (vt->open && (rc = vt->open(sfh, p, partition, mode))) {
#ifdef ZSERVER_VERBOSE
			printf("ZSRV: failed to open, rc=%d\n", rc);
#endif
	      // Free memory resources
	      pfree(&_sfup, sfu);
	      sfh->u = NULL; // Trash pointer, to catch errors.
	      pfree(&_sfhp, sfh);
      	return rc;	// Usually -ENOENT if error
      }
		if (mode & O_APPEND) {
			vt->seek(sfh, 0L, SEEK_END);
         if (vt->tell)
         	sfh->offset = vt->tell(sfh);
         else
         	sfh->offset = vt->length(p, partition);
      }
   }
   else {
   	// Not a file.  This is OK, just return the ram or flash sspec for it.
      // Note that the SERVER_ERROR flag just tells sspec_findname not to examine the
      // virtual filesystem hierarchy.
      sspec = sspec_findname(path, context->server | SERVER_ERROR);
      if (sspec < 0)
      	return -EINVAL;
#ifdef ZSERVER_VERBOSE
      printf("ZSRV: static resource, sspec=%04X\n", sspec);
#endif
      ssp = sspec_nvhandle(sspec);
      spp = &ssp->perm;
      if (spp && sap) {
      	if (mode & O_WRITE && !(sap->mask & spp->writegroups && sap->writeaccess & context->server) ||
             mode & O_READ && !(sap->mask & spp->readgroups)) {
#ifdef ZSERVER_VERBOSE
				printf("ZSRV: server %04X, user %d denied\n", context->server, context->userid);
#endif
         	return -EACCES;
			}
      }
   }
   return sspec;
}

/*** BeginHeader sspec_stat */
int sspec_stat(char * name, ServerContext * context, SSpecStat * s);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_stat                       <ZSERVER.LIB>

SYNTAX: int sspec_stat(char * name, ServerContext * context,
								SSpecStat * s);

KEYWORDS:		tcpip, server

DESCRIPTION:   Get information about a resource by name.  The name may
               refer to a flash- or ram-spec entry, or may be the name
               of a file in a filesystem.

					See sspec_open() for a more detailed description of the
               name and context parameters.

PARAMETER1:		Resource name, as a null terminated string.  This name
					is assumed to be relative to context->cwd if it does not
               begin with a '/' character.  Otherwise, the name is
               assumed to be relative to context->rootdir.
PARAMETER2:		Additional context information.  The ServerContext struct
					should be set up by the caller.
PARAMETER3:		Returned data.  This should be a pointer to the following
               structure, which will be filled in on return.
	               typedef struct
	               {
	                  word     flags;
	               #define SSPEC_ATTR_MDTM    0x0001
                        // Have modification date/time
	               #define SSPEC_ATTR_LENGTH  0x0002
                        // Have current length
	               #define SSPEC_ATTR_WRITE   0x0004
                        // File is writable
	               #define SSPEC_ATTR_EXEC    0x0008
                        // File is "executable"
	               #define SSPEC_ATTR_HIDDEN  0x0010
                        // "Hidden" attribute bit
	               #define SSPEC_ATTR_SYSTEM  0x0020
                        // "System" attribute bit
	               #define SSPEC_ATTR_ARCHIVE 0x0040
                        // "Archive" attribute bit
	               #define SSPEC_ATTR_DIR     0x0080
                        // This is directory name
	               #define SSPEC_ATTR_COMPRESSED 0x0100
                     // File stored in compressed format
	               #define SSPEC_ATTR_MAXLENGTH  0x0200
                     // Have maximum length
	               #define SSPEC_ATTR_SEEKABLE   0x0400
                     // Resource is randomly accessible
	               #define SSPEC_ATTR_EXTENSIBLE 0x0800
                     // File may be expanded at end

	                  long     mdtm;
                        // Modification date/time (SEC_TIMER format)
                        // Only valid of SSPEC_ATTR_MDTM set.
	                  long     length;
                        // Current file size
                        // Only valid of SSPEC_ATTR_LENGTH set.
	                  long     maxlength;
                        // Maximum allowable file size
                        // Only valid of SSPEC_ATTR_MAXLENGTH set.
	                  ServerPermissions *
	                           perm;
                        // Access (groups and server).  See below.
	               } SSpecStat;

               The ServerPermissions struct is defined as follows:
	               typedef struct {
	                  word readgroups;
                                   // Read permission granted if current
                                   // ServerAuth.mask (i.e. userid
                                   // entry group mask) matches in at
	                                // least one bit position.
	                  word writegroups;
                                   // Similar, for write access.
	                  word servermask;
                                   // Bit set for each server which can
                                   // access this resource.
	                  char * realm; // Realm string of the resource (only
                                   // used by HTTP server, but can
	                                // be used for other purposes).
	                  char  method; // Authentication method(s) allowed:
                                   // combination of SERVER_AUTH_* bits.
	               } ServerPermissions;


RETURN VALUE:   >=0		success.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -ENOENT		The resource was not found.
               -EINVAL     The resource name was malformed (e.g. too long),
                  or context was NULL, or the resource was not a file type.

SEE ALSO:		sspec_open, sspec_delete, sspec_close

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_stat(char * name, ServerContext * context, SSpecStat * s)
{
	auto char path[SSPEC_MAXNAME+1];
   auto const char __far * p;
   auto word partition;
   auto const SSpecVTable * vt;

	if (!context)
   	return -EINVAL;
   // Note: we set the 'look for directory' flag here, to avoid adding the default
   // name from the context.
   if (p = sspec_name_parse(name, path, &partition, &s->perm, &vt, NULL, context, 1, NULL))
      return vt->stat(p, partition, s);
   else
   	return -EINVAL;
}

/*** BeginHeader sspec_access */
int sspec_access(char * name, ServerContext * context);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_access                       <ZSERVER.LIB>

SYNTAX: int sspec_access(char * name, ServerContext * context);

KEYWORDS:		tcpip, server

DESCRIPTION:	Test access to a given resource by a specified user.
					The userid is set in context->userid, or -1 for
               testing access by the server in general.

               Note: sspec_checkpermissions() performs a similar
               function, except on a resource handle rather than
               a resource name.

PARAMETER1:		Resource name, as a null terminated string.  This name
					is assumed to be relative to context->cwd if it does not
               begin with a '/' character.  Otherwise, the name is
               assumed to be relative to context->rootdir.
PARAMETER2:		Additional context information.  The ServerContext struct
					should be set up by the caller.  See sspec_open() for
               documentation on this structure.  For this function,
               context->userid should be set to the current user whose
               access is being tested, or may be set to -1 to test access
               by the server in general.

RETURN VALUE:  >=0		success.  The return value is a bitmask of the
                  following values:
                    O_READ  - user+server has read access
                    O_WRITE - user+server has write access
                    0 (zero) - no access
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -ENOENT		The resource was not found.
               -EINVAL     The resource name was malformed (e.g. too long),
                  or context was NULL, or the resource was not a file type.

SEE ALSO:		sspec_read, sspec_write, sspec_seek, sspec_tell,
					sspec_close, sspec_checkpermissions

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_access(char * name, ServerContext * context)
{
	auto char path[SSPEC_MAXNAME+1];
   auto const char __far * p;
   auto word partition;
   auto const SSpecVTable * vt;
   auto ServerAuth * sap;
   auto const ServerPermissions * spp;
   auto int rc;

	if (!context)
   	return -EINVAL;
  	sap = sauth_pointer(context->userid);	// May be NULL.
   if (p = sspec_name_parse(name, path, &partition, &spp, &vt, NULL, context, 0, NULL)) {
     	if (!(!spp->servermask || context->server & spp->servermask))
      	return 0;
      if (spp && sap) {
	      rc = 0;
      	if (sap->mask & spp->writegroups && sap->writeaccess & context->server)
         	rc |= O_WRITE;
      	if (sap->mask & spp->readgroups)
         	rc |= O_READ;
         return rc;
      }
		return O_READ|O_WRITE;	// Testing server only, assume read+write
   }
   else
   	return -EINVAL;
}

/*** BeginHeader sspec_close */
int sspec_close(int sspec);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_close                       <ZSERVER.LIB>

SYNTAX: int sspec_close(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION:	Close a file.  This function must be called by servers
					when they have completed operations on the file, otherwise
               there will be a resource leak and future open calls will
               fail.

PARAMETER1:		Open file handle.  This must be a handle that was returned
					by sspec_open().

RETURN VALUE:   >=0		success.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -EBADF		The specified handle was not open or invalid.
               Other -ve values indicate an error in closing the resource.

SEE ALSO:		sspec_read, sspec_write, sspec_seek, sspec_tell,
					sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_close(int sspec)
{
   auto SSpecFileHandle * sfh;
   auto int rc;

   if (!(sfh = sspec_fh(sspec)))
   	return -EBADF;

   // Passed validity checks.  Call specific close function, if any.
   if (sfh->vt->close)
   	rc = sfh->vt->close(sfh);
   else
   	rc = 0;
	// Free memory resources
   pfree(&_sfup, sfh->u);
   sfh->u = NULL;	// Trash pointer, to catch errors.
   pfree(&_sfhp, sfh);
   return rc;
}


/*** BeginHeader sspec_read */
int sspec_read(int sspec, char __far * buf, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_read                       <ZSERVER.LIB>

SYNTAX: int sspec_read(int sspec, char far * buf, int len);

KEYWORDS:		tcpip, server

DESCRIPTION:	Read the next byte(s) from the given resource.

PARAMETER1:		Open file handle.  This must be a handle that was returned
					by sspec_open().
PARAMETER2:		Buffer into which data is copied.
PARAMETER3:		Length of the above buffer.  If len is zero, then the
               return value will be the minimum number of characters
               that could be read at the current position, which is
               usually at least 1 except at EOF (0).  Thus, this function
               can also be used to test for EOF e.g.
                 if (sspec_read(sspec, NULL, 0) == 0)
                 		... is at EOF ...

RETURN VALUE:  0: No data is currently available.  If the len parameter
                  was zero, then a return value of 0 definitely means
                  end-of-file has been reached.  If len > 0, there may
                  be data available in the future e.g. because the
                  underlying filesystem is socket-based and this host
                  has read all available data, but the socket is still
                  open to receive more data.
               1..len: the specified number of characters has been copied
                  to the supplied buffer, and the current file position
                  has been advanced by that many bytes.  Possibly less
                  than len bytes may be read, in which case the server
                  should test for EOF.
               >len: no data was copied, because the underlying filesystem
                  is unable to return a partial record and maintain its
                  current position.  The return value is the minimum
                  sized buffer which should be passed on the next call.
                  Note: this sort of return is not currently implemented
                  by any of the file systems, however servers should be
                  coded to handle this case for future anticipated systems
                  which have record-level access rather than byte-level.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -EINVAL		len parameter was < 0.
               -EBADF		The specified handle was not open or invalid.
               Any other negative values indicate an error.

SEE ALSO:		sspec_close, sspec_write, sspec_seek, sspec_tell,
					sspec_open, sspec_readchr

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_read(int sspec, char __far * buf, int len)
{
   auto SSpecFileHandle * sfh;
   auto int rc;

   if (len < 0)
   	return -EINVAL;
   if (!(sfh = sspec_fh(sspec)) || !sfh->vt->read)
   	return -EBADF;

   // Passed validity checks.  Call specific read function (which must exist).
  	rc = sfh->vt->read(sfh, buf, len);
   if (rc > 0 && rc <= len)
   	sfh->offset += rc;
   return rc;
}


/*** BeginHeader sspec_readchr */
int sspec_readchr(int sspec, char __far * buf, int len, char delim);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_readchr                       <ZSERVER.LIB>

SYNTAX: int sspec_readchr(int sspec, char far * buf, int len, char delim);

KEYWORDS:		tcpip, server

DESCRIPTION:	Read the next byte(s) from the given resource, until
               specified delimiter is read and transferred to buffer.
               If EOF is encountered before reading a delimiter char,
               then the buffer may not be terminated with the delimiter
               char.  Similarly if the delimiter was not found before
               the given buffer was full.  The buffer is *not* null
               terminated.

PARAMETER1:		Open file handle.  This must be a handle that was returned
					by sspec_open().
PARAMETER2:		Buffer into which data is copied.
PARAMETER3:		Length of the above buffer.
PARAMETER4:		Delimiter character.

RETURN VALUE:  0: No data is currently available.
               1..len: the specified number of characters has been copied
                  to the supplied buffer, and the current file position
                  has been advanced by that many bytes.  Possibly less
                  than len bytes may be read, in which case the server
                  should test for EOF.
               >len: no data was copied, because the underlying filesystem
                  is unable to return a partial record and maintain its
                  current position.  The return value is the minimum
                  sized buffer which should be passed on the next call.
                  Note: this sort of return is not currently implemented
                  by any of the file systems, however servers should be
                  coded to handle this case for future anticipated systems
                  which have record-level access rather than byte-level.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -EINVAL		len parameter was < 0.
               -EBADF		The specified handle was not open or invalid.
               Any other negative values indicate an error.

SEE ALSO:		sspec_close, sspec_read, sspec_seek, sspec_tell,
					sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_readchr(int sspec, char __far * buf, int len, char delim)
{
	auto char rbuf[64];
   auto int rc;
   auto int rlen;
   auto char * p;
   auto int m;

	rlen = 0;
	for (;;) {
		m = len - rlen;
		if (!m)
			return rlen;
		if (m > sizeof(rbuf))
			m = sizeof(rbuf);
		rc = sspec_read(sspec, rbuf, m);
		if (rc <= 0)
			return rc;
		if (rc > m)
			return -EPERM;	// op not permitted because of record buffering
		p = memchr(rbuf, delim, rc);
		if (p) {
			m = p - rbuf + 1;
			_f_memcpy(buf, rbuf, m);
			rlen += m;
			if (m < rc) {
				// Seek so next call re-reads the tail end we are discarding
				rc = sspec_seek(sspec, m - rc, SEEK_CUR);
				if (rc < 0)
					return rc;
			}
			return rlen;
		}
		_f_memcpy(buf, rbuf, rc);
		rlen += rc;
		buf += rc;
	}

   return rc;
}


/*** BeginHeader sspec_write */
int sspec_write(int sspec, char __far * buf, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_write                       <ZSERVER.LIB>

SYNTAX: int sspec_write(int sspec, char far * buf, int len);

KEYWORDS:		tcpip, server

DESCRIPTION:	Write byte(s) to the given resource.  The data is written
               to the current position, then the current position is
               advanced by the number of bytes written.

PARAMETER1:		Open file handle.  This must be a handle that was returned
					by sspec_open().
PARAMETER2:		Buffer from which data is copied.
PARAMETER3:		Length of the above buffer.

RETURN VALUE:  0: No data was written because len was zero or because
                  a local buffer is full (e.g. when writing to an
                  underlying filesystem that streams data to a peer).
               1..len: the specified number of characters has been copied
                  from the supplied buffer, and the current file position
                  has been advanced by that many bytes.  Possibly less
                  than len bytes may be written, in which case the server
                  should attempt to write the remaining data later.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -EINVAL		len parameter was < 0.
               -EBADF		The specified handle was not open or invalid.
               -ENOSPC		There is insufficient space in the underlying
                  filesystem, or the file cannot be extended.
               -EPERM		The resource does not support writing (e.g.
                  xmem files, or a read-only filesystem).
               Any other negative values indicate an error.

SEE ALSO:		sspec_close, sspec_read, sspec_seek, sspec_tell,
					sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_write(int sspec, char __far * buf, int len)
{
   auto SSpecFileHandle * sfh;
   auto int rc;

   if (len < 0) {
   #ifdef ZSERVER_VERBOSE
   	printf("ZSRV: sspec_write len<0\n");
   #endif
   	return -EINVAL;
   }
   if (!(sfh = sspec_fh(sspec))) {
   #ifdef ZSERVER_VERBOSE
   	printf("ZSRV: sspec_write bad file handle\n");
   #endif
   	return -EBADF;
   }
   if (!sfh->vt->write) {
   #ifdef ZSERVER_VERBOSE
   	printf("ZSRV: sspec_write no write function\n");
   #endif
   	return -EPERM;
   }

   // Passed validity checks.  Call specific write function.
  	rc = sfh->vt->write(sfh, buf, len);
   if (rc > 0)
   	sfh->offset += rc;
   #ifdef ZSERVER_VERBOSE
   printf("ZSRV: sspec_write len=%d rc=%d offset=%ld\n", len, rc, sfh->offset);
   #endif
   return rc;
}


/*** BeginHeader _sspec_fatfile */
#ifdef SSPEC_USEFAT
FATfile * _sspec_fatfile(int sspec);
#endif
/*** EndHeader */
_zserver_nodebug
FATfile * _sspec_fatfile(int sspec)
{
	// Internal function: return FATFile point if this is a FAT resource,
   // else NULL.  This is handy for special functions (such as fat_Truncate)
   // which are not available to the generic sspec interface.
   auto SSpecFileHandle * sfh;
   if (!(sfh = sspec_fh(sspec))) {
   #ifdef ZSERVER_VERBOSE
   	printf("ZSRV: _sspec_fatfile bad file handle\n");
   #endif
   	return NULL;
   }
   if (sspec_vt(SSPEC_FATFILE) == sfh->vt)
   	return &sfh->u->fatfile;
   return NULL;
}


/*** BeginHeader sspec_seek */
int sspec_seek(int sspec, long offset, int whence);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_seek                       <ZSERVER.LIB>

SYNTAX: int sspec_seek(int sspec, long offset, int whence);

KEYWORDS:		tcpip, server

DESCRIPTION:	Seek to specified offset in the resource.  The next
					sspec_read() or sspec_write() call will start at this
               position.

               Note that offsets which are not in the file are 'clamped'
               the the start of end of the file as appropriate.

PARAMETER1:		Open file handle.  This must be a handle that was returned
					by sspec_open().
PARAMETER2:		Byte offset.
PARAMETER3:		Reference point for seek.  One of the following constants:
                 SEEK_SET: start of file.  offset should be non-negative.
                 SEEK_CUR: current position in file.  offset may be
                   negative, zero, or positive.
                 SEEK_END: end of file.  offset should be non-positive
                   to stay within the file.


RETURN VALUE:  0: OK.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -EINVAL		whence parameter was invalid.
               -EBADF		The specified handle was not open or invalid.
               -EPERM		Operation not permitted on this resource.  This
                  is usually because the resource is not seekable (such
                  as a compressed file).
               Any other negative values indicate an error.

SEE ALSO:		sspec_close, sspec_write, sspec_read, sspec_tell,
					sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_seek(int sspec, long offset, int whence)
{
   auto SSpecFileHandle * sfh;

   if (whence < SEEK_SET || whence > SEEK_END)
   	return -EINVAL;
   if (!(sfh = sspec_fh(sspec)))
   	return -EBADF;
	if (!sfh->vt->seek)
   	return -EPERM;

   // Passed validity checks.  Call specific seek function.  Note that the seek
   // method is responsible for maintaining sfh->offset.
  	return sfh->vt->seek(sfh, offset, whence);
}


/*** BeginHeader sspec_tell */
long sspec_tell(int sspec);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_tell                       <ZSERVER.LIB>

SYNTAX: long sspec_tell(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION:	Return the current read/write offset in the resource.  This
               will be a non-negative value unless there was an error.

PARAMETER1:		Open file handle.  This must be a handle that was returned
					by sspec_open().

RETURN VALUE:  >= 0: Offset in the resource.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -EBADF		The specified handle was not open or invalid.
               Any other negative values indicate an error.

SEE ALSO:		sspec_close, sspec_write, sspec_read, sspec_tell,
					sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug long sspec_tell(int sspec)
{
   auto SSpecFileHandle * sfh;

   if (!(sfh = sspec_fh(sspec)))
   	return -EBADF;
	if (!sfh->vt->tell)
   	return sfh->offset;
   // Passed validity checks.  Call specific tell function.
	return sfh->vt->tell(sfh);
}


/*** BeginHeader sspec_delete */
int sspec_delete(char __far * name, ServerContext * context);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_delete                       <ZSERVER.LIB>

SYNTAX: int sspec_delete(char * name, ServerContext * context);

KEYWORDS:		tcpip, server

DESCRIPTION:	Delete a resource, by name.  See sspec_open() for more
               detailed description of parameters.

PARAMETER1:		Name of resource.
PARAMETER2:		Current server context.

RETURN VALUE:  0: OK.
       			note: the following return values are negatives of the
                  values defined in "errno.h".
               -ENOENT		The specified resource did not exist.
               Any other negative values indicate an error.

SEE ALSO:		sspec_mkdir, sspec_rmdir, sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_delete(char __far * name, ServerContext * context)
{
	auto char path[SSPEC_MAXNAME+1];
   auto const char __far * p;
   auto word partition;
   auto int sspec;
   auto int rc;
   auto const SSpecVTable * vt;
   auto const ServerPermissions * spp;
   auto ServerSpec * ssp;
   auto ServerAuth * sap;

	if (!context)
   	return -EINVAL;
  	sap = sauth_pointer(context->userid);	// May be NULL.
   if (p = sspec_name_parse(name, path, &partition, &spp, &vt, &ssp, context, 0, NULL)) {
   	// Test accessibility (W)
     	if (spp && !(!spp->servermask || context->server & spp->servermask))
      	return -EACCES;	// Server denied in general
      if (spp && sap) {
      	if (!(sap->mask & spp->writegroups && sap->writeaccess & context->server))
         	return -EACCES;
      }
      // Make sure the necessary methods are available for the mode.
      if (!vt->delete)
      	return -EPERM;
      return vt->delete(p, partition);
   }
   return -EINVAL;
}


/*** BeginHeader sspec_mkdir */
int sspec_mkdir(char * name, ServerContext * context);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_mkdir                       <ZSERVER.LIB>

SYNTAX: int sspec_mkdir(char * name, ServerContext * context);

KEYWORDS:		tcpip, server

DESCRIPTION:	Create a named directory in the FAT filesystem.

PARAMETER1:		Name of new directory.
PARAMETER2:		Current server context.

RETURN VALUE:  0: OK.
					-EPERM: not a filesystem which supports creation of
                 new directories.
               -EACCES: not authorized
               Any other negative values indicate an error.

SEE ALSO:		sspec_delete, sspec_rmdir, sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_mkdir(char * name, ServerContext * context)
{
	auto char path[SSPEC_MAXNAME+1];
   auto const char __far * p;
   auto word partition;
   auto int sspec;
   auto int rc;
   auto const SSpecVTable * vt;
   auto ServerSpec * ssp;
   auto const ServerPermissions * spp;
   auto ServerAuth * sap;

	if (!context)
   	return -EINVAL;
  	sap = sauth_pointer(context->userid);	// May be NULL.
   if (p = sspec_name_parse(name, path, &partition, &spp, &vt, &ssp, context, 1, NULL)) {
   	// Test accessibility (W)
     	if (spp && !(!spp->servermask || context->server & spp->servermask))
      	return -EACCES;	// Server denied in general
      if (spp && sap) {
      	if (!(sap->mask & spp->writegroups && sap->writeaccess & context->server))
         	return -EACCES;
      }
      // Make sure the necessary methods are available for the mode.
      if (!vt->mkdir)
      	return -EPERM;
      return vt->mkdir(p, partition);
   }
   return -EINVAL;
}


/*** BeginHeader sspec_rmdir */
int sspec_rmdir(char * name, ServerContext * context);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_rmdir                       <ZSERVER.LIB>

SYNTAX: int sspec_rmdir(char * name, ServerContext * context);

KEYWORDS:		tcpip, server

DESCRIPTION:	Delete a named directory in the FAT filesystem.

PARAMETER1:		Name of directory to delete.
PARAMETER2:		Current server context.

RETURN VALUE:  0: OK.
					-EPERM: not a filesystem which supports deletion of
                 directories.
               -EACCES: not authorized
               Any other negative values indicate an error.

SEE ALSO:		sspec_delete, sspec_mkdir, sspec_open

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_rmdir(char * name, ServerContext * context)
{
	auto char path[SSPEC_MAXNAME+1];
   auto const char __far * p;
   auto word partition;
   auto int sspec;
   auto int rc;
   auto const SSpecVTable * vt;
   auto ServerSpec * ssp;
   auto const ServerPermissions * spp;
   auto ServerAuth * sap;

	if (!context)
   	return -EINVAL;
  	sap = sauth_pointer(context->userid);	// May be NULL.
   if (p = sspec_name_parse(name, path, &partition, &spp, &vt, &ssp, context, 1, NULL)) {
   	// Test accessibility (W)
     	if (spp && !(!spp->servermask || context->server & spp->servermask))
      	return -EACCES;	// Server denied in general
      if (spp && sap) {
      	if (!(sap->mask & spp->writegroups && sap->writeaccess & context->server))
         	return -EACCES;
      }
      // Make sure the necessary methods are available for the mode.
      if (!vt->rmdir)
      	return -EPERM;
      return vt->rmdir(p, partition);
   }
   return -EINVAL;
}


/*** BeginHeader sspec_cd */
int sspec_cd(char __far * path, ServerContext * context, int check);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_cd                       <ZSERVER.LIB>

SYNTAX: int sspec_cd(char * path, ServerContext * context, int check);

KEYWORDS:		tcpip, server

DESCRIPTION:	Change the current working directory in the ServerContext
               structure.  This function may be used by servers which
               support the concept of a 'current directory', such as FTP
               (but not HTTP).  Standard Unix-like path names are used,
               including support for '.' and '..' directory components.

               The resulting directory name is not allowed to be closer
               to the root directory than context->rootdir.  If there
               is any specification error, then the current directory
               is not changed.

               The resulting absolute directory name cannot be longer
               than SSPEC_MAXNAME, including a leading and trailing
               '/' character.

               If the 3rd parameter is true:

               If the new directory seems valid, it is checked to see
               if there is such a directory.  Only if the directory
               exists is the change made.

PARAMETER1:		New directory path string, as a null-terminated string.
					If this starts with '/', it is merely appended to the
               context->rootdir string.  Otherwise, it is appended to
               the current directory (in context->cwd).  Directory
               components are separated by '/' characters.  A trailing
               slash is optional.  A directory component '.' means
               'no change to this level', and a component of '..' means
               'up one level' (towards the root).
PARAMETER2:		Server context structure.  Two fields in this are of
					interest: rootdir points to a virtual root directory
               for this server.  E.g., if the FTP server was only
               allowed to access files under the /A/ directory, then
               rootdir would point to a string "/A/".  Then, if the
               user entered a directory name of "/ftpfiles/" then the
               full directory would be "/A/ftpfiles/".
               The other field, which is updated by this function, is
               called cwd.  This is an array of characters of length
               SSPEC_MAXNAME.  It contains the absolute path of the
               current directory, with leading and trailing slash,
               including the rootdir part (if any).
PARAMETER3:		If TRUE, check the resulting directory name to see if
               it exists.  Otherwise, no check is made.

RETURN VALUE:  0: OK.
               Any other negative values indicate an error:
               	-E2BIG   resulting directory name too long
                  -EACCES  attempt to change above root directory
                  -ENOENT  3rd parameter was TRUE, and the directory
                           did not exist.

SEE ALSO:		sspec_pwd

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_cd(char __far * path, ServerContext * context, int check)
{
	auto int rc;
	auto char abs[SSPEC_MAXNAME+2];	// Temp store for abs pathname

   if (rc = sspec_simplify(path, abs, context, 1))
   	return rc;
   if (check && !sspec_is_directory(abs))
   	return -ENOENT;
   strcpy(context->cwd, abs);
   return 0;
}


/*** BeginHeader sspec_pwd */
char * sspec_pwd(ServerContext * context, char * buf);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_pwd                       <ZSERVER.LIB>

SYNTAX: char * sspec_pwd(ServerContext * context, char * buf);

KEYWORDS:		tcpip, server

DESCRIPTION:	Print the current working directory in the ServerContext
               structure, to the specified buffer.  The context->cwd
               field contains the CWD.  This function removes the
               root directory component (context->rootdir) and copies
               the result.  This makes rootdir 'invisible' to the
               end user.

               The leading slash is included, but the trailing slash is
               omitted from the result (unless the result is just '/').

               Example:

                 context->rootdir points to "/A/"
                 context->cwd[] contains "/A/ftpfiles/"

                 result will be "/ftpfiles"

PARAMETER1:		Server context structure.  Two fields in this are of
					interest: rootdir points to a virtual root directory
               for this server, and cwd is a char array containing the
               CWD.
PARAMETER2:		Points to buffer which is filled with resulting string.
               This buffer is assumed to be dimensioned at least
               SSPEC_MAXNAME chars long, and it will be null terminated
               on return.

RETURN VALUE:  The buf parameter is returned.

SEE ALSO:		sspec_cd

END DESCRIPTION **********************************************************/

_zserver_nodebug char * sspec_pwd(ServerContext * context, char * buf)
{
	strcpy(buf, context->cwd + strlen(context->rootdir) - 1);
   if (strlen(buf) > 1)
   	buf[strlen(buf)-1] = 0;	// Zap trailing slash if wan't just '/'.
   return buf;
}


/*** BeginHeader sspec_ls_date */
char * sspec_ls_date(long t, char * buf);
/*** EndHeader */
#include "lc_time.h"
_zserver_nodebug char * sspec_ls_date(long t, char * buf)
{
	// Do ls -l format timestamp.  buf should be at least 13 bytes.
	// Returns buf.  t is a SEC_TIMER value.
	auto struct tm y;
	auto int dfmt;		// Whether "distant" format (Mon dd  yyyy), else "near"
							// format (Mon dd hh:mm).
	dfmt = t > SEC_TIMER || t < SEC_TIMER - 28000000;	// future or older than about 11 months
	mktm(&y, t);
	if (dfmt)
		_strftime( buf, 40, "%b %e  %Y", &y, &_lc_time_C);
	else
		_strftime( buf, 40, "%b %e %H:%M", &y, &_lc_time_C);
	return buf;
}


/*** BeginHeader sspec_dirlist */
int sspec_dirlist(int item, char __far *line, int linelen,
                 	ServerContext * context, word options);
#define SSPEC_LIST_LONG	0x0001
#define SSPEC_LIST_END	0x0002
#define SSPEC_LIST_BIN	0x0004

typedef struct {
   char  path[SSPEC_MAXNAME*2+1];
   int   isdir;         // Non-zero for directory
   long  length;        // File length (0 for dir)
   long  mod_date;      // Seconds since 1980
} sspec_ls_t;


/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_dirlist                       <ZSERVER.LIB>

SYNTAX:int sspec_dirlist(int item, char *line, int linelen,
                 	ServerContext * context, word options);

KEYWORDS:		tcpip, server

DESCRIPTION:	Return formatted directory listing line.  To use this
               function, call it with item=0 the first time, then keep
               calling it with item = <previous return value> until
               it returns negative.  This allows you to iterate through all
               entries in a directory.

               The ServerContext struct contains the current user ID,
               server, and the name of the directory to list.

               Note: For a given directory, you should call this function
               with item=0, followed by more calls until it returns -1.
               If you want to terminate the directory listing without
               iterating through every entry, pass the SSPEC_LIST_END
               option flag (see below).  This allows zserver to release
               any temporary resources acquired for the purpose of
               iterating through the directory.  This is especially
               important for FAT filesystem listings.  After this function
               returns negative, you must start the next directory listing
               from the top i.e. item=0.

               If you do not complete the listing, then your application
               may not be able to perform further listings owing to
               internal resource leakage -- this is similar to the need
               to close files which are opened.  See the 2nd example below.

               You should pass the same ServerContext struct for the
               entire directory list sequence, since zserver keeps track
               of state information in this struct.

EXAMPLE:			To iterate through all resources under "/A/":

						ServerContext ctx;
                  int item;
                  char buf[80];
                  word opts;
                  word n;

                  ctx.rootdir = "/";
                  ctx.server = SERVER_FTP;
                  ctx.userid = sauth_getuserid("foo", SERVER_FTP);
						sspec_cd("/A", &ctx);
						for (item = 0; item >= 0; ) {
							item = sspec_dirlist(item, buf, sizeof(buf),
                                          &ctx, SSPEC_LIST_LONG);
                     if (item >= 0)
                     	printf(buf);
                  }
                  // finished now, can re-use ctx.

               To iterate through the first 5 resources only:

               	opts = SSPEC_LIST_LONG;
						for (item = 0, n = 0; item >= 0; ++n) {
                     if (n >= 4)
                     	opts |= SSPEC_LIST_END;
							item = sspec_dirlist(item, buf, sizeof(buf),
                                          &ctx, opts);
                     if (item >= 0)
                     	printf(buf);
                  }


PARAMETER1:		Directory entry to list.  If zero, this always returns the
               first entry in the directory.  Thereafter, you should pass
               the return value from the previous call to this function
               to get the next item(s).  NOTE: the return value does not
               necessarily count up 1, 2, 3 etc.  Apart from 0, the only
               values you should pass in this parameter are previous
               return values, otherwise the results will be undefined.
PARAMETER2:		Points to buffer which is filled with resulting string.
					The string will be terminated with \r\n (CRLF) then a null.
PARAMETER3:		Length of the above buffer.  If it is not long enough, then
					the line will be truncated (however it will still have the
               terminating CRLF + null).  The minimum reasonable value
               is about 15 for format 0, and 80 for format 1.
PARAMETER4:		Server context.  This struct should have the following
					fields initialized:
                 userid: current user who is doing the listing, or -1
                         if no specific user.
                 server: mask bit of the server who is performing the
                         listing.
                 cwd[]:  set to the directory to list.  The sspec_cd()
                         function can be used to set this field
                         correctly.
               This struct must be the same instance for all calls in a
               single directory listing sequence.
PARAMETER5:		Listing options.  This is a bit field which should have
					a combination of the following flags:
                 SSPEC_LIST_LONG		Long format listing (else just names)
                 SSPEC_LIST_BIN		Binary format listing
                 SSPEC_LIST_END     Close the current directory listing.
               For the long format, the template is
                 <permissions> 1 <user> <group> <length> <date> <name>
               Where
               . permissions is a string of 10 characters in 3 sets
                 of 3, plus one.  Each set of 3 indicates read, write
                 or execute permissions for the user, group, and 'world'
                 respectively.  The 1st char is 'd' if the entry is a
                 directory, or '-' otherwise.  Since zserver does not
                 really support file owners or groups, or execute
                 permissions, the 3 sets will be either 'rw-' or 'r--'
                 or sometimes '-w-'.  The user bits are set according
                 to the current user's access.  The group bits are set
                 if any _other_ user has access, and the 'world' bits
                 are set if any other _server_ has access.
               . '1' is a constant for Unix compatibility.
               . user is the username who 'owns' the file.  Since zserver
                 does not have the concept of resource ownership, this is
                 set to the user ID of the context->userid field.  If
                 context->userid is -1, this is set to "anon".
               . group is the resource 'group name'.  zserver does not
                 support this Unix concept either, so this field is set
                 to the realm of the resource (if it has one) otherwise
                 it is set to "anon".
               . length is set to the current length of the file, or
                 0 if not known.
               . date is set to the modification date of the resource in
                 Mon dd yyyy format.
					. name is the name of the resource in this directory.
              Example:
                dr--r--r--  1  foo   admin    0   Jan 1  1980  ftpfiles
                -rw-rw-rw-  1  foo   admin  1250  Mar 16 2003  index.htm
					For the SSPEC_LIST_BIN format, the 'line' parameter points
               to a buffer of type sspec_ls_t, which will be populated
               with available data:
               typedef struct {
               	char	path[SSPEC_MAXNAME*2+1];
                  int	isdir;			// Non-zero for directory
						long	length;			// File length (0 for dir)
                  long	mod_date;		// Seconds since 1980
               } sspec_ls_t;

RETURN VALUE:  -EEOF: there were no (more) entries in this directory.
					Any other negative value: parameter or I/O error.
					Otherwise (non-negative): the return value should be passed
               back to this function as the 'item' parameter value, to
               retrieve the next entry.

SEE ALSO:		sspec_cd

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_dirlist(int item, char __far *line, int linelen,
                 	ServerContext * context, word options)
{
	auto SSpecStat stat;
	auto char path[SSPEC_MAXNAME+1];
	auto char fpath[SSPEC_MAXNAME*2+1];
   auto char datestr[16];
   auto const char __far * p;
   auto char * abs;
   auto word partition;
   auto word fsystem;
   auto int rc, frc;
   auto const SSpecVTable * vt;
   auto SSpecFileHandle * sfh;
   auto SSpecFileUnion * sfu;
   auto ServerSpec * ssp;
   auto const ServerPermissions * spp;
   auto ServerAuth * sap;
   auto word uread, uwrite, gread, gwrite, oread, owrite;
   auto sspec_ls_t __far * ls;

   if (!context)
   	return -EINVAL;
  	sap = sauth_pointer(context->userid);	// May be NULL.
	if (!item) {
      abs = context->cwd;
	   if (p = sspec_name_parse(context->cwd, context->cwd, &partition, &spp, &vt, &ssp, NULL, 1, &fsystem)) {
	      // Test accessibility (R)
	      if (spp && !(!spp->servermask || context->server & spp->servermask))
	         return -EACCES;   // Server denied in general
	      if (!vt->opendir)
	         return -EPERM;    // Directory listing not permitted (implemented) for this FS type
	      if (spp && sap && !(sap->mask & spp->readgroups))
	            return -EACCES;
	      // Allocate SSpecFileHandle from pool, and a virtual sspec handle.
	      sfh = (SSpecFileHandle *)palloc(&_sfhp);
	      if (!sfh)
	         return -ENOMEM;
	      sfu = (SSpecFileUnion *)palloc(&_sfup);
	      if (!sfu) {
	         pfree(&_sfhp, sfh);
	         return -ENOMEM;
	      }
         memset(sfh, 0, sizeof *sfh);
         memset(sfu, 0, sizeof *sfu);
	      context->dirlist = sfh;
	      sfh->u = sfu;
	      // If the entry is from the flash or RAM table, store pointer to it.  (Else it will be null).
	      sfh->realspec = ssp;
	      sfh->vt = vt;
      #ifdef SSPEC_USEDEV
      	if ((fsystem & 0x00FF) == SSPEC_DEVFILE)
         	sfu->devdata.sde = _sspec_devtable + (fsystem>>8);
      #endif
	      if ((rc = vt->opendir(sfh, p, partition))) {
	         // Free memory resources
	         pfree(&_sfup, sfu);
	         sfh->u = NULL; // Trash pointer, to catch errors.
	         pfree(&_sfhp, sfh);
	         return rc;  // Usually -ENOENT if error
	      }
	   }
	   else
	      return -EINVAL;
   }
   else {
		sfh = context->dirlist;
      vt = sfh->vt;
      sfu = sfh->u;
   }
   if (!sfu)
   	return -EEOF;			// Finished listing

	frc = (int)sfh->offset;	// Function return code for this iteration.
   // Now read next dir entry and format it as requested.  File name goes in 'path' and metadata in 'stat'.
	rc = vt->nextdir(sfh, &stat, path);
   if (rc < 0)
   	frc = rc;
	if (!rc) {
   	// Got next entry.  Format it.
      if (options & SSPEC_LIST_BIN) {
      	ls = (sspec_ls_t __far *)line;
         _f_strcpy(ls->path, context->cwd);
         _f_strcat(ls->path, path);		// Make absolute path name to file entry
			ls->isdir = (stat.flags & SSPEC_ATTR_DIR) != 0;
         ls->length = stat.flags & SSPEC_ATTR_LENGTH ? stat.length : 0;
			ls->mod_date = stat.flags & SSPEC_ATTR_MDTM ? stat.mdtm : 0;
      }
      else if (options & SSPEC_LIST_LONG) {
         strcpy(fpath, context->cwd);
         strcat(fpath, path);		// Make absolute path name to file entry
  			spp = sspec_findrule(fpath, sfh->realspec);
         uread = uwrite = gread = gwrite = oread = owrite = '-';
         if (sap) {
         	if (sap->mask & spp->readgroups)
            	uread = 'r';
            if (sap->mask & spp->writegroups && sap->writeaccess & context->server)
            	uwrite = 'w';
            if (spp->readgroups & ~sap->mask)
            	gread = 'r';
            if (spp->writegroups & ~sap->mask)
            	gwrite = 'w';
            if (spp->servermask & ~context->server)
            	oread = 'r';
            // Note: owrite is never set since it is not meaningful.
         }
         else
         	uread = 'r';
			snprintf(line, linelen-1, "%c%c%c-%c%c-%c%c-   1 %-10s %-10s %10ld %s %s"
           ,stat.flags & SSPEC_ATTR_DIR ? 'd' : '-'
           ,uread, uwrite, gread, gwrite, oread, owrite
           ,sap ? sap->username : "anon"
           ,spp && spp->realm && *spp->realm ? spp->realm : "anon"
           ,stat.flags & SSPEC_ATTR_LENGTH ? stat.length : 0
           ,stat.flags & SSPEC_ATTR_MDTM ? sspec_ls_date(stat.mdtm, datestr) : "Jan 1  1980"
           ,path[0] == '/' ? path+1 : path
         	);
         line[linelen-1] = 0;	// Enforce null term
      }
      else {
      	_f_strncpy(line, path[0] == '/' ? path+1 : path, linelen-3);
         line[linelen-2] = 0;
      }
      if (!(options & SSPEC_LIST_BIN))
			_f_strcat(line, "\r\n");
	   rc = (int)sfh->offset;
   }
   // Clean up if necessary
	if (rc < 0 || options & SSPEC_LIST_END) {
   	// Just listed last entry, release resources.
   	if (vt->closedir)
      	vt->closedir(sfh);
      pfree(&_sfup, sfu);
      sfh->u = NULL; // NULL pointer, so next call returns -EEOF.
      pfree(&_sfhp, sfh);
   }
   return frc;

}


/*** BeginHeader sspec_readfilehandle */
int sspec_readfilehandle(SSpecFileHandle *handle, char __far *buffer, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_readfilehandle                       <ZSERVER.LIB>

SYNTAX: int sspec_readfilehandle(SSpecFileHandle *handle, char far *buffer,
                                 int len);

KEYWORDS:		tcpip, server

DESCRIPTION:	This function reads from the given file handle, which
					must have been opened with sspec_openfilehandle().
               The next len bytes of file data will be read into the
               given buffer.  If there is no more data to read, then
               0 is returned (to indicate no bytes read).

               Note: it is now recommended to use sspec_open()
               in conjunction with sspec_read().

PARAMETER1:		pointer to file handle structure
PARAMETER2:		destination buffer for file data
PARAMETER3:		number of bytes to read

RETURN VALUE:  > 0	number of bytes read from file
					  0	no more bytes left in file
                -1	error

SEE ALSO:		sspec_openfilehandle, sspec_closefilehandle, sspec_readfile

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_readfilehandle(SSpecFileHandle *handle, char __far *buffer,
                                          int len)
{
	auto int bytes;
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(handle->sspec)))
   	return -1;
   bytes = handle->vt->read(handle, buffer, len);
   if (bytes < 0)
   	return -1;
   if (bytes > len)
   	return 0;
   handle->offset += bytes;
   return bytes;
}

/*** BeginHeader sspec_seekfilehandle */
int sspec_seekfilehandle(SSpecFileHandle *handle, long new_pos);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_seekfilehandle                       <ZSERVER.LIB>

SYNTAX: int sspec_seekfilehandle(SSpecFileHandle *handle, long new_pos);

KEYWORDS:		tcpip, server

DESCRIPTION:	This function seeks to the specified offset in the given
               file handle, which must have been opened with
               sspec_openfilehandle().

               Note that compressed files are not seekable.  If the handle
               is referring to a non-seekable file, then the return code
               will be -1 and the file position will not be changed.

PARAMETER1:		pointer to file handle structure
PARAMETER2:		offset in file (0 is start of file).

RETURN VALUE:  -1	error: this type of file is not seekable.
               0  success.

SEE ALSO:		sspec_openfilehandle, sspec_closefilehandle, sspec_readfile

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_seekfilehandle(SSpecFileHandle *handle, long new_pos)
{
	if (handle->vt->seek) {
   	handle->vt->seek(handle, new_pos, SEEK_SET);
	   return 0;
   }
   return -1;
}

/*** BeginHeader sspec_closefilehandle */
int sspec_closefilehandle(SSpecFileHandle *handle);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sspec_closefilehandle                       <ZSERVER.LIB>

SYNTAX: int sspec_closefilehandle(SSpecFileHandle *handle);

KEYWORDS:		tcpip, server

DESCRIPTION:	This function closes the given file handle so that
					the file handle can be reused and internal data
               structures can be freed.

PARAMETER1:		pointer to file handle structure

RETURN VALUE:   0	file closed successfully
               -1	error (such as, file already closed)

SEE ALSO:		sspec_openfilehandle, sspec_readfilehandle, sspec_readfile

END DESCRIPTION **********************************************************/

_zserver_nodebug int sspec_closefilehandle(SSpecFileHandle *handle)
{
	auto int rc;

	if (handle->offset < 0) {
   	// Already closed
   	return -1;
   }
   handle->offset = -1;
   if (handle->vt->close)
   	rc = handle->vt->close(handle);
   else
   	rc = 0;
   if (handle->u) {
   	pfree(&_sfup, handle->u);
      handle->u = NULL;
   }
   return rc;
}

/*** BeginHeader sspec_readvariable */

/* START FUNCTION DESCRIPTION ********************************************
sspec_readvariable                         <ZSERVER.LIB>

SYNTAX: int sspec_readvariable(int sspec, char far * buffer);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Put a string representation of a given variable
					represented by the sspec index into a given buffer of a
					given length.  This function will null-terminate the
					buffer.

PARAMETER1: 	spec index
PARAMETER2:		buffer in which to put the variable

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getvaraddr

END DESCRIPTION **********************************************************/

int sspec_readvariable(int sspec, char __far * buffer);
/*** EndHeader */

_zserver_nodebug int sspec_readvariable(int sspec, char __far * buffer)
{
	auto void* addr;
	auto char tempbuf[SSPEC_XMEMVARLEN];
	auto int len, atype;
	auto char is_ptr16;
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return -1;
   atype = sspec_actualtype(ssp);
	if (atype == SSPEC_ROOTVAR) {
		addr = ssp->addr;
	} else if (atype == SSPEC_XMEMVAR) {
		is_ptr16 = 0;
		switch (ssp->vartype) {
		case PTR16:
			len = SSPEC_XMEMVARLEN;
			is_ptr16 = 1;
			break;
		case INT8:
			len = 1;
			break;
		case INT16:
			len = 2;
			break;
		case INT32:
			len = 4;
			break;
		case FLOAT32:
			len = 4;
			break;
		default:
			return -1;
		}
		xmem2root(tempbuf, ssp->data, len);
		if (is_ptr16 == 1) {
			tempbuf[SSPEC_XMEMVARLEN-1] = '\0';
		}
		addr = (void *)tempbuf;
	} else {
		return -1;
	}
	switch (ssp->vartype) {
	case PTR16:
		sprintf(buffer, ssp->format, addr);
		break;
	case INT8:
		sprintf(buffer, ssp->format, (int)(*(char *)(addr)));
		break;
	case INT16:
		sprintf(buffer, ssp->format, *(int *)(addr));
		break;
	case INT32:
		sprintf(buffer, ssp->format, *(long int *)(addr));
		break;
	case FLOAT32:
		sprintf(buffer, ssp->format, *(float*)(addr));
		break;
	default:
		return -1;
	}
	return 0;
}

/*** BeginHeader sspec_getvaraddr */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getvaraddr                           <ZSERVER.LIB>

SYNTAX: void* sspec_getvaraddr(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns a pointer to the variable represented by the sspec
					index.

PARAMETER1: 	spec index

RETURN VALUE:  !=NULL	variable pointer
               NULL		failure

SEE ALSO:		sspec_readvariable

END DESCRIPTION **********************************************************/

void* sspec_getvaraddr(int sspec);
/*** EndHeader */

_zserver_nodebug void* sspec_getvaraddr(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return NULL;
	if (sspec_actualtype(ssp) == SSPEC_ROOTVAR)
		return ssp->addr;
	return NULL;
}

/*** BeginHeader sspec_getvarkind */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getvarkind                           <ZSERVER.LIB>

SYNTAX: word sspec_getvarkind(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the kind of variable represented by sspec (INT8,
					INT16, INT32, FLOAT32, or PTR16)

PARAMETER1: 	spec index

RETURN VALUE:  !=0	kind of variable
               0		failure

SEE ALSO:		sspec_getvaraddr, sspec_getvartype, sspec_gettype

END DESCRIPTION **********************************************************/

word sspec_getvarkind(int sspec);
/*** EndHeader */

_zserver_nodebug word sspec_getvarkind(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return 0;
	if (ssp->type == SSPEC_ROOTVAR || ssp->type == SSPEC_VARIABLE ||
	    ssp->type == SSPEC_XMEMVAR)
		return ssp->vartype;
	return 0;
}

/*** BeginHeader sspec_getvartype */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getvartype                       <ZSERVER.LIB>

SYNTAX: word sspec_getvartype(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION:	Get the type of variable represented by the given spec index.

PARAMETER1: 	spec index of the variable

RETURN VALUE:  !=SSPEC_ERROR	type of variable (SSPEC_ROOTVAR or
                   SSPEC_XMEMVAR)
               SSPEC_ERROR		failure

SEE ALSO:		sspec_getvaraddr, sspec_getvarkind, sspec_gettype

END DESCRIPTION **********************************************************/

word sspec_getvartype(int sspec);
/*** EndHeader */

_zserver_nodebug word sspec_getvartype(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)) ||
		 sspec_gettype(sspec) != SSPEC_VARIABLE)
		return SSPEC_ERROR;
	return sspec_actualtype(ssp);
}

/*** BeginHeader sspec_getservermask */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getservermask                    <ZSERVER.LIB>

SYNTAX: int sspec_getservermask(int sspec, word *servermask);

KEYWORDS:		tcpip, server

DESCRIPTION:	Gets the server mask for the given spec entry.  This is
					the bitmask passed in when the entry is created with the
					sspec_add*() functions.

               This function only works for RAM and flash table entries.

PARAMETER1: 	spec index of the variable
PARAMETER2:		address in which the servermask will be returned

RETURN VALUE:   0		success
               -1		failure

END DESCRIPTION **********************************************************/

int sspec_getservermask(int sspec, word *servermask);
/*** EndHeader */

_zserver_nodebug int sspec_getservermask(int sspec, word *servermask)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return -1;
   *servermask = ssp->perm.servermask;
   return 0;
}

/*** BeginHeader sspec_getxvaraddr */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getxvaraddr                          <ZSERVER.LIB>

SYNTAX: long sspec_getxvaraddr(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns a pointer to the variable in xmem represented by
					the sspec index.

PARAMETER1: 	spec index

RETURN VALUE:  >= 0	variable pointer
               -1		failure

SEE ALSO:		sspec_readvariable

END DESCRIPTION **********************************************************/

long sspec_getxvaraddr(int sspec);
/*** EndHeader */

_zserver_nodebug long sspec_getxvaraddr(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return -1;
	if (sspec_actualtype(ssp) == SSPEC_XMEMVAR)
		return (ssp->data);
	return -1;
}

/*** BeginHeader sspec_getfunction */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfunction                          <ZSERVER.LIB>

SYNTAX: void* sspec_getfunction(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns a pointer to the function represented by the sspec
					index.  The entry must have been created as a SSPEC_FUNCTION
               or as a SSPEC_CGI.

PARAMETER1: 	spec index

RETURN VALUE:  !=NULL	function pointer
               NULL		failure

SEE ALSO:		sspec_addfunction

END DESCRIPTION **********************************************************/

void* sspec_getfunction(int sspec);
/*** EndHeader */

_zserver_nodebug void* sspec_getfunction(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return NULL;
	if (ssp->type == SSPEC_FUNCTION || ssp->type == SSPEC_CGI)
		return ssp->addr;
	return NULL;
}

/*** BeginHeader sspec_remove */

/* START FUNCTION DESCRIPTION ********************************************
sspec_remove                               <ZSERVER.LIB>

SYNTAX: int sspec_remove(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Removes a spec entry (by marking it unused).  In the case
					of files, note that this function does not actually
					remove the file, only the reference to the file in the
					spec structure.

               This only works for RAM table entries.

PARAMETER1: 	spec index

RETURN VALUE:   0		success
               -1		failure

END DESCRIPTION **********************************************************/

int sspec_remove(int sspec);
/*** EndHeader */

_zserver_nodebug int sspec_remove(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(sspec)))
   	return -1;
   memset(ssp, 0, sizeof(*ssp));
	return 0;
}

/*** BeginHeader sspec_removebytype */
int sspec_removebytype(word type);
/*** EndHeader */
/*
 * Remove all RAM entries of a specified type
 * returns the number of entries removed
 */
_zserver_nodebug int sspec_removebytype(word type)
{
	auto int i, count;

	count = 0;
	for (i = 0; i < SSPEC_MAXSPEC; i++) {
		if (server_spec[i].type == type) {
			server_spec[i].type = SSPEC_UNUSED;
			count += 1;
		}
	}
	return count;
}

/*** BeginHeader sspec_needsauthentication */

/* START FUNCTION DESCRIPTION ********************************************
sspec_needsauthentication                  <ZSERVER.LIB>

SYNTAX: int sspec_needsauthentication(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Checks if the item represented by the spec entry needs
					authentication to access.  This is defined by having a
               non-NULL "realm" string for the resource.

               This function is deprecated, but is retained for cases
               where the permissions structure for a resource contains
               an authentication method of SERVER_AUTH_DEFAULT (0).

PARAMETER1: 	spec index

RETURN VALUE:   0		does not need authentication
					 1		needs authentication
               -1		failure: no permissions struct assigned or invalid
                     sspec handle.

SEE ALSO:		sspec_getrealm

END DESCRIPTION **********************************************************/

int sspec_needsauthentication(int sspec);
/*** EndHeader */

_zserver_nodebug int sspec_needsauthentication(int sspec)
{
   auto const ServerPermissions * spp;

   if (!(spp = sspec_perm(sspec)))
   	return -1;
	return spp->realm != NULL;
}

/*** BeginHeader sspec_checkaccess */

/* START FUNCTION DESCRIPTION ********************************************
sspec_checkaccess                          <ZSERVER.LIB>

SYNTAX: int sspec_checkaccess(int sspec, int userid);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Checks if the item represented by the spec entry is
					accessible by the given user.  Only read access is checked.

PARAMETER1: 	spec index
PARAMETER2:		user index

RETURN VALUE:   0		does not have access
					 1		has access
               -1		failure

SEE ALSO:		sspec_needsauthentication

END DESCRIPTION **********************************************************/

int sspec_checkaccess(int sspec, int userid);
/*** EndHeader */

_zserver_nodebug int sspec_checkaccess(int sspec, int userid)
{
   auto const ServerPermissions * spp;

   if (!(spp = sspec_perm(sspec)))
   	return -1;

	if (userid < 0 || userid >= SAUTH_MAXUSERS
       || (server_auth[userid].username[0] == '\0')) {
		return -1;
	}
	return 0 != (spp->readgroups & server_auth[userid].mask);
}

/*** BeginHeader sspec_getrealm */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getrealm                             <ZSERVER.LIB>

SYNTAX: char* sspec_getrealm(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the realm of the spec entry represented by the
					sspec index

PARAMETER1: 	spec index

RETURN VALUE:  !=NULL	realm string
               NULL		failure

SEE ALSO:		sspec_setrealm

END DESCRIPTION **********************************************************/

char* sspec_getrealm(int sspec);
/*** EndHeader */

_zserver_nodebug char* sspec_getrealm(int sspec)
{
   auto const ServerPermissions * spp;

   if (!(spp = sspec_perm(sspec)))
   	return NULL;
	return spp->realm;
}

/*** BeginHeader sspec_checkpermissions */

/* START FUNCTION DESCRIPTION ********************************************
sspec_checkpermissions                             <ZSERVER.LIB>

SYNTAX: int sspec_checkpermissions(int sspec, ServerContext * context);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the access permissions for the given server and
               user, for the given resource.

               Note: sspec_access() performs the same function, except
               that a resource name can be given (rather than an open
               resource handle).

PARAMETER1: 	spec index
PARAMETER2: 	Server context.  Relevant fields are
                 context->server: the current server (SERVER_HTTP etc.)
                 context->userid: current user, or -1 for testing the
                   server in general.  NOTE: when testing server in
                   general, both O_READ and O_WRITE will be returned.

RETURN VALUE:  >= 0: bitwise combination of:
                 O_READ: resource is readable
                 O_WRITE: resource has write permission.  This does NOT
                   necessarily mean that the resource can actually be
                   written, only that the permission bits allow it.
               < 0: error e.g. no permissions can be located or invalid
                 sspec handle.

SEE ALSO:		sspec_setpermissions, sspec_getpermissions, sspec_access

END DESCRIPTION **********************************************************/

int sspec_checkpermissions(int sspec, ServerContext * context);
/*** EndHeader */

_zserver_nodebug int sspec_checkpermissions(int sspec, ServerContext * context)
{
   auto const ServerPermissions * spp;
   auto ServerAuth * sap;
   auto int rc;

   if (!context || !(spp = sspec_perm(sspec)))
   	return -EINVAL;
	if (context->userid < 0) {
   	// Server access
      if (!spp->servermask || context->server & spp->servermask)
      	return O_READ | O_WRITE;
      return 0;
   }
   // Specific user
  	sap = sauth_pointer(context->userid);
   if (!sap)
   	return -EINVAL;
   rc = 0;
   if (sap->mask & spp->writegroups && sap->writeaccess & context->server)
   	rc |= O_WRITE;
   if (sap->mask & spp->readgroups)
   	rc |= O_READ;
   return rc;
}

/*** BeginHeader sspec_setpermissions */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setpermissions                               <ZSERVER.LIB>

SYNTAX: int sspec_setpermissions(int sspec,
                                 char * realm,
                                 word readgroups,
                                 word writegroups,
                                 word servermask,
                                 word method,
                                 MIMETypeMap * mimetype);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set the permission (access control) attributes of a
               resource.

               This only works for RAM table entries.  For entries
               in a filesystem, use sspec_addrule().

PARAMETER1: 	spec index
PARAMETER2:		realm string, or NULL
PARAMETER3:		mask of user groups who have read access
PARAMETER4:		mask of user groups who have write access
PARAMETER5:		servers which can access this resource (or SERVER_ANY
                 for all servers).
PARAMETER6:		required authentication method (0, SERVER_AUTH_BASIC etc.)
PARAMETER7:		MIME table entry, or NULL.


RETURN VALUE:   0		success
               <0		failure e.g. not a RAM spec handle.

SEE ALSO:		sspec_checkpermissions, sspec_getpermissions, sspec_access

END DESCRIPTION **********************************************************/

int sspec_setpermissions(int sspec,
                                 char * realm,
                                 word readgroups,
                                 word writegroups,
                                 word servermask,
                                 word method,
                                 MIMETypeMap * mimetype);
/*** EndHeader */

_zserver_nodebug int sspec_setpermissions(int sspec,
                                 char * realm,
                                 word readgroups,
                                 word writegroups,
                                 word servermask,
                                 word method,
                                 MIMETypeMap * mimetype)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(sspec)))
   	return -EINVAL;
   if (realm && !*realm)
   	realm = NULL;
   ssp->perm.realm = realm;
   ssp->perm.readgroups = readgroups;
   ssp->perm.writegroups = writegroups;
   ssp->perm.servermask = servermask;
   ssp->perm.method = method;
   ssp->perm.mimetype = mimetype;
	return 0;
}

/*** BeginHeader sspec_getpermissions */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getpermissions                               <ZSERVER.LIB>

SYNTAX: int sspec_getpermissions(int sspec,
                                 char ** realm,
                                 word * readgroups,
                                 word * writegroups,
                                 word * servermask,
                                 word * method,
                                 MIMETypeMap ** mimetype);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Get the permission (access control) attributes of a
               resource.

               Except for sspec, all parameters are pointers to
               variables which will be set to the appropriate return value.
               If the parameter is NULL, then that information is not
               retrieved.

               The data at **realm and **mimetype should not
               be altered by the caller.  The data is read-only.

PARAMETER1: 	spec index
PARAMETER2:		pointer to pointer to realm string
PARAMETER3:		pointer to mask of user groups who have read access
PARAMETER4:		pointer to mask of user groups who have write access
PARAMETER5:		pointer to servers which can access this resource.
PARAMETER6:		pointer to required authentication method.
PARAMETER7:		pointer to pointer to MIME table entry.


RETURN VALUE:   0		success
               <0		failure e.g. bad sspec handle

SEE ALSO:		sspec_setpermissions, sspec_checkpermissions, sspec_access

END DESCRIPTION **********************************************************/

int sspec_getpermissions(int sspec,
                                 char ** realm,
                                 word * readgroups,
                                 word * writegroups,
                                 word * servermask,
                                 word * method,
                                 MIMETypeMap ** mimetype);
/*** EndHeader */

_zserver_nodebug int sspec_getpermissions(int sspec,
                                 char ** realm,
                                 word * readgroups,
                                 word * writegroups,
                                 word * servermask,
                                 word * method,
                                 MIMETypeMap ** mimetype)
{
   auto const ServerPermissions * spp;

   if (!(spp = sspec_perm(sspec)))
   	return -EINVAL;

   if (realm) *realm = spp->realm;
   if (readgroups) *readgroups = spp->readgroups;
   if (writegroups) *writegroups = spp->writegroups;
   if (servermask) *servermask = spp->servermask;
   if (method) *method = spp->method;
   if (mimetype) *mimetype = spp->mimetype;
	return 0;
}

/*** BeginHeader sspec_getusername */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getusername                          <ZSERVER.LIB>

SYNTAX: char* sspec_getusername(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the username of the spec entry represented by the
					sspec index.  Note that if multiple users are associated
					with this resource, the first user's username will be
					returned.  See sspec_getuserid() to get all userids for a
					resource, and sauth_getusername() to convert the userids to
					usernames.

               This only works for RAM and flash table entries.

PARAMETER1: 	spec index

RETURN VALUE:  !=NULL	username string
               NULL		failure, or no user has read access to this
                 resource.

SEE ALSO:		sauth_adduser, sspec_setuser, sspec_getuserid,
					sauth_getusername

END DESCRIPTION **********************************************************/

char* sspec_getusername(int sspec);
/*** EndHeader */

_zserver_nodebug char* sspec_getusername(int sspec)
{
   auto ServerAuth * sap;
   auto ServerSpec * ssp;
   auto int j;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return NULL;
   for (j = 0, sap = server_auth; j < SAUTH_MAXUSERS; ++j, ++sap)
   	if (sap->username[0] && sap->mask & ssp->perm.readgroups)
      	return sap->username;
	return NULL;
}

/*** BeginHeader sspec_getuserid */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getuserid                            <ZSERVER.LIB>

SYNTAX: int sspec_getuserid(int sspec, int index);

KEYWORDS:		tcpip, server

DESCRIPTION:	Returns a userid for the given sspec resource.  Since
					a resource can have multiple userids associated with it,
					index indicates which userid should be returned.

               If there is no
					userid for a given index, -1 will be returned.  If -1 is
					returned for an index, then -1 will also be returned for
					all higher indices.

               This function may be used to iterate through all users
               which have read access to a particular resource.

               This only works for RAm and flash table entries.

PARAMETER1: 	spec index.
PARAMETER2:		index of userid for this sspec resource to return:
					  0, 1, 2...

RETURN VALUE:  -1		index is greater than or equal to the number of
						users with read access.
					>= 0	userid

SEE ALSO:		sspec_getusername, sauth_getusername

END DESCRIPTION **********************************************************/

int sspec_getuserid(int sspec, int index);
/*** EndHeader */

_zserver_nodebug int sspec_getuserid(int sspec, int index)
{
   auto ServerSpec * ssp;
   auto ServerAuth * sap;
   auto int j;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return -1;
   for (j = 0, sap = server_auth; j < SAUTH_MAXUSERS; ++j, ++sap)
   	if (sap->username[0] && sap->mask & ssp->perm.readgroups) {
      	if (!index)
      		return j;
         --index;
      }
	return -1;
}

/*** BeginHeader sspec_gettype */

/* START FUNCTION DESCRIPTION ********************************************
sspec_gettype                              <ZSERVER.LIB>

SYNTAX: word sspec_gettype(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the type (SSPEC_FILE, SSPEC_VARIABLE, etc.)
					of the spec entry represented by the sspec index.  This
               is a "generic" type:  SSPEC_FILE is returned for any
               type (SSPEC_ROOTFILE, SSPEC_FSFILE etc.) which has file
               properties.  SSPEC_VARIABLE is returned for SSPEC_ROOTVAR
               or SSPEC_XMEMVAR.  Other types are returned without
               translation.

PARAMETER1: 	spec index

RETURN VALUE:  !=SSPEC_ERROR	type
               SSPEC_ERROR		failure

SEE ALSO:		sspec_getfiletype, sspec_getvartype

END DESCRIPTION **********************************************************/

word sspec_gettype(int sspec);
/*** EndHeader */

_zserver_nodebug word sspec_gettype(int sspec)
{
   auto ServerSpec * ssp;

   if (SSPEC_IS_VIRT(sspec))
   	return SSPEC_FILE;
   if (!(ssp = sspec_nvhandle(sspec)))
   	return SSPEC_ERROR;
	if ((ssp->type == SSPEC_ROOTFILE) ||
	    (ssp->type == SSPEC_XMEMFILE) ||
	    (ssp->type == SSPEC_ZMEMFILE) ||
	    (ssp->type == SSPEC_FATFILE) ||
	    (ssp->type == SSPEC_FSFILE))
		return SSPEC_FILE;
	if ((ssp->type == SSPEC_ROOTVAR) ||
	    (ssp->type == SSPEC_XMEMVAR))
		return SSPEC_VARIABLE;
	return ssp->type;
}

/*** BeginHeader sspec_getname */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getname                              <ZSERVER.LIB>

SYNTAX: char* sspec_getname(int sspec);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the name of the spec entry represented by the
					sspec index

               This only works for RAM and flash table entries.

PARAMETER1: 	spec index

RETURN VALUE:  !=NULL			name
               NULL				failure

END DESCRIPTION **********************************************************/

char* sspec_getname(int sspec);
/*** EndHeader */

_zserver_nodebug char* sspec_getname(int sspec)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(sspec)))
   	return NULL;
	if (ssp->type != SSPEC_UNUSED)
		return ssp->name;
	return NULL;
}

/*** BeginHeader sspec_setfvcheck */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvcheck                           <ZSERVER.LIB>

SYNTAX: int sspec_setfvcheck(int form, int var, int (*varcheck)());

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the function that can be used to check the integrity
					of a form variable.  The integrity-checking function
					should return 0 if there is no error, or !0 if there is an
					error.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		pointer to integrity checking function

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_setfvfloatrange, sspec_setfvoptlist,
					sspec_setfvrange

END DESCRIPTION **********************************************************/

int sspec_setfvcheck(int form, int var, int (*varcheck)());
/*** EndHeader */

_zserver_nodebug int sspec_setfvcheck(int form, int var, int (*varcheck)())
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].varcheck = varcheck;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setfvname */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvname                            <ZSERVER.LIB>

SYNTAX: int sspec_setfvname(int form, int var, char* name);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the name of a variable that is displayed in the HTML
					form table.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		name to give the variable

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getfvname

END DESCRIPTION **********************************************************/

int sspec_setfvname(int form, int var, char* name);
/*** EndHeader */

_zserver_nodebug int sspec_setfvname(int form, int var, char* name)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].name = name;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setfvdesc */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvdesc                            <ZSERVER.LIB>

SYNTAX: int sspec_setfvdesc(int form, int var, char* desc);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the description of a variable that is displayed in
					the HTML form table.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		description of the variable

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getfvdesc

END DESCRIPTION **********************************************************/

int sspec_setfvdesc(int form, int var, char* desc);
/*** EndHeader */

_zserver_nodebug int sspec_setfvdesc(int form, int var, char* desc)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].desc = desc;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getfvdesc */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvdesc                            <ZSERVER.LIB>

SYNTAX: char* sspec_getfvdesc(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the description of a variable that is displayed in
					the HTML form table.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:  !NULL		description of the variable
               NULL		failure

SEE ALSO:		sspec_setfvdesc

END DESCRIPTION **********************************************************/

char* sspec_getfvdesc(int form, int var);
/*** EndHeader */

_zserver_nodebug char* sspec_getfvdesc(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return NULL;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		return ((FormVar *)ssp->addr)[var].desc;
	}
	return NULL;
}

/*** BeginHeader sspec_setfventrytype */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfventrytype                       <ZSERVER.LIB>

SYNTAX: int sspec_setfventrytype(int form, int var, int entrytype);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the type of form entry element that should be used for
					the given variable

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		HTML_FORM_TEXT for a text box or HTML_FORM_PULLDOWN for a
					pull-down menu (defaults to HTML_FORM_TEXT)

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getfventrytype

END DESCRIPTION **********************************************************/

int sspec_setfventrytype(int form, int var, int entrytype);
/*** EndHeader */

_zserver_nodebug int sspec_setfventrytype(int form, int var, int entrytype)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].entrytype = entrytype;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getfventrytype */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfventrytype                         <ZSERVER.LIB>

SYNTAX: int sspec_getfventrytype(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the type of form entry element that should be used for
					the given variable

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:  HTML_FORM_TEXT			is a text box
					HTML_FORM_PULLDOWN	is a pull-down menu
               -1							failure

SEE ALSO:		sspec_setfventrytype

END DESCRIPTION **********************************************************/

int sspec_getfventrytype(int form, int var);
/*** EndHeader */

_zserver_nodebug int sspec_getfventrytype(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		return ((FormVar *)ssp->addr)[var].entrytype;
	}
	return -1;
}

/*** BeginHeader sspec_setfvlen */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvlen                             <ZSERVER.LIB>

SYNTAX: int sspec_setfvlen(int form, int var, int len);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the length of a form variable (the maximum length of
					the string representation of the variable).  Note that for
					string variables, len should include the NULL terminator.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		length of the variable

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getfvlen

END DESCRIPTION **********************************************************/

int sspec_setfvlen(int form, int var, int len);
/*** EndHeader */

_zserver_nodebug int sspec_setfvlen(int form, int var, int len)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].varlen = len;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getfvlen */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvlen                            <ZSERVER.LIB>

SYNTAX: int sspec_getfvlen(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the length of a form variable (the maximum length of
					the string representation of the variable)

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:  >= 0	length of the form variable
               -1		failure

SEE ALSO:		sspec_setfvlen

END DESCRIPTION **********************************************************/

int sspec_getfvlen(int form, int var);
/*** EndHeader */

_zserver_nodebug int sspec_getfvlen(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		return ((FormVar *)ssp->addr)[var].varlen;
	}
	return -1;
}

/*** BeginHeader sspec_setfvoptlist */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvoptlist                         <ZSERVER.LIB>

SYNTAX: int sspec_setfvoptlist(int form, int var, const char* list[], int listlen);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets an enumerated list of possible values for a string
					variable

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		array of string values that the variable can assume
PARAMETER4:		length of the array

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getfvopt, sspec_getfvoptlistlen,
					sspec_setfvfloatrange, sspec_setfvrange

END DESCRIPTION **********************************************************/

int sspec_setfvoptlist(int form, int var, const char* const *list, int listlen);
/*** EndHeader */

_zserver_nodebug int sspec_setfvoptlist(int form, int var, const char* const *list, int listlen)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].values = (const char **)list;
		((FormVar *)ssp->addr)[var].valueslen = listlen;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setfvrange */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvrange                           <ZSERVER.LIB>

SYNTAX: int sspec_setfvrange(int form, int var, long low, long high);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the range of an integer variable

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		minimum value of the variable
PARAMETER4:		maximum value of the variable

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_setfvfloatrange, sspec_setfvoptlist

END DESCRIPTION **********************************************************/

int sspec_setfvrange(int form, int var, long low, long high);
/*** EndHeader */

_zserver_nodebug int sspec_setfvrange(int form, int var, long low, long high)
{
	auto FormVar* fv;
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		fv = ((FormVar *)ssp->addr) + var;
		fv->low = low;
		fv->high = high;
		fv->rangeset = 1;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setfvfloatrange */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvfloatrange                           <ZSERVER.LIB>

SYNTAX: int sspec_setfvfloatrange(int form, int var, float low, float high);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the range of a float variable

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		minimum value of the variable
PARAMETER4:		maximum value of the variable

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_setfvrange, sspec_setfvoptlist

END DESCRIPTION **********************************************************/

int sspec_setfvfloatrange(int form, int var, float low, float high);
/*** EndHeader */

_zserver_nodebug int sspec_setfvfloatrange(int form, int var, float low, float high)
{
	auto FormVar* fv;
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		fv = ((FormVar *)ssp->addr) + var;
		fv->flow = low;
		fv->fhigh = high;
		fv->rangeset = 1;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setfvreadonly */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setfvreadonly                        <ZSERVER.LIB>

SYNTAX: int sspec_setfvreadonly(int form, int var, int readonly);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets a form variable to be read-only.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		0 for modifiable, 1 for read-only

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getfvreadonly

END DESCRIPTION **********************************************************/

int sspec_setfvreadonly(int form, int var, int readonly);
/*** EndHeader */

_zserver_nodebug int sspec_setfvreadonly(int form, int var, int readonly)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		((FormVar *)ssp->addr)[var].readonly = (byte)readonly;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getfvreadonly */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvreadonly                        <ZSERVER.LIB>

SYNTAX: int sspec_getfvreadonly(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Checks if a form variable is read-only.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:   0		not readonly
					 1		readonly
               -1		failure

SEE ALSO:		sspec_setfvreadonly

END DESCRIPTION **********************************************************/

int sspec_getfvreadonly(int form, int var);
/*** EndHeader */

_zserver_nodebug int sspec_getfvreadonly(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		return ((FormVar *)ssp->addr)[var].readonly;
	}
	return -1;
}

/*** BeginHeader sspec_setformtitle */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setformtitle                         <ZSERVER.LIB>

SYNTAX: int sspec_setformtitle(int form, char* title);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the title for an automatically generated form

PARAMETER1: 	spec index of the form
PARAMETER2:		title of the HTML page

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getformtitle

END DESCRIPTION **********************************************************/

int sspec_setformtitle(int form, char* title);
/*** EndHeader */

_zserver_nodebug int sspec_setformtitle(int form, char* title)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if (ssp->type == SSPEC_FORM) {
		ssp->format = title;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getformtitle */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getformtitle                         <ZSERVER.LIB>

SYNTAX: char* sspec_getformtitle(int form);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the title for an automatically generated form

PARAMETER1: 	spec index of the form

RETURN VALUE:  !NULL		title string
               NULL		failure

SEE ALSO:		sspec_setformtitle

END DESCRIPTION **********************************************************/

char* sspec_getformtitle(int form);
/*** EndHeader */

_zserver_nodebug char* sspec_getformtitle(int form)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return NULL;
	if (ssp->type == SSPEC_FORM) {
		return ssp->format;
	}
	return NULL;
}

/*** BeginHeader sspec_setformfunction */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setformfunction                      <ZSERVER.LIB>

SYNTAX: int sspec_setformfunction(int form, void (*fptr)());

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the function that will generate the form

PARAMETER1: 	spec index of the form
PARAMETER2:		form generation function (NULL for the default function)

RETURN VALUE:   0		success
               -1		failure

END DESCRIPTION **********************************************************/

int sspec_setformfunction(int form, void (*fptr)());
/*** EndHeader */

_zserver_nodebug int sspec_setformfunction(int form, void (*fptr)())
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if (ssp->type == SSPEC_FORM) {
		ssp->formfunc = fptr;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_setpreformfunction */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setpreformfunction                   <ZSERVER.LIB>

SYNTAX: int sspec_setpreformfunction(int form, void (*fptr)());

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets a user function that will be called just before form
					generation.  The user function is not called when the form
					is being generated because of errors in the form input.
					The user function must have the following prototype:

					void userfunction(int form);

					The function may not use the form parameter, but it is
					useful if the same user function is used for multiple
					forms.

PARAMETER1: 	spec index of the form
PARAMETER2:		pointer to user function to be called just before form
					generation

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_getpreformfunction

END DESCRIPTION **********************************************************/

int sspec_setpreformfunction(int form, void (*fptr)());
/*** EndHeader */

_zserver_nodebug int sspec_setpreformfunction(int form, void (*fptr)())
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
	if (ssp->type == SSPEC_FORM) {
		ssp->preformfunc = fptr;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getpreformfunction */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getpreformfunction                   <ZSERVER.LIB>

SYNTAX: void* sspec_getpreformfunction(int form);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the user function that will be called just before form
					generation.  This function is mainly useful for custom form
					generation functions.

PARAMETER1: 	spec index of the form

RETURN VALUE:  NULL  No user function
               !NULL Pointer to user function

SEE ALSO:		sspec_setpreformfunction, sspec_setformfunction

END DESCRIPTION **********************************************************/

void* sspec_getpreformfunction(int form);
/*** EndHeader */

_zserver_nodebug void* sspec_getpreformfunction(int form)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return NULL;
	if (ssp->type == SSPEC_FORM) {
		return ssp->preformfunc;
	}
	return NULL;
}

/*** BeginHeader sspec_getformfunction */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getformfunction                   <ZSERVER.LIB>

SYNTAX: void* sspec_getformfunction(int form);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the user function that will generate the form.

PARAMETER1: 	spec index of the form

RETURN VALUE:  NULL  No user function
               !NULL Pointer to user function

SEE ALSO:		sspec_setpreformfunction, sspec_setformfunction

END DESCRIPTION **********************************************************/

void* sspec_getformfunction(int form);
/*** EndHeader */

_zserver_nodebug void* sspec_getformfunction(int form)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return NULL;
	if (ssp->type == SSPEC_FORM) {
		return ssp->formfunc;
	}
	return NULL;
}

/*** BeginHeader sspec_setformepilog */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setformepilog                        <ZSERVER.LIB>

SYNTAX: int sspec_setformepilog(int form, int function);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the function that will be called when the form has
					been successfully submitted.  This function can, for
					example, execute a cgi_redirectto to redirect to a
					specific page.  It should accept "HttpState* state" as
					an argument, return 0 when it is not finished, and 1
					when it is finished (i.e., behave like a normal CGI
					function).

PARAMETER1: 	spec index of the form
PARAMETER2:		spec index of the function to call on success

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_setformprolog

END DESCRIPTION **********************************************************/

int sspec_setformepilog(int form, int function);
/*** EndHeader */

_zserver_nodebug int sspec_setformepilog(int form, int function)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
   if (!sspec_nvhandle(function))
   	return -1;
	if (ssp->type == SSPEC_FORM) {
		ssp->formepilog = function;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getformepilog */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getformepilog                        <ZSERVER.LIB>

SYNTAX: int sspec_getformepilog(int form);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the function that will be called when the form has
					been successfully submitted.

PARAMETER1: 	spec index of the form

RETURN VALUE:  >=0		success, form epilog function handle is returned.
               -1		failure

SEE ALSO:		sspec_setformepilog

END DESCRIPTION **********************************************************/

int sspec_getformepilog(int form);
/*** EndHeader */

_zserver_nodebug int sspec_getformepilog(int form)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if (ssp->type == SSPEC_FORM)
		return ssp->formepilog;
	return -1;
}

/*** BeginHeader sspec_setformprolog */

/* START FUNCTION DESCRIPTION ********************************************
sspec_setformprolog                        <ZSERVER.LIB>

SYNTAX: int sspec_setformprolog(int form, int function);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Sets the function that will be called just before a set
					of form variables will be updated.  This can be used, for
					instance, to implement a lock during so that other code
					will not update the form variables (which can then be
					unlocked in the epilog function).  It should accept
					"HttpState* state" as an argument, return 0 when it is
					not finished, and 1 when it is finished (i.e., behave
					like a normal CGI function).

PARAMETER1: 	spec index of the form
PARAMETER2:		spec index of the prolog function

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:		sspec_setformepilog

END DESCRIPTION **********************************************************/

int sspec_setformprolog(int form, int function);
/*** EndHeader */

_zserver_nodebug int sspec_setformprolog(int form, int function)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_ramhandle(form)))
   	return -1;
   if (!sspec_nvhandle(function))
   	return -1;
	if (ssp->type == SSPEC_FORM) {
		ssp->formprolog = function;
		return 0;
	}
	return -1;
}

/*** BeginHeader sspec_getformprolog */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getformprolog                        <ZSERVER.LIB>

SYNTAX: int sspec_getformprolog(int form);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the function that will be called before updating a
               form.

PARAMETER1: 	spec index of the form

RETURN VALUE:  >=0		success, form epilog function handle is returned.
               -1		failure

SEE ALSO:		sspec_setformprolog

END DESCRIPTION **********************************************************/

int sspec_getformprolog(int form);
/*** EndHeader */

_zserver_nodebug int sspec_getformprolog(int form)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if (ssp->type == SSPEC_FORM)
		return ssp->formprolog;
	return -1;
}

/*** BeginHeader sspec_getfvnum */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvnum                             <ZSERVER.LIB>

SYNTAX: int sspec_getfvnum(int form);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the number of variables in a form.

PARAMETER1: 	spec index of the form

RETURN VALUE:  >= 0		number of form variables
               -1			failure

END DESCRIPTION **********************************************************/

int sspec_getfvnum(int form);
/*** EndHeader */

_zserver_nodebug int sspec_getfvnum(int form)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if (ssp->type == SSPEC_FORM) {
		return (ssp->highvar);
	}
	return -1;
}

/*** BeginHeader sspec_getfvspec */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvspec                            <ZSERVER.LIB>

SYNTAX: int sspec_getfvspec(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the spec index of a variable in a form.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:  >= 0		spec index of the variable
               -1			failure

SEE ALSO:		sspec_addfv

END DESCRIPTION **********************************************************/

int sspec_getfvspec(int form, int var);
/*** EndHeader */

_zserver_nodebug int sspec_getfvspec(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		return ((FormVar *)ssp->addr)[var].varspec;
	}
	return -1;
}

/*** BeginHeader sspec_getfvname */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvname                            <ZSERVER.LIB>

SYNTAX: char* sspec_getfvname(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the name of a variable that is displayed in the HTML
					form table.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:  !NULL		name of the form variable
               NULL		failure

SEE ALSO:		sspec_setfvname

END DESCRIPTION **********************************************************/

char* sspec_getfvname(int form, int var);
/*** EndHeader */

_zserver_nodebug char* sspec_getfvname(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return NULL;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar)) {
		return ((FormVar *)ssp->addr)[var].name;
	}
	return NULL;
}

/*** BeginHeader sspec_getfvopt */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvopt                             <ZSERVER.LIB>

SYNTAX: const char* sspec_getfvopt(int form, int var, int option);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the numbered option (starting from 0) of the form
					variable.  This function is only valid if the form variable
					has the option list set.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable
PARAMETER3:		index of the form variable option

RETURN VALUE:  !NULL		the form variable option
               NULL		failure

SEE ALSO:		sspec_setfvoptlist, sspec_getfvoptlistlen

END DESCRIPTION **********************************************************/

const char* sspec_getfvopt(int form, int var, int option);
/*** EndHeader */

_zserver_nodebug const char* sspec_getfvopt(int form, int var, int option)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return NULL;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar) &&
	    (option >= 0) && (option < ((FormVar*)ssp->addr)[var].valueslen)) {
		return ((FormVar *)ssp->addr)[var].values[option];
	}
	return NULL;
}

/*** BeginHeader sspec_getfvoptlistlen */

/* START FUNCTION DESCRIPTION ********************************************
sspec_getfvoptlistlen                      <ZSERVER.LIB>

SYNTAX: int sspec_getfvoptlistlen(int form, int var);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the length of the options list of the form variable.
					This function is only valid if the form variable has the
					option list set.

PARAMETER1: 	spec index of the form
PARAMETER2:		form index of the variable

RETURN VALUE:  > 0		the length of the options array
               -1			failure

SEE ALSO:		sspec_getfvopt, sspec_setfvoptlist

END DESCRIPTION **********************************************************/

int sspec_getfvoptlistlen(int form, int var);
/*** EndHeader */

_zserver_nodebug int sspec_getfvoptlistlen(int form, int var)
{
   auto ServerSpec * ssp;

   if (!(ssp = sspec_nvhandle(form)))
   	return -1;
	if ((ssp->type == SSPEC_FORM) &&
	    (var >= 0) && (var < ssp->highvar) &&
	    (((FormVar *)ssp->addr)[var].valueslen > 0)) {
		return ((FormVar *)ssp->addr)[var].valueslen;
	}
	return -1;
}


/*** BeginHeader sauth_findunused */
int sauth_findunused(char *username, word servermask);
/*** EndHeader */
_zserver_nodebug int sauth_findunused(char *username, word servermask)
{
	auto int i;

   if (*username)
	   for (i = 0; i < SAUTH_MAXUSERS; i++)
	      if (!strncmp(server_auth[i].username, username, SAUTH_MAXNAME))
	         return -1;  // Non-null name already exists
	for (i = 0; i < SAUTH_MAXUSERS; i++)
		if (!server_auth[i].username[0] && !server_auth[i].password[0])
			return i;
	return -1;
}

/*** BeginHeader sauth_adduser */

/* START FUNCTION DESCRIPTION ********************************************
sauth_adduser                              <ZSERVER.LIB>

SYNTAX: int sauth_adduser(char* username, char* password, word servermask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Add a user to the user list.

               Note that the group mask for the user defaults to the
               assigned index number (0..SAUTH_MAXNAME-1), as a bit
               number i.e. 1<<index.  This effectively creates each user
               in a unique (single) group.  Since this does not offer
               any real control over the assigned group mask, it is
               recommended to use sauth_setusermask() after this to
               assign the correct access masks.

PARAMETER1: 	name of the user
PARAMETER2: 	password for the user
PARAMETER3:		bitmask representing valid servers for this user.

RETURN VALUE:  >= 0	successfully added user index
               -1		failed to add user

SEE ALSO:      sauth_setwriteaccess, sauth_getwriteaccess,
					sauth_authenticate, sauth_setusermask

END DESCRIPTION **********************************************************/

int sauth_adduser(char* username, char* password, word servermask);
/*** EndHeader */

_zserver_nodebug int sauth_adduser(char* username, char* password, word servermask)
{
	auto int i;

	i = sauth_findunused(username, servermask);
	if (i != -1) {
		strncpy(server_auth[i].username, username, SAUTH_MAXNAME);
		strncpy(server_auth[i].password, password, SAUTH_MAXNAME);
		server_auth[i].writeaccess = servermask & SERVER_WRITABLE ? servermask & SERVER_ANY : 0;
		server_auth[i].servermask = servermask;
      server_auth[i].mask = 1<<i;
	}
	return i;
}

/*** BeginHeader sauth_setwriteaccess */

/* START FUNCTION DESCRIPTION ********************************************
sauth_setwriteaccess                       <ZSERVER.LIB>

SYNTAX: int sauth_setwriteaccess(int sauth, int writeaccessmask);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set whether or not a user has write access with the
					specified server(s)

PARAMETER1: 	user index
PARAMETER2: 	Server bitmask, with bit set to 1 for write access, 0 for no
               write access

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:      sauth_getwriteaccess

END DESCRIPTION **********************************************************/

int sauth_setwriteaccess(int sauth, int writeaccessmask);
/*** EndHeader */

_zserver_nodebug int sauth_setwriteaccess(int sauth, int writeaccessmask)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(sauth)))
		return -1;
	sap->writeaccess = writeaccessmask;
	return 0;
}

/*** BeginHeader sauth_getwriteaccess */

/* START FUNCTION DESCRIPTION ********************************************
sauth_getwriteaccess                       <ZSERVER.LIB>

SYNTAX: int sauth_getwriteaccess(int sauth);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns whether or not a user has write access to any
               server's resources.  This is an 'in principle' test.
               Each resource is individually protected from write
               access: this is not checked.  In other words, this
               function may return 'true' even when none of the
               resources are writable to this user.

PARAMETER1: 	user index

RETURN VALUE:   0		does not have write access
					 non-zero: has write access.  One bit is set for each
                  server which allows write access to this user.  For
                  example, to test whether the user can write resources
                  server by FTP, use the test
                    if (sauth_getwriteaccess(userid) & SERVER_FTP) ...
               -1		failure e.g. invalid userid (index).

SEE ALSO:      sauth_setwriteaccess

END DESCRIPTION **********************************************************/

int sauth_getwriteaccess(int sauth);
/*** EndHeader */

_zserver_nodebug int sauth_getwriteaccess(int sauth)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(sauth)))
		return -1;
	return sap->writeaccess;
}

/*** BeginHeader sauth_setserver */

/* START FUNCTION DESCRIPTION ********************************************
sauth_setserver                       <ZSERVER.LIB>

SYNTAX: int sauth_setserver(int sauth, int server);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set whether or not a user is visible to the specified
					server(s).

PARAMETER1: 	user index
PARAMETER2: 	Server bitmask, with bit set to 1 to make this user
               "known" to the server.  If this parameter is zero, then
               the user is visible to ALL servers, however it is
               recommended to pass the value SERVER_ANY in this case.

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:      sauth_getserver

END DESCRIPTION **********************************************************/

int sauth_setserver(int sauth, int server);
/*** EndHeader */

_zserver_nodebug int sauth_setserver(int sauth, int server)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(sauth)))
		return -1;
	sap->servermask = server;
	return 0;
}

/*** BeginHeader sauth_getserver */

/* START FUNCTION DESCRIPTION ********************************************
sauth_getserver                       <ZSERVER.LIB>

SYNTAX: int sauth_getserver(int sauth);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns whether or not a user ID is visible to particular
               server(s).

PARAMETER1: 	user index

RETURN VALUE:	0: this user is visible to all servers
					non-zero: visible to select servers.  One bit is set for each
                  server which knows about this user.
               -1		failure e.g. invalid userid (index).

SEE ALSO:      sauth_setserver

END DESCRIPTION **********************************************************/

int sauth_getserver(int sauth);
/*** EndHeader */

_zserver_nodebug int sauth_getserver(int sauth)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(sauth)))
		return -1;
	return sap->servermask;
}

/*** BeginHeader sauth_authenticate */

/* START FUNCTION DESCRIPTION ********************************************
sauth_authenticate                         <ZSERVER.LIB>

SYNTAX: int sauth_authenticate(char* username, char* password, word server);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Authenticate the user and return the user index
					representing the authenticated user.  This performs only
               a plaintext comparison of the userid and password.
               Servers probably will have their own, more sophisticated,
               checks.

               If username is null, or empty string, then password-only
               matching is attempted for servers who allow this type
               of authentication (as defined by the SERVER_PASSWORD_ONLY
               macro).

PARAMETER1: 	user name
PARAMETER2:		user's password
PARAMETER3:		the server for which this function is authenticating.  This
               should have only a single bit set e.g. SERVER_HTTP for
               checking web server access.

RETURN VALUE:  >= 0	user index
               -1		failure or not authorized.

SEE ALSO:      sauth_adduser

END DESCRIPTION **********************************************************/

int sauth_authenticate(char* username, char* password, word server);
/*** EndHeader */

_zserver_nodebug int sauth_authenticate(char* username, char* password, word server)
{
	auto int i;

   if (username && *username) {
	   i = sauth_getuserid(username, server);
      if (i < 0)
      	return -1;
      if (strncmp(server_auth[i].password, password, SAUTH_MAXNAME))
			i = -1;
   }
   else if (server & SERVER_PASSWORD_ONLY) {
      i = sauth_getuserid(password, server);
   }
   else {
      return -1;
   }

	return i;
}

/*** BeginHeader sauth_getusername */

/* START FUNCTION DESCRIPTION ********************************************
sauth_getusername                          <ZSERVER.LIB>

SYNTAX: char* sauth_getusername(int userid);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Returns the username of the user id entry

PARAMETER1: 	user id

RETURN VALUE:  !=NULL	username string
               NULL		failure

SEE ALSO:		sspec_getusername

END DESCRIPTION **********************************************************/

char* sauth_getusername(int sauth);
/*** EndHeader */

_zserver_nodebug char* sauth_getusername(int sauth)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(sauth)))
		return NULL;
	return sap->username;
}

/*** BeginHeader sauth_getuserid */
/* START FUNCTION DESCRIPTION ********************************************
sauth_getuserid                            <ZSERVER.LIB>

SYNTAX: int sauth_getuserid(char* username, word server);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Gets the user index for a user.

PARAMETER1: 	user's name.  If this name is not found, then the list is
               re-scanned looking for an entry with an empty user name
               ("") and a password which matches "username".  Note that
               this second pass is only done for servers which allow
               "password-only" matching.  Such servers must be specified
               by defining a symbol SERVER_PASSWORD_ONLY to be a bitmask
               of such servers.
PARAMETER2:		server(s) for which we are looking up (use SERVER_ANY if
               not concerned with server mask).

RETURN VALUE:  >= 0	user index
               -1		failure

SEE ALSO:

END DESCRIPTION **********************************************************/

int sauth_getuserid(char __far * username, word server);
/*** EndHeader */

_zserver_nodebug int sauth_getuserid(char __far * username, word server)
{
	auto int i;

   if (!username || !*username)
   	return -1;
	for (i = 0; i < SAUTH_MAXUSERS; i++) {
		if (!strncmp(server_auth[i].username, username, SAUTH_MAXNAME)) {
			if (!server_auth[i].servermask || server_auth[i].servermask & server)
				return i;
         return -1;
		}
	}
   server &= SERVER_PASSWORD_ONLY;
   if (server)
	   for (i = 0; i < SAUTH_MAXUSERS; i++)
	      if (!server_auth[i].username[0] && !strncmp(server_auth[i].password, username, SAUTH_MAXNAME) &&
	          (!server_auth[i].servermask || server_auth[i].servermask & server))
	            return i;
	return -1;
}

/*** BeginHeader sauth_setpassword */
/* START FUNCTION DESCRIPTION ********************************************
sauth_setpassword                          <ZSERVER.LIB>

SYNTAX: int sauth_setpassword(int userid, char* password);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set the password for a user

PARAMETER1: 	user index
PARAMETER2: 	user's new password

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:      sauth_getpassword

END DESCRIPTION **********************************************************/

int sauth_setpassword(int userid, char* password);
/*** EndHeader */

_zserver_nodebug int sauth_setpassword(int userid, char* password)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(userid)))
		return -1;
	strncpy(sap->password, password, SAUTH_MAXNAME);
	return 0;
}

/*** BeginHeader sauth_getpassword */
/* START FUNCTION DESCRIPTION ********************************************
sauth_getpassword                          <ZSERVER.LIB>

SYNTAX: char* sauth_getpassword(int userid);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Get the password for a user

PARAMETER1: 	user index

RETURN VALUE:  !=NULL	password string
               NULL		failure

SEE ALSO:      sauth_setpassword

END DESCRIPTION **********************************************************/

char* sauth_getpassword(int userid);
/*** EndHeader */

_zserver_nodebug char* sauth_getpassword(int userid)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(userid)))
		return NULL;
	return sap->password;
}

/*** BeginHeader sauth_removeuser */
/* START FUNCTION DESCRIPTION ********************************************
sauth_removeuser                           <ZSERVER.LIB>

SYNTAX: int sauth_removeuser(int userid);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Remove the given user from the user list.  IMPORTANT:
					Any associations of the given user with web pages should
					be changed.  Otherwise, no one will have access to the
					unchanged web pages.  Authentication can be turned off
					for a page with sspec_setrealm(sspec, "") .

PARAMETER1: 	user index

RETURN VALUE:   0		success
               -1		failure

SEE ALSO:      sauth_adduser

END DESCRIPTION **********************************************************/

int sauth_removeuser(int userid);
/*** EndHeader */

_zserver_nodebug int sauth_removeuser(int userid)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(userid)))
		return -1;
	memset(sap, 0, sizeof(*sap));
	return 0;
}

/*** BeginHeader sauth_setusermask */
/* START FUNCTION DESCRIPTION ********************************************
sauth_setusermask                          <ZSERVER.LIB>

SYNTAX: int sauth_setusermask(int userid, word groupbits, void * authdata);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Set the group access bit(s) and authorization data for a
               given user ID.

PARAMETER1: 	user index
PARAMETER2:		bitmask of group(s) of which this user is a member.  This
               should be non-zero, otherwise the user will not have
               access to any resources.
PARAMETER3:		Arbitrary data which may be used by specific servers.

RETURN VALUE:  0: OK
					-1: failed: userid not valid.

SEE ALSO:

END DESCRIPTION **********************************************************/

int sauth_setusermask(int userid, word groupbits, void * authdata);
/*** EndHeader */

_zserver_nodebug int sauth_setusermask(int userid, word groupbits, void * authdata)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(userid)))
		return -1;
	sap->mask = groupbits;
   sap->data = authdata;
   return 0;
}

/*** BeginHeader sauth_getusermask */
/* START FUNCTION DESCRIPTION ********************************************
sauth_getusermask                          <ZSERVER.LIB>

SYNTAX: int sauth_getusermask(int userid, word * groupbits,
									void ** authdata);

KEYWORDS:		tcpip, server

DESCRIPTION: 	Get the group access bit(s) and/or authorization data for a
               given user ID.

PARAMETER1: 	user index
PARAMETER2:		Pointer to bitmask which will be set to group(s) of which
               this user is a member.  If NULL, this info is not
               retrieved.
PARAMETER3:		Pointer to void* which is set to arbitrary server data.
               If NULL, this info is not retrieved.

RETURN VALUE:  0: OK
					-1: failed: userid not valid.

SEE ALSO:

END DESCRIPTION **********************************************************/

int sauth_getusermask(int userid, word * groupbits, void ** authdata);
/*** EndHeader */

_zserver_nodebug int sauth_getusermask(int userid, word * groupbits, void ** authdata)
{
   auto ServerAuth * sap;

   if (!(sap = sauth_pointer(userid)))
		return -1;
   if (groupbits) *groupbits = sap->mask;
   if (authdata) *authdata = sap->data;
   return 0;
}


/*** BeginHeader sspec_dup */

/* START _FUNCTION DESCRIPTION ********************************************
sspec_dup                            <ZSERVER.LIB>

SYNTAX: int sspec_dup(int sspec, void far * far * addr, long * lenp,
						char far * name, const ServerContext * ctx);

KEYWORDS:		tcpip, server, malloc

DESCRIPTION: 	Allocate (using malloc()) a buffer and copy the
               contents of the specified resource.

               Caller is responsible for freeing the allocated storage
               (using free()) if *addr is returned not NULL.

PARAMETER1: 	Open resource handle, or if negative then the name and
                 context parameters are used to temporarily open the
                 named resource.  If the handle is already open,
                 then it remains open on return.
PARAMETER2:    Pointer to a far pointer which will be set to the
               address of the allocated storage.  It will be set to
               NULL on any failure.  Otherwise, the caller is responsible
               for freeing this storage.
PARAMETER3: 	if not NULL, the length of the copied data is returned
               at the indicated location.
PARAMETER4:    If sspec<0, then this is a resource name to temporarily open.
					Ignored if sspec >= 0.
PARAMETER5:    If sspec<0, then this is context for the name parameter.
					Ignored if sspec >= 0.

RETURN VALUE:  <0  failure opening, allocating or reading file
                       -ENOMEM: allocation failure
                       other: failure to open or read the resource
               0	 success.

SEE ALSO:		sspec_readfile, sspec_getlength

END DESCRIPTION **********************************************************/

int sspec_dup(int sspec, void __far * __far * addr, long * lenp,
						char __far * name, const ServerContext * ctx);
/*** EndHeader */
_zserver_nodebug
int sspec_dup(int sspec, void __far * __far * addr, long * lenp,
						char __far * name, const ServerContext * ctx)
{
	// Specify application far space
	return _sspec_dup(sspec, addr, lenp, name, ctx, malloc, free);
}


/*** BeginHeader _sspec_dup */
int _sspec_dup(int sspec, void __far * __far * addr, long * lenp,
						char __far * name, const ServerContext * ctx,
		 				void __far * (*)(), void (*)());
/*** EndHeader */
_zserver_nodebug
int _sspec_dup(int sspec, void __far * __far * addr, long * lenp,
						char __far * name, const ServerContext * ctx,
						void __far * (*alloc)(), void (*unalloc)())
{
   auto char temp_buf[256]; // Temporary root buffer
	auto long len;
	auto char __far * buf;
	auto int frag_len;
	auto int do_close;

	*addr = NULL;
	if (sspec < 0) {
		_f_strcpy(temp_buf, name);
      sspec = sspec_open(temp_buf, ctx, O_READ, 0);
      if (sspec < 0)
         return sspec;
		do_close = 1;
	}
	else
		do_close = 0;

   len = sspec_getlength(sspec);
   if (lenp)
   	*lenp = len;
   buf = (char __far *)alloc(len);
	*addr = buf;
   if (!buf) {
   	if (do_close)
   		sspec_close(sspec);
      return -ENOMEM;
   }
   do {
      //DEVIDEA: we really need to convert Zserver to far ptrs
      frag_len = sspec_read(sspec, temp_buf, sizeof(temp_buf));
      if (frag_len > sizeof(temp_buf) || frag_len < 0) {
         unalloc(buf);
         *addr = NULL;
     		if (do_close)
   			sspec_close(sspec);
         // operation not permitted; underlying filesystem needs bigger buffer
         // which we can't resize.  This will never happen for filesystems as of
         // 2007, but don't want to break in the future.
         return frag_len >= 0 ? -EPERM : frag_len;
      }
      if (frag_len > 0) {
         _f_memcpy(buf, temp_buf, frag_len);
         buf += frag_len;
      }
   }
   while (frag_len);
   if (do_close)
   	sspec_close(sspec);
   return 0;
}



/*** BeginHeader  ********************************************/
#endif
/*** EndHeader ***********************************************/

