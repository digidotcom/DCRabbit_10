/*
   Copyright (c) 2015, Digi International Inc.

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
/*******************************************************************************

	ioconfig_switchecho.c

	This program is used with RCM4100 series controllers and prototyping boards.


	Description
	===========

	This program transmits and then receives an ASCII string on either serial
	port E (self-echo) or on serial ports D and F when the S2 or S3 switch,
	respectively, is pressed. It also displays the echoed serial data echoed via
	either serial port E or ports D and F in the STDIO window.

	Note that the I/O lines that carry serial port E signals are not the Rabbit
	4000 CPU defaults.  The serial port D, E and F I/O lines are configured by
	calling a library function, serDEFconfig(), that was generated by the Rabbit
	4000 IOCONFIG.EXE utility program.  Note that the serDopen(), serEopen() and
	serFopen() function calls are made within the generated library code.

	Serial port D is left in its default configuration, using parallel port C
	bits PC1 and PC0.  These signals are available on the prototyping board's
	RS232 connector.

	Serial port E is configured to use parallel port E bits PE7 and PE6.  These
	signals are available on the prototyping board's Module Extension Header.

	Serial port F is left in its default configuration, using parallel port C
	bits PC3 and PC2.  The default overrides the RXC and TXC pins on the
	prototyping board's RS232 connector.

	Also note that there are two IOCONFIG.EXE generated libraries.  One library
	is for the 29 MHz RCM4110 and the other is for the 58 MHz RCM4100 / RCM4120.


	Prototyping Board Connections
	=============================

	For serial port E, on the Module Extension Header connect a wire jumper
	between the pins marked PE7 and PE6.

	For serial ports D and F, on the RS232 connector place a wire jumper between
	the pins marked RXD and TXC (TXC is really TXF due to the configuration of
	serial port F).


	Instructions
	============

	1. Compile and run this program.
	2. Press and release S2 or S3, as desired, on the prototyping board.
	3. View data echoed via the respective serial port in the STDIO window.

*******************************************************************************/
#class auto

#define TIME_OUT 1000	// wait up to 1000 mS for CR in receive string

#if (_BOARD_TYPE_ & 0xFF00) != (RCM4100 & 0xFF00)
	#error "This sample program is intended for RCM4100 series boards."
#endif

#if _BOARD_TYPE_ == RCM4110
	#use "RCM41_29MHZ_IOCONFIG.LIB"
#elif (_BOARD_TYPE_ == RCM4100) || (_BOARD_TYPE_ == RCM4120)
	#use "RCM41_58MHZ_IOCONFIG.LIB"
#else
	#error "Unrecognized RCM4100 series board type!"
	#error "Choose or create an I/O configuration library to #use here."
#endif

///////////////////////////////////////////////////////////////////////////
// S2 uses PB4
#define S2_PORT		PBDR
#define S2_SHADOW		PBDRShadow
#define S2_BIT 		4

// S3 uses PB5
#define S3_PORT		PBDR
#define S3_SHADOW		PBDRShadow
#define S3_BIT 		5

// Useful definitions
#define ON	1
#define OFF 0

nodebug
void msDelay(unsigned int delay)
{
	auto unsigned long time0;

	for (time0 = MS_TIMER; MS_TIMER - time0 < delay; ) ;
}

const char * const string1 = {
	"S2 pressed, this message self-echoed via serial port E.\n\r" };
const char * const string2 = {
	"S3 pressed, this message echoed via serial ports D and F.\n\r" };

main()
{
	static char buf_sw2[64], buf_sw3[64];	// buffers used for serial data
	auto int i, j, ch, rc, timer2, timer3;
	auto int sw2, sw3;

   // Configure serial ports D, E and F as described in comments above
	serDEFconfig();

   // Ensure serial ports D, E, F read / write buffers are empty at this point
   serDrdFlush();
	serDwrFlush();
 	serErdFlush();
   serEwrFlush();
   serFrdFlush();
   serFwrFlush();

	// Initialize switch flags to false value
	sw2 = sw3 = OFF;

	// Clear our local data buffers
	memset(buf_sw2, 0x00, sizeof(buf_sw2));
	memset(buf_sw3, 0x00, sizeof(buf_sw3));

   printf("Sample program is running:\n");
   printf("Waiting for prototyping board S2 or S3 switch click.\n\n");

   //---------------------------------------------------------------------
   // Do continuous loop echoing data via serial ports E or D and F
   //---------------------------------------------------------------------
	while(1) {
		costate {
			if (BitRdPortI(S2_PORT, S2_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S2_PORT, S2_BIT)) {	//wait for switch release
				sw2 = !sw2;
				abort;
			}
		}

		costate {
			if (BitRdPortI(S3_PORT, S3_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S3_PORT, S3_BIT)) {	//wait for switch release
				sw3 = !sw3;
				abort;
			}
		}

		costate {
			if (sw2) {
				sw2 = !sw2;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serErdFlush();
   			// Echo an ASCII string over serial port E
				memcpy(buf_sw2, string1, strlen(string1));
   			serEputs(buf_sw2);
				memset(buf_sw2, 0x00, sizeof(buf_sw2));

   			// Get the data string that was transmitted via port E
		    	i = 0;
     			timer2 = TIME_OUT;
		     	while (timer2 > 0) {
		     		ch = serEgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer2;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer2 = 0;	// end of line CR character, force an exit!
					} else {
						if (i < sizeof(buf_sw2) - 3) {
							buf_sw2[i++] = ch;
						}
					}
				}
				buf_sw2[i++] = ch;			 //copy '\r' to the data buffer
     			buf_sw2[i]   = '\0';      //terminate the ascii string

		     	// Display ASCII string received from serial port E echo
     			printf("%s", buf_sw2);

		  		// Clear buffer
				memset(buf_sw2, 0x00, sizeof(buf_sw2));
			}
		}

		costate {
			if (sw3) {
				sw3 = !sw3;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serDrdFlush();
		   	// Transmit an ASCII string over serial port F
				memcpy(buf_sw3, string2, strlen(string2));
     			serFputs(buf_sw3);
		     	memset(buf_sw3, 0x00, sizeof(buf_sw3));

				// Get the data string that was transmitted via serial port F
     			j = 0;
     			timer3 = TIME_OUT;
		     	while (timer3 > 0) {
		     		ch = serDgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer3;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer3 = 0;	// end of line CR character, force an exit!
					} else {
						if (j < sizeof(buf_sw3) - 3) {
							buf_sw3[j++] = ch;
						}
					}
				}
		     	buf_sw3[j++] = ch; 		//copy '\r' to the data buffer
		     	buf_sw3[j]   = '\0';     //terminate the ascii string

	     		// Display ASCII string received from serial port F echo to D
		   	printf("%s", buf_sw3);

		  		// Clear buffer
				memset(buf_sw3, 0x00, sizeof(buf_sw3));
			} //endif
		} //endcostate
	} //endwhile
}
///////////////////////////////////////////////////////////////////////////