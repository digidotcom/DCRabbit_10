/*******************************************************************************

	ioconfig_switchecho.c
	Rabbit Semiconductor, Inc. 2007

	This program is used with RCM4400W series controllers and prototyping boards.


	Description
	===========

	This program transmits and then receives an ASCII string on either serial
	port E (self-echo) or on serial port D (self-echo) when the S2 or S3 switch,
	respectively, is pressed. It also displays the echoed serial data echoed via
	either serial port E or port D in the STDIO window.

	Note that the I/O lines that carry serial port E signals are not the Rabbit
	4000 CPU defaults.  The serial ports D and E I/O lines are configured by
	calling a library function, serDEconfig(), that was generated by the Rabbit
	4000 IOCONFIG.EXE utility program.  Note that the serDopen() and serEopen()
	function calls are made within the generated library code.

	Serial port D is left in its default configuration, using parallel port C
	bits PC1 and PC0.  These signals are available on the prototyping board's
	RS232 connector.

	Serial port E is configured to use parallel port D bits PD7	and PD6.  These
   signals are available on the prototyping board's Module Extension Header.


	Prototyping Board Connections
	=============================

	For serial port E, on the Module Extension Header connect a	wire jumper
   between the pins marked PD7 and PD6.

	For serial port D, on the RS232 connector place a wire jumper between the
	pins marked RXD and TXD.


	Instructions
	============

	1. Compile and run this program.
	2. Press and release S2 or S3, as desired, on the prototyping board.
	3. View data echoed via the respective serial port(s) in the STDIO window.

*******************************************************************************/
#class auto

#define TIME_OUT 1000	// wait up to 1000 mS for CR in receive string

#if (_BOARD_TYPE_ & 0xFF00) != (RCM4400W & 0xFF00)
	#error "This sample program is intended for RCM4400W series boards."
#endif


#use "RCM4400W_IOCONFIG.LIB"

///////////////////////////////////////////////////////////////////////////
// S2 uses PB4
#define S2_PORT		PBDR
#define S2_SHADOW		PBDRShadow
#define S2_BIT 		4

// S3 uses PB5
#define S3_PORT		PBDR
#define S3_SHADOW		PBDRShadow
#define S3_BIT 		5

// Useful definitions
#define ON	1
#define OFF 0

nodebug
void msDelay(unsigned int delay)
{
	auto unsigned long time0;

	for (time0 = MS_TIMER; MS_TIMER - time0 < delay; ) ;
}

const char * const string1 = {
	"S2 pressed, this message self-echoed via serial port E.\n\r" };
const char * const string2 = {
	"S3 pressed, this message self-echoed via serial port D.\n\r" };

main()
{
	static char buf_sw2[64], buf_sw3[64];	// buffers used for serial data
	auto int i, j, ch, rc, timer2, timer3;
	auto int sw2, sw3;

	// Configure serial ports D and E as described in comments above
	serDEconfig();

   // Ensure serial ports D, E read / write buffers are empty at this point
   serDrdFlush();
	serDwrFlush();
 	serErdFlush();
   serEwrFlush();

	// Initialize switch flags to false value
	sw2 = sw3 = OFF;

	// Clear our local data buffers
	memset(buf_sw2, 0x00, sizeof(buf_sw2));
	memset(buf_sw3, 0x00, sizeof(buf_sw3));

   printf("Sample program is running:\n");
   printf("Waiting for prototyping board S2 or S3 switch click.\n\n");

   //---------------------------------------------------------------------
   // Do continuous loop echoing data via serial ports D and E
   //---------------------------------------------------------------------
	while(1) {
		costate {
			if (BitRdPortI(S2_PORT, S2_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S2_PORT, S2_BIT)) {	//wait for switch release
				sw2 = !sw2;
				abort;
			}
		}

		costate {
			if (BitRdPortI(S3_PORT, S3_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S3_PORT, S3_BIT)) {	//wait for switch release
				sw3 = !sw3;
				abort;
			}
		}

		costate {
			if (sw2) {
				sw2 = !sw2;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serErdFlush();
   			// Echo an ASCII string over serial port E
				memcpy(buf_sw2, string1, strlen(string1));
   			serEputs(buf_sw2);
				memset(buf_sw2, 0x00, sizeof(buf_sw2));

   			// Get the data string that was transmitted via port E
		    	i = 0;
     			timer2 = TIME_OUT;
		     	while (timer2 > 0) {
		     		ch = serEgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer2;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer2 = 0;	// end of line CR character, force an exit!
					} else {
						if (i < sizeof(buf_sw2) - 3) {
							buf_sw2[i++] = ch;
						}
					}
				}
				buf_sw2[i++] = ch;			 //copy '\r' to the data buffer
     			buf_sw2[i]   = '\0';      //terminate the ascii string

		     	// Display ASCII string received from serial port E echo
     			printf("%s", buf_sw2);

		  		// Clear buffer
				memset(buf_sw2, 0x00, sizeof(buf_sw2));
			}
		}

		costate {
			if (sw3) {
				sw3 = !sw3;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serDrdFlush();
		   	// Transmit an ASCII string over serial port D
				memcpy(buf_sw3, string2, strlen(string2));
     			serDputs(buf_sw3);
		     	memset(buf_sw3, 0x00, sizeof(buf_sw3));

				// Get the data string that was transmitted via serial port D
     			j = 0;
     			timer3 = TIME_OUT;
		     	while (timer3 > 0) {
		     		ch = serDgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer3;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer3 = 0;	// end of line CR character, force an exit!
					} else {
						if (j < sizeof(buf_sw3) - 3) {
							buf_sw3[j++] = ch;
						}
					}
				}
		     	buf_sw3[j++] = ch; 		//copy '\r' to the data buffer
		     	buf_sw3[j]   = '\0';     //terminate the ascii string

	     		// Display ASCII string received from serial port D echo
		   	printf("%s", buf_sw3);

		  		// Clear buffer
				memset(buf_sw3, 0x00, sizeof(buf_sw3));
			} //endif
		} //endcostate
	} //endwhile
}
///////////////////////////////////////////////////////////////////////////