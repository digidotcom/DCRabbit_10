/*
   Copyright (c) 2015, Digi International Inc.

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
/*******************************************************************************

	ioconfig_switchecho.c

	This program is used with RCM4300 series controllers and prototyping boards.


	Description
	===========

	This program transmits and then receives an ASCII string on either serial
	ports D to F or on serial ports F to D when the S2 or S3 switch,
	respectively, is pressed. It also displays the echoed serial data echoed via
	serial ports D and F in the STDIO window.

	Note that the I/O lines that carry serial port F signals are not the Rabbit
	4000 CPU defaults.  The serial ports D and F I/O lines are configured by
	calling a library function, serDFconfig(), that was generated by the Rabbit
	4000 IOCONFIG.EXE utility program.  Note that the serDopen() and serFopen()
	function calls are made within the generated library code.

	Serial port D is left in its default configuration, using parallel port C
	bits PC1 and PC0.  These signals are available on the prototyping board's
	RS232 connector.

	Serial port F is left in its default configuration, using parallel port C
	bits PC3 and PC2.  This default overrides the RXC and TXC pins on the
	prototyping board's RS232 connector.

	Also note that the same IOCONFIG.EXE generated library is used for the
	59MHz RCM4300, RCM4310 and RCM4320.


	Prototyping Board Connections
	=============================

	For serial ports D to F, on the RS232 connector place a wire jumper between
	the pins marked TXD and RXC (RXC is really RXF due to the reconfiguration of
	serial port F).

	For serial ports F to D, on the RS232 connector place a wire jumper between
	the pins marked RXD and TXC (TXC is really TXF due to the reconfiguration of
	serial port F).


	Instructions
	============

	1. Compile and run this program.
	2. Press and release S2 or S3, as desired, on the prototyping board.
	3. View data echoed via the respective serial port in the STDIO window.

*******************************************************************************/
#class auto

#define TIME_OUT 1000	// wait up to 1000 mS for CR in receive string

#if (_BOARD_TYPE_ & 0xFF00) != (RCM4300 & 0xFF00)
	#error "This sample program is intended for RCM4300 series boards."
#endif

#use "RCM43_58MHZ_IOCONFIG.LIB"

///////////////////////////////////////////////////////////////////////////
// S2 uses PB4
#define S2_PORT		PBDR
#define S2_SHADOW		PBDRShadow
#define S2_BIT 		4

// S3 uses PB5
#define S3_PORT		PBDR
#define S3_SHADOW		PBDRShadow
#define S3_BIT 		5

// Useful definitions
#define ON	1
#define OFF 0

nodebug
void msDelay(unsigned int delay)
{
	auto unsigned long time0;

	for (time0 = MS_TIMER; MS_TIMER - time0 < delay; ) ;
}

const char * const string1 = {
	"S2 pressed, this message echoed via serial ports F to D.\n\r" };
const char * const string2 = {
	"S3 pressed, this message echoed via serial ports D to F.\n\r" };

main()
{
	static char buf_sw2[64], buf_sw3[64];	// buffers used for serial data
	auto int i, j, ch, rc, timer2, timer3;
	auto int sw2, sw3;

   // Configure serial ports D and F as described in comments above
	serDFconfig();

   // Ensure serial ports D, F read / write buffers are empty at this point
   serDrdFlush();
	serDwrFlush();
   serFrdFlush();
   serFwrFlush();

	// Initialize switch flags to false value
	sw2 = sw3 = OFF;

	// Clear our local data buffers
	memset(buf_sw2, 0x00, sizeof(buf_sw2));
	memset(buf_sw3, 0x00, sizeof(buf_sw3));

   printf("Sample program is running:\n");
   printf("Waiting for prototyping board S2 or S3 switch click.\n\n");

   //---------------------------------------------------------------------
   // Do continuous loop echoing data via serial ports D and F
   //---------------------------------------------------------------------
	while(1) {
		costate {
			if (BitRdPortI(S2_PORT, S2_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S2_PORT, S2_BIT)) {	//wait for switch release
				sw2 = !sw2;
				abort;
			}
		}

		costate {
			if (BitRdPortI(S3_PORT, S3_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S3_PORT, S3_BIT)) {	//wait for switch release
				sw3 = !sw3;
				abort;
			}
		}

		costate {
			if (sw2) {
				sw2 = !sw2;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serFrdFlush();
   			// Transmit an ASCII string over serial port D
				memcpy(buf_sw2, string1, strlen(string1));
   			serDputs(buf_sw2);
				memset(buf_sw2, 0x00, sizeof(buf_sw2));

   			// Get the data string that was transmitted via serial port D
		    	i = 0;
     			timer2 = TIME_OUT;
		     	while (timer2 > 0) {
		     		ch = serFgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer2;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer2 = 0;	// end of line CR character, force an exit!
					} else {
						if (i < sizeof(buf_sw2) - 3) {
							buf_sw2[i++] = ch;
						}
					}
				}
				buf_sw2[i++] = ch;			 //copy '\r' to the data buffer
     			buf_sw2[i]   = '\0';      //terminate the ascii string

		     	// Display ASCII string received from serial port D echo to F
     			printf("%s", buf_sw2);

		  		// Clear buffer
				memset(buf_sw2, 0x00, sizeof(buf_sw2));
			}
		}

		costate {
			if (sw3) {
				sw3 = !sw3;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serDrdFlush();
		   	// Transmit an ASCII string over serial port F
				memcpy(buf_sw3, string2, strlen(string2));
     			serFputs(buf_sw3);
		     	memset(buf_sw3, 0x00, sizeof(buf_sw3));

				// Get the data string that was transmitted via serial port F
     			j = 0;
     			timer3 = TIME_OUT;
		     	while (timer3 > 0) {
		     		ch = serDgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer3;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer3 = 0;	// end of line CR character, force an exit!
					} else {
						if (j < sizeof(buf_sw3) - 3) {
							buf_sw3[j++] = ch;
						}
					}
				}
		     	buf_sw3[j++] = ch; 		//copy '\r' to the data buffer
		     	buf_sw3[j]   = '\0';     //terminate the ascii string

	     		// Display ASCII string received from serial port F echo to D
		   	printf("%s", buf_sw3);

		  		// Clear buffer
				memset(buf_sw3, 0x00, sizeof(buf_sw3));
			} //endif
		} //endcostate
	} //endwhile
}
///////////////////////////////////////////////////////////////////////////