/*******************************************************************************

	ioconfig_switchecho.c
	Rabbit Semiconductor, Inc. 2006

	This program is used with RCM4200 series controllers and prototyping boards.


	Description
	===========

	This program transmits and then receives an ASCII string on either serial
	port E (self-echo, RCM4210 only) or on serial port D (self-echo) when the S2
	or S3 switch, respectively, is pressed. It also displays the echoed serial
	data echoed via either serial port E (RCM4210 only) or port D in the STDIO
	window.

	Note that the I/O lines that carry serial port E signals are not the Rabbit
	4000 CPU defaults, and even these lines are not available on the RCM4200 due
	to their alternate use as analog inputs.  The serial ports D and E (RCM4210
	only) I/O lines are configured by calling a library function, serDEconfig(),
	that was generated by the Rabbit 4000 IOCONFIG.EXE utility program.  Note
	that the serDopen() and serEopen() (RCM4210 only) function calls are made
	within the generated library code.

	Serial port D is left in its default configuration, using parallel port C
	bits PC1 and PC0.  These signals are available on the prototyping board's
	RS232 connector.

	Serial port E (RCM4210 only) is configured to use parallel port D bits PD7
	and PD6.  These signals are available on the prototyping board's Module
	Extension Header.

	Also note that there are two IOCONFIG.EXE generated libraries.  One library
	is for the 29 MHz RCM4210 and the other is for the 58 MHz RCM4200.


	Prototyping Board Connections
	=============================

	For serial port E (RCM4210 only), on the Module Extension Header connect a
	wire jumper between the pins marked PD7 and PD6.

	For serial port D, on the RS232 connector place a wire jumper between the
	pins marked RXD and TXD.


	Instructions
	============

	1. Compile and run this program.
	2. Press and release S2 or S3, as desired, on the prototyping board.
	3. View data echoed via the respective serial port(s) in the STDIO window.

*******************************************************************************/
#class auto

#define TIME_OUT 1000	// wait up to 1000 mS for CR in receive string

#if (_BOARD_TYPE_ & 0xFF00) != (RCM4200 & 0xFF00)
	#error "This sample program is intended for RCM4200 series boards."
#endif

#if _BOARD_TYPE_ == RCM4210
	#use "RCM42_29MHZ_IOCONFIG.LIB"
#elif _BOARD_TYPE_ == RCM4200
	#use "RCM42_58MHZ_IOCONFIG.LIB"
#else
	#error "Unrecognized RCM4200 series board type!"
	#error "Choose or create an I/O configuration library to #use here."
#endif

///////////////////////////////////////////////////////////////////////////
// S2 uses PB4
#define S2_PORT		PBDR
#define S2_SHADOW		PBDRShadow
#define S2_BIT 		4

// S3 uses PB5
#define S3_PORT		PBDR
#define S3_SHADOW		PBDRShadow
#define S3_BIT 		5

// Useful definitions
#define ON	1
#define OFF 0

nodebug
void msDelay(unsigned int delay)
{
	auto unsigned long time0;

	for (time0 = MS_TIMER; MS_TIMER - time0 < delay; ) ;
}

const char * const string1 = {
	"S2 pressed, this message self-echoed via serial port E.\n\r" };
const char * const string2 = {
	"S3 pressed, this message self-echoed via serial port D.\n\r" };

main()
{
	static char buf_sw2[64], buf_sw3[64];	// buffers used for serial data
	auto int i, j, ch, rc, timer2, timer3;
	auto int sw2, sw3;

	// Configure serial ports D and E (RCM4210 only) as described
	//  in the comments above
	serDEconfig();

   // Ensure serial ports D, E read / write buffers are empty at this point
   serDrdFlush();
	serDwrFlush();
#if _BOARD_TYPE_ == RCM4210
 	serErdFlush();
   serEwrFlush();
#endif

	// Initialize switch flags to false value
	sw2 = sw3 = OFF;

	// Clear our local data buffers
	memset(buf_sw2, 0x00, sizeof(buf_sw2));
	memset(buf_sw3, 0x00, sizeof(buf_sw3));

#if _BOARD_TYPE_ == RCM4200
	printf("Please note that this sample does not actually demonstrate serial\n");
	printf(" port I/O reconfiguration on an RCM4200.\n\n");
#endif
   printf("Sample program is running:\n");
   printf("Waiting for prototyping board S2 or S3 switch click.\n\n");

   //---------------------------------------------------------------------
   // Do continuous loop echoing data via serial port D and maybe E
   //---------------------------------------------------------------------
	while(1) {
		costate {
			if (BitRdPortI(S2_PORT, S2_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S2_PORT, S2_BIT)) {	//wait for switch release
				sw2 = !sw2;
				abort;
			}
		}

		costate {
			if (BitRdPortI(S3_PORT, S3_BIT))		//wait for switch press
				abort;
			waitfor(DelayMs(50));
			if (BitRdPortI(S3_PORT, S3_BIT)) {	//wait for switch release
				sw3 = !sw3;
				abort;
			}
		}

		costate {
			if (sw2) {
				sw2 = !sw2;

#if _BOARD_TYPE_ == RCM4210
            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serErdFlush();
   			// Echo an ASCII string over serial port E
				memcpy(buf_sw2, string1, strlen(string1));
   			serEputs(buf_sw2);
				memset(buf_sw2, 0x00, sizeof(buf_sw2));

   			// Get the data string that was transmitted via port E
		    	i = 0;
     			timer2 = TIME_OUT;
		     	while (timer2 > 0) {
		     		ch = serEgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer2;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer2 = 0;	// end of line CR character, force an exit!
					} else {
						if (i < sizeof(buf_sw2) - 3) {
							buf_sw2[i++] = ch;
						}
					}
				}
				buf_sw2[i++] = ch;			 //copy '\r' to the data buffer
     			buf_sw2[i]   = '\0';      //terminate the ascii string

		     	// Display ASCII string received from serial port E echo
     			printf("%s", buf_sw2);

		  		// Clear buffer
				memset(buf_sw2, 0x00, sizeof(buf_sw2));
#elif _BOARD_TYPE_ == RCM4200
				printf("Note:  Serial port E is not available on the RCM4200.\n");
#endif
			}
		}

		costate {
			if (sw3) {
				sw3 = !sw3;

            // The switch is attached to the serial port, so we need to read
            // the characters it sends
            serDrdFlush();
		   	// Transmit an ASCII string over serial port D
				memcpy(buf_sw3, string2, strlen(string2));
     			serDputs(buf_sw3);
		     	memset(buf_sw3, 0x00, sizeof(buf_sw3));

				// Get the data string that was transmitted via serial port D
     			j = 0;
     			timer3 = TIME_OUT;
		     	while (timer3 > 0) {
		     		ch = serDgetc();
		     		// Preventing buffer overrun, copy only valid RCV'd characters
		     		//  to the buffer
					if (ch == -1) {
						waitfor(DelayMs(1));
						--timer3;
						// just in case we've timed out, force an end of line CR
						ch = '\r';
					}
					else if (ch == '\r') {
						timer3 = 0;	// end of line CR character, force an exit!
					} else {
						if (j < sizeof(buf_sw3) - 3) {
							buf_sw3[j++] = ch;
						}
					}
				}
		     	buf_sw3[j++] = ch; 		//copy '\r' to the data buffer
		     	buf_sw3[j]   = '\0';     //terminate the ascii string

	     		// Display ASCII string received from serial port D echo
		   	printf("%s", buf_sw3);

		  		// Clear buffer
				memset(buf_sw3, 0x00, sizeof(buf_sw3));
			} //endif
		} //endcostate
	} //endwhile
}
///////////////////////////////////////////////////////////////////////////