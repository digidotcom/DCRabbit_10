/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/*
	Standard C Library: Streams, formatted print and formatted scan.

	Questions:

	2) Current FAT API doesn't like filenames in far buffers.  Is it OK to
		limit the streams API to root filenames as well?
*/

#ifndef __STDIO_H
#define __STDIO_H

#define NULL	(void *) 0
typedef unsigned int size_t;

// EOF: Return value indication end-of-file.  Note that some functions in
// ctype.h accept this value.
#define EOF			(-1)

// L_tmpnam: Size needed for an array of char large enough to hold a
// temporary file name string generated by the tmpnam() function.  In our
// implementation for FAT filesystems, A:TEMP####.TMP<nul>
#define L_tmpnam		15

// TMP_MAX: minimum number of unique file names generated by the tmpnam()
// function.  In our implementation for FAT filesystems, TEMP####.TMP.
#define TMP_MAX		10000

/*
	This private structure (FILE) holds information used by the STDIO stream
	functions.  It's members should NOT be accessed directly and may change
	in future releases of Dynamic C.
*/

typedef struct FILE
{
	unsigned int	flags;
		#define _FILE_FLAG_OPEN_READ		0x0001	// opened for reading
		#define _FILE_FLAG_OPEN_WRITE		0x0002	// opened for writing
		#define _FILE_FLAG_OPEN_RW	(_FILE_FLAG_OPEN_READ | _FILE_FLAG_OPEN_WRITE)
		#define _FILE_FLAG_OPEN_APPEND	0x0004	// all writes go to end of file
		#define _FILE_FLAG_OPEN_BINARY	0x0008	// treat file as binary

		// _CAN_READ and _CAN_WRITE are set to ((_OPEN_READ|_OPEN_WRITE) << 4).
		// On a seek or flush, set based on how file was opened.  After a write,
		// _CAN_READ is cleared.  After a read, _CAN_WRITE is cleared.
		#define _FILE_FLAG_CAN_READ		(_FILE_FLAG_OPEN_READ << 4)
		#define _FILE_FLAG_CAN_WRITE		(_FILE_FLAG_OPEN_WRITE << 4)

		#define _FILE_FLAG_UNUSED1			0x0040
		#define _FILE_FLAG_UNUSED2			0x0080

		#define _FILE_FLAG_BUF_NONE		0x0000	// not buffered
		#define _FILE_FLAG_BUF_FULL		0x0100	// fully buffered
		#define _FILE_FLAG_BUF_LINE		0x0200	// line buffered
		#define _FILE_FLAG_BUFFERED		0x0300	// mask for buffer mode

		#define _FILE_FLAG_BUF_NEVER		0x0400	// buffering not allowed*

		// AUTOFLUSH used for stdout/stderr to allow printf() to buffer multiple
		// characters before sending.  On an interactive device (e.g., the stdio
		// window in DC), stdout is supposed to be unbuffered (and stderr is
		// always unbuffered).  If we were truly unbuffered, our printf would
		// generate a packet for each character sent.
		#define _FILE_FLAG_AUTOFLUSH		0x0800

		// need flags to indicate whether last action was READ or WRITE or NONE
		// (NONE is set after flushing or seeking) -- necessary for handling
		// fread called after fwrite without intervening flush/seek.

		#define _FILE_FLAG_EOF				0x1000
		#define _FILE_FLAG_ERROR			0x2000
		#define _FILE_FLAG_USED				0x4000	// entry is in-use*
		#define _FILE_FLAG_OPEN				0x8000

		// *_FILE_FLAG_BUF_NEVER is used for streams interfaces to devices that
		// do their own buffering (like serial ports).

		// *_FILE_FLAG_USED flag is set by _stdio_FILE_alloc and cleared by
		// _stdio_FILE_free.

	// Name of temporary file that should be deleted on close.  Set to empty
	// string if not an temporary file.
	char tmpnam[L_tmpnam];

	long	offset;			// current offset, if less than zero, overflowed
								// Note that this is offset of next read or write.
								// actual offset of stream is:
								//		offset - (buffer_end - buffer_cur)

	// if .bufsize == 0, stream is not buffered
	size_t bufsize;		// size of buffer allocated to stream

	// if .buffer_alloc != NULL, a buffer was allocated for this stream
	char __far *buffer_alloc;		// malloc() buffer for stream

	// .buffer_base points to .bufsize bytes available for buffering
	// if buffer_base == NULL, buffer_base = buffer_alloc = malloc()
	char __far *buffer_base;

	// if .write_cur == NULL, there isn't any buffered data to write
	// if .write_cur < .write_end, there is room to buffer more data
	char __far *write_cur;
	char __far *write_end;

	// if .read_cur == NULL, there isn't any buffered read data
	// if .read_cur < .read_end, there is buffered data for the stream
	char __far *read_cur;
	char __far *read_end;

	// Set up a small buffer for ungetc() to use.  One char for ungetc(),
	// one char for scanf().
	// Insert: if (.unget_idx < _STDIO_UNGET_BYTES) .unget_buf[.unget_idx++] = c;
	// Remove: if (.unget_idx) c = .unget_buf[--.unget_idx];
	#define _STDIO_UNGET_BYTES 2
	int unget_idx;
	char unget_buf[_STDIO_UNGET_BYTES];

	void __far *cookie;		// cookie passed to read/write/seek/close functions
	/*
		DEVNOTE: Consider adding getc/putc handlers as well, since our current
					STDIO.LIB works that way.  fgetc would use the getc function
					pointer if available and fall back on the read function pointer.
					Likewise, reading multiple bytes with fread would try the read
					function pointer first, and fall back on getc if fread == NULL.

					Maybe that's only beneficial for unbuffered I/O (like
					stdin/stdout)?  You'd also want to use it for RS232.LIB and
					other streams that do their own buffering (RabbitNet?).
	*/

	/*
		See function help for _stream_read, _stream_write, _stream_seek and
		_stream_close for documentation on these function pointers.

		If read is NULL, attempts to read the stream will return EOF.
		If write is NULL, writes to the stream will be discarded.
		If seek is NULL, the stream is not seekable.
		If close is NULL, the stream doesn't do additional cleanup on close.
	*/
	size_t (*read)( void __far *cookie, void __far *buffer, size_t bytes);
	size_t (*write)( void __far *cookie, const void __far *buffer, size_t bytes);
	int (*seek)( void __far *cookie, long int *offset, int whence);
	int (*close)( void __far *cookie);
} FILE;


// FOPEN_MAX: Minimum number of files that can be open simultaneously.  Must be
// at least eight, including stdin, stdout and stderr.
#ifndef FOPEN_MAX
	#define FOPEN_MAX			8
#endif

extern __far FILE _stdio_files[];

#define stdin		(&_stdio_files[0])
#define stdout		(&_stdio_files[1])
#define stderr		(&_stdio_files[2])

// FILENAME_MAX: The size needed for an array of char large enough to hold the
// longest file name string that the implementation guarantees can be opened.
#define FILENAME_MAX		128		// Arbitrarily chosen (for now)

/*****
 *		Temporary files (using FAT filesystem)
 */
FILE __far *tmpfile( void);
char *tmpnam( char *s);


/*****
 *		Filesystem functions (delete file, rename file); will map to FAT
 */
int remove( const char *filename);
int rename( const char *old, const char *new);


/*****
 *		Stream open/close/flush
 */
FILE __far *fopen( const char *filename, const char *mode);
FILE __far *freopen( const char *filename, const char *mode, FILE __far *stream);
int fflush( FILE __far *stream);
int fclose( FILE __far *stream);


/*****
 *		Stream functions for serial ports
 */
size_t _stream_serial_read( void __far *cookie, void __far *buffer, size_t bytes);
size_t _stream_serial_write( void __far *cookie, const void __far *buffer,
																						size_t bytes);
int _stream_serial_seek( void __far *cookie, long int offset, int whence);
int _stream_serial_close( void __far *cookie);


/*****
 *		Stream functions for FAT files
 */
/*
size_t _stream_fat_read( void far *cookie, void far *buffer, size_t bytes);
size_t _stream_fat_write( void far *cookie, const void far *buffer,
																						size_t bytes);
int _stream_fat_seek( void far *cookie, long int *offset, int whence);
int _stream_fat_close( void far *cookie);
*/

/*****
 *		Stream buffering
 */
void setbuf( FILE __far *stream, char __far *buf);
	// BUFSIZ: Size of buffer used by setbuf(), must be at least 256.
	// Rabbit's FAT library uses 512-byte sectors, good choice for buffer size.
	#define BUFSIZ		512

int setvbuf( FILE __far *stream, char __far *buf, int mode, size_t bufsize);
	// Options for the "mode" parameter of setvbuf().
	#define _IOFBF		0		// fully buffered
	#define _IOLBF		1		// line buffered
	#define _IONBF		2		// unbuffered


/*****
 *		Stream seeking (via long integer offset)
 */
int fseek( FILE __far *stream, long int offset, int whence);
	// Options for the "whence" parameter of fseek().  For compatibility with
	// legacy FAT library, use 0/1/2 for SET/CUR/END.
	#define SEEK_SET	0		// seek from beginning of file
	#define SEEK_CUR	1		// seek from current offset
	#define SEEK_END	2		// seek from end of file
long int ftell( FILE __far *stream);
void rewind( FILE __far *stream);

/*****
 *		Stream seeking (via fpos_t)
 */
// Making fpos_t a structure now allows for possible future changes.  Callers
// to fgetpos() and fsetpos() shouldn't touch the contents of fpos_t -- only
// fgetpos() and fsetpos() should make use of the contents.
// On this platform, all seekable streams (FAT files) are smaller than 2GB,
// so we can represent the offset in a signed long.
typedef struct {
	long		offset;
} fpos_t;

int fgetpos( FILE __far *stream, fpos_t *pos);
int fsetpos( FILE __far *stream, const fpos_t *pos);


/*****
 *		Stream read
 */
int fgetc( FILE __far *stream);
int getc( FILE __far *stream);
int getchar( void);
int ungetc( int c, FILE __far *stream);

char __far *fgets( char __far *s, int n, FILE __far *stream);
char *gets( char *s);
// gets() uses near pointers to remain compatible with legacy code

size_t fread( void __far *ptr, size_t membsize, size_t nmemb, FILE __far *stream);


/*****
 *		Stream write
 */
int fputc( int c, FILE __far *stream);
int putc( int c, FILE __far *stream);
int putchar( int c);

int fputs( const char __far *s, FILE __far *stream);
int puts( const char __far *s);

size_t fwrite( const void __far *ptr, size_t membsize, size_t nmemb,
																				FILE __far *stream);


/*****
 *		Stream error check/clear/print
 */
void clearerr( FILE __far *stream);
int feof( FILE __far *stream);
int ferror( FILE __far *stream);
void perror( const char __far *s);


/*****
 *		Formatted printing to stream or buffer.
 *		(snprintf and vsnprintf are from C99 standard)
 */

// Note that we can't include stdarg.h just to get va_list for the definitions
// of the variadic versions of fprintf, printf and sprintf.  Instead, we
// duplicate the definition here, which should be acceptable as long as it
// matches in both locations.
typedef char *va_list;

int printf( const char __far *format, ...);
int vprintf( const char __far *format, va_list arg);
int fprintf( FILE __far *stream, const char __far *format, ...);
int vfprintf( FILE __far *stream, const char __far *format, va_list arg);

int sprintf( char __far *s, const char __far *format, ...);
int vsprintf( char __far *s, const char __far *format, va_list arg);
int snprintf( char __far *s, size_t num, const char __far *format, ...);
int vsnprintf( char __far *s, size_t num, const char __far *format, va_list arg);


/*****
 *		Formatted scanning of input from stream or buffer.
 *		(vscanf, vfscanf and vsscanf are from C99 standard)
 *		(_f_sscanf is a legacy Dynamic C function)
 */
int scanf( const char __far *format, ...);
int vscanf( const char __far *format, va_list arg);
int sscanf( const char __far *s, const char __far *format, ...);
int _f_sscanf( const char __far * str, const char __far * format, ...);
int vsscanf( const char __far *s, const char __far *format, va_list arg);
int fscanf( FILE __far *stream, const char __far *format, ...);
int vfscanf( FILE __far *stream, const char __far *format, va_list arg);

#endif	// ! defined __STDIO_H

// Automatically #use the libraries with stdio.h functionality.  Wrap in a
// guard macro in case any of them try to #include stdio.h.
// This isn't inside the other guard macro, so we can have stdio.h visible
// at the global scope, yet have its functions controlled by macros in the
// program scope.
#ifndef __STDIO_LOOP
	#define __STDIO_LOOP
	#use "stdio.c"
	#use "stdio_fat.c"
	#use "stdio_serial.c"
	#use "stdio_printf.c"
	#use "stdio_scanf.c"
	#use "stdio_dk.c"
	#use "stdio.lib"
	#undef __STDIO_LOOP
#endif